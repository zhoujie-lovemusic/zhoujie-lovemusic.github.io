<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Vue常用组件封装+工具函数，直接复制使用</title>
    <link href="/2025/04/04/Vue%E5%B8%B8%E7%94%A8%E7%BB%84%E4%BB%B6%E5%B0%81%E8%A3%85%EF%BC%8C%E7%9B%B4%E6%8E%A5%E5%A4%8D%E5%88%B6%E4%BD%BF%E7%94%A8/"/>
    <url>/2025/04/04/Vue%E5%B8%B8%E7%94%A8%E7%BB%84%E4%BB%B6%E5%B0%81%E8%A3%85%EF%BC%8C%E7%9B%B4%E6%8E%A5%E5%A4%8D%E5%88%B6%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="工具函数"><a href="#工具函数" class="headerlink" title="工具函数"></a>工具函数</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; parseTime &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./ruoyi&#x27;</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 表格时间格式化</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">formatDate</span>(<span class="hljs-params">cellValue</span>) &#123;<br>  <span class="hljs-keyword">if</span> (cellValue == <span class="hljs-literal">null</span> || cellValue == <span class="hljs-string">&#x27;&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;</span><br>  <span class="hljs-keyword">var</span> date = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(cellValue)<br>  <span class="hljs-keyword">var</span> year = date.<span class="hljs-title function_">getFullYear</span>()<br>  <span class="hljs-keyword">var</span> month =<br>    date.<span class="hljs-title function_">getMonth</span>() + <span class="hljs-number">1</span> &lt; <span class="hljs-number">10</span> ? <span class="hljs-string">&#x27;0&#x27;</span> + (date.<span class="hljs-title function_">getMonth</span>() + <span class="hljs-number">1</span>) : date.<span class="hljs-title function_">getMonth</span>() + <span class="hljs-number">1</span><br>  <span class="hljs-keyword">var</span> day = date.<span class="hljs-title function_">getDate</span>() &lt; <span class="hljs-number">10</span> ? <span class="hljs-string">&#x27;0&#x27;</span> + date.<span class="hljs-title function_">getDate</span>() : date.<span class="hljs-title function_">getDate</span>()<br>  <span class="hljs-keyword">var</span> hours = date.<span class="hljs-title function_">getHours</span>() &lt; <span class="hljs-number">10</span> ? <span class="hljs-string">&#x27;0&#x27;</span> + date.<span class="hljs-title function_">getHours</span>() : date.<span class="hljs-title function_">getHours</span>()<br>  <span class="hljs-keyword">var</span> minutes =<br>    date.<span class="hljs-title function_">getMinutes</span>() &lt; <span class="hljs-number">10</span> ? <span class="hljs-string">&#x27;0&#x27;</span> + date.<span class="hljs-title function_">getMinutes</span>() : date.<span class="hljs-title function_">getMinutes</span>()<br>  <span class="hljs-keyword">var</span> seconds =<br>    date.<span class="hljs-title function_">getSeconds</span>() &lt; <span class="hljs-number">10</span> ? <span class="hljs-string">&#x27;0&#x27;</span> + date.<span class="hljs-title function_">getSeconds</span>() : date.<span class="hljs-title function_">getSeconds</span>()<br>  <span class="hljs-keyword">return</span> (<br>    year + <span class="hljs-string">&#x27;-&#x27;</span> + month + <span class="hljs-string">&#x27;-&#x27;</span> + day + <span class="hljs-string">&#x27; &#x27;</span> + hours + <span class="hljs-string">&#x27;:&#x27;</span> + minutes + <span class="hljs-string">&#x27;:&#x27;</span> + seconds<br>  )<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number</span>&#125; <span class="hljs-variable">time</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">string</span>&#125; <span class="hljs-variable">option</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns</span> &#123;<span class="hljs-type">string</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">formatTime</span>(<span class="hljs-params">time, option</span>) &#123;<br>  <span class="hljs-keyword">if</span> ((<span class="hljs-string">&#x27;&#x27;</span> + time).<span class="hljs-property">length</span> === <span class="hljs-number">10</span>) &#123;<br>    time = <span class="hljs-built_in">parseInt</span>(time) * <span class="hljs-number">1000</span><br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    time = +time<br>  &#125;<br>  <span class="hljs-keyword">const</span> d = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(time)<br>  <span class="hljs-keyword">const</span> now = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>()<br><br>  <span class="hljs-keyword">const</span> diff = (now - d) / <span class="hljs-number">1000</span><br><br>  <span class="hljs-keyword">if</span> (diff &lt; <span class="hljs-number">30</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;刚刚&#x27;</span><br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (diff &lt; <span class="hljs-number">3600</span>) &#123;<br>    <span class="hljs-comment">// less 1 hour</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">ceil</span>(diff / <span class="hljs-number">60</span>) + <span class="hljs-string">&#x27;分钟前&#x27;</span><br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (diff &lt; <span class="hljs-number">3600</span> * <span class="hljs-number">24</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">ceil</span>(diff / <span class="hljs-number">3600</span>) + <span class="hljs-string">&#x27;小时前&#x27;</span><br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (diff &lt; <span class="hljs-number">3600</span> * <span class="hljs-number">24</span> * <span class="hljs-number">2</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;1天前&#x27;</span><br>  &#125;<br>  <span class="hljs-keyword">if</span> (option) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">parseTime</span>(time, option)<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">return</span> (<br>      d.<span class="hljs-title function_">getMonth</span>() +<br>      <span class="hljs-number">1</span> +<br>      <span class="hljs-string">&#x27;月&#x27;</span> +<br>      d.<span class="hljs-title function_">getDate</span>() +<br>      <span class="hljs-string">&#x27;日&#x27;</span> +<br>      d.<span class="hljs-title function_">getHours</span>() +<br>      <span class="hljs-string">&#x27;时&#x27;</span> +<br>      d.<span class="hljs-title function_">getMinutes</span>() +<br>      <span class="hljs-string">&#x27;分&#x27;</span><br>    )<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">string</span>&#125; <span class="hljs-variable">url</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns</span> &#123;<span class="hljs-type">Object</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getQueryObject</span>(<span class="hljs-params">url</span>) &#123;<br>  url = url == <span class="hljs-literal">null</span> ? <span class="hljs-variable language_">window</span>.<span class="hljs-property">location</span>.<span class="hljs-property">href</span> : url<br>  <span class="hljs-keyword">const</span> search = url.<span class="hljs-title function_">substring</span>(url.<span class="hljs-title function_">lastIndexOf</span>(<span class="hljs-string">&#x27;?&#x27;</span>) + <span class="hljs-number">1</span>)<br>  <span class="hljs-keyword">const</span> obj = &#123;&#125;<br>  <span class="hljs-keyword">const</span> reg = <span class="hljs-regexp">/([^?&amp;=]+)=([^?&amp;=]*)/g</span><br>  search.<span class="hljs-title function_">replace</span>(reg, <span class="hljs-function">(<span class="hljs-params">rs, $1, $2</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> name = <span class="hljs-built_in">decodeURIComponent</span>($1)<br>    <span class="hljs-keyword">let</span> val = <span class="hljs-built_in">decodeURIComponent</span>($2)<br>    val = <span class="hljs-title class_">String</span>(val)<br>    obj[name] = val<br>    <span class="hljs-keyword">return</span> rs<br>  &#125;)<br>  <span class="hljs-keyword">return</span> obj<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">string</span>&#125; input value</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns</span> &#123;<span class="hljs-type">number</span>&#125; output value</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">byteLength</span>(<span class="hljs-params">str</span>) &#123;<br>  <span class="hljs-comment">// returns the byte length of an utf8 string</span><br>  <span class="hljs-keyword">let</span> s = str.<span class="hljs-property">length</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = str.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>    <span class="hljs-keyword">const</span> code = str.<span class="hljs-title function_">charCodeAt</span>(i)<br>    <span class="hljs-keyword">if</span> (code &gt; <span class="hljs-number">0x7f</span> &amp;&amp; code &lt;= <span class="hljs-number">0x7ff</span>) s++<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (code &gt; <span class="hljs-number">0x7ff</span> &amp;&amp; code &lt;= <span class="hljs-number">0xffff</span>) s += <span class="hljs-number">2</span><br>    <span class="hljs-keyword">if</span> (code &gt;= <span class="hljs-number">0xdc00</span> &amp;&amp; code &lt;= <span class="hljs-number">0xdfff</span>) i--<br>  &#125;<br>  <span class="hljs-keyword">return</span> s<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Array</span>&#125; <span class="hljs-variable">actual</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns</span> &#123;<span class="hljs-type">Array</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">cleanArray</span>(<span class="hljs-params">actual</span>) &#123;<br>  <span class="hljs-keyword">const</span> newArray = []<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; actual.<span class="hljs-property">length</span>; i++) &#123;<br>    <span class="hljs-keyword">if</span> (actual[i]) &#123;<br>      newArray.<span class="hljs-title function_">push</span>(actual[i])<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> newArray<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Object</span>&#125; <span class="hljs-variable">json</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns</span> &#123;<span class="hljs-type">Array</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">param</span>(<span class="hljs-params">json</span>) &#123;<br>  <span class="hljs-keyword">if</span> (!json) <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">cleanArray</span>(<br>    <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(json).<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">key</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">if</span> (json[key] === <span class="hljs-literal">undefined</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">encodeURIComponent</span>(key) + <span class="hljs-string">&#x27;=&#x27;</span> + <span class="hljs-built_in">encodeURIComponent</span>(json[key])<br>    &#125;),<br>  ).<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;&amp;&#x27;</span>)<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">string</span>&#125; <span class="hljs-variable">url</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns</span> &#123;<span class="hljs-type">Object</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">param2Obj</span>(<span class="hljs-params">url</span>) &#123;<br>  <span class="hljs-keyword">const</span> search = <span class="hljs-built_in">decodeURIComponent</span>(url.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;?&#x27;</span>)[<span class="hljs-number">1</span>]).<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/\+/g</span>, <span class="hljs-string">&#x27; &#x27;</span>)<br>  <span class="hljs-keyword">if</span> (!search) &#123;<br>    <span class="hljs-keyword">return</span> &#123;&#125;<br>  &#125;<br>  <span class="hljs-keyword">const</span> obj = &#123;&#125;<br>  <span class="hljs-keyword">const</span> searchArr = search.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;&amp;&#x27;</span>)<br>  searchArr.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">v</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> index = v.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&#x27;=&#x27;</span>)<br>    <span class="hljs-keyword">if</span> (index !== -<span class="hljs-number">1</span>) &#123;<br>      <span class="hljs-keyword">const</span> name = v.<span class="hljs-title function_">substring</span>(<span class="hljs-number">0</span>, index)<br>      <span class="hljs-keyword">const</span> val = v.<span class="hljs-title function_">substring</span>(index + <span class="hljs-number">1</span>, v.<span class="hljs-property">length</span>)<br>      obj[name] = val<br>    &#125;<br>  &#125;)<br>  <span class="hljs-keyword">return</span> obj<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">string</span>&#125; <span class="hljs-variable">val</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns</span> &#123;<span class="hljs-type">string</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">html2Text</span>(<span class="hljs-params">val</span>) &#123;<br>  <span class="hljs-keyword">const</span> div = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;div&#x27;</span>)<br>  div.<span class="hljs-property">innerHTML</span> = val<br>  <span class="hljs-keyword">return</span> div.<span class="hljs-property">textContent</span> || div.<span class="hljs-property">innerText</span><br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Merges two objects, giving the last one precedence</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Object</span>&#125; <span class="hljs-variable">target</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">(Object|Array)</span>&#125; <span class="hljs-variable">source</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns</span> &#123;<span class="hljs-type">Object</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">objectMerge</span>(<span class="hljs-params">target, source</span>) &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> target !== <span class="hljs-string">&#x27;object&#x27;</span>) &#123;<br>    target = &#123;&#125;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(source)) &#123;<br>    <span class="hljs-keyword">return</span> source.<span class="hljs-title function_">slice</span>()<br>  &#125;<br>  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(source).<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">property</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> sourceProperty = source[property]<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> sourceProperty === <span class="hljs-string">&#x27;object&#x27;</span>) &#123;<br>      target[property] = <span class="hljs-title function_">objectMerge</span>(target[property], sourceProperty)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      target[property] = sourceProperty<br>    &#125;<br>  &#125;)<br>  <span class="hljs-keyword">return</span> target<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">HTMLElement</span>&#125; <span class="hljs-variable">element</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">string</span>&#125; <span class="hljs-variable">className</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">toggleClass</span>(<span class="hljs-params">element, className</span>) &#123;<br>  <span class="hljs-keyword">if</span> (!element || !className) &#123;<br>    <span class="hljs-keyword">return</span><br>  &#125;<br>  <span class="hljs-keyword">let</span> classString = element.<span class="hljs-property">className</span><br>  <span class="hljs-keyword">const</span> nameIndex = classString.<span class="hljs-title function_">indexOf</span>(className)<br>  <span class="hljs-keyword">if</span> (nameIndex === -<span class="hljs-number">1</span>) &#123;<br>    classString += <span class="hljs-string">&#x27;&#x27;</span> + className<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    classString =<br>      classString.<span class="hljs-title function_">substr</span>(<span class="hljs-number">0</span>, nameIndex) +<br>      classString.<span class="hljs-title function_">substr</span>(nameIndex + className.<span class="hljs-property">length</span>)<br>  &#125;<br>  element.<span class="hljs-property">className</span> = classString<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">string</span>&#125; <span class="hljs-variable">type</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns</span> &#123;<span class="hljs-type">Date</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getTime</span>(<span class="hljs-params">type</span>) &#123;<br>  <span class="hljs-keyword">if</span> (type === <span class="hljs-string">&#x27;start&#x27;</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">getTime</span>() - <span class="hljs-number">3600</span> * <span class="hljs-number">1000</span> * <span class="hljs-number">24</span> * <span class="hljs-number">90</span><br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">toDateString</span>())<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Function</span>&#125; <span class="hljs-variable">func</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number</span>&#125; <span class="hljs-variable">wait</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">boolean</span>&#125; <span class="hljs-variable">immediate</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">*</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">debounce</span>(<span class="hljs-params">func, wait, immediate</span>) &#123;<br>  <span class="hljs-keyword">let</span> timeout, args, context, timestamp, result<br><br>  <span class="hljs-keyword">const</span> later = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 据上一次触发时间间隔</span><br>    <span class="hljs-keyword">const</span> last = +<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>() - timestamp<br><br>    <span class="hljs-comment">// 上次被包装函数被调用时间间隔 last 小于设定时间间隔 wait</span><br>    <span class="hljs-keyword">if</span> (last &lt; wait &amp;&amp; last &gt; <span class="hljs-number">0</span>) &#123;<br>      timeout = <span class="hljs-built_in">setTimeout</span>(later, wait - last)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      timeout = <span class="hljs-literal">null</span><br>      <span class="hljs-comment">// 如果设定为immediate===true，因为开始边界已经调用过了此处无需调用</span><br>      <span class="hljs-keyword">if</span> (!immediate) &#123;<br>        result = func.<span class="hljs-title function_">apply</span>(context, args)<br>        <span class="hljs-keyword">if</span> (!timeout) context = args = <span class="hljs-literal">null</span><br>      &#125;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">...args</span>) &#123;<br>    context = <span class="hljs-variable language_">this</span><br>    timestamp = +<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>()<br>    <span class="hljs-keyword">const</span> callNow = immediate &amp;&amp; !timeout<br>    <span class="hljs-comment">// 如果延时不存在，重新设定延时</span><br>    <span class="hljs-keyword">if</span> (!timeout) timeout = <span class="hljs-built_in">setTimeout</span>(later, wait)<br>    <span class="hljs-keyword">if</span> (callNow) &#123;<br>      result = func.<span class="hljs-title function_">apply</span>(context, args)<br>      context = args = <span class="hljs-literal">null</span><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> result<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * This is just a simple version of deep copy</span><br><span class="hljs-comment"> * Has a lot of edge cases bug</span><br><span class="hljs-comment"> * If you want to use a perfect deep copy, use lodash&#x27;s _.cloneDeep</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Object</span>&#125; <span class="hljs-variable">source</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns</span> &#123;<span class="hljs-type">Object</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">deepClone</span>(<span class="hljs-params">source</span>) &#123;<br>  <span class="hljs-keyword">if</span> (!source &amp;&amp; <span class="hljs-keyword">typeof</span> source !== <span class="hljs-string">&#x27;object&#x27;</span>) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;error arguments&#x27;</span>, <span class="hljs-string">&#x27;deepClone&#x27;</span>)<br>  &#125;<br>  <span class="hljs-keyword">const</span> targetObj = source.<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Array</span> ? [] : &#123;&#125;<br>  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(source).<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">keys</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (source[keys] &amp;&amp; <span class="hljs-keyword">typeof</span> source[keys] === <span class="hljs-string">&#x27;object&#x27;</span>) &#123;<br>      targetObj[keys] = <span class="hljs-title function_">deepClone</span>(source[keys])<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      targetObj[keys] = source[keys]<br>    &#125;<br>  &#125;)<br>  <span class="hljs-keyword">return</span> targetObj<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Array</span>&#125; <span class="hljs-variable">arr</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns</span> &#123;<span class="hljs-type">Array</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">uniqueArr</span>(<span class="hljs-params">arr</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(arr))<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Check if an element has a class</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">HTMLElement</span>&#125; <span class="hljs-variable">elm</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">string</span>&#125; <span class="hljs-variable">cls</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns</span> &#123;<span class="hljs-type">boolean</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">hasClass</span>(<span class="hljs-params">ele, cls</span>) &#123;<br>  <span class="hljs-keyword">return</span> !!ele.<span class="hljs-property">className</span>.<span class="hljs-title function_">match</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(<span class="hljs-string">&#x27;(\\s|^)&#x27;</span> + cls + <span class="hljs-string">&#x27;(\\s|$)&#x27;</span>))<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Add class to element</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">HTMLElement</span>&#125; <span class="hljs-variable">elm</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">string</span>&#125; <span class="hljs-variable">cls</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">addClass</span>(<span class="hljs-params">ele, cls</span>) &#123;<br>  <span class="hljs-keyword">if</span> (!<span class="hljs-title function_">hasClass</span>(ele, cls)) ele.<span class="hljs-property">className</span> += <span class="hljs-string">&#x27; &#x27;</span> + cls<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Remove class from element</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">HTMLElement</span>&#125; <span class="hljs-variable">elm</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">string</span>&#125; <span class="hljs-variable">cls</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">removeClass</span>(<span class="hljs-params">ele, cls</span>) &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-title function_">hasClass</span>(ele, cls)) &#123;<br>    <span class="hljs-keyword">const</span> reg = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(<span class="hljs-string">&#x27;(\\s|^)&#x27;</span> + cls + <span class="hljs-string">&#x27;(\\s|$)&#x27;</span>)<br>    ele.<span class="hljs-property">className</span> = ele.<span class="hljs-property">className</span>.<span class="hljs-title function_">replace</span>(reg, <span class="hljs-string">&#x27; &#x27;</span>)<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">makeMap</span>(<span class="hljs-params">str, expectsLowerCase</span>) &#123;<br>  <span class="hljs-keyword">const</span> map = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-literal">null</span>)<br>  <span class="hljs-keyword">const</span> list = str.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;,&#x27;</span>)<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; list.<span class="hljs-property">length</span>; i++) &#123;<br>    map[list[i]] = <span class="hljs-literal">true</span><br>  &#125;<br>  <span class="hljs-keyword">return</span> expectsLowerCase ? <span class="hljs-function">(<span class="hljs-params">val</span>) =&gt;</span> map[val.<span class="hljs-title function_">toLowerCase</span>()] : <span class="hljs-function">(<span class="hljs-params">val</span>) =&gt;</span> map[val]<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> exportDefault = <span class="hljs-string">&#x27;export default &#x27;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> beautifierConf = &#123;<br>  <span class="hljs-attr">html</span>: &#123;<br>    <span class="hljs-attr">indent_size</span>: <span class="hljs-string">&#x27;2&#x27;</span>,<br>    <span class="hljs-attr">indent_char</span>: <span class="hljs-string">&#x27; &#x27;</span>,<br>    <span class="hljs-attr">max_preserve_newlines</span>: <span class="hljs-string">&#x27;-1&#x27;</span>,<br>    <span class="hljs-attr">preserve_newlines</span>: <span class="hljs-literal">false</span>,<br>    <span class="hljs-attr">keep_array_indentation</span>: <span class="hljs-literal">false</span>,<br>    <span class="hljs-attr">break_chained_methods</span>: <span class="hljs-literal">false</span>,<br>    <span class="hljs-attr">indent_scripts</span>: <span class="hljs-string">&#x27;separate&#x27;</span>,<br>    <span class="hljs-attr">brace_style</span>: <span class="hljs-string">&#x27;end-expand&#x27;</span>,<br>    <span class="hljs-attr">space_before_conditional</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">unescape_strings</span>: <span class="hljs-literal">false</span>,<br>    <span class="hljs-attr">jslint_happy</span>: <span class="hljs-literal">false</span>,<br>    <span class="hljs-attr">end_with_newline</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">wrap_line_length</span>: <span class="hljs-string">&#x27;110&#x27;</span>,<br>    <span class="hljs-attr">indent_inner_html</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">comma_first</span>: <span class="hljs-literal">false</span>,<br>    <span class="hljs-attr">e4x</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">indent_empty_lines</span>: <span class="hljs-literal">true</span>,<br>  &#125;,<br>  <span class="hljs-attr">js</span>: &#123;<br>    <span class="hljs-attr">indent_size</span>: <span class="hljs-string">&#x27;2&#x27;</span>,<br>    <span class="hljs-attr">indent_char</span>: <span class="hljs-string">&#x27; &#x27;</span>,<br>    <span class="hljs-attr">max_preserve_newlines</span>: <span class="hljs-string">&#x27;-1&#x27;</span>,<br>    <span class="hljs-attr">preserve_newlines</span>: <span class="hljs-literal">false</span>,<br>    <span class="hljs-attr">keep_array_indentation</span>: <span class="hljs-literal">false</span>,<br>    <span class="hljs-attr">break_chained_methods</span>: <span class="hljs-literal">false</span>,<br>    <span class="hljs-attr">indent_scripts</span>: <span class="hljs-string">&#x27;normal&#x27;</span>,<br>    <span class="hljs-attr">brace_style</span>: <span class="hljs-string">&#x27;end-expand&#x27;</span>,<br>    <span class="hljs-attr">space_before_conditional</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">unescape_strings</span>: <span class="hljs-literal">false</span>,<br>    <span class="hljs-attr">jslint_happy</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">end_with_newline</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">wrap_line_length</span>: <span class="hljs-string">&#x27;110&#x27;</span>,<br>    <span class="hljs-attr">indent_inner_html</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">comma_first</span>: <span class="hljs-literal">false</span>,<br>    <span class="hljs-attr">e4x</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">indent_empty_lines</span>: <span class="hljs-literal">true</span>,<br>  &#125;,<br>&#125;<br><br><span class="hljs-comment">// 首字母大小</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">titleCase</span>(<span class="hljs-params">str</span>) &#123;<br>  <span class="hljs-keyword">return</span> str.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/( |^)[a-z]/g</span>, <span class="hljs-function">(<span class="hljs-params">L</span>) =&gt;</span> L.<span class="hljs-title function_">toUpperCase</span>())<br>&#125;<br><br><span class="hljs-comment">// 下划转驼峰</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">camelCase</span>(<span class="hljs-params">str</span>) &#123;<br>  <span class="hljs-keyword">return</span> str.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/_[a-z]/g</span>, <span class="hljs-function">(<span class="hljs-params">str1</span>) =&gt;</span> str1.<span class="hljs-title function_">substr</span>(-<span class="hljs-number">1</span>).<span class="hljs-title function_">toUpperCase</span>())<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">isNumberStr</span>(<span class="hljs-params">str</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-regexp">/^[+-]?(0|([1-9]\d*))(\.\d+)?$/g</span>.<span class="hljs-title function_">test</span>(str)<br>&#125;<br><br><span class="hljs-comment">// 根据文件url获取文件名</span><br><span class="hljs-comment">// 师资中文件url格式  /filename_dateid.txt</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getFileNameByUrl</span>(<span class="hljs-params">url</span>) &#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">if</span> (!url) <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;</span><br>    <span class="hljs-keyword">let</span> start = url.<span class="hljs-title function_">lastIndexOf</span>(<span class="hljs-string">&#x27;/&#x27;</span>)<br>    <span class="hljs-keyword">let</span> end = url.<span class="hljs-title function_">lastIndexOf</span>(<span class="hljs-string">&#x27;_&#x27;</span>)<br>    <span class="hljs-keyword">let</span> suffixIndex = url.<span class="hljs-title function_">lastIndexOf</span>(<span class="hljs-string">&#x27;.&#x27;</span>)<br>    <span class="hljs-keyword">let</span> fileName = url.<span class="hljs-title function_">substring</span>(start + <span class="hljs-number">1</span>, end)<br>    <span class="hljs-keyword">let</span> suffix = url.<span class="hljs-title function_">substring</span>(suffixIndex)<br>    <span class="hljs-keyword">return</span> fileName + suffix<br>  &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(e)<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;</span><br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 下载文件的函数</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">downloadFile</span> = (<span class="hljs-params">item</span>) =&gt; &#123;<br>  <span class="hljs-title function_">fetch</span>(item.<span class="hljs-property">url</span>) <span class="hljs-comment">// 假设 baseUrl 已经在全局定义或者通过其他方式传递进来</span><br>    .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> res.<span class="hljs-title function_">blob</span>())<br>    .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">blob</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">let</span> a = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;a&#x27;</span>)<br>      <span class="hljs-keyword">let</span> url = <span class="hljs-variable language_">window</span>.<span class="hljs-property">URL</span>.<span class="hljs-title function_">createObjectURL</span>(blob)<br>      <span class="hljs-keyword">let</span> filename = item.<span class="hljs-property">name</span><br>      a.<span class="hljs-property">href</span> = url<br>      a.<span class="hljs-property">download</span> = filename<br>      a.<span class="hljs-title function_">click</span>()<br>      <span class="hljs-variable language_">window</span>.<span class="hljs-property">URL</span>.<span class="hljs-title function_">revokeObjectURL</span>(url)<br>    &#125;)<br>&#125;<br><br><span class="hljs-comment">// 判断是否为 PDF 文件</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">isPdfUrl</span>(<span class="hljs-params">url</span>) &#123;<br>  <span class="hljs-keyword">const</span> urlExtension = url.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;.&#x27;</span>).<span class="hljs-title function_">pop</span>()<br>  <span class="hljs-keyword">return</span> urlExtension.<span class="hljs-title function_">toLowerCase</span>() === <span class="hljs-string">&#x27;pdf&#x27;</span><br>&#125;<br><br><span class="hljs-comment">// 判断是否为图片文件</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">isImageUrl</span>(<span class="hljs-params">url</span>) &#123;<br>  <span class="hljs-keyword">const</span> urlExtension = url.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;.&#x27;</span>).<span class="hljs-title function_">pop</span>()<br>  <span class="hljs-keyword">return</span> [<span class="hljs-string">&#x27;jpg&#x27;</span>, <span class="hljs-string">&#x27;jpeg&#x27;</span>, <span class="hljs-string">&#x27;png&#x27;</span>].<span class="hljs-title function_">includes</span>(urlExtension.<span class="hljs-title function_">toLowerCase</span>())<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span> string转number</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">*</span>&#125; <span class="hljs-variable">str</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns</span> &#123;<span class="hljs-type">number</span>&#125;</span><br><span class="hljs-comment"> * */</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">stringToNumber</span>(<span class="hljs-params">str</span>) &#123;<br>  <span class="hljs-keyword">if</span> (!str) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">NaN</span><br>  &#125;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> str !== <span class="hljs-string">&#x27;string&#x27;</span>) &#123;<br>    <span class="hljs-keyword">return</span> str<br>  &#125;<br>  <span class="hljs-comment">// 判断str每个字符是否为数字</span><br>  <span class="hljs-keyword">const</span> reg = <span class="hljs-regexp">/^[0-9]+.?[0-9]*$/</span><br>  <span class="hljs-keyword">if</span> (!reg.<span class="hljs-title function_">test</span>(str)) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">NaN</span><br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Number</span>(str)<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h1><p> <a href="......%5C%E5%B8%88%E8%B5%84%E5%BA%93%5Cszk-admin%5Csrc%5Cviews%5Ccomponents%5CselfComponents.zip">selfComponents.zip</a> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs vue"><br>&lt;template&gt;<br>  &lt;component :is=&quot;componentList[config.type]&quot; :config=&quot;config&quot; :form=&quot;form&quot; /&gt;<br>&lt;/template&gt;<br><br>&lt;script setup name=&quot;selfElFormItem&quot;&gt;<br>import selfInput from &#x27;./selfInput&#x27;<br>import selfDatePicker from &#x27;./selfDatePicker&#x27;<br>import selfSelect from &#x27;./selfSelect&#x27;<br>import selfRadioGroup from &#x27;./selfRadioGroup&#x27;<br>import selfCheckboxGroup from &#x27;./selfCheckboxGroup&#x27;<br>import selfFileUpload from &#x27;./selfFileUpload&#x27;<br>import selfCascader from &#x27;./selfCascader&#x27;<br>import selfElAutoComplete from &#x27;./selfElAutoComplete&#x27;<br>import selfInputNumber from &#x27;./selfInputNumber.vue&#x27;<br><br>const componentList = &#123;<br>  input: selfInput,<br>  datePickerRange: selfDatePicker,<br>  datePicker: selfDatePicker,<br>  select: selfSelect,<br>  radio: selfRadioGroup,<br>  checkbox: selfCheckboxGroup,<br>  fileUpload: selfFileUpload,<br>  cascader: selfCascader,<br>  autoComplete: selfElAutoComplete,<br>  inputNumber: selfInputNumber,<br>&#125;<br><br>const props = defineProps(&#123;<br>  form: &#123;<br>    type: Object,<br>    default: () =&gt; &#123;&#125;,<br>  &#125;,<br>  config: &#123;<br>    type: Object,<br>    default: () =&gt; &#123;&#125;,<br>  &#125;,<br>&#125;)<br>&lt;/script&gt;<br><br></code></pre></td></tr></table></figure><h1 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h1><p><strong>表格组件最好不好直接传api和params到里面，因为可能会碰到api和params动态变化的情况，需要另外写监听，比较麻烦，因此表格只接受数据就好</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div class=&quot;table-container&quot; :class=&quot;[&#123; noPadding: noPadding &#125;]&quot;&gt;<br>    &lt;div class=&quot;p-b-[15px]&quot; :class=&quot;[&#123; noPadding: noPadding &#125;]&quot;&gt;<br>      &lt;slot name=&quot;search&quot;&gt; &lt;/slot&gt;<br>      &lt;slot v-if=&quot;props.showDefaultBtn&quot; name=&quot;button&quot;&gt;<br>        &lt;el-button type=&quot;primary&quot; :icon=&quot;Edit&quot; @click=&quot;handleAdd&quot;&gt;新增&lt;/el-button&gt;<br>        &lt;el-button type=&quot;danger&quot; :icon=&quot;Delete&quot; @click=&quot;handleBatchDel&quot;&gt;批量删除&lt;/el-button&gt;<br>      &lt;/slot&gt;<br>    &lt;/div&gt;<br>    &lt;el-table ref=&quot;tableRef&quot; v-loading=&quot;loading&quot; :highlight-current-row=&quot;highlightCurrentRow&quot; row-key=&quot;id&quot;<br>      :reserve-selection=&quot;true&quot; :data=&quot;data&quot; :header-cell-style=&quot;calcHeaderStyles&quot; :style=&quot;style&quot;<br>      :max-height=&quot;maxHeight&quot; @sortChange=&quot;handleSort&quot; @selection-change=&quot;handleSelectionChange&quot;<br>      @current-change=&quot;handleCurrentChange&quot;&gt;<br>      &lt;el-table-column v-for=&quot;col in columns&quot; :key=&quot;col.prop&quot; :prop=&quot;col.prop&quot; :label=&quot;col.label&quot; :width=&quot;col.width&quot;<br>        :min-width=&quot;col.minWidth&quot; :fixed=&quot;col.fixed&quot; :align=&quot;calcAlign(col)&quot; :sortable=&quot;col.sortable&quot; :type=&quot;col.type&quot;<br>        :show-overflow-tooltip=&quot;col.showOverflowTooltip ?? true&quot;&gt;<br>        &lt;template v-if=&quot;col.slotLabel&quot; #header&gt;<br>          &lt;slot :name=&quot;col.slotLabel&quot;&gt;&lt;/slot&gt;<br>        &lt;/template&gt;<br>        &lt;!-- 自定义动态渲染 --&gt;<br>        &lt;template v-if=&quot;col.slotName&quot; #default=&quot;scope&quot;&gt;<br>          &lt;slot :name=&quot;col.slotName&quot; :row=&quot;scope.row&quot; :index=&quot;scope.$index&quot;&gt;&lt;/slot&gt;<br>        &lt;/template&gt;<br>        &lt;!-- 默认渲染 --&gt;<br>        &lt;template v-else-if=&quot;!col.slotName &amp;&amp; col.type !== &#x27;index&#x27; &amp;&amp; col.type !== &#x27;selection&#x27;&quot; #default=&quot;scope&quot;&gt;<br>          &lt;span&gt;&#123;&#123;<br>            scope.row[col.prop] === undefined || scope.row[col.prop] === null ? &#x27;--&#x27; : scope.row[col.prop]<br>          &#125;&#125;&lt;/span&gt;<br>        &lt;/template&gt;<br>      &lt;/el-table-column&gt;<br>      &lt;el-table-column v-if=&quot;showOperationColumn&quot; label=&quot;操作&quot; :width=&quot;operationColumn&quot; fixed=&quot;right&quot; align=&quot;left&quot;&gt;<br>        &lt;template #default=&quot;scope&quot;&gt;<br>          &lt;slot name=&quot;operation&quot; :row=&quot;scope.row&quot;&gt;<br>            &lt;el-button link type=&quot;primary&quot; @click=&quot;handleEdit(scope.row)&quot;&gt;编辑&lt;/el-button&gt;<br>            &lt;el-popconfirm :width=&quot;200&quot; confirm-button-text=&quot;是&quot; cancel-button-text=&quot;否&quot; :icon=&quot;InfoFilled&quot;<br>              icon-color=&quot;#626AEF&quot; title=&quot;你是否删除这条记录吗?&quot; @confirm=&quot;confirmEvent(scope.row)&quot;<br>              @cancel=&quot;cancelEvent(scope.row)&quot;&gt;<br>              &lt;template #reference&gt;<br>                &lt;el-button link type=&quot;danger&quot; @click=&quot;handleDelete(scope.row)&quot;&gt;删除&lt;/el-button&gt;<br>              &lt;/template&gt;<br>            &lt;/el-popconfirm&gt;<br>          &lt;/slot&gt;<br>        &lt;/template&gt;<br>      &lt;/el-table-column&gt;<br>    &lt;/el-table&gt;<br>    &lt;div v-if=&quot;showPagination&quot; class=&quot;flex flex-row justify-end pt-[15px]&quot;&gt;<br>      &lt;el-pagination v-model:current-page=&quot;pageParams.pageNum&quot; v-model:page-size=&quot;pageParams.pageSize&quot;<br>        :page-sizes=&quot;[10, 20, 30, 50]&quot; background layout=&quot;total, sizes, prev, pager, next, jumper&quot;<br>        :total=&quot;Number(total)&quot; @size-change=&quot;handlePageSizeChange&quot; @current-change=&quot;handleCurrentPageChange&quot; /&gt;<br>    &lt;/div&gt;<br>    &lt;div :class=&quot;[&#x27;!py-[30px] flex items-center text-[14px]&#x27;, showBatchOperation ? &#x27;justify-between&#x27; : &#x27;justify-end&#x27;]&quot;&gt;<br>      &lt;!-- 批量操作 --&gt;<br>      &lt;section v-if=&quot;showBatchOperation&quot; class=&quot;flex gap-x-[20px]&quot;&gt;<br>        &lt;span<br>          &gt;已选择 &lt;span&gt;&#123;&#123; selectedList?.length &#125;&#125;&lt;/span&gt; 项&lt;/span<br>        &gt;<br>        &lt;slot name=&quot;batchOperation&quot;&gt;&lt;/slot&gt;<br>      &lt;/section&gt;<br><br>      &lt;pagination<br>        v-if=&quot;total &gt; 0&quot;<br>        v-model:total=&quot;total&quot;<br>        v-model:page=&quot;queryParams.pageNum&quot;<br>        v-model:limit=&quot;queryParams.pageSize&quot;<br>        @pagination=&quot;handleQuery&quot;<br>      /&gt;<br>    &lt;/div&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script setup name=&quot;listTable&quot;&gt;<br>import &#123; Delete, Edit, InfoFilled &#125; from &#x27;@element-plus/icons-vue&#x27;<br><br>/**<br> * 定义组件发出的事件类型。<br> *<br> * @returns &#123;Object&#125; 返回一个对象，包含组件可能发出的所有事件类型。<br> */<br>const emits = defineEmits([<br>  &#x27;sortChange&#x27;, // 排序变化事件<br>  &#x27;pageChange&#x27;, // 页码变化事件<br>  &#x27;handleAdd&#x27;, // 添加操作事件<br>  &#x27;handleBatchDel&#x27;, // 批量删除操作事件<br>  &#x27;handleDelete&#x27;, // 删除操作事件<br>  &#x27;handleEdit&#x27;, // 编辑操作事件<br>  &#x27;confirmEvent&#x27;, // 确认操作事件<br>  &#x27;cancelEvent&#x27;, // 取消操作事件<br>  &#x27;handlePageSizeChange&#x27;, // 页面大小变化事件<br>  &#x27;handleCurrentPageChange&#x27;, // 当前页码变化事件<br>  &#x27;update:pageNum&#x27;, // 更新页码事件<br>  &#x27;update:pageSize&#x27;, // 更新页面大小事件<br>  &#x27;handleSelectionChange&#x27;, // 选择项变化事件<br>  &#x27;handleCurrentChange&#x27;, //选择项变化事件（单选）<br>])<br>const props = defineProps(&#123;<br>  /**<br>   * 定义数据属性。<br>   *<br>   * @description 表格所需的数据。<br>   * @property &#123;Array&#125; type 数据类型，此处指定为数组。<br>   * @property &#123;Function&#125; default 默认值回调函数，返回一个空数组作为默认值。<br>   */<br>  data: &#123;<br>    type: Array,<br>    default: () =&gt; [],<br>  &#125;,<br>  total: &#123;<br>    type: Number,<br>    default: 0,<br>  &#125;,<br>  // 定义组件属性：当前页码<br>  // 类型为Number，默认值为1<br>  initialCurrentPage: &#123;<br>    type: Number,<br>    default: 1,<br>  &#125;,<br>  // 设置初始页面大小的属性<br>  initialPageSize: &#123;<br>    type: Number, // 属性类型为数字<br>    default: 10, // 默认页面大小为10<br>  &#125;,<br>  loading: &#123;<br>    type: Boolean,<br>    default: false,<br>  &#125;,<br>  //表格渲染的列<br>  columns: &#123;<br>    type: Array,<br>    default: () =&gt; [],<br>  &#125;,<br>  style: &#123;<br>    type: [Object, String],<br>    default: () =&gt; &#123; &#125;,<br>  &#125;,<br>  // 定义头部样式的配置项<br>  headerStyle: &#123;<br>    type: [Object, String], // 可以是对象或字符串类型<br>    default: () =&gt; &#123; &#125;, // 默认值为空函数，返回一个空对象<br>  &#125;,<br>  // 控制分页显示的配置项<br>  showPagination: &#123;<br>    type: Boolean, // 数据类型为布尔值<br>    default: true, // 默认值为true，即在组件初始化时，分页器是可见的<br>  &#125;,<br>  // 控制是否显示默认操作列<br>  showDefaultBtn: &#123;<br>    type: Boolean,<br>    default: true,<br>  &#125;,<br>  /**<br>   * showOperationColumn 属性配置<br>   * 用于控制是否显示操作列<br>   *<br>   * @type &#123;Boolean&#125; 是否显示操作列<br>   * @default &#123;true&#125; 默认为 true，即显示操作列<br>   */<br>  showOperationColumn: &#123;<br>    type: Boolean,<br>    default: true,<br>  &#125;,<br>  operationColumn: &#123;<br>    type: Number,<br>    default: 150,<br>  &#125;,<br>  // pageParams: &#123;<br>  //   type: Object,<br>  //   default: () =&gt; &#123;&#125;,<br>  // &#125;<br>  noPadding: &#123;<br>    type: Boolean,<br>    default: false,<br>  &#125;,<br>  maxHeight: &#123;<br>    type: [Number, String],<br>    default: &#x27;-&#x27;,<br>  &#125;,<br>  // 高亮当前行<br>  highlightCurrentRow: &#123;<br>    type: Boolean,<br>    default: true,<br>  &#125;,<br>   showBatchOperation: &#123;<br>    //是否显示批量操作<br>    type: Boolean,<br>    default: false,<br>  &#125;,<br>&#125;)<br><br>const tableRef = ref(null)<br>const pageSize = ref(props.initialPageSize)<br>const pageNum = ref(props.initialCurrentPage)<br>// const pageParams = ref(props.pageParams)<br><br>// watch(() =&gt; [pageNum.value, pageSize.value], (newV) =&gt; &#123;<br>//   console.log(newV)<br>// &#125;)<br><br>// watch(() =&gt; pageParams.value, (newV) =&gt; &#123;<br>//   console.log(newV)<br>// &#125;, &#123;deep: true&#125;)<br><br>/**<br> * 监听 pageSize 和 pageNum 的变化。<br> * 当这两个值发生变化时，会触发 &#x27;update:pageSize&#x27; 和 &#x27;update:pageNum&#x27; 两个自定义事件，<br> * 分别携带新的 pageSize 和 pageNum 值。<br> * 可以在父组件中使用v-model:pageSize 和 v-model:pageNum 来监听和修改这两个值。<br> *<br> * @param newValue 新的 pageSize 和 pageNum 值组成的数组<br> */<br>// watch(<br>//   () =&gt; [pageParams.value.pageNum, pageParams.value.pageSize], // 监听对象为 pageSize 和 pageNum 的值<br>//   newValue =&gt; &#123;<br>//     emits(&#x27;update:pageSize&#x27;, newValue[0]) // 发出 &#x27;update:pageSize&#x27; 事件，更新 pageSize 值<br>//     emits(&#x27;update:pageNum&#x27;, newValue[1]) // 发出 &#x27;update:pageNum&#x27; 事件，更新 pageNum 值<br>//   &#125;<br>// )<br><br>const headerStyles = ref(&#123;<br>  backgroundColor: &#x27;#F2F3F6&#x27;, // 使用淡雅的浅灰色背景，保持简洁<br>  color: &#x27;#303133&#x27;, // 使用深灰色文字，确保清晰可读<br>  fontSize: &#x27;14px&#x27;, // 合适的字体大小，兼顾阅读性和空间效率<br>  fontWeight: &#x27;550&#x27;, // 稍微加重字体，但不过于显眼<br>  borderBottom: &#x27;1px solid #eaeef5&#x27;, // 细实线下边框，清晰划分表头与内容<br>&#125;)<br><br>/**<br> * 计算并返回头部样式的对象。这个计算属性会根据传入的props中的headerStyle来决定返回的样式，<br> * 如果props中没有提供headerStyle，则返回外部定义的headerStyles的值。<br> *<br> * @return &#123;Object&#125; 返回一个包含头部样式的对象。<br> */<br>const calcHeaderStyles = computed(() =&gt; &#123;<br>  // 根据props中的headerStyle决定返回值<br>  return props.headerStyle ? props.headerStyle : headerStyles.value<br>&#125;)<br><br>// 处理是左对齐还是右对齐<br>function calcAlign(col) &#123;<br>  if ([&#x27;selection&#x27;].includes(col.type)) &#123;<br>    return &#x27;left&#x27;<br>  &#125; else if (col.align) &#123;<br>    return col.align<br>  &#125;<br>  return &#x27;center&#x27;<br>&#125;<br><br>/**<br> * 处理排序操作<br> * @param &#123;any&#125; data - 排序数据或信息<br> * @emits &#x27;sortChange&#x27; - 发出排序变更事件，携带排序数据或信息<br> */<br>function handleSort(data) &#123;<br>  emits(&#x27;sortChange&#x27;, data) // 触发排序变更事件<br>&#125;<br><br>/**<br> * 处理添加操作的函数。<br> * 该函数没有参数。<br> * 没有返回值。<br> * 通过触发名为&#x27;handleAdd&#x27;的自定义事件来响应操作。<br> * @emits &#x27;handleAdd&#x27; 当调用此函数时，会发出此事件。<br> */<br>function handleAdd() &#123;<br>  emits(&#x27;handleAdd&#x27;) // 触发&#x27;handleAdd&#x27;事件<br>&#125;<br><br>/**<br> * 处理批量删除操作的函数。<br> * 该函数会触发一个名为 &#x27;handleBatchDel&#x27; 的自定义事件。<br> *<br> * @emits &#x27;handleBatchDel&#x27; 当调用此函数时，会发出此事件。<br> */<br>function handleBatchDel() &#123;<br>  emits(&#x27;handleBatchDel&#x27;) // 触发 &#x27;handleBatchDel&#x27; 事件<br>&#125;<br><br>/**<br> * 处理编辑操作的函数。<br> * 该函数会触发一个名为 &#x27;handleEdit&#x27; 的事件。<br> *<br> * @emits &#x27;handleEdit&#x27; 当调用此函数时，会发出 &#x27;handleEdit&#x27; 事件。<br> */<br>function handleEdit() &#123;<br>  emits(&#x27;handleEdit&#x27;) // 触发 &#x27;handleEdit&#x27; 事件<br>&#125;<br><br>/**<br> * 处理单个删除操作的函数。<br> * 该函数会触发一个名为 &#x27;handleDelete&#x27; 的事件。<br> *<br> * @emits &#x27;handleDelete&#x27; 当调用此函数时，会发出 &#x27;handleDelete&#x27; 事件。<br> */<br>function handleDelete() &#123;<br>  emits(&#x27;handleDelete&#x27;) // 触发 &#x27;handleDelete&#x27; 事件<br>&#125;<br><br>/**<br> * 确认事件操作<br> * @param &#123;Object&#125; row - 行对象，代表需要操作的数据行<br> * @emits &#x27;confirmEvent&#x27; - 触发名为&#x27;confirmEvent&#x27;的自定义事件，将行对象作为参数传递给事件监听器<br> */<br>function confirmEvent(row) &#123;<br>  emits(&#x27;confirmEvent&#x27;, row)<br>&#125;<br><br>/**<br> * 取消事件操作<br> * @param &#123;Object&#125; row - 代表一行数据的对象，此参数在取消事件时会传递给监听此事件的父组件。<br> * @emits &#x27;cancelEvent&#x27; - 发出一个名为&#x27;cancelEvent&#x27;的自定义事件，携带参数row。<br> */<br>function cancelEvent(row) &#123;<br>  emits(&#x27;cancelEvent&#x27;, row) // 触发&#x27;cancelEvent&#x27;事件，通知父组件取消操作的发生。<br>&#125;<br><br>/**<br> * 处理分页大小更改事件<br> * @param &#123;number&#125; pageSize - 新的每页记录数<br> * @emits &#x27;handlePageSizeChange&#x27; - 触发分页大小更改事件，传递新的每页记录数<br> */<br>function handlePageSizeChange(pageSize) &#123;<br>  emits(&#x27;handlePageSizeChange&#x27;, pageSize)<br>&#125;<br><br>/**<br> * 处理当前页码变化的事件<br> * @param pageNum &#123;number&#125; 新的页码<br> * @emits &#x27;handleCurrentPageChange&#x27; 触发当前页码变化的自定义事件，将新的页码作为参数传递<br> */<br>function handleCurrentPageChange(pageNum) &#123;<br>  emits(&#x27;handleCurrentPageChange&#x27;, pageNum)<br>&#125;<br><br>/**<br> * 处理选择列表的变化<br> * @param selectedList 选择后的列表<br> * @emits &#x27;handleSelectionChange&#x27; 触发选择列表变化的事件，携带当前选择的列表作为参数<br> */<br>function handleSelectionChange(selectedList) &#123;<br>  emits(&#x27;handleSelectionChange&#x27;, selectedList)<br>&#125;<br>/**<br> * 处理选择项的变化<br> * @param selectedRow 选择后的列表<br> * @emits &#x27;handleCurrentChange&#x27; 触发选择变化的事件，携带当前选择的项作为参数<br> */<br>function handleCurrentChange(selectedRow) &#123;<br>  emits(&#x27;handleCurrentChange&#x27;, selectedRow)<br>&#125;<br><br>// 暴露给父组件的方法,处理你选中的行需要回显<br>function handleSelectRow(selectedRowIdList, key) &#123;<br>  //回显被选中的数据<br>  nextTick(() =&gt; &#123;<br>    props.data.forEach(row =&gt; &#123;<br>      if (selectedRowIdList.includes(row[key])) &#123;<br>        tableRef.value.toggleRowSelection(row, true)<br>      &#125;<br>    &#125;)<br>  &#125;)<br>&#125;<br><br>defineExpose(&#123;<br>  handleSelectRow,<br>&#125;)<br>&lt;/script&gt;<br>&lt;style scoped lang=&quot;scss&quot;&gt;<br>.table-container &#123;<br>  width: 100%;<br>  box-sizing: border-box;<br>  padding: 20px;<br>&#125;<br><br>.noPadding &#123;<br>  padding: 0px;<br>&#125;<br>&lt;/style&gt;<br><br></code></pre></td></tr></table></figure><h1 id="大屏"><a href="#大屏" class="headerlink" title="大屏"></a>大屏</h1><h2 id="自适应大屏组件"><a href="#自适应大屏组件" class="headerlink" title="自适应大屏组件"></a>自适应大屏组件</h2><h3 id="版本一：两边有空隙"><a href="#版本一：两边有空隙" class="headerlink" title="版本一：两边有空隙"></a><strong>版本一：两边有空隙</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;section<br>    ref=&quot;box&quot;<br>    :style=&quot;&#123; ...styles.box, ...boxStyle &#125;&quot;<br>    class=&quot;v-screen-box&quot;<br>  &gt;<br>    &lt;div<br>      ref=&quot;screenWrapper&quot;<br>      :style=&quot;&#123; ...styles.wrapper, ...wrapperStyle &#125;&quot;<br>      class=&quot;screen-wrapper&quot;<br>    &gt;<br>      &lt;slot&gt;&lt;/slot&gt;<br>    &lt;/div&gt;<br>  &lt;/section&gt;<br>&lt;/template&gt;<br>&lt;script setup&gt;<br>import &#123; nextTick, onMounted, onUnmounted, reactive, ref, watch &#125; from &#x27;vue&#x27;<br><br>/**<br> * 防抖函数<br> * @param &#123;Function&#125; fn<br> * @param &#123;number&#125; delay<br> * @returns &#123;() =&gt; void&#125;<br> */<br>function debounce(fn, delay) &#123;<br>  // let timer: NodeJS.Timer;<br>  let timer<br>  return function (...args) &#123;<br>    if (timer) clearTimeout(timer)<br>    timer = setTimeout(<br>      () =&gt; &#123;<br>        typeof fn === &#x27;function&#x27; &amp;&amp; fn.apply(null, args)<br>        clearTimeout(timer)<br>      &#125;,<br>      delay &gt; 0 ? delay : 100,<br>    )<br>  &#125;<br>&#125;<br><br>// interface IState &#123;<br>//   originalWidth: string | number;<br>//   originalHeight: string | number;<br>//   width?: string | number;<br>//   height?: string | number;<br>//   observer: null | MutationObserver;<br>// &#125;<br>// type IAutoScale =<br>//   | boolean<br>//   | &#123;<br>//     x?: boolean;<br>//     y?: boolean;<br>//   &#125;;<br>const props = defineProps(&#123;<br>  width: &#123;<br>    type: Number,<br>    default: 1920,<br>  &#125;,<br>  height: &#123;<br>    type: Number,<br>    default: 1080,<br>  &#125;,<br>  fullScreen: &#123;<br>    type: Boolean,<br>    default: false,<br>  &#125;,<br>  autoScale: &#123;<br>    type: Boolean,<br>    default: true,<br>  &#125;,<br>  delay: &#123;<br>    type: Number,<br>    default: 500,<br>  &#125;,<br>  boxStyle: &#123;<br>    type: Object,<br>    default: () =&gt; (&#123;&#125;),<br>  &#125;,<br>  wrapperStyle: &#123;<br>    type: Object,<br>    default: () =&gt; (&#123;&#125;),<br>  &#125;,<br>&#125;)<br><br>const state = reactive(&#123;<br>  width: 0,<br>  height: 0,<br>  originalWidth: 0,<br>  originalHeight: 0,<br>  observer: null,<br>&#125;)<br><br>const styles = &#123;<br>  box: &#123;<br>    overflow: &#x27;hidden&#x27;,<br>    backgroundSize: `100% 100%`,<br>    background: `#000`,<br>    width: `100vw`,<br>    height: `100vh`,<br>  &#125;,<br>  wrapper: &#123;<br>    transitionProperty: `all`,<br>    transitionTimingFunction: `cubic-bezier(0.4, 0, 0.2, 1)`,<br>    transitionDuration: `500ms`,<br>    position: `relative`,<br>    overflow: `hidden`,<br>    zIndex: 100,<br>    transformOrigin: `left top`,<br>  &#125;,<br>&#125;<br><br>const screenWrapper = ref()<br>const box = ref()<br><br>watch(<br>  () =&gt; props.autoScale,<br>  async (newVal) =&gt; &#123;<br>    if (newVal) &#123;<br>      onResize()<br>      addListener()<br>    &#125; else &#123;<br>      clearListener()<br>      clearScreenWrapperStyle()<br>    &#125;<br>  &#125;,<br>)<br>/**<br> * 初始化大屏容器宽高<br> */<br>const initSize = () =&gt; &#123;<br>  return new Promise((resolve) =&gt; &#123;<br>    box.value.scrollLeft = 0<br>    box.value.scrollTop = 0<br>    nextTick(() =&gt; &#123;<br>      // region 获取大屏真实尺寸<br>      if (props.width &amp;&amp; props.height) &#123;<br>        state.width = props.width<br>        state.height = props.height<br>      &#125; else &#123;<br>        state.width = screenWrapper.value?.clientWidth<br>        state.height = screenWrapper.value?.clientHeight<br>      &#125;<br>      // endregion<br><br>      // region 获取画布尺寸<br>      if (!state.originalHeight || !state.originalWidth) &#123;<br>        state.originalWidth = window.screen.width<br>        state.originalHeight = window.screen.height<br>      &#125;<br>      // endregion<br>      resolve()<br>    &#125;)<br>  &#125;)<br>&#125;<br><br>/**<br> * 更新大屏容器宽高<br> */<br>const updateSize = () =&gt; &#123;<br>  if (state.width &amp;&amp; state.height) &#123;<br>    screenWrapper.value.style.width = `$&#123;state.width&#125;px`<br>    screenWrapper.value.style.height = `$&#123;state.height&#125;px`<br>  &#125; else &#123;<br>    screenWrapper.value.style.width = `$&#123;state.originalWidth&#125;px`<br>    screenWrapper.value.style.height = `$&#123;state.originalHeight&#125;px`<br>  &#125;<br>&#125;<br>const clearScreenWrapperStyle = () =&gt; &#123;<br>  screenWrapper.value.style.transform = &#x27;&#x27;<br>  screenWrapper.value.style.margin = &#x27;&#x27;<br>&#125;<br>const autoScale = (scale) =&gt; &#123;<br>  if (!props.autoScale) &#123;<br>    return<br>  &#125;<br>  const domWidth = screenWrapper.value.clientWidth<br>  const domHeight = screenWrapper.value.clientHeight<br>  const currentWidth = document.body.clientWidth<br>  const currentHeight = document.body.clientHeight<br>  screenWrapper.value.style.transform = `scale($&#123;scale&#125;,$&#123;scale&#125;)`<br>  let mx = Math.max((currentWidth - domWidth * scale) / 2, 0)<br>  let my = Math.max((currentHeight - domHeight * scale) / 2, 0)<br>  if (typeof props.autoScale === &#x27;object&#x27;) &#123;<br>    !props.autoScale.x &amp;&amp; (mx = 0)<br>    !props.autoScale.y &amp;&amp; (my = 0)<br>  &#125;<br>  screenWrapper.value.style.margin = `$&#123;my&#125;px $&#123;mx&#125;px`<br>&#125;<br>const updateScale = () =&gt; &#123;<br>  // 获取真实视口尺寸<br>  const currentWidth = document.body.clientWidth<br>  const currentHeight = document.body.clientHeight<br>  // 获取大屏最终的宽高<br>  const realWidth = state.width || state.originalWidth<br>  const realHeight = state.height || state.originalHeight<br>  // 计算缩放比例<br>  const widthScale = currentWidth / +realWidth<br>  const heightScale = currentHeight / +realHeight<br>  // 若要铺满全屏，则按照各自比例缩放<br>  if (props.fullScreen) &#123;<br>    screenWrapper.value.style.transform = `scale($&#123;widthScale&#125;,$&#123;heightScale&#125;)`<br>    return false<br>  &#125;<br>  // 按照宽高最小比例进行缩放<br>  const scale = Math.min(widthScale, heightScale)<br>  autoScale(scale)<br>&#125;<br><br>const onResize = debounce(async () =&gt; &#123;<br>  await initSize()<br>  updateSize()<br>  updateScale()<br>&#125;, props.delay)<br>const initMutationObserver = () =&gt; &#123;<br>  const observer = (state.observer = new MutationObserver(() =&gt; &#123;<br>    onResize()<br>  &#125;))<br>  observer.observe(screenWrapper.value, &#123;<br>    attributes: true,<br>    attributeFilter: [&#x27;style&#x27;],<br>    attributeOldValue: true,<br>  &#125;)<br>&#125;<br><br>const clearListener = () =&gt; &#123;<br>  window.removeEventListener(&#x27;resize&#x27;, onResize)<br>  // state.observer?.disconnect();<br>&#125;<br><br>const addListener = () =&gt; &#123;<br>  window.addEventListener(&#x27;resize&#x27;, onResize)<br>  // initMutationObserver();<br>&#125;<br>onMounted(() =&gt; &#123;<br>  nextTick(async () =&gt; &#123;<br>    await initSize()<br>    updateSize()<br>    updateScale()<br>    addListener()<br>    // initMutationObserver();<br>  &#125;)<br>&#125;)<br>onUnmounted(() =&gt; &#123;<br>  clearListener()<br>  // state.observer?.disconnect();<br>&#125;)<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h3 id="版本二：没有空隙，但是需要看文档"><a href="#版本二：没有空隙，但是需要看文档" class="headerlink" title="版本二：没有空隙，但是需要看文档"></a>版本二：没有空隙，但是需要看文档</h3><p><a href="https://auto-plugin.github.io/autofit.js/api.html">https://auto-plugin.github.io/autofit.js/api.html</a></p><h2 id="列表自动滚动（悬浮暂停，可手动滚动）"><a href="#列表自动滚动（悬浮暂停，可手动滚动）" class="headerlink" title="列表自动滚动（悬浮暂停，可手动滚动）"></a>列表自动滚动（悬浮暂停，可手动滚动）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div class=&quot;autoScroll-container w-full&quot; :style=&quot;&#123; height: height + &#x27;px&#x27; &#125;&quot;&gt;<br>    &lt;el-scrollbar ref=&quot;scrollbarRef&quot; :height=&quot;height&quot; @scroll=&quot;scroll&quot; @mouseenter=&quot;onMouseenter&quot;<br>      @mouseleave=&quot;onMouseleave&quot;&gt;<br>      &lt;div ref=&quot;scrollAreaRef&quot;&gt;<br>        &lt;slot&gt;&lt;/slot&gt;<br>        &lt;slot v-if=&quot;canScrollHeight &gt; 0&quot;&gt;&lt;/slot&gt;<br>      &lt;/div&gt;<br>    &lt;/el-scrollbar&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script setup&gt;<br>import &#123; nextTick, onUnmounted, ref, watch &#125; from &#x27;vue&#x27;<br><br>const props = defineProps(&#123;<br>  list: &#123;<br>    type: Array,<br>    default: () =&gt; [],<br>  &#125;,<br>  height: &#123;<br>    type: Number,<br>    default: 0,<br>  &#125;,<br>  // 是否可以滚动<br>  isCanScroll: &#123;<br>    type: Boolean,<br>    default: true,<br>  &#125;,<br>  // 滚动速度<br>  speed: &#123;<br>    type: Number,<br>    default: 0.5,<br>  &#125;,<br>&#125;)<br><br>const scrollbarRef = ref(null)<br>const scrollAreaRef = ref(null)<br>const canScrollHeight = ref(0) // 可滚动高度<br><br>let caseScrollTop = 0 // 滚动位置距离顶部高度<br>let animateId = null // 动画帧id<br>let isAnimating = false // 动画是否正在进行<br>let isOnContainer = false // 鼠标是否在容器区域内<br><br>watch(<br>  () =&gt; props.isCanScroll,<br>  (newVal) =&gt; &#123;<br>    // 可以滚动且不存在动画帧且不在容器区域内<br>    if (newVal &amp;&amp; !isAnimating &amp;&amp; !isOnContainer) &#123;<br>      startScrollAnimate()<br>    &#125;<br>  &#125;,<br>)<br><br>// 监听数据，获取可滚动高度。同时开始滚动<br>watch(<br>  () =&gt; props.list,<br>  async (newVal) =&gt; &#123;<br>    if (newVal.length &gt; 0) &#123;<br>      await nextTick()<br><br>      canScrollHeight.value = scrollAreaRef.value.scrollHeight - props.height<br>      // 停止旧动画后再启动新动画<br>      stopScrollAnimate()<br>      startScrollAnimate()<br>    &#125;<br>  &#125;,<br>  &#123;<br>    immediate: true,<br>  &#125;,<br>)<br><br>onUnmounted(() =&gt; &#123;<br>  stopScrollAnimate()<br>&#125;)<br><br>/**<br> * 开始滚动（超出可视区，才滚动）<br> */<br>function startScrollAnimate() &#123;<br>  if (canScrollHeight.value &lt;= 0) return<br><br>  const st = scrollbarRef.value.wrapRef.scrollTop // 滚动高度<br>  const sh = scrollAreaRef.value.scrollHeight / 2 // 单内容区高度<br>  if (st &gt;= sh) &#123;<br>    caseScrollTop = 0<br>  &#125;<br>  caseScrollTop += props.speed<br>  scrollbarRef.value.setScrollTop(caseScrollTop)<br>  animateId = requestAnimationFrame(startScrollAnimate)<br>  isAnimating = true<br>&#125;<br><br>/**<br> * 停止滚动<br> */<br>function stopScrollAnimate() &#123;<br>  if (animateId) &#123;<br>    cancelAnimationFrame(animateId)<br>    isAnimating = false<br>  &#125;<br>&#125;<br><br>/**<br> * 鼠标移入<br> */<br>function onMouseenter() &#123;<br>  isOnContainer = true<br>  stopScrollAnimate()<br>&#125;<br><br>/**<br> * 鼠标移出<br> */<br>function onMouseleave() &#123;<br>  isOnContainer = false<br>  if (props.isCanScroll) &#123;<br>    startScrollAnimate()<br>  &#125;<br>&#125;<br><br>/**<br> * 手动滚动后，重新设置滚动位置<br> */<br>function scroll(&#123; scrollTop &#125;) &#123;<br>  const sh = scrollAreaRef.value.scrollHeight / 2 // 单内容区高度<br>  if (scrollTop &gt;= sh) &#123;<br>    caseScrollTop = 0<br>    scrollbarRef.value.setScrollTop(caseScrollTop)<br>  &#125; else &#123;<br>    caseScrollTop = scrollTop<br>  &#125;<br>&#125;<br><br>onUnmounted(() =&gt; &#123;<br>  stopScrollAnimate()<br>&#125;)<br>&lt;/script&gt;<br><br>&lt;style lang=&quot;scss&quot; scoped&gt;<br>:deep(.el-scrollbar__bar.is-vertical) &#123;<br>  width: 0;<br>&#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><h2 id="Echarts（待优化）"><a href="#Echarts（待优化）" class="headerlink" title="Echarts（待优化）"></a>Echarts（待优化）</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> echarts <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;echarts/core&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;echarts/lib/component/graphic&#x27;</span><br><span class="hljs-keyword">import</span> &#123;<br>  <span class="hljs-title class_">BarChart</span>,<br>  <span class="hljs-title class_">LineChart</span>,<br>  <span class="hljs-title class_">LinesChart</span>,<br>  <span class="hljs-title class_">PieChart</span>,<br>  <span class="hljs-title class_">ScatterChart</span>,<br>  <span class="hljs-title class_">RadarChart</span>,<br>  <span class="hljs-title class_">GaugeChart</span>,<br>  <span class="hljs-title class_">PictorialBarChart</span>,<br>  <span class="hljs-title class_">CustomChart</span>,<br>&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;echarts/charts&#x27;</span><br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">LegendComponent</span>, <span class="hljs-title class_">PolarComponent</span>, <span class="hljs-title class_">GeoComponent</span>, <span class="hljs-title class_">ToolboxComponent</span>, <span class="hljs-title class_">DataZoomComponent</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;echarts/components&#x27;</span><br><span class="hljs-keyword">import</span> &#123;<br>  <span class="hljs-title class_">TitleComponent</span>,<br>  <span class="hljs-title class_">TooltipComponent</span>,<br>  <span class="hljs-title class_">GridComponent</span>,<br>  <span class="hljs-comment">// 数据集组件</span><br>  <span class="hljs-title class_">DatasetComponent</span>,<br>  <span class="hljs-comment">// 内置数据转换器组件 (filter, sort)</span><br>  <span class="hljs-title class_">TransformComponent</span>,<br>&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;echarts/components&#x27;</span><br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">LabelLayout</span>, <span class="hljs-title class_">UniversalTransition</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;echarts/features&#x27;</span><br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">CanvasRenderer</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;echarts/renderers&#x27;</span><br><br><span class="hljs-comment">// 注册必须的组件</span><br>echarts.<span class="hljs-title function_">use</span>([<br>  <span class="hljs-title class_">LegendComponent</span>,<br>  <span class="hljs-title class_">TitleComponent</span>,<br>  <span class="hljs-title class_">TooltipComponent</span>,<br>  <span class="hljs-title class_">GridComponent</span>,<br>  <span class="hljs-title class_">DatasetComponent</span>,<br>  <span class="hljs-title class_">TransformComponent</span>,<br>  <span class="hljs-title class_">BarChart</span>,<br>  <span class="hljs-title class_">LineChart</span>,<br>  <span class="hljs-title class_">LabelLayout</span>,<br>  <span class="hljs-title class_">UniversalTransition</span>,<br>  <span class="hljs-title class_">CanvasRenderer</span>,<br>  <span class="hljs-title class_">TitleComponent</span>,<br>  <span class="hljs-title class_">TooltipComponent</span>,<br>  <span class="hljs-title class_">GridComponent</span>,<br>  <span class="hljs-title class_">DatasetComponent</span>,<br>  <span class="hljs-title class_">TransformComponent</span>,<br>  <span class="hljs-title class_">LegendComponent</span>,<br>  <span class="hljs-title class_">PolarComponent</span>,<br>  <span class="hljs-title class_">GeoComponent</span>,<br>  <span class="hljs-title class_">ToolboxComponent</span>,<br>  <span class="hljs-title class_">DataZoomComponent</span>,<br>  <span class="hljs-title class_">BarChart</span>,<br>  <span class="hljs-title class_">LineChart</span>,<br>  <span class="hljs-title class_">LinesChart</span>,<br>  <span class="hljs-title class_">PieChart</span>,<br>  <span class="hljs-title class_">ScatterChart</span>,<br>  <span class="hljs-title class_">RadarChart</span>,<br>  <span class="hljs-title class_">GaugeChart</span>,<br>  <span class="hljs-title class_">LabelLayout</span>,<br>  <span class="hljs-title class_">UniversalTransition</span>,<br>  <span class="hljs-title class_">CanvasRenderer</span>,<br>  <span class="hljs-title class_">PictorialBarChart</span>,<br>  <span class="hljs-title class_">CustomChart</span>,<br>])<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> echarts<br><br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div class=&quot;w-full h-full&quot;&gt;<br>    &lt;div id=&quot;echarts&quot; ref=&quot;chartRef&quot; class=&quot;w-full h-full&quot; /&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script setup&gt;<br>const props = defineProps(&#123;<br>  renderData: &#123;<br>    type: Object,<br>    default: () =&gt; (&#123;&#125;),<br>  &#125;,<br>&#125;)<br>import echarts from &#x27;@/components/ECharts/echarts.js&#x27;<br>import &#123; debounce &#125; from &#x27;@/utils&#x27;<br><br>/*<br>props格式<br>&#123;<br>    yData: [&#x27;30-40岁&#x27;, &#x27;40-50岁&#x27;, &#x27;50-60岁&#x27;],<br>    result:  [12, 5, 2],<br>  &#125;<br>*/<br><br>// 当前被渲染的div实例，用来初始化echarts实例<br>const chartRef = ref(null)<br><br>// echart实例，不要使用ref、reactive响应式变量，会和echarts的交互造成冲突，比如tooltip不显示<br>const chartInstance = shallowRef(null)<br><br>let timer = null<br><br>// 配置项函数<br>// const options = computed(() =&gt; &#123;<br>//   return &#123;&#125;<br>// &#125;)<br><br>const options = computed(() =&gt; &#123;<br>  return &#123;<br>    grid: &#123;<br>      left: &#x27;-35%&#x27;,<br>      right: &#x27;8%&#x27;,<br>      top: &#x27;10%&#x27;, // 调整顶部间距以适应纵坐标和数值<br>      bottom: &#x27;-8%&#x27;,<br>      containLabel: true,<br>    &#125;,<br>    tooltip: &#123;<br>      trigger: &#x27;axis&#x27;,<br>      axisPointer: &#123;<br>        type: &#x27;shadow&#x27;,<br>        shadowStyle: &#123;<br>          color: &#x27;transparent&#x27;, // 将遮罩层颜色设置为透明<br>        &#125;,<br>      &#125;,<br>      extraCssText: `<br>    height: 36px;<br>    background: rgba(0,32,83,0.9);<br>    border-radius: 4px;<br>    border: 1px solid #3973AE;<br>    padding: 0; /* 去掉默认的 padding */<br>  `,<br>      formatter: (params) =&gt; &#123;<br>        return `<br>      &lt;div style=&quot;display: flex; align-items: center; height: 36px; background: rgba(0,32,83,0.9); border-radius: 4px; border: 1px solid #3973AE;&quot;&gt;<br>&lt;div style=&quot;flex: 1; text-align: right;padding-left: 10px; padding-right: 10px; font-family: DINAlternate, DINAlternate; font-weight: normal; font-size: 14px; color: #FFFFFF; line-height: 21px; text-align: right; font-style: normal;&quot;&gt;<br>          $&#123;params[0].name&#125;<br>        &lt;/div&gt;<br>        &lt;div style=&quot;flex: 1; text-align: left; padding-right: 10px; font-family: DINAlternate, DINAlternate; font-weight: bold; font-size: 18px; color: #66FFFF; line-height: 21px; text-align: left; font-style: normal;&quot;&gt;<br>          $&#123;params[0].value&#125;<br>        &lt;/div&gt;<br>      &lt;/div&gt;<br>    `<br>      &#125;,<br>    &#125;,<br>    xAxis: &#123;<br>      type: &#x27;value&#x27;,<br>      show: false, // 隐藏 x 轴<br>    &#125;,<br>    yAxis: &#123;<br>      type: &#x27;category&#x27;,<br>      data: props.renderData.yData, // 修改纵坐标顺序<br>      axisTick: &#123; show: false &#125;, // 隐藏刻度线<br>      axisLine: &#123; show: false &#125;, // 隐藏轴线<br>      axisLabel: &#123;<br>        fontSize: 14,<br>        margin: 20, // 增加纵坐标与柱子的间距<br>        position: &#x27;top&#x27;, // 纵坐标显示在柱子上方<br>        align: &#x27;left&#x27;, // 纵坐标文本左对齐<br>        verticalAlign: &#x27;bottom&#x27;, // 垂直方向对齐方式<br>        padding: [0, 0, 15, 20], // 微调纵坐标的水平位置，使其靠近柱子开头<br>        color: &#x27;#fff&#x27;, // 纵坐标文字颜色<br>        fontFamily: &#x27;PingFangSC&#x27;,<br>      &#125;,<br>      inverse: true, // 反转 y 轴顺序，使数据从上到下排列<br>    &#125;,<br>    series: [<br>      &#123;<br>        name: &#x27;年龄&#x27;,<br>        type: &#x27;bar&#x27;,<br>        barWidth: &#x27;20%&#x27;,<br>        data: props.renderData.result,<br>        itemStyle: &#123;<br>          color: function (params) &#123;<br>            // 设置渐变色<br>            const colorList = [<br>              &#123;<br>                type: &#x27;linear&#x27;,<br>                x: 0,<br>                y: 0,<br>                x2: 1, // 渐变方向从左到右<br>                y2: 0,<br>                colorStops: [<br>                  &#123; offset: 0, color: &#x27;#37C6FE&#x27; &#125;, // 起始颜色<br>                  &#123; offset: 1, color: &#x27;#1C52CE&#x27; &#125;, // 结束颜色<br>                ],<br>                global: false, // 缺省为 false<br>              &#125;,<br>            ]<br>            return colorList[0]<br>          &#125;,<br>          barBorderRadius: 0, // 设置柱子圆角<br>        &#125;,<br>        label: &#123;<br>          show: true,<br>          position: &#x27;position&#x27;, // 显示在柱子的右端<br>          color: &#x27;#fff&#x27;, // 标签文字颜色<br>          fontSize: 14,<br>          offset: [145, -20], // 水平偏移量，微调标签位置<br>          formatter: function (params) &#123;<br>            return params.value // 显示当前柱子的值<br>          &#125;,<br>        &#125;,<br>      &#125;,<br>      &#123;<br>        // 分隔<br>        type: &#x27;pictorialBar&#x27;,<br>        itemStyle: &#123;<br>          normal: &#123;<br>            color: &#x27;#100c29&#x27;,<br>          &#125;,<br>        &#125;,<br>        symbolRepeat: &#x27;fixed&#x27;,<br>        symbolMargin: 2,<br>        symbol: &#x27;rect&#x27;,<br>        symbolClip: true,<br>        symbolSize: [4, 15], // 分隔的宽度和高度，第一个是宽，第二个是高<br>        symbolPosition: &#x27;start&#x27;,<br>        symbolOffset: [-4, 0],<br>        // symbolBoundingData: this.total,<br>        data: props.renderData.result,<br>        width: 25,<br>        z: 0,<br>        zlevel: 1,<br>      &#125;,<br>    ],<br>  &#125;<br>&#125;)<br><br>// options变化时重新加载options<br>watch(<br>  () =&gt; options.value,<br>  () =&gt; &#123;<br>    if (chartInstance.value &amp;&amp; options.value) &#123;<br>      chartInstance.value.clear()<br>      chartInstance.value.setOption(options.value)<br>    &#125;<br>  &#125;,<br>  &#123; deep: true &#125;,<br>)<br><br>function setChartInterval() &#123;<br>  if (timer) &#123;<br>    clearInterval(timer)<br>  &#125;<br>  let currentIndex = 0<br>  timer = setInterval(() =&gt; &#123;<br>    chartInstance.value.dispatchAction(&#123;<br>      type: &#x27;hideTip&#x27;,<br>    &#125;)<br>    chartInstance.value.dispatchAction(&#123;<br>      type: &#x27;highlight&#x27;,<br>      seriesIndex: 0,<br>      dataIndex: currentIndex,<br>    &#125;)<br>    chartInstance.value.dispatchAction(&#123;<br>      type: &#x27;showTip&#x27;,<br>      seriesIndex: 0,<br>      dataIndex: currentIndex,<br>    &#125;)<br>    currentIndex = (currentIndex + 1) % options.value.series[0].data.length<br>  &#125;, 3000)<br>&#125;<br><br>/**<br> *@description 为图表重新计算高度<br> *@param container 父容器<br> *@param charts echarts对象<br> *@param offsetX 横轴偏移，可不填，默认50px<br> *@param offsetY 纵轴偏移，可不填，默认70px<br> */<br>function chartsSize(container, charts, offsetX = 50, offsetY = 70) &#123;<br>  function getStyle(el) &#123;<br>    // window.getComputedStyle可获取元素计算后（有变化）的样式，包括宽高、背景色、字体、颜色等<br>    if (window?.getComputedStyle) &#123;<br>      const doc = window?.getComputedStyle(el)<br>      const height = parseInt(doc.height)<br>      const width = parseInt(doc.width)<br>      return &#123; height, width &#125;<br>    &#125; else &#123;<br>      return &#123; height: el.clientHeight, width: el.clientWidth &#125;<br>    &#125;<br>  &#125;<br>  // 获取计算后的宽度、高度，并重新渲染图图表<br>  const &#123; height, width &#125; = getStyle(container)<br>  charts.resize(&#123;<br>    width: parseInt((width - offsetX).toString()),<br>    height: parseInt((height - offsetY).toString()),<br>  &#125;)<br>&#125;<br><br>// 通过重新计算容器大小来实现图表自适应<br>function resize() &#123;<br>  chartsSize(chartRef.value, chartInstance.value, 0, 0)<br>&#125;<br><br>// 使用防抖避免频繁resize<br>const debounceResize = debounce(resize, 300)<br><br>// 初始化<br>function init() &#123;<br>  if (!chartRef.value) return<br>  chartInstance.value = echarts.getInstanceByDom(chartRef.value)<br>  if (!chartInstance.value) &#123;<br>    chartInstance.value = echarts.init(chartRef.value)<br>  &#125;<br>  console.log(&#x27;图表初始化&#x27;, chartInstance.value)<br>&#125;<br><br>onMounted(() =&gt; &#123;<br>  init()<br>  chartInstance.value.setOption(options.value)<br>  setChartInterval()<br><br>  window.addEventListener(&#x27;resize&#x27;, debounceResize)<br>&#125;)<br><br>onUnmounted(() =&gt; &#123;<br>  if (timer) &#123;<br>    clearInterval(timer)<br>  &#125;<br>&#125;)<br>&lt;/script&gt;<br><br>&lt;style scoped lang=&quot;less&quot;&gt;&lt;/style&gt;<br><br></code></pre></td></tr></table></figure><blockquote><p>注意：这个需要配合<a href="https://www.isqqw.com/?t=pie&amp;s=%E6%B8%90%E5%8F%98">https://www.isqqw.com/?t=pie&amp;s=%E6%B8%90%E5%8F%98</a> + <a href="https://www.makeapie.cn/echarts_category/series-pie">https://www.makeapie.cn/echarts_category/series-pie</a> 找例子 填入options就行</p></blockquote><h2 id="超过固定宽度才显示tooltip"><a href="#超过固定宽度才显示tooltip" class="headerlink" title="超过固定宽度才显示tooltip"></a>超过固定宽度才显示tooltip</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;el-tooltip<br>    :content=&quot;content&quot;<br>    :placement=&quot;placement&quot;<br>    :show-after=&quot;300&quot;<br>    :visible=&quot;visible&quot;<br>  &gt;<br>    &lt;div<br>      @mouseover=&quot;<br>        visible = $event.target.scrollWidth &gt; $event.target.clientWidth<br>      &quot;<br>      @mouseleave=&quot;visible = false&quot;<br>    &gt;<br>      &lt;slot&gt;&lt;/slot&gt;<br>    &lt;/div&gt;<br>  &lt;/el-tooltip&gt;<br>&lt;/template&gt;<br><br>&lt;script setup&gt;<br>defineProps(&#123;<br>  content: &#123;<br>    type: String,<br>    default: &#x27;&#x27;,<br>  &#125;,<br>  placement: &#123;<br>    type: String,<br>    default: &#x27;top&#x27;,<br>  &#125;,<br>&#125;)<br><br>const visible = ref(false)<br>&lt;/script&gt;<br><br>&lt;style lang=&quot;scss&quot; scoped&gt;&lt;/style&gt;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>经验</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端开发和解决问题的思路：逆向思维</title>
    <link href="/2025/04/04/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%92%8C%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98%E7%9A%84%E6%80%9D%E8%B7%AF%EF%BC%9A%E9%80%86%E5%90%91%E6%80%9D%E7%BB%B4/"/>
    <url>/2025/04/04/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%92%8C%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98%E7%9A%84%E6%80%9D%E8%B7%AF%EF%BC%9A%E9%80%86%E5%90%91%E6%80%9D%E7%BB%B4/</url>
    
    <content type="html"><![CDATA[<p><strong>前言</strong></p><p>为什么会想到总结这个东西？真的有一个万能的或者固定的思路吗？</p><p>有的。这个是我之前别人跟我说开发流程要闭环的时候体会到的，流程如何闭环？比如你开发前端页面，此时接口还没写好，如何做到接口一写好我做最小改动？那当然是 先把用到的数据先用变量写好，然后 假设此时有接口，该调接口的调接口，只是在@/Api/xxx/index.js中return的不是具体接口而是 假接口，只是data是mock数据，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> mockData <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/views/Xxx/config/mock.js&#x27;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">getXxxList</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-attr">code</span>: <span class="hljs-number">200</span>,<br>      <span class="hljs-attr">data</span>: mockData,<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最终将返回的数据赋值给定义好的变量然后展示，这就是一个简单的流程闭环的例子，从这里可以看出，思路就是 逆向思维，先逆向假设有接口是什么样的，然后再往前推就行。</p><p>我们解决问题也是一样的，先确定能确定的，然后就追根溯源往前推，如果不能确定，那就假设确定，如果假设有多个，那就得分类讨论，最终确定 得到 需要解决的 那个最根源的 东西，这样一个大的复杂的问题 就 转变为 解决那个最根源的东西即可，此时相当于已经化繁为简一遍了（这也是对问题化繁为简的方法）。                                                                                                                                                                               </p>]]></content>
    
    
    <categories>
      
      <category>经验</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何根据设计稿快速开发页面？</title>
    <link href="/2025/04/04/%E5%A6%82%E4%BD%95%E6%A0%B9%E6%8D%AE%E8%AE%BE%E8%AE%A1%E7%A8%BF%E5%BF%AB%E9%80%9F%E5%BC%80%E5%8F%91%E9%A1%B5%E9%9D%A2%EF%BC%9F/"/>
    <url>/2025/04/04/%E5%A6%82%E4%BD%95%E6%A0%B9%E6%8D%AE%E8%AE%BE%E8%AE%A1%E7%A8%BF%E5%BF%AB%E9%80%9F%E5%BC%80%E5%8F%91%E9%A1%B5%E9%9D%A2%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<h3 id="化繁为简"><a href="#化繁为简" class="headerlink" title="化繁为简"></a>化繁为简</h3><p>你要做的就是思考布局，剩下的直接复制 设计稿的样式即可（保证一比一还原设计稿）</p><blockquote><p>注意：</p><p>页面层级要清楚，使用BEM类名命名法划清从属关系，这样一眼就知道页面结构，例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 块：block-name --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;product-card&quot;</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 元素：block-name__element --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;product-card_image&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;image.jpg&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;Product Image&quot;</span> /&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;product-card_content&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h3</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;product-card_title&quot;</span>&gt;</span>Product Title<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;product-card_description&quot;</span>&gt;</span>Description of the product<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 修饰符：block-name_element--modifier --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;product-card_button--active&quot;</span>&gt;</span>Add to Cart<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>通常最后一层  修饰符，用的比较少，不可能每个状态都写一遍，除非这个带状态的样式多个地方要用，那你单独写一下，多个地方使用</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技巧总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue:关于父子传值以及computed和监听的总结</title>
    <link href="/2025/02/27/Vue-%E5%85%B3%E4%BA%8E%E7%88%B6%E5%AD%90%E4%BC%A0%E5%80%BC%E4%BB%A5%E5%8F%8Acomputed%E5%92%8C%E7%9B%91%E5%90%AC%E7%9A%84%E6%80%BB%E7%BB%93/"/>
    <url>/2025/02/27/Vue-%E5%85%B3%E4%BA%8E%E7%88%B6%E5%AD%90%E4%BC%A0%E5%80%BC%E4%BB%A5%E5%8F%8Acomputed%E5%92%8C%E7%9B%91%E5%90%AC%E7%9A%84%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p><strong>前言</strong></p><p>这段时间写了很多弹框涉及到父子传值，中间用到了计算属性和监听，遇到了一些问题，引发了一些思考。</p><p><strong>内容</strong></p><p>我们在父子传值的时候，我看有的人直接拿 props的数据进行展示，有的人另外用ref数据来接受，有的人用watch监听来保持数据一致，到底每种到底怎么用？先说结论：</p><ul><li>不用父组件的数据，自给自足 ————直接用自己数据 ——–&gt; 新增操作</li><li>用父组件的数据，但不写回去 ———– 直接用props数据，用于 展示、整合数据调用接口—-&gt; 编辑操作 都可</li><li>用父组件的数据，但是需要额外处理 ———-&gt; 计算属性computed</li><li>用父组件的数据，但是需要触发一系列除了简单赋值以外的操作 ——&gt; watch监听–监听父传子数据调用函数</li></ul><p>如果是弹框再次总结：</p><ul><li>新增操作—-&gt;父组件用v-model打开弹框，子组件赋值给:model-value</li><li>编辑、查看操作 ———-&gt;父组件直接传递detailInfo，子组件直接拿props.detailInfo来用，数据能保持一致</li><li>新增、编辑、查看等—&gt;父组件用ref打开弹框，子组件暴露一个opeDialog函数，可传递type（编辑/新增/查看）和 row（编辑、查看的数据）</li></ul><p>​       如果使用传递detailInfo来处理，可以使用计算属性 直接return detailInfo（编辑、详情）||{}（新增）—不推荐，可读性差</p>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>使用场景</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端开发规范</title>
    <link href="/2024/12/08/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/"/>
    <url>/2024/12/08/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/</url>
    
    <content type="html"><![CDATA[<h3 id="通用规范"><a href="#通用规范" class="headerlink" title="通用规范"></a>通用规范</h3><p><strong>注释</strong></p><p>避免让团队其他成员去猜，提高整体团队开发效率</p><ul><li>公共组件</li><li>函数</li><li>接口说明</li><li>变量名</li></ul><p><strong>调试</strong></p><p>console.log()、debugger使用完要及时删除，减少打包体积</p><p><strong>文件夹的建立</strong></p><p>为了高内聚低耦合，尽可能地每一个拆分的组件都用一个新的文件夹，然后该组件使用自己的再次拆分的components和config，除非使用的组件是和它同级公用的，这时才把公共组件放到同级componnets里。分得越细越好，这样好维护。</p><h3 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h3><p><strong>项目命名</strong></p><p>小写+中线分隔：例如web-abs</p><p><strong>目录、文件名</strong></p><ul><li><p>小写+中线分隔（比小驼峰更加易理解），有复数要加复数，例如：scripts / styles / demo-styles</p></li><li><p>JS、CSS、SCSS、HTML、PNG命名同理，例如：@/assets/img/logo-white.png</p></li></ul><p><strong>组件文件名</strong></p><ul><li><p>大驼峰命名（使用组件时首字母也需要大写，在定义的时候就保持一致）</p></li><li><p>不同类别又有不同命名方式：</p><ul><li>基础组件（UI展示类组件，无业务逻辑）——– BaseXXX.vue，比如BaseButton.vue</li><li>紧密耦合的组件（用于页面较复杂需要多层封装的组件）—–如下：<br>|- TodoList.vue<br>|- TodoListItem.vue<br>|- TodoListItemButton.vue</li><li>业务组件（封装特定业务的组件）———完整名字组成，StudentDashboardSettings.vue</li></ul></li><li><p>单词的顺序：一般性描述单词开头，修饰型单词结尾<br>|- SearchButtonClear.vue<br>|- SearchButtonRun.vue<br>|- SearchInputQuery.vue<br>|- SearchInputExcludeGlob.vue<br>|- SettingsCheckboxTerms.vue<br>|- SettingsCheckboxLaunchOnStartup.vue</p></li></ul><blockquote><p>总结：文件以及以上级别的都用kebab-case（短横线连接式），特殊地：组件用大驼峰（组件大驼峰和文件的名命可以区分开来，否则都是短横线还以为是一个东西呢）</p></blockquote><p><strong>路由名</strong></p><p> kebab-case</p><p><strong>组件名（name）</strong></p><p>始终保持大驼峰（PascalCase），这么做为了和现有的HTML标签（都是一个单词且小写的）做区分</p><p><strong>prop名</strong></p><p>在在 HTML 中始终保持 kebab-case（短横线连接式），而子组件的prop名字保持大驼峰（PascalCase），这是HTML和Js这两种语言的自然约定</p><blockquote><p>事件名：遵循on-xxx的规范</p></blockquote><p><strong>函数、变量</strong></p><p>大驼峰命名</p><blockquote><p>方法名规范：动词或动词+名词</p><p>事件方法名（绑定事件的方法）：handle+名词（可选）+动词</p></blockquote><p><strong>常量</strong></p><p>大写+下划线</p><h3 id="HTML规范"><a href="#HTML规范" class="headerlink" title="HTML规范"></a>HTML规范</h3><p><strong>样式</strong></p><p>避免使用style样式，而是多用class</p><p><strong>img</strong></p><p>一定要加上alt属性，为了当图片不能正常显示时，则显示alt中的文字</p><h3 id="CSS规范"><a href="#CSS规范" class="headerlink" title="CSS规范"></a>CSS规范</h3><p><strong>class类名和id选择器的命名</strong></p><ul><li>class类名 ———&gt; BEM（块_元素–修饰符），例如：product-card_button–active，最后一个–修饰符用到的比较少，如果这个带状态的类名多个地方都会用才用，否则基本不用，因为可以直接写在上一级的元素里</li><li>id选择器 ——-&gt; 小驼峰</li></ul><p><strong>样式顺序</strong></p><p>位置-大小-文字-背景</p><h3 id="Js规范"><a href="#Js规范" class="headerlink" title="Js规范"></a>Js规范</h3><h3 id="Vue规范"><a href="#Vue规范" class="headerlink" title="Vue规范"></a>Vue规范</h3><p>是要两个一级以上用到的组件就要封装，不要觉得麻烦，当你要维护的时候就知道香了，结构清晰，改一个地方就行，不用每个地方都改</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>规范</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端开发宝典(Vue项目)</title>
    <link href="/2024/11/20/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%AE%9D%E5%85%B8-Vue-ElementUI/"/>
    <url>/2024/11/20/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%AE%9D%E5%85%B8-Vue-ElementUI/</url>
    
    <content type="html"><![CDATA[<h1 id="Js"><a href="#Js" class="headerlink" title="Js"></a>Js</h1><h3 id="使用任何-内部-数据-方法之前都要判断是否存在（-或者-amp-amp-）"><a href="#使用任何-内部-数据-方法之前都要判断是否存在（-或者-amp-amp-）" class="headerlink" title="使用任何 内部 数据/方法之前都要判断是否存在（?或者&amp;&amp;）"></a>使用任何 内部 数据/方法之前都要判断是否存在（?或者&amp;&amp;）</h3><p> <strong>只检验能否能拿得到数据用?，更复杂的判断用&amp;&amp;</strong></p><ul><li><p>数据（从父组件传过来的）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> aaa = <span class="hljs-title function_">computed</span>(<span class="hljs-function">()=&gt;</span>props?.<span class="hljs-property">xxx</span>)<br></code></pre></td></tr></table></figure><p>数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">res&amp;&amp;res.<span class="hljs-property">data</span>&amp;&amp;<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(res.<span class="hljs-property">data</span>) ? res.<span class="hljs-property">data</span>:[] <span class="hljs-comment">// 考虑周到：检查数据本身以及不存在的情况</span><br></code></pre></td></tr></table></figure></li><li><p>方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">handleClick</span> = (<span class="hljs-params">event</span>) =&gt; props.<span class="hljs-property">click</span> &amp;&amp; props.<span class="hljs-title function_">click</span>(event) <span class="hljs-comment">// props.click(event)是执行函数</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="使用-备用选项-使用"><a href="#使用-备用选项-使用" class="headerlink" title="使用 备用选项  使用 ||"></a>使用 备用选项  使用 ||</h3><ul><li><p>||比三元表达、if更优美</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 使用 || </span><br><span class="hljs-keyword">const</span> x = specialValue || defaultValue<br><span class="hljs-comment">// 使用三元表达</span><br><span class="hljs-keyword">const</span> x = specialValue ? specialValue : defaultValue<br><span class="hljs-comment">// 使用 if 语句</span><br><span class="hljs-keyword">if</span>(specialValue)&#123;<br>    x= specialValue<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>    x= defaultValue<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="tableData的数据结构要和html展示结构要一致"><a href="#tableData的数据结构要和html展示结构要一致" class="headerlink" title="tableData的数据结构要和html展示结构要一致"></a>tableData的数据结构要和html展示结构要一致</h3><ul><li><p>如果数据层数太多的话，会出现无法编辑的情况</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs html">                  <span class="hljs-tag">&lt;<span class="hljs-name">div</span></span><br><span class="hljs-tag">                    <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;setting-ticket-item&quot;</span></span><br><span class="hljs-tag">                    <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(item, index) in scope.row.currentTicketTypes.realName&quot;</span></span><br><span class="hljs-tag">                    <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;index&quot;</span></span><br><span class="hljs-tag">                  &gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&#123;&#123; item.name + &#x27;：&#x27; &#125;&#125;&lt;/span<br>                    &gt;<span class="hljs-tag">&lt;<span class="hljs-name">el-input</span></span><br><span class="hljs-tag">                      <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;width: 50px;&quot;</span></span><br><span class="hljs-tag">                      <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;item.ticket_value&quot;</span></span><br><span class="hljs-tag">                      <span class="hljs-attr">size</span>=<span class="hljs-string">&quot;small&quot;</span></span><br><span class="hljs-tag">                    &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">el-input</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>张<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>            <br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>比如当前el-table-column的字段是currentTicketTypes，那么就不能跳过currentTicetTypes直接用下一层数据realName，结果就是el-input无法输入，卡住了一样</p></li></ul><h3 id="：符号的意思"><a href="#：符号的意思" class="headerlink" title="：符号的意思"></a>：符号的意思</h3><ul><li>不仅仅是能填变量，而是指可以填常量，看你原来是什么数据，就是什么。比如:label=”3”，此时获取到的值就是3，而label:”3”，获取到的是“3”</li></ul><h3 id="多用const而不是let"><a href="#多用const而不是let" class="headerlink" title="多用const而不是let"></a>多用const而不是let</h3><ul><li>中间处理的数据都 重新用const定义一个变量，然后再赋值给想要的数据上，这样各司其职很清晰</li></ul><h3 id="const对于引用类型，限制的只是地址，因此内部的value可以修改"><a href="#const对于引用类型，限制的只是地址，因此内部的value可以修改" class="headerlink" title="const对于引用类型，限制的只是地址，因此内部的value可以修改"></a>const对于引用类型，限制的只是地址，因此内部的value可以修改</h3><h3 id="只有分别暴露才能边声明边暴露，默认暴露必须先声明好，再export-default-xxx"><a href="#只有分别暴露才能边声明边暴露，默认暴露必须先声明好，再export-default-xxx" class="headerlink" title="只有分别暴露才能边声明边暴露，默认暴露必须先声明好，再export default xxx"></a>只有分别暴露才能边声明边暴露，默认暴露必须先声明好，再export default xxx</h3><h3 id="Async-Await"><a href="#Async-Await" class="headerlink" title="Async/Await"></a>Async/Await</h3><p><strong>异步数据作为函数的返回值来使用 (使用场景较少,一般不这么用)</strong></p><ul><li>想要获取类似接口这样的异步数据作为函数的返回值在别处使用，必须使用await/async，因为只有await才能把数据返回出去</li><li>而async函数返回的一定是一个Promise，因此在别处使用又要用await</li><li>async一定还要加在离当前await最近的函数上，如果是回调函数要加在回调函数前面</li></ul><p><strong>想要一直保持同步，必须要一直连续await</strong></p><ul><li>一个包含await的函数想要仍然保持 函数里的同步顺序，外部在使用时必须再await，外部await是内部await的保障</li></ul><p><strong>异步操作的遍历不能用map函数</strong></p><ul><li><p>异步操作的遍历不能用map函数，否则返回的每一个item是一个promise，即使使用了await关键字也无法等待，因为map不回去处理异步操作，比较急躁</p></li><li><p>要用for循环（item的某一个属性值单独用await，然后再赋值上去）或者用Promise.all所有的promise来解决（用了map之后，是一个包含promsie的数组，那么就用Promise.all获取所有结果）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> item <span class="hljs-keyword">of</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">reserveTemplateInfo</span>) &#123;<br>            <span class="hljs-keyword">const</span> reservePeopleAll = (<span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getReservePersonTypeOptions</span>(item.<span class="hljs-property">id</span>)) || [];<br>            reserveObjectPerson.<span class="hljs-title function_">push</span>(&#123;<br>              <span class="hljs-attr">name</span>: item.<span class="hljs-property">name</span>,<br>              <span class="hljs-attr">id</span>: item.<span class="hljs-property">id</span>,<br>              reservePeopleAll,<br>              <span class="hljs-attr">reservePeople</span>: [],<br>              <span class="hljs-attr">department_type</span>: <span class="hljs-number">0</span>,<br>            &#125;);<br>          &#125;<br>          <span class="hljs-variable language_">this</span>.<span class="hljs-property">formData</span>.<span class="hljs-property">reserveObjectPerson</span> = reserveObjectPerson;<br></code></pre></td></tr></table></figure></li></ul><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p><strong>方法数据使用前的 注意点</strong></p><ul><li>一定要先判断 当前数组arr&amp;&amp;arr.length&amp;&amp;arr.map，否则会报map为undefined</li></ul><p><strong>各方法使用场景</strong></p><ul><li><p>reduce：对数组每项数据的数据结构进行重组，有点类似map，但是比map功能更强大，比如 </p><p>二维数组 -&gt; 一维数组（concat）</p><p>一维数组 -&gt; 对象（初始值设置为{}即可）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 将reserveObjectPerson每项reservePeople(数组)全放到一个数组里</span><br><span class="hljs-comment">// 如果用map实现就得遍历两次，因为map双层遍历返回的是二维数组</span><br>surfaceFormData.<span class="hljs-property">reserveObjectPerson</span>.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">acc, item</span>) =&gt;</span> &#123;<br>          <span class="hljs-keyword">const</span> people = item.<span class="hljs-property">reservePeople</span>;<br>          <span class="hljs-keyword">if</span> (people &amp;&amp; people.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) &#123;<br>            acc.<span class="hljs-title function_">push</span>(...people);<br>          &#125;<br>          <span class="hljs-keyword">return</span> acc;<br>        &#125;, []);<br></code></pre></td></tr></table></figure></li><li><p>every：返回值为boolean值，用于判断，数组的每个item都满足条件才返回true（有点类似allSettled）</p></li><li><p>some：返回值为boolean值，有一个满足返回true</p></li><li><p>concat：多个数组连成一个数组，在reduce方法里比较常用</p></li></ul><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><ul><li>hasOwnProperty：可以用来判断对象是否有传入的属性值</li></ul><h3 id="数据处理（复杂的交给chatgpt，简单的自己算，每次把复杂的积累下来）"><a href="#数据处理（复杂的交给chatgpt，简单的自己算，每次把复杂的积累下来）" class="headerlink" title="数据处理（复杂的交给chatgpt，简单的自己算，每次把复杂的积累下来）"></a>数据处理（复杂的交给chatgpt，简单的自己算，每次把复杂的积累下来）</h3><ul><li><p>在原来数据基础上加新数据项（新数据想需要另外遍历计算）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js">  <span class="hljs-keyword">let</span> newItem = &#123;     <br>      <span class="hljs-comment">// 先把原来的数据项中的属性都复制过来     </span><br>      ...item,    <br>  &#125;<br>    <span class="hljs-comment">// 到regionData查找匹配的地区    </span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; regionData.<span class="hljs-property">length</span>; i++) &#123;     <br>      <span class="hljs-keyword">if</span> (item.<span class="hljs-property">label</span>.<span class="hljs-title function_">includes</span>(regionData[i])) &#123;      <br>          newItem.<span class="hljs-property">region</span> = regionData[i] + <span class="hljs-string">&#x27;市&#x27;</span>      <span class="hljs-keyword">break</span>     <br>      &#125;   <br>  &#125;    <br><span class="hljs-keyword">return</span> newItem<br></code></pre></td></tr></table></figure></li><li><p>如果需要计算的每一项 都比较的复杂，那么就干脆不全放在一个map里面（慢一点）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> uniquePositions = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>()<br>tableDataAddRegions.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">tableItem</span> =&gt;</span> &#123;<br>    regionDots.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">regionDotItem</span> =&gt;</span> &#123;<br>       <span class="hljs-keyword">if</span> (tableItem.<span class="hljs-property">region</span> === regionDotItem.<span class="hljs-property">region</span>) &#123;<br>         <span class="hljs-keyword">const</span> position = regionDotItem.<span class="hljs-property">position</span><br>        uniquePositions.<span class="hljs-title function_">add</span>(position)<br>      &#125;<br>    &#125;)<br> &#125;)<br> <span class="hljs-comment">// 组装数据</span><br> mapChartData.<span class="hljs-property">value</span> = &#123;<br>    <span class="hljs-attr">renderData</span>: tableDataAddRegions.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item),<br>    <span class="hljs-attr">dotsData</span>: <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(uniquePositions),<br> &#125;<br></code></pre></td></tr></table></figure><p>去重的处理，就用 new Set()，保证内容不重复，熟悉下api，add–等于数组的push</p></li><li><p>把一样的某个值放在一起，这种叫分组，一开始故意用一个空数据（空对象）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> groupedData = &#123;&#125;<br>   <span class="hljs-comment">// 先遍历原始数据，将相同region的item.val进行累加分组</span><br>   props.<span class="hljs-property">mapChartData</span>.<span class="hljs-property">renderData</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> &#123;<br>     <span class="hljs-keyword">const</span> region = item.<span class="hljs-property">region</span><br>     <span class="hljs-keyword">const</span> val = <span class="hljs-built_in">parseFloat</span>(item.<span class="hljs-property">val</span>) <span class="hljs-comment">// 将字符串形式的数字转换为数字类型以便累加</span><br><br>     <span class="hljs-comment">// 如果不存在该region，则创建该region，并设置val值，否则进行累加</span><br>     <span class="hljs-keyword">if</span> (!groupedData[region]) &#123;<br>       groupedData[region] = &#123; region, val &#125;<br>     &#125; <span class="hljs-keyword">else</span> &#123;<br>       groupedData[region].<span class="hljs-property">val</span> += val<br>     &#125;<br>   &#125;)<br><br>   <span class="hljs-comment">// 将分组后的数据转换为数组形式返回</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">values</span>(groupedData)<br></code></pre></td></tr></table></figure><p>获取某个数组内所有对象的某个值，用Object.values</p><p>groupedData[region]是当前组名，{ region, val }才是Object.values要获取的值</p></li><li><p>递归给每一层加level字段</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js">/ 给树形部门名称的每一层加一个level字段表示当前层数 /<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">addLevelToObjects</span>(<span class="hljs-params">deptList</span>) &#123;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">addLevelRecursive</span>(<span class="hljs-params">arr, level</span>) &#123;<br>    <span class="hljs-keyword">return</span> arr.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">obj</span>) =&gt;</span> &#123;<br>      obj.<span class="hljs-property">level</span> = level;<br>      <span class="hljs-keyword">if</span> (obj.<span class="hljs-property">children</span>) &#123;<br>        obj.<span class="hljs-property">children</span> = <span class="hljs-title function_">addLevelRecursive</span>(obj.<span class="hljs-property">children</span>, level + <span class="hljs-number">1</span>);<br>      &#125;<br>      <span class="hljs-keyword">return</span> obj;<br>    &#125;);<br>  &#125;<br>   <br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">addLevelRecursive</span>(deptList, <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>把数组数据按照某个顺序分组 不如就遍历一下然后分多个类型数组分别push</p></li></ul><h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><h3 id="设置固定的px时一定要考虑不同电脑分辨率（尤其是宽度）的一定要有所冗余，不能刚刚好我电脑可以显示，很可能在其它电脑-会挤开"><a href="#设置固定的px时一定要考虑不同电脑分辨率（尤其是宽度）的一定要有所冗余，不能刚刚好我电脑可以显示，很可能在其它电脑-会挤开" class="headerlink" title="设置固定的px时一定要考虑不同电脑分辨率（尤其是宽度）的一定要有所冗余，不能刚刚好我电脑可以显示，很可能在其它电脑 会挤开"></a>设置固定的px时一定要考虑不同电脑分辨率（尤其是宽度）的一定要有所冗余，不能刚刚好我电脑可以显示，很可能在其它电脑 会挤开</h3><h3 id="在组件内部某个标签的样式-搜索出来只有一个不能代表没有用-有可能有全局设置样式"><a href="#在组件内部某个标签的样式-搜索出来只有一个不能代表没有用-有可能有全局设置样式" class="headerlink" title="在组件内部某个标签的样式 搜索出来只有一个不能代表没有用 有可能有全局设置样式"></a>在组件内部某个标签的样式 搜索出来只有一个不能代表没有用 有可能有全局设置样式</h3><h3 id="页面布局由外向内-的顺序来写，外部是内部的准备工作"><a href="#页面布局由外向内-的顺序来写，外部是内部的准备工作" class="headerlink" title="页面布局由外向内 的顺序来写，外部是内部的准备工作"></a>页面布局由外向内 的顺序来写，外部是内部的准备工作</h3><h3 id="内容溢出-gt-肯定哪里设置了固定宽-高"><a href="#内容溢出-gt-肯定哪里设置了固定宽-高" class="headerlink" title="内容溢出-&gt;肯定哪里设置了固定宽/高"></a>内容溢出-&gt;肯定哪里设置了固定宽/高</h3><ul><li>父元素设置太小</li><li>子元素设置太大</li></ul><h3 id="文本溢出显示省略号，注意要加宽度"><a href="#文本溢出显示省略号，注意要加宽度" class="headerlink" title="文本溢出显示省略号，注意要加宽度"></a>文本溢出显示省略号，注意要加宽度</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">width</span>: <span class="hljs-number">170px</span>; //设置宽度才知道哪里开始溢出<br><span class="hljs-attribute">white-space</span>: nowrap;//通常都是不换行显示省略号<br><span class="hljs-attribute">overflow</span>: hidden; //溢出内容隐藏<br><span class="hljs-attribute">text-overflow</span>: ellipsis;//用省略号代替<br></code></pre></td></tr></table></figure><h3 id="内容过多时出现滚动条"><a href="#内容过多时出现滚动条" class="headerlink" title="内容过多时出现滚动条"></a>内容过多时出现滚动条</h3><ul><li>在父级元素（哪个父级元素看需要滚动条多大范围）上增加 overflow:auto + 固定width</li></ul><h3 id="元素定位不相互挤压"><a href="#元素定位不相互挤压" class="headerlink" title="元素定位不相互挤压"></a>元素定位不相互挤压</h3><ul><li>只要用margin就会在文档流里，就会相互挤压，而绝对定位还能脱离文档流</li></ul><h3 id="渐变的分割线"><a href="#渐变的分割线" class="headerlink" title="渐变的分割线"></a>渐变的分割线</h3><ul><li><p>div加上以下样式</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">background</span>: <span class="hljs-built_in">linear-gradient</span>(to left, <span class="hljs-number">#ffffff</span>, <span class="hljs-number">#ddd8d8</span>, <span class="hljs-number">#ffffff</span>);<span class="hljs-attribute">height</span>: <span class="hljs-number">1px</span>;<br></code></pre></td></tr></table></figure></li></ul><h3 id="使用apply可以使用tailwind写法"><a href="#使用apply可以使用tailwind写法" class="headerlink" title="使用apply可以使用tailwind写法"></a>使用apply可以使用tailwind写法</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.charts-box</span> &#123;<br>  <span class="hljs-keyword">@apply</span> bg-amber;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="高度为-会跟渲染有关，尽量少用，渲染会卡，有些东西会渲染不出来（echarts）"><a href="#高度为-会跟渲染有关，尽量少用，渲染会卡，有些东西会渲染不出来（echarts）" class="headerlink" title="高度为%会跟渲染有关，尽量少用，渲染会卡，有些东西会渲染不出来（echarts）"></a>高度为%会跟渲染有关，尽量少用，渲染会卡，有些东西会渲染不出来（echarts）</h3><h3 id="cursor-pointer不能放在图标上，否则点击后会有黑框，要放在外面的div上"><a href="#cursor-pointer不能放在图标上，否则点击后会有黑框，要放在外面的div上" class="headerlink" title="cursor-pointer不能放在图标上，否则点击后会有黑框，要放在外面的div上"></a>cursor-pointer不能放在图标上，否则点击后会有黑框，要放在外面的div上</h3><h3 id="svg图标颜色想要动态修改"><a href="#svg图标颜色想要动态修改" class="headerlink" title="svg图标颜色想要动态修改"></a>svg图标颜色想要动态修改</h3><ul><li>把当前svg文件内的fill改成current</li><li>这个图标的颜色就跟随 使用到的位置的父元素给它设置的颜色了，即可以通过父元素给他设置颜色</li></ul><h3 id="span外面不要加div，字体一大就换行了（一般的div都设置了宽度），不能自己随字体增大而撑大"><a href="#span外面不要加div，字体一大就换行了（一般的div都设置了宽度），不能自己随字体增大而撑大" class="headerlink" title="span外面不要加div，字体一大就换行了（一般的div都设置了宽度），不能自己随字体增大而撑大"></a>span外面不要加div，字体一大就换行了（一般的div都设置了宽度），不能自己随字体增大而撑大</h3><h3 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h3><p><strong>经验</strong></p><ul><li>父元素来控制边距 和 子元素间距，子元素就直接full就行</li></ul><p><strong>flex布局</strong></p><ul><li>flex-wrap ———— 自动换行，只要是遍历某个元素，父元素都加</li><li>flex-1 ————– flex-grow（占比）、flex-shrink（收缩比例）、flex-basis（基础大小），如果只是单纯的剩余空间随父元素自适应，那么直接flex:1，如果各个子元素有相应占比需求，还是用flex-grow，因为直接写flex:1、flex:2在纵轴方向有时候占比会反着来</li><li>flex-center ——- 能直接水平垂直居中，还不用先写flex,也就是说 相当于三个属性：flex、items-center、justfy-center</li><li>和普通div的区别———–只要想内容不会挤出来，想要自动撑开父元素 直接flex布局即可（不要加高度）—-&gt; 子元素多大就占多大，不像div默认占一行</li><li>flex布局需要两边都设置宽度才不会相互挤压（只设置一边，另一边仍然会把这边给挤压变小、下次一边设置宽度，另一边直接用flex-1填充剩余（也是加了宽度））</li></ul><p>————-上面两点用一句话总结：父元素加了flex子元素会’野蛮生长-&gt;弹性’，得加一点其他限制，才能更好控制：gap、flex-1、grow-1</p><ul><li>和 max-content 的区别：都有能自己撑开父元素的效果，但是 flex加了宽度就能限制住了，而max-content限制不住，只管自己的需求</li></ul><p><strong>flex和grid布局的各自使用场景</strong></p><p>—&gt;flex</p><ul><li>一维（一个方向的轴）</li><li>各个元素不需要指定具体的宽高，需要利用flex的自适应</li></ul><p>—&gt;grid</p><ul><li>二维（横纵轴）</li><li>指明了具体的列数和宽度/比例（网格）</li></ul><p><strong>grid的使用</strong></p><ul><li>父元素通过grid-template-columns和grid-template-rows既能控制 水平还是垂直，还能控制每个元素之间的宽度/比例</li><li>设置每列具体宽度或者使用repeat(个数,1fr)，1fr是每一行/列 自己平均分配 fraction 区域</li><li>repeat(个数,1fr)是可以和单个 多少fr用字符串拼接的，这样就可以 特殊处理某一列，然后剩余再用repeat拼接</li></ul><p><strong>flex布局和绝对定位的各自使用场景</strong></p><ul><li>flex是父元素控制子元素位置，而绝对定位是 自己控制自己的位置</li><li>优先使用 flex，flex布局无法解决，然后再使用 绝对定位（如果有一些子元素有特殊的 距离控制，用padding更好）</li><li>所以 flex-&gt;padding-&gt;绝对定位</li></ul><h3 id="间隙用gap比margin更方便，因为不用考虑一头一尾"><a href="#间隙用gap比margin更方便，因为不用考虑一头一尾" class="headerlink" title="间隙用gap比margin更方便，因为不用考虑一头一尾"></a>间隙用gap比margin更方便，因为不用考虑一头一尾</h3><h3 id="类名一定要有区分度，不能写Container这种，很可能会被覆盖"><a href="#类名一定要有区分度，不能写Container这种，很可能会被覆盖" class="headerlink" title="类名一定要有区分度，不能写Container这种，很可能会被覆盖"></a>类名一定要有区分度，不能写Container这种，很可能会被覆盖</h3><h3 id="对于一些标志性位置，可以专门写个类名在style中，这样是为了方便其他人一下子理解布局，然后一些更细的具体的就直接用-tailwindcss单独写"><a href="#对于一些标志性位置，可以专门写个类名在style中，这样是为了方便其他人一下子理解布局，然后一些更细的具体的就直接用-tailwindcss单独写" class="headerlink" title="对于一些标志性位置，可以专门写个类名在style中，这样是为了方便其他人一下子理解布局，然后一些更细的具体的就直接用 tailwindcss单独写"></a>对于一些标志性位置，可以专门写个类名在style中，这样是为了方便其他人一下子理解布局，然后一些更细的具体的就直接用 tailwindcss单独写</h3><h3 id="使用-amp-hover就可以实现父元素hover的时候处理一些东西，因为一般某个图标太小，在图标上面Hover没有意义"><a href="#使用-amp-hover就可以实现父元素hover的时候处理一些东西，因为一般某个图标太小，在图标上面Hover没有意义" class="headerlink" title="使用&amp;:hover就可以实现父元素hover的时候处理一些东西，因为一般某个图标太小，在图标上面Hover没有意义"></a>使用&amp;:hover就可以实现父元素hover的时候处理一些东西，因为一般某个图标太小，在图标上面Hover没有意义</h3><h3 id="那种颜色渐变很丰富的-直接切图不要自己调，水印都可以是图片"><a href="#那种颜色渐变很丰富的-直接切图不要自己调，水印都可以是图片" class="headerlink" title="那种颜色渐变很丰富的 直接切图不要自己调，水印都可以是图片"></a>那种颜色渐变很丰富的 直接切图不要自己调，水印都可以是图片</h3><h3 id="好用的工具地址"><a href="#好用的工具地址" class="headerlink" title="好用的工具地址"></a>好用的工具地址</h3><ul><li><a href="https://getwaves.io/">https://getwaves.io/</a> ————&gt; 生成波浪型的svg图</li><li><a href="https://animista.net/play/background">https://animista.net/play/background</a> ——&gt; 各种动画例子代码 （包括PPT动画、文字动画、游戏3D动画、背景颜色、图片动画）</li></ul><h1 id="Echarts"><a href="#Echarts" class="headerlink" title="Echarts"></a>Echarts</h1><h3 id="超级实用的例子大全"><a href="#超级实用的例子大全" class="headerlink" title="超级实用的例子大全"></a>超级实用的例子大全</h3><ul><li>做项目直接到里面去找就行了</li><li><a href="https://www.isqqw.com/?t=pie&s=%E6%B8%90%E5%8F%98">https://www.isqqw.com/?t=pie&amp;s=%E6%B8%90%E5%8F%98</a></li></ul><h3 id="柱状图"><a href="#柱状图" class="headerlink" title="柱状图"></a>柱状图</h3><p>取值</p><ul><li><p>通过回调函数来自定义数据（柱状图有系列概念，有的图表没有，比如饼图）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">formatter</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">params</span>) &#123;<br>   <span class="hljs-comment">// params是个数组，表示柱状图系列种类，如果只有一种，那就[0]来取值</span><br>   <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;新增人数: &#x27;</span> + params[<span class="hljs-number">0</span>].<span class="hljs-property">value</span><br>&#125;,<br></code></pre></td></tr></table></figure></li></ul><h3 id="图表经验总结"><a href="#图表经验总结" class="headerlink" title="图表经验总结"></a>图表经验总结</h3><p><strong>图表显示不出啦？</strong> 没有设置宽高，和图片一样</p><p><strong>tooltip的显示不出来？</strong>echarts实例，不要使用ref、reactive响应式变量（使用shallowRef或者普通变量），会和echarts的交互造成冲突，比如tooltip的显示会有问题</p><p><strong>如何布局最方便？</strong>用w-1/4 w-3/4（仍然遵循用父元素来控制位置的原则，因为echarts默认渲染在空间的正中间位置，而echarts内部基本上就调个垂直位置）</p><p><strong>如何增加自定义文本图形图片等？</strong>用graphic属性，例如：加两个文本</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">graphic</span>: [<br>      &#123;<br>        <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;text&#x27;</span>,<br>        <span class="hljs-attr">left</span>: <span class="hljs-string">&#x27;center&#x27;</span>,<br>        <span class="hljs-attr">top</span>: <span class="hljs-string">&#x27;35%&#x27;</span>,<br>        <span class="hljs-attr">z</span>: <span class="hljs-number">10</span>,<br>        <span class="hljs-attr">style</span>: &#123;<br>          <span class="hljs-attr">fill</span>: <span class="hljs-string">&#x27;#1a1a1a&#x27;</span>,<br>          <span class="hljs-attr">text</span>: props.<span class="hljs-property">renderData</span>.<span class="hljs-property">count</span>,<br>          <span class="hljs-attr">textAlign</span>: <span class="hljs-string">&#x27;center&#x27;</span>,<br>          <span class="hljs-attr">fontWeight</span>: <span class="hljs-string">&#x27;bold&#x27;</span>,<br>          <span class="hljs-attr">color</span>: <span class="hljs-string">&#x27;#000&#x27;</span>,<br>          <span class="hljs-attr">fontSize</span>: <span class="hljs-number">18</span>,<br>        &#125;,<br>      &#125;,<br>      &#123;<br>        <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;text&#x27;</span>,<br>        <span class="hljs-attr">left</span>: <span class="hljs-string">&#x27;center&#x27;</span>,<br>        <span class="hljs-attr">top</span>: <span class="hljs-string">&#x27;83%&#x27;</span>,<br>        <span class="hljs-attr">z</span>: <span class="hljs-number">10</span>,<br>        <span class="hljs-attr">style</span>: &#123;<br>          <span class="hljs-attr">fill</span>: <span class="hljs-string">&#x27;#1a1a1a&#x27;</span>,<br>          <span class="hljs-attr">text</span>: props.<span class="hljs-property">renderData</span>.<span class="hljs-property">label</span>,<br>          <span class="hljs-attr">textAlign</span>: <span class="hljs-string">&#x27;center&#x27;</span>,<br>          <span class="hljs-attr">fontSize</span>: <span class="hljs-number">14</span>,<br>          <span class="hljs-attr">fontWeight</span>: <span class="hljs-string">&#x27;normal&#x27;</span>,<br>          <span class="hljs-attr">color</span>: <span class="hljs-string">&#x27;#444&#x27;</span>,<br>        &#125;,<br>      &#125;,<br>    ],<br></code></pre></td></tr></table></figure><p><strong>如何控制图表大小？</strong>用grid</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">grid</span>: &#123;<br>       <span class="hljs-comment">// 通过各方向的margin来改变图表大小</span><br>       <span class="hljs-attr">left</span>: <span class="hljs-string">&#x27;3%&#x27;</span>,<br>       <span class="hljs-attr">right</span>: <span class="hljs-string">&#x27;5%&#x27;</span>,<br>       <span class="hljs-attr">bottom</span>: props.<span class="hljs-property">renderData</span>?.<span class="hljs-property">title</span> ? <span class="hljs-string">&#x27;7%&#x27;</span> : <span class="hljs-string">&#x27;0%&#x27;</span>, <span class="hljs-comment">// 标题存在时，y轴距离底部腾出位置来显示，否则不偏移距离</span><br>       <span class="hljs-attr">containLabel</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">//保证不会超出父元素</span><br>     &#125;,<br></code></pre></td></tr></table></figure><blockquote><p>特殊情况：饼图是通过（两个）半径来控制大小的，不用grid</p></blockquote><p><strong>做一个图表总共需要做以下三件事</strong></p><p><strong>1.绘表图表</strong> </p><ul><li>由外向内 一层层在series数组里添加一个个对象，这样拼在一起就是一个图，最内层可以用graphic属性添加图片   —- 饼图最典型</li></ul><p><strong>2.数据初始化以及切换</strong> </p><ul><li>根据id或者ref初始化实例-&gt;设置options</li><li>根据父组件拿过来的数据重新computed (写成计算属性即可)-&gt;options自动重新computed (写成计算属性即可) -&gt; 监听optios重新resize，这里的计算属性和监听都是因为数据的变化-&gt;图表的变化（尤其是监听，因为父组件传过来的数据是初始值，不会自动变化）</li></ul><p><strong>3.自适应</strong></p><ul><li><p>重新写一个resize方法 在mounted时 添加到 window.resize 事件中 即可</p></li><li><p>随 整个屏幕的宽度 变化而变化 – &gt; 大屏</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">resizeGraphic</span>(<span class="hljs-params"></span>) &#123;<br>  chartInstance.<span class="hljs-property">value</span> = userChartRef.<span class="hljs-property">value</span>.<span class="hljs-title function_">getInstance</span>();<br>  <span class="hljs-keyword">const</span> screenWidth = <span class="hljs-variable language_">window</span>.<span class="hljs-property">innerWidth</span>;<br>  <span class="hljs-keyword">const</span> graphicWidth = (screenWidth / <span class="hljs-number">100</span>) * <span class="hljs-number">6.5</span>; <span class="hljs-comment">// 设定宽度为屏幕宽度的36%</span><br>就是   screenWidth*<span class="hljs-number">0.065</span><br><span class="hljs-keyword">const</span> graphicHeight = (screenWidth / <span class="hljs-number">100</span>) * <span class="hljs-number">6.5</span>; <span class="hljs-comment">// 设定高度为屏幕宽度的30%</span><br>  <span class="hljs-keyword">const</span> graphicElements = chartInstance.<span class="hljs-property">value</span>.<span class="hljs-title function_">getOption</span>().<span class="hljs-property">graphic</span>;<br>  <span class="hljs-keyword">if</span> (graphicElements) &#123;<br>    graphicElements.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">graphic</span>) =&gt;</span> &#123;<br>      graphic.<span class="hljs-property">elements</span>[<span class="hljs-number">0</span>].<span class="hljs-property">style</span>.<span class="hljs-property">width</span> = graphicWidth;<br>      graphic.<span class="hljs-property">elements</span>[<span class="hljs-number">0</span>].<span class="hljs-property">style</span>.<span class="hljs-property">height</span> = graphicHeight;<br>    &#125;);<br>    chartInstance.<span class="hljs-property">value</span>.<span class="hljs-title function_">setOption</span>(&#123; <span class="hljs-attr">graphic</span>: graphicElements &#125;); <span class="hljs-comment">// 重新设置 graphic</span><br>    chartInstance.<span class="hljs-property">value</span>.<span class="hljs-title function_">resize</span>(&#123; <span class="hljs-attr">animation</span>: &#123; <span class="hljs-attr">duration</span>: <span class="hljs-number">300</span> &#125; &#125;);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>随 父元素的宽度/高度 变化而变化 ——&gt;非大屏</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 当父容器大小变化时，重新调整Echarts图表大小,map-parent-container是父元素id</span><br> <span class="hljs-keyword">const</span> parent = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;#map-parent-container&#x27;</span>)<br> <span class="hljs-keyword">const</span> resizeObserver = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ResizeObserver</span>(<span class="hljs-function"><span class="hljs-params">entries</span> =&gt;</span> &#123;<br>   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> entry <span class="hljs-keyword">of</span> entries) &#123;<br>     chartInstance.<span class="hljs-property">value</span>.<span class="hljs-title function_">resize</span>()<br>   &#125;<br> &#125;)<br> resizeObserver.<span class="hljs-title function_">observe</span>(parent)<br></code></pre></td></tr></table></figure></li></ul><h1 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h1><h3 id="Store"><a href="#Store" class="headerlink" title="Store"></a>Store</h3><ul><li>尽量不要在组件外使用store，很可能那个时候 仓库实例 还没有完全创建完毕，比如 layout组件就不能引入用store的utils的函数</li><li>从store拿过来的数据（ref）不需要 .value（Vue3）,类似模板使用数据，特殊处理过了</li><li>在使用store的时候 不要使用computed（接父元素数据），而是usexxStore()—调用函数，计算属性只是获取某个变量而已和函数调用没关系 </li></ul><h3 id="引入组件一定要在setup函数里，因为这里面才可以默认注册"><a href="#引入组件一定要在setup函数里，因为这里面才可以默认注册" class="headerlink" title="引入组件一定要在setup函数里，因为这里面才可以默认注册"></a>引入组件一定要在setup函数里，因为这里面才可以默认注册</h3><h3 id="从外部引入的数据都要在当前组件重新赋一个变量来使用（解耦）"><a href="#从外部引入的数据都要在当前组件重新赋一个变量来使用（解耦）" class="headerlink" title="从外部引入的数据都要在当前组件重新赋一个变量来使用（解耦）"></a>从外部引入的数据都要在当前组件重新赋一个变量来使用（解耦）</h3><ul><li>ref变量</li><li>从父组件</li></ul><h3 id="defineProps没有用变量接受是不能在setup里面用的，只能在模板上用来展示"><a href="#defineProps没有用变量接受是不能在setup里面用的，只能在模板上用来展示" class="headerlink" title="defineProps没有用变量接受是不能在setup里面用的，只能在模板上用来展示"></a>defineProps没有用变量接受是不能在setup里面用的，只能在模板上用来展示</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> props = <span class="hljs-title function_">defineProps</span>(&#123;...&#125;)<br></code></pre></td></tr></table></figure><h3 id="封装组件-用插槽可以-帮助你-传递自己的结构进来，就是这样来应用个性化场景的"><a href="#封装组件-用插槽可以-帮助你-传递自己的结构进来，就是这样来应用个性化场景的" class="headerlink" title="封装组件 用插槽可以 帮助你 传递自己的结构进来，就是这样来应用个性化场景的"></a>封装组件 用插槽可以 帮助你 传递自己的结构进来，就是这样来应用个性化场景的</h3><ul><li>写slot不写名字，会默认有个名字 #default，其实就是默认插槽和具名插槽</li></ul><h3 id="封装原则"><a href="#封装原则" class="headerlink" title="封装原则"></a>封装原则</h3><ul><li>多个页面长得类似，但是里面细节不同，此时要做的不是 一个组件多次复用，而是 将这个页面拆分为多个组件，然后多个页面就可以随意组装了，这样也相互独立了，代码不会全在一个组件里堆积</li></ul><h3 id="涉及到响应式对象内部数据的修改（计算），要先深克隆到一个变量再处理"><a href="#涉及到响应式对象内部数据的修改（计算），要先深克隆到一个变量再处理" class="headerlink" title="涉及到响应式对象内部数据的修改（计算），要先深克隆到一个变量再处理"></a>涉及到响应式对象内部数据的修改（计算），要先深克隆到一个变量再处理</h3><ul><li>因为类似直接赋值的浅拷贝本质山地址一样—-&gt;响应式更新还保留着，并且内部深层都有响应式</li></ul><h3 id="动态修改Html结构-v-html"><a href="#动态修改Html结构-v-html" class="headerlink" title="动态修改Html结构-v-html"></a>动态修改Html结构-v-html</h3><ul><li><p>可以在原本要显示数据的地方使用v-html指令，数据用个计算属性（提供一个计算的平台）</p></li><li><p>本质上是用html字符串的处理，那么就可以用各种字符串处理方法，不好处理用split转成数组处理，最后在拼接（join方法）</p></li><li><p>找到文字内关键词并标绿</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> keywordHighlight = <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">originSent, label</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (originSent.<span class="hljs-title function_">includes</span>(label)) &#123;<br>      <span class="hljs-keyword">const</span> highlightedPart = <span class="hljs-string">`&lt;span style=&quot;color: #00BAAD;&quot;&gt;<span class="hljs-subst">$&#123;label&#125;</span>&lt;/span&gt;`</span><br>      <span class="hljs-keyword">return</span> originSent.<span class="hljs-title function_">replace</span>(label, highlightedPart)<br>    &#125;<br>    <span class="hljs-keyword">return</span> originSent<br>  &#125;<br>&#125;)<br>&lt;span<br>                          v-html=<span class="hljs-string">&quot;</span><br><span class="hljs-string">                            keywordHighlight(row.originSent, itemTag.label)</span><br><span class="hljs-string">                          &quot;</span><br>                        &gt;&lt;/span&gt;<br></code></pre></td></tr></table></figure></li></ul><h3 id="模态框（dialog）作为子组件显示，可见性需要更新回父组件"><a href="#模态框（dialog）作为子组件显示，可见性需要更新回父组件" class="headerlink" title="模态框（dialog）作为子组件显示，可见性需要更新回父组件"></a>模态框（dialog）作为子组件显示，可见性需要更新回父组件</h3><ul><li><p>子组件要使用计算属性接受，顺便利用set来更新回去</p></li><li><p>不是单向数据流吗？为什么要更新回去？因为父子组件各自都有权力控制显示，不更新回去任一方的更新都将无效，且这样不用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">computed</span>: &#123;<br>    <span class="hljs-attr">localExportFailVisible</span>: &#123;<br>      <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">exportFailVisible</span>;<br>      &#125;,<br>      <span class="hljs-title function_">set</span>(<span class="hljs-params">val</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.$emit(<span class="hljs-string">&#x27;update:exportFailVisible&#x27;</span>, val);<br>      &#125;,<br>    &#125;,<br>  &#125;,<br></code></pre></td></tr></table></figure></li><li><p>this.$emit(‘update:exportFailVisible’, val);是用于更新用v-model绑定的数据，也就是说子组件是使用v-model绑定可见性的</p></li></ul><h3 id="父组件传数据给子组件而不是子组件每次实例化来请求数据"><a href="#父组件传数据给子组件而不是子组件每次实例化来请求数据" class="headerlink" title="父组件传数据给子组件而不是子组件每次实例化来请求数据"></a>父组件传数据给子组件而不是子组件每次实例化来请求数据</h3><ul><li>这样一次请求就行了，而且子组件的展示也不是用v-if，而是用可见性</li></ul><h3 id="全局样式要去掉scoped"><a href="#全局样式要去掉scoped" class="headerlink" title="全局样式要去掉scoped"></a>全局样式要去掉scoped</h3><ul><li>有时候即使使用了deep穿透样式还是无法生效，就要F12看看是否是全局样式，也就是在body下的第一层，而一个组件内的样式加了scoped是指局部样式，所以要去掉scoped</li></ul><h3 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h3><p><strong>传参计算需要返回一个回调函数在里面return才可以</strong></p><ul><li><p>computed设计初衷是根据实例已有的数据进行计算，而形参并不属于已有的数据，所以无法在computed回调函数里面去获得</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> tendencyTransfer = <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">tendency</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> tendency === <span class="hljs-string">&#x27;1&#x27;</span> ? <span class="hljs-string">&#x27;优点&#x27;</span> : <span class="hljs-string">&#x27;缺点&#x27;</span><br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure></li></ul><p><strong>写get个set的时候不需要写回调函数，里面只是要一个对象即可，因为get和set是键值类型的键</strong></p><p><strong>watch和computed</strong></p><ul><li>只用重新返回一个值的话用computed，否则有其他复杂逻辑用watch</li></ul><h3 id="封装的组件拿来用一定要首字母大写，否则不算做一个组件，显示不出来"><a href="#封装的组件拿来用一定要首字母大写，否则不算做一个组件，显示不出来" class="headerlink" title="封装的组件拿来用一定要首字母大写，否则不算做一个组件，显示不出来"></a>封装的组件拿来用一定要首字母大写，否则不算做一个组件，显示不出来</h3><h3 id="v-for和v-if不能一起用，那么就提前用计算属性把list筛选好"><a href="#v-for和v-if不能一起用，那么就提前用计算属性把list筛选好" class="headerlink" title="v-for和v-if不能一起用，那么就提前用计算属性把list筛选好"></a>v-for和v-if不能一起用，那么就提前用计算属性把list筛选好</h3><h3 id="组件封装注意点"><a href="#组件封装注意点" class="headerlink" title="组件封装注意点"></a>组件封装注意点</h3><ul><li><p>一定要加插槽,为了 结构个性化,  而且要配合template，因为 如果没有传插槽可以 不占空间 </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 渲染表头数据，支持插槽：slotLabel --&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">div</span></span><br><span class="hljs-tag">            <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;column in columns&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;column.prop&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;flex-center w-full h-full&quot;</span></span><br><span class="hljs-tag">          &gt;</span><br>              <span class="hljs-comment">&lt;!-- 个性化结构 --&gt;</span> <br>            <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;column?.slotLabel&quot;</span>&gt;</span><br>              <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">:name</span>=<span class="hljs-string">&quot;column.slotLabel&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br>              <span class="hljs-comment">&lt;!-- 默认结构 --&gt;</span> <br>            <span class="hljs-tag">&lt;<span class="hljs-name">span</span></span><br><span class="hljs-tag">              <span class="hljs-attr">v-else</span></span><br><span class="hljs-tag">              <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;text-[#fff]&quot;</span></span><br><span class="hljs-tag">              <span class="hljs-attr">:style</span>=<span class="hljs-string">&quot;&#123; fontSize: headerFontSize &#125;&quot;</span></span><br><span class="hljs-tag">              &gt;</span>&#123;&#123; column.label &#125;&#125;&lt;/span<br>            &gt;<br>          <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>若要动态加载第三方组件,要使用<component></p><p>is—–&gt;组件名; v-bind — 绑定的属性; </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">component</span></span><br><span class="hljs-tag">          <span class="hljs-attr">:is</span>=<span class="hljs-string">&quot;useSeamlessScroll ? &#x27;vue3-seamless-scroll&#x27; : &#x27;div&#x27;&quot;</span></span><br><span class="hljs-tag">          <span class="hljs-attr">v-bind</span>=<span class="hljs-string">&quot;useSeamlessScroll ? seamlessScrollProps : &#123;&#125;&quot;</span></span><br><span class="hljs-tag">          <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;&#123;</span></span><br><span class="hljs-string"><span class="hljs-tag">            &#x27;scroll-seamless&#x27;:</span></span><br><span class="hljs-string"><span class="hljs-tag">              useSeamlessScroll &amp;&amp; !isLessThanMaxRowHeightLimit,</span></span><br><span class="hljs-string"><span class="hljs-tag">            &#x27;scroll-seamless-min&#x27;:</span></span><br><span class="hljs-string"><span class="hljs-tag">              useSeamlessScroll &amp;&amp; isLessThanMaxRowHeightLimit,</span></span><br><span class="hljs-string"><span class="hljs-tag">          &#125;&quot;</span></span><br><span class="hljs-tag">          <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;h-full&quot;</span></span><br><span class="hljs-tag">        &gt;</span><br></code></pre></td></tr></table></figure></li><li><p><strong>大屏可滚动表格的封装例子（可自动滚也可手动滚）</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;template&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;autoScroll-container w-full&quot;</span> <span class="hljs-attr">:style</span>=<span class="hljs-string">&quot;&#123; height: height + &#x27;px&#x27; &#125;&quot;</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">el-scrollbar</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;scrollbarRef&quot;</span> <span class="hljs-attr">:height</span>=<span class="hljs-string">&quot;height&quot;</span> @<span class="hljs-attr">scroll</span>=<span class="hljs-string">&quot;scroll&quot;</span> @<span class="hljs-attr">mouseenter</span>=<span class="hljs-string">&quot;onMouseenter&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">      @<span class="hljs-attr">mouseleave</span>=<span class="hljs-string">&quot;onMouseleave&quot;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;scrollAreaRef&quot;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">slot</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;canScrollHeight &gt; 0&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">el-scrollbar</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&lt;/template&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> &#123; nextTick, onUnmounted, ref, watch &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">const</span> props = <span class="hljs-title function_">defineProps</span>(&#123;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">list</span>: &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-attr">type</span>: <span class="hljs-title class_">Array</span>,</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-attr">default</span>: <span class="hljs-function">() =&gt;</span> [],</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">height</span>: &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-attr">type</span>: <span class="hljs-title class_">Number</span>,</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-attr">default</span>: <span class="hljs-number">0</span>,</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-comment">// 是否可以滚动</span></span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">isCanScroll</span>: &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-attr">type</span>: <span class="hljs-title class_">Boolean</span>,</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-attr">default</span>: <span class="hljs-literal">true</span>,</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-comment">// 滚动速度</span></span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">speed</span>: &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-attr">type</span>: <span class="hljs-title class_">Number</span>,</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-attr">default</span>: <span class="hljs-number">0.5</span>,</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">&#125;)</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">const</span> scrollbarRef = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">null</span>)</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">const</span> scrollAreaRef = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">null</span>)</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">const</span> canScrollHeight = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>) <span class="hljs-comment">// 可滚动高度</span></span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">let</span> caseScrollTop = <span class="hljs-number">0</span> <span class="hljs-comment">// 滚动位置距离顶部高度</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">let</span> animateId = <span class="hljs-literal">null</span> <span class="hljs-comment">// 动画帧id</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">let</span> isAnimating = <span class="hljs-literal">false</span> <span class="hljs-comment">// 动画是否正在进行</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">let</span> isOnContainer = <span class="hljs-literal">false</span> <span class="hljs-comment">// 鼠标是否在容器区域内</span></span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-title function_">watch</span>(</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-function">() =&gt;</span> props.<span class="hljs-property">isCanScroll</span>,</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-function">(<span class="hljs-params">newVal</span>) =&gt;</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// 可以滚动且不存在动画帧且不在容器区域内</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">if</span> (newVal &amp;&amp; !isAnimating &amp;&amp; !isOnContainer) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-title function_">startScrollAnimate</span>()</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">)</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-comment">// 监听数据，获取可滚动高度。同时开始滚动</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-title function_">watch</span>(</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-function">() =&gt;</span> props.<span class="hljs-property">list</span>,</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-keyword">async</span> (newVal) =&gt; &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">if</span> (newVal.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-keyword">await</span> <span class="hljs-title function_">nextTick</span>()</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">      canScrollHeight.<span class="hljs-property">value</span> = scrollAreaRef.<span class="hljs-property">value</span>.<span class="hljs-property">scrollHeight</span> - props.<span class="hljs-property">height</span></span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-comment">// 停止旧动画后再启动新动画</span></span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-title function_">stopScrollAnimate</span>()</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-title function_">startScrollAnimate</span>()</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">  &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-attr">immediate</span>: <span class="hljs-literal">true</span>,</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">)</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-title function_">onUnmounted</span>(<span class="hljs-function">() =&gt;</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-title function_">stopScrollAnimate</span>()</span></span><br><span class="language-javascript"><span class="language-xml">&#125;)</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-comment">/**</span></span></span><br><span class="hljs-comment"><span class="language-javascript"><span class="language-xml"> * 开始滚动（超出可视区，才滚动）</span></span></span><br><span class="hljs-comment"><span class="language-javascript"><span class="language-xml"> */</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">function</span> <span class="hljs-title function_">startScrollAnimate</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-keyword">if</span> (canScrollHeight.<span class="hljs-property">value</span> &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span></span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-keyword">const</span> st = scrollbarRef.<span class="hljs-property">value</span>.<span class="hljs-property">wrapRef</span>.<span class="hljs-property">scrollTop</span> <span class="hljs-comment">// 滚动高度</span></span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-keyword">const</span> sh = scrollAreaRef.<span class="hljs-property">value</span>.<span class="hljs-property">scrollHeight</span> / <span class="hljs-number">2</span> <span class="hljs-comment">// 单内容区高度</span></span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-keyword">if</span> (st &gt;= sh) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    caseScrollTop = <span class="hljs-number">0</span></span></span><br><span class="language-javascript"><span class="language-xml">  &#125;</span></span><br><span class="language-javascript"><span class="language-xml">  caseScrollTop += props.<span class="hljs-property">speed</span></span></span><br><span class="language-javascript"><span class="language-xml">  scrollbarRef.<span class="hljs-property">value</span>.<span class="hljs-title function_">setScrollTop</span>(caseScrollTop)</span></span><br><span class="language-javascript"><span class="language-xml">  animateId = <span class="hljs-title function_">requestAnimationFrame</span>(startScrollAnimate)</span></span><br><span class="language-javascript"><span class="language-xml">  isAnimating = <span class="hljs-literal">true</span></span></span><br><span class="language-javascript"><span class="language-xml">&#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-comment">/**</span></span></span><br><span class="hljs-comment"><span class="language-javascript"><span class="language-xml"> * 停止滚动</span></span></span><br><span class="hljs-comment"><span class="language-javascript"><span class="language-xml"> */</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">function</span> <span class="hljs-title function_">stopScrollAnimate</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-keyword">if</span> (animateId) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-title function_">cancelAnimationFrame</span>(animateId)</span></span><br><span class="language-javascript"><span class="language-xml">    isAnimating = <span class="hljs-literal">false</span></span></span><br><span class="language-javascript"><span class="language-xml">  &#125;</span></span><br><span class="language-javascript"><span class="language-xml">&#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-comment">/**</span></span></span><br><span class="hljs-comment"><span class="language-javascript"><span class="language-xml"> * 鼠标移入</span></span></span><br><span class="hljs-comment"><span class="language-javascript"><span class="language-xml"> */</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">function</span> <span class="hljs-title function_">onMouseenter</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">  isOnContainer = <span class="hljs-literal">true</span></span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-title function_">stopScrollAnimate</span>()</span></span><br><span class="language-javascript"><span class="language-xml">&#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-comment">/**</span></span></span><br><span class="hljs-comment"><span class="language-javascript"><span class="language-xml"> * 鼠标移出</span></span></span><br><span class="hljs-comment"><span class="language-javascript"><span class="language-xml"> */</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">function</span> <span class="hljs-title function_">onMouseleave</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">  isOnContainer = <span class="hljs-literal">false</span></span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-keyword">if</span> (props.<span class="hljs-property">isCanScroll</span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-title function_">startScrollAnimate</span>()</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;</span></span><br><span class="language-javascript"><span class="language-xml">&#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-comment">/**</span></span></span><br><span class="hljs-comment"><span class="language-javascript"><span class="language-xml"> * 手动滚动后，重新设置滚动位置</span></span></span><br><span class="hljs-comment"><span class="language-javascript"><span class="language-xml"> */</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">function</span> <span class="hljs-title function_">scroll</span>(<span class="hljs-params">&#123; scrollTop &#125;</span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-keyword">const</span> sh = scrollAreaRef.<span class="hljs-property">value</span>.<span class="hljs-property">scrollHeight</span> / <span class="hljs-number">2</span> <span class="hljs-comment">// 单内容区高度</span></span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-keyword">if</span> (scrollTop &gt;= sh) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    caseScrollTop = <span class="hljs-number">0</span></span></span><br><span class="language-javascript"><span class="language-xml">    scrollbarRef.<span class="hljs-property">value</span>.<span class="hljs-title function_">setScrollTop</span>(caseScrollTop)</span></span><br><span class="language-javascript"><span class="language-xml">  &#125; <span class="hljs-keyword">else</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    caseScrollTop = scrollTop</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;</span></span><br><span class="language-javascript"><span class="language-xml">&#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-title function_">onUnmounted</span>(<span class="hljs-function">() =&gt;</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-title function_">stopScrollAnimate</span>()</span></span><br><span class="language-javascript"><span class="language-xml">&#125;)</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;scss&quot;</span> <span class="hljs-attr">scoped</span>&gt;</span><span class="language-css"></span></span><br><span class="language-css"><span class="language-xml">:<span class="hljs-built_in">deep</span>(.el-scrollbar__bar.is-vertical) &#123;</span></span><br><span class="language-css"><span class="language-xml">  <span class="hljs-attribute">width</span>: <span class="hljs-number">0</span>;</span></span><br><span class="language-css"><span class="language-xml">&#125;</span></span><br><span class="language-css"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></span><br><br></code></pre></td></tr></table></figure></li><li><p>只有显示省略号才显示tooltip组件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;el-tooltip<br>    :content=&quot;content&quot;<br>    :placement=&quot;placement&quot;<br>    :show-after=&quot;300&quot;<br>    :visible=&quot;visible&quot;<br>  &gt;<br>    &lt;div<br>      @mouseover=&quot;<br>        visible = $event.target.scrollWidth &gt; $event.target.clientWidth<br>      &quot;<br>      @mouseleave=&quot;visible = false&quot;<br>    &gt;<br>      &lt;slot&gt;&lt;/slot&gt;<br>    &lt;/div&gt;<br>  &lt;/el-tooltip&gt;<br>&lt;/template&gt;<br><br>&lt;script setup&gt;<br>defineProps(&#123;<br>  content: &#123;<br>    type: String,<br>    default: &#x27;&#x27;,<br>  &#125;,<br>  placement: &#123;<br>    type: String,<br>    default: &#x27;top&#x27;,<br>  &#125;,<br>&#125;)<br><br>const visible = ref(false)<br>&lt;/script&gt;<br><br>&lt;style lang=&quot;scss&quot; scoped&gt;&lt;/style&gt;<br><br></code></pre></td></tr></table></figure><p>其实就是 实际宽度 &gt; 容器宽度 时再显示，再配合CSS省略号处理即可</p></li></ul><h3 id="添加二级路由并部署（Vue2版）"><a href="#添加二级路由并部署（Vue2版）" class="headerlink" title="添加二级路由并部署（Vue2版）"></a>添加二级路由并部署（Vue2版）</h3><ul><li><p>路由router对象添加配置项：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">base</span>: <span class="hljs-string">&#x27;/二级路由/&#x27;</span><br></code></pre></td></tr></table></figure></li><li><p>在build.js（vue.config.js）的build项里面的assetsPublicPath添加配置项：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">assetsPublicPath</span>: <span class="hljs-string">&#x27;/二级路由/./&#x27;</span>,<br></code></pre></td></tr></table></figure><p>其中，后面的./是为了history模式刷新后后端能重定向到index.html</p><p>为什么建议使用history模式，暂时还不知道</p></li></ul><h3 id="代理的原理以及作用"><a href="#代理的原理以及作用" class="headerlink" title="代理的原理以及作用"></a>代理的原理以及作用</h3><ul><li><p>前端在env里面设置API_PATH=’代理标识符’，就说明这个代理标识符是用来将localhost替换成这真正的API地址，不让别人看到真正的API地址是什么，事实上请求时换成了proxy配置项对应的地址</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">proxyTable</span>: &#123;<br>       <span class="hljs-string">&#x27;/eval-padconfig-admin/v2&#x27;</span>: <span class="hljs-string">&#x27;http://192.168.2.32:18088&#x27;</span>,<br>     &#125;,<br></code></pre></td></tr></table></figure></li><li><p>可能也是为了 负载均衡，用代理服务器来转发到目标服务器</p></li><li><p>最后的请求地址是 localhost:8080/eval-padconfig-admin/v2…看不到真正的API地址</p></li></ul><h3 id="build打包要看清楚是哪个环境"><a href="#build打包要看清楚是哪个环境" class="headerlink" title="build打包要看清楚是哪个环境"></a>build打包要看清楚是哪个环境</h3><ul><li><p>NODE_ENV=production —环境</p></li><li><p>env_config=pre-prod —– 环境的文件名</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-string">&quot;build:pre-prod&quot;</span>：<span class="hljs-string">&quot;cross-env NODE_ENV=production env_config=pre-prod node build/b</span><br></code></pre></td></tr></table></figure></li></ul><h1 id="Vite"><a href="#Vite" class="headerlink" title="Vite"></a>Vite</h1><h3 id="外部引入的js文件修改了，需要刷新页面才能有效果"><a href="#外部引入的js文件修改了，需要刷新页面才能有效果" class="headerlink" title="外部引入的js文件修改了，需要刷新页面才能有效果"></a>外部引入的js文件修改了，需要刷新页面才能有效果</h3><h3 id="正向代理和反向代理的区别"><a href="#正向代理和反向代理的区别" class="headerlink" title="正向代理和反向代理的区别"></a>正向代理和反向代理的区别</h3><ul><li>正向代理是代理客户端，服务器不用知道具体客户端是什么，只用知道代理客户端的地址</li><li>反向代理是代理服务器，客户端不用知道具体服务器的地址，只用知道代理服务器的地址</li><li>代理服务器可以进行转发多个目标，这样就有只知道一个地址却能一对多的效果</li></ul><h1 id="ElementUI"><a href="#ElementUI" class="headerlink" title="ElementUI"></a>ElementUI</h1><h3 id="UI组件-弹框-也是promise返回值，因此想要让这种对话框同步操作，只要在前面加个await，并且点确定才会完成await操作，否则会阻塞代码"><a href="#UI组件-弹框-也是promise返回值，因此想要让这种对话框同步操作，只要在前面加个await，并且点确定才会完成await操作，否则会阻塞代码" class="headerlink" title="UI组件(弹框)也是promise返回值，因此想要让这种对话框同步操作，只要在前面加个await，并且点确定才会完成await操作，否则会阻塞代码"></a>UI组件(弹框)也是promise返回值，因此想要让这种对话框同步操作，只要在前面加个await，并且点确定才会完成await操作，否则会阻塞代码</h3><ul><li>想要控制弹框和其他操作的顺序只能用 ElMessageBox.confirm，因为这个可以用js代码控制异步顺序</li></ul><h3 id="el-tab"><a href="#el-tab" class="headerlink" title="el-tab"></a>el-tab</h3><p><strong>想要在el-tab切换和按钮放在一行是不行的，因为tab切换是会占一整行的，会相互挤压</strong></p><h3 id="UI组件如果提供了专门的class自定义类，那肯定是可以用的，不生效是方法不对"><a href="#UI组件如果提供了专门的class自定义类，那肯定是可以用的，不生效是方法不对" class="headerlink" title="UI组件如果提供了专门的class自定义类，那肯定是可以用的，不生效是方法不对"></a>UI组件如果提供了专门的class自定义类，那肯定是可以用的，不生效是方法不对</h3><ul><li>比如el-table的:cellStyle</li></ul><h3 id="el-table"><a href="#el-table" class="headerlink" title="el-table"></a>el-table</h3><p><strong>设置el-table每个单元格高度</strong></p><ul><li><p>去掉padding影响</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">/deep/(vue2版本，vue3用::v-deep) .el-table .el-table__body td &#123;<span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span> <span class="hljs-meta">!important</span>; &#125;<br></code></pre></td></tr></table></figure></li><li><p>通过行高设置具体高度（去掉padding之后此时内部是span高度由行高决定）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">&lt;el-<span class="hljs-selector-tag">table</span> :cell-style=<span class="hljs-string">&quot;&#123; lineHeight: &#x27;10px&#x27; &#125;&quot;</span>&gt;<br></code></pre></td></tr></table></figure></li></ul><p><strong>设置单元格（行、列）样式</strong></p><ul><li><p>使用:cellStyle，这个计算属性里，有点v-html的感觉</p></li><li><p>参数里有行、列的对象和索引，可以用，很方便</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">cellStyle</span>(<span class="hljs-params">&#123; columnIndex &#125;</span>) &#123;<br>      <span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;line-height:10px;&#x27;</span>;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">errorColumn</span> === <span class="hljs-string">&#x27;code&#x27;</span>) &#123;<br>        <span class="hljs-keyword">if</span> (columnIndex === <span class="hljs-number">1</span>) &#123;<br>          str += <span class="hljs-string">&#x27;color: red;&#x27;</span>;<br>        &#125;<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">errorColumn</span> === <span class="hljs-string">&#x27;encode&#x27;</span>) &#123;<br>        <span class="hljs-keyword">if</span> (columnIndex === <span class="hljs-number">2</span>) &#123;<br>          str += <span class="hljs-string">&#x27;color: red;&#x27;</span>;<br>        &#125;<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">errorColumn</span> === <span class="hljs-string">&#x27;address&#x27;</span>) &#123;<br>        <span class="hljs-keyword">if</span> (columnIndex === <span class="hljs-number">4</span>) &#123;<br>          str += <span class="hljs-string">&#x27;color: red;&#x27;</span>;<br>        &#125;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 其他情况</span><br>      &#125;<br>      <span class="hljs-keyword">return</span> str;<br>    &#125;<br></code></pre></td></tr></table></figure></li></ul><p><strong>x轴出现滚动条</strong></p><ul><li>可以在每个item加固定width</li></ul><h3 id="el-dialog"><a href="#el-dialog" class="headerlink" title="el-dialog"></a>el-dialog</h3><p><strong>自定义内间距，且内容被子元素高度撑开</strong></p><ul><li>直接设置.el-dialog__body 的padding（使用deep加速器）</li><li>如果内容不想被撑开，想加上滚动条，在子元素外部添加overflow:auto + 固定width</li></ul><p><strong>如果无法穿透，那么很可能就是放到全局元素去了，不需要穿透</strong></p><ul><li><p>把style的scoped去掉</p></li><li><p>el-dialog加个自定义类名</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.custom-dialog</span> &#123;<br>  <span class="hljs-selector-class">.el-dialog__header</span> &#123;<br>    <span class="hljs-attribute">padding</span>: <span class="hljs-number">15px</span> <span class="hljs-number">0</span> <span class="hljs-number">15px</span> <span class="hljs-number">20px</span>;<br>  &#125;<br>  <span class="hljs-selector-class">.el-dialog__title</span> &#123;<br>    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">16px</span>;<br>    <span class="hljs-attribute">font-weight</span>: bold;<br>  &#125;   &#125;<br>  <br>  <span class="hljs-selector-class">.el-dialog__body</span> &#123;<br>    <span class="hljs-attribute">border-top</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#ccc</span>;<br>    <span class="hljs-attribute">border-bottom</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#ccc</span>;<br>  &#125;<br>  <span class="hljs-selector-class">.el-dialog__footer</span> &#123;<br>    <span class="hljs-attribute">padding</span>: <span class="hljs-number">15px</span> <span class="hljs-number">0px</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p><strong>设置基于页面的水平垂直居中</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs css">::v-deep .el-dialog&#123;<br>       <span class="hljs-attribute">display</span>: flex;<br>       <span class="hljs-attribute">flex-direction</span>: column;<br>       <span class="hljs-attribute">margin</span>:<span class="hljs-number">0</span> <span class="hljs-meta">!important</span>;<br>       <span class="hljs-attribute">position</span>:absolute;<br>       <span class="hljs-attribute">top</span>:<span class="hljs-number">50%</span>;<br>       <span class="hljs-attribute">left</span>:<span class="hljs-number">50%</span>;<br>       <span class="hljs-attribute">transform</span>:<span class="hljs-built_in">translate</span>(-<span class="hljs-number">50%</span>,-<span class="hljs-number">50%</span>);<br>       <span class="hljs-attribute">max-height</span>:<span class="hljs-built_in">calc</span>(<span class="hljs-number">100%</span> - <span class="hljs-number">30px</span>);<br>       <span class="hljs-attribute">max-width</span>:<span class="hljs-built_in">calc</span>(<span class="hljs-number">100%</span> - <span class="hljs-number">30px</span>);<br>   &#125;<br>  ::v-deep  .el-dialog .el-dialog__body&#123;<br>       <span class="hljs-attribute">flex</span>:<span class="hljs-number">1</span>;<br>       <span class="hljs-attribute">overflow</span>: auto;<br>   &#125;<br></code></pre></td></tr></table></figure><h3 id="e-form"><a href="#e-form" class="headerlink" title="e-form"></a>e-form</h3><p><strong>想要校验的“红星”样式，但是不触发任何校验</strong></p><ul><li>直接在el-form-item加上class=”is-required”</li></ul><p><strong>某个表单元素穿透样式？</strong> 自定义个类名 一起写在:deep里，和被穿透的类名 连起来（没有空格）或者不连起来</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">:<span class="hljs-built_in">deep</span>(.custom-date-picker .el-form-item) &#123;<br>    <span class="hljs-attribute">margin-right</span>: -<span class="hljs-number">1px</span> <span class="hljs-meta">!important</span>;<br>  &#125;<br></code></pre></td></tr></table></figure><h3 id="radio-group"><a href="#radio-group" class="headerlink" title="radio-group"></a>radio-group</h3><p><strong>循环radio-group时，各个group的值不会相互影响</strong></p><ul><li>要保证每个radio-group有自己的v-model值，这样各个radio-group的选中的数据不会相互影响</li></ul><p><strong>el-radio-group的el-radio一定要有label，否则选中无效果</strong></p><p><strong>el-radio-group的change事件获取的值是label而不是value，value是v-model获取的</strong></p><p><strong>el-radio-group的change事件如果每次拿的是上一次的值，那就换成input事件试试</strong></p><h3 id="el-upload"><a href="#el-upload" class="headerlink" title="el-upload"></a>el-upload</h3><p><strong>:beforfe-upload和:on-change的区别</strong></p><ul><li>beforfe-upload在上传之前就触发了，后面就都不会再触发了</li><li>on-change在文件上传、上传失败、上传成功都会触发</li><li>如果只想在文件上传之前触发一次—-&gt;beforfe-upload；想阶段分的再细点—-&gt;on-change（用的更多一点）</li></ul><p><strong>手动触发action，而不是自动触发</strong></p><ul><li>:auto-upload:“false”</li><li>注意在触发之前，千万不能this.refs.upload.clearFiles()，没有文件是不会触发action的</li><li>利用ref手动触发：this.refs.upload.submit()</li></ul><p><strong>需要在onchange事件里面手动校验 是否已有文件</strong></p><ul><li>一开始没上传提示 ‘请上传’，然后手动上传了以后 并不会自动校验，而是需要在onchange里面手动触发（就像submit按钮做的那样）</li></ul><h3 id="el-select"><a href="#el-select" class="headerlink" title="el-select"></a>el-select</h3><p>支持手动输入（添加选项：allow-create），回显时 能匹配到options的id就显示对应label，否则就认为是手动输入的值</p><h3 id="穿透的东西不只有类名，标签名也可以-deep-gt-div"><a href="#穿透的东西不只有类名，标签名也可以-deep-gt-div" class="headerlink" title="穿透的东西不只有类名，标签名也可以:deep(&gt; div) {"></a>穿透的东西不只有类名，标签名也可以:deep(&gt; div) {</h3><h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><h3 id="删除分支（保持分支整洁）"><a href="#删除分支（保持分支整洁）" class="headerlink" title="删除分支（保持分支整洁）"></a>删除分支（保持分支整洁）</h3><ul><li>删除远程分支 —— git branch -D xxx</li><li>删除本地分支 —— git branch -d xxx</li></ul><h3 id="新建远程分支"><a href="#新建远程分支" class="headerlink" title="新建远程分支"></a>新建远程分支</h3><ul><li>只能用git push origin 分支名（没有会自动创建）</li></ul><h3 id="git-add-A而不是git-add"><a href="#git-add-A而不是git-add" class="headerlink" title="git add -A而不是git add ."></a>git add -A而不是git add .</h3><ul><li>git add -A还能提交文件删除的记录，而git add .不能</li></ul><h3 id="git-pull-–rebase而不是git-pull"><a href="#git-pull-–rebase而不是git-pull" class="headerlink" title="git pull –rebase而不是git pull"></a>git pull –rebase而不是git pull</h3><ul><li>rebase可以在合并操作后不会留下commit记录，保证提交记录线性化，更清晰</li><li>如果合并碰到冲突，使用git add+git rebase –continue完成剩余的合并操作</li></ul><h3 id="更新远程分支"><a href="#更新远程分支" class="headerlink" title="更新远程分支"></a>更新远程分支</h3><p>git fetch</p><h3 id="分支合并"><a href="#分支合并" class="headerlink" title="分支合并"></a>分支合并</h3><p>不要让不同分支合并，否则全都认为是新的改动</p><ul><li>本地aaa分支和远程develop合并的话，此时只要有不一样的代码都会认为是 即将新的commit的部分</li></ul><h3 id="本地没有合并成功，后面手动在gitlab上合并也可以，只要私仓是最新的就行"><a href="#本地没有合并成功，后面手动在gitlab上合并也可以，只要私仓是最新的就行" class="headerlink" title="本地没有合并成功，后面手动在gitlab上合并也可以，只要私仓是最新的就行"></a>本地没有合并成功，后面手动在gitlab上合并也可以，只要私仓是最新的就行</h3><h3 id="fix-提交第一个字符为字母的话不能为大写"><a href="#fix-提交第一个字符为字母的话不能为大写" class="headerlink" title="fix: 提交第一个字符为字母的话不能为大写"></a>fix: 提交第一个字符为字母的话不能为大写</h3><h3 id="更改项目文件首字母大小写后，会无法commit-解决方法就是把文件删了重新新建（当然要拍备份）"><a href="#更改项目文件首字母大小写后，会无法commit-解决方法就是把文件删了重新新建（当然要拍备份）" class="headerlink" title="更改项目文件首字母大小写后，会无法commit,解决方法就是把文件删了重新新建（当然要拍备份）"></a>更改项目文件首字母大小写后，会无法commit,解决方法就是把文件删了重新新建（当然要拍备份）</h3><h1 id="第三方库-插件"><a href="#第三方库-插件" class="headerlink" title="第三方库/插件"></a>第三方库/插件</h1><h3 id="lodash"><a href="#lodash" class="headerlink" title="lodash"></a>lodash</h3><ul><li>有一些封装好的复杂一些的函数，比如 debounce、deepClone、groupBy（很方便，能将一个数组里某个字段进行分组（这个字段变为一个对象的key），每个组作为当前key的value）、sortBy(自定义排序规则)</li><li>细说 debouce 的使用：在原来的函数外面再包一层就行了，然后调用 包防抖的函数（参数一：事件名，参数二：时间）</li></ul><h3 id="md编辑器"><a href="#md编辑器" class="headerlink" title="md编辑器"></a>md编辑器</h3><ul><li>Vue3 md编辑器的使用 <a href="https://imzbf.github.io/md-editor-v3/en-US/index">https://imzbf.github.io/md-editor-v3/en-US/index</a></li></ul><h1 id="业务场景"><a href="#业务场景" class="headerlink" title="业务场景"></a>业务场景</h1><h3 id="在接受接口数据时，使用key-value形式更灵活"><a href="#在接受接口数据时，使用key-value形式更灵活" class="headerlink" title="在接受接口数据时，使用key-value形式更灵活"></a>在接受接口数据时，使用key-value形式更灵活</h3><ul><li><p>有时候需要 接口返回的部分数据，并不是所有，因此直接赋值并不方便；若前端提前把对应的字段名定义好，然后使用key-value的方式来获取，能有针对性地那我想要的数据，例子如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> leaderboardData = <span class="hljs-title function_">ref</span>(&#123;<br>  <span class="hljs-attr">statsDataAccessRankingList</span>: [],<br>  <span class="hljs-attr">statsDataAssetRankingList</span>: [],<br>  <span class="hljs-attr">statsDeptBusinessSupportRankingList</span>: [],<br>&#125;);<br> <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> <span class="hljs-title function_">getLeaderboardData</span>();<br>  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(res.<span class="hljs-property">data</span>).<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">key</span>) =&gt;</span> &#123;<br>    leaderboardData.<span class="hljs-property">value</span>[key] = res.<span class="hljs-property">data</span>[key] || [];<br>  &#125;);<br></code></pre></td></tr></table></figure></li></ul><h3 id="整个页面加水印"><a href="#整个页面加水印" class="headerlink" title="整个页面加水印"></a>整个页面加水印</h3><ul><li><p>在所有路由组件外部加一个 水印组件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">el-watermark</span>  <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;h-full !z-99&quot;</span>  <span class="hljs-attr">:font</span>=<span class="hljs-string">&quot;fontStyle&quot;</span>  <span class="hljs-attr">:content</span>=<span class="hljs-string">&quot;[watermarkContent]&quot;</span> &gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">router-view</span> /&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name">el-watermark</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="无感刷新"><a href="#无感刷新" class="headerlink" title="无感刷新"></a>无感刷新</h3><ul><li>用setInterval每隔一秒调用获取列表的接口（记得组件销毁时clearInterval）———–刷新</li><li>“删除”、“编辑”等修改列表数据的操作时需要clearInterval，操作成功后再开启 —- 保持无感刷新</li><li>把列表加载数据时的loading效果要去掉 ——— 无感</li></ul><h3 id="template-admin框架的下拉框独有的回显方式"><a href="#template-admin框架的下拉框独有的回显方式" class="headerlink" title="template-admin框架的下拉框独有的回显方式"></a>template-admin框架的下拉框独有的回显方式</h3><ul><li>内置有useProxy方法获取某个下拉框数据的（字典值和label）组成的数组</li><li>这个字典值会默认从store中去取，没有还会自动去请求接口并保存在store中</li><li>如果是 修改 模式，则在具体的字典值来之前准备好数组即可；如果是 查看 模式，则还需要另外的方法将字典值转化为对应的label值</li></ul><h3 id="下载切图时一定要用svg格式的，避免分辨率不同带来的模糊"><a href="#下载切图时一定要用svg格式的，避免分辨率不同带来的模糊" class="headerlink" title="下载切图时一定要用svg格式的，避免分辨率不同带来的模糊"></a>下载切图时一定要用svg格式的，避免分辨率不同带来的模糊</h3><ul><li>svg格式的图片能自适应还不失真</li></ul><h3 id="多个数据同时开定时器实现数据变化"><a href="#多个数据同时开定时器实现数据变化" class="headerlink" title="多个数据同时开定时器实现数据变化"></a>多个数据同时开定时器实现数据变化</h3><ul><li><p>就是每一个定时器 用完就关，再检查一下，直到检查到最后一个定时器全部完成再提示</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js">selected.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">row</span> =&gt;</span> &#123;<br><span class="hljs-keyword">const</span> interval = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;<br><span class="hljs-keyword">if</span> (row.<span class="hljs-property">unaggregatedField</span> &gt; <span class="hljs-number">0</span>) &#123;<br>row.<span class="hljs-property">unaggregatedField</span>--;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-built_in">clearInterval</span>(interval);<br><span class="hljs-keyword">const</span> allCompleted = selected.<span class="hljs-title function_">every</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item.<span class="hljs-property">unaggregatedField</span> === <span class="hljs-number">0</span>);<br><span class="hljs-keyword">if</span> (allCompleted) &#123;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">$message</span>.<span class="hljs-title function_">success</span>(<span class="hljs-string">&#x27;汇总完毕&#x27;</span>);<br>&#125;<br>&#125;<br>&#125;, <span class="hljs-number">100</span>);<br>&#125;);<br></code></pre></td></tr></table></figure></li><li><p>开定时器最好再加个timeout，避免定时器相互影响</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>   <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>     todoStore.<span class="hljs-title function_">onload</span>()<br>     notificationStore.<span class="hljs-title function_">setNotificationCount</span>(todoStore.<span class="hljs-property">todoMenuList</span>.<span class="hljs-property">length</span>)<br>   &#125;, <span class="hljs-number">0</span>)<br> &#125;, <span class="hljs-number">5000</span>)<br></code></pre></td></tr></table></figure></li></ul><h3 id="搜索框搜索的几种实现方式"><a href="#搜索框搜索的几种实现方式" class="headerlink" title="搜索框搜索的几种实现方式"></a>搜索框搜索的几种实现方式</h3><ul><li>封装的useCommonTable 这个可以直接传入接口函数、搜索参数，就可以获取tableData</li><li>也可以用watch和watcheffect（整个获取list接口写在里面，用到的数据变了就会变）</li></ul><h3 id="永远要用父组件控制子组件的的位置和大小"><a href="#永远要用父组件控制子组件的的位置和大小" class="headerlink" title="永远要用父组件控制子组件的的位置和大小"></a>永远要用父组件控制子组件的的位置和大小</h3><ul><li>子组件 长宽  全部100%即可</li><li>父组件来控制大小和位置</li></ul><h3 id="涉及到列表的循环展示的，最外面要加el-scrollbar滚动条"><a href="#涉及到列表的循环展示的，最外面要加el-scrollbar滚动条" class="headerlink" title="涉及到列表的循环展示的，最外面要加el-scrollbar滚动条"></a>涉及到列表的循环展示的，最外面要加el-scrollbar滚动条</h3><h3 id="计算比值：Math-floor（count-total）-100"><a href="#计算比值：Math-floor（count-total）-100" class="headerlink" title="计算比值：Math.floor（count/total）*100"></a>计算比值：Math.floor（count/total）*100</h3><h3 id="复杂业务（包括技术难点）"><a href="#复杂业务（包括技术难点）" class="headerlink" title="复杂业务（包括技术难点）"></a>复杂业务（包括技术难点）</h3><h1 id="工作经验"><a href="#工作经验" class="headerlink" title="工作经验"></a>工作经验</h1><h3 id="效率相关"><a href="#效率相关" class="headerlink" title="效率相关"></a>效率相关</h3><ul><li><p><strong>和后端联调时</strong>，直接先设计好数据结构然后对应的参数传上，后面通知后端按照这个来就行。这样就不会被后端该接口影响进度</p></li><li><p><strong>改Bug时</strong></p><ul><li><p>原有的东西能不动则不动，我没有必要花时间熟悉原来其他的逻辑，还有可能把原有功能改坏了</p></li><li><p>新增一个变量来处理永远比用之前现有的要方便很多，因为之前的变量有其他用途不能瞎改</p></li></ul></li><li><p><strong>debug时</strong>，打印语句到当前模块开发完毕再统一删掉，因为可能整个过程都要用到</p></li><li><p><strong>解决问题时</strong>，非常偏没有实际案例的问题优先找AI（chatgpt）</p></li></ul><h3 id="规范意识"><a href="#规范意识" class="headerlink" title="规范意识"></a>规范意识</h3><ul><li><strong>需求调整后</strong>，自己检查一下还有没有关联的地方没有修改</li><li><strong>弹框提示要居中</strong></li><li><strong>一行太长除了显示省略号还要加tooltip给别人看</strong></li></ul>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技巧总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git中那些涉及merge的操作</title>
    <link href="/2024/09/03/git%E4%B8%AD%E9%82%A3%E4%BA%9B%E6%B6%89%E5%8F%8Amerge%E7%9A%84%E6%93%8D%E4%BD%9C/"/>
    <url>/2024/09/03/git%E4%B8%AD%E9%82%A3%E4%BA%9B%E6%B6%89%E5%8F%8Amerge%E7%9A%84%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<p><strong>前言</strong></p><p>总结一些涉及到merge操作的git指令</p><hr><p><strong>pull和commit的顺序的顺序问题</strong></p><ul><li>改相同的一块代码，不管pull和commit的顺序如何，最终都是要merge，因为即使先pull会提示你先commit或者stash</li></ul><p>-&gt;既然先pull如果有同一块代码会有提示你commit再合并，那以后都先pull不就行了：</p><p>–&gt;如果没有共同代码，刚刚好拿到了最新代码</p><p>–&gt;如果有，那git中合并记录，记录一下</p><p><strong>git merge到底是哪个合并到哪</strong></p><ul><li>git merge A—&gt;把A的分支合并到当前分支（本地合并）</li></ul><p><strong>如何将某的分支的commit提交到本分之</strong></p><ul><li>git log A —-&gt;查看A分支的提交记录</li><li>git cherry-pick commitId —-&gt;把某分支的commit合并到当前分支</li></ul><p><strong>如何合并远程其他分支的代码</strong></p><ul><li>git pull —&gt;先把其他分支的内容更新到一下，否则获取不到远程其他分支最新代码</li><li>使用vscode工具合并远程别的分支的代码后，是不需要commit的，因为当前就是在合并，commit已经写好了就是合并，剩下的就是合并后的push（优先使用vscode工具来将主分支合并远程其他各个分支的内容，用命令的话需要先拉到本地并合并，比较麻烦）</li></ul>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git操作</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js:如何根据返回的状态只提示成功一次？</title>
    <link href="/2024/08/21/js-%E5%A6%82%E4%BD%95%E6%A0%B9%E6%8D%AE%E8%BF%94%E5%9B%9E%E7%9A%84%E7%8A%B6%E6%80%81%E5%8F%AA%E6%8F%90%E7%A4%BA%E6%88%90%E5%8A%9F%E4%B8%80%E6%AC%A1%EF%BC%9F/"/>
    <url>/2024/08/21/js-%E5%A6%82%E4%BD%95%E6%A0%B9%E6%8D%AE%E8%BF%94%E5%9B%9E%E7%9A%84%E7%8A%B6%E6%80%81%E5%8F%AA%E6%8F%90%E7%A4%BA%E6%88%90%E5%8A%9F%E4%B8%80%E6%AC%A1%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<p><strong>前言</strong></p><p>有这样一个场景：用户User1从第三方页面A设置某状态status为1，然后自动跳转到我的页面B时，第一次进入若status为1，则提示“成功”，但是后面都不再提示（也就是说只有从第三方页面第一次跳回到自己的页面若查到status为1才提示，后面就不提示）</p><p><strong>分析</strong></p><p>也就是要满足两个条件</p><ul><li>第一次提示后，后面都不提示 ————-  &gt;用localStorage+当前用户据的flag为true再提示</li><li>要根据具体的用户来 —————————-&gt;存的键名需要带上用户id，保证唯一</li></ul>]]></content>
    
    
    <categories>
      
      <category>Js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>业务</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js:字符串与数字0比较要注意</title>
    <link href="/2024/08/19/js-%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8E%E6%95%B0%E5%AD%970%E6%AF%94%E8%BE%83%E8%A6%81%E6%B3%A8%E6%84%8F/"/>
    <url>/2024/08/19/js-%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8E%E6%95%B0%E5%AD%970%E6%AF%94%E8%BE%83%E8%A6%81%E6%B3%A8%E6%84%8F/</url>
    
    <content type="html"><![CDATA[<p><strong>前言</strong></p><p>本来以为 == 会因为隐式转换可以 将 “0”==0 结果为true，结果却不一样</p><p><strong>结论</strong></p><h4 id="字母开头的字符串-与-数字0-用-模糊比较总是true"><a href="#字母开头的字符串-与-数字0-用-模糊比较总是true" class="headerlink" title="字母开头的字符串 与 数字0 用 == 模糊比较总是true"></a><code>字母开头的字符串 与 数字0 用 == 模糊比较总是true</code></h4><p>因此以后要注意不要用 == 偷懒 隐式转换来比较，要用===类型相同的数据来比</p>]]></content>
    
    
    <categories>
      
      <category>Js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>不同数据类型比较</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>uniapp学习</title>
    <link href="/2024/07/30/uniapp%E5%AD%A6%E4%B9%A0/"/>
    <url>/2024/07/30/uniapp%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h3 id="1-view标签和div标签比有什么区别（优点）？"><a href="#1-view标签和div标签比有什么区别（优点）？" class="headerlink" title="1.view标签和div标签比有什么区别（优点）？"></a>1.view标签和div标签比有什么区别（优点）？</h3><blockquote><p>他们都可以容纳其他标签的容器，除此以外有以下区别：</p><ul><li>view标签具有平台兼容性，而div没有</li></ul><p>主要体现在样式和事件两个方面。view的默认样式会遵循各个平台（微信小程序、h5、app，主要是移动端）的设计规范，能保持风格一致。view能方便绑定各个平台特定的时间，就拿点击事件举例，可以使用web端的click事件，也可以使用原生app的touchstart、touchmove、touchend事件，也有uniapp特有的tap、longpress事件，保证兼容所有平台。</p><ul><li>在移动端，view标签的的性能要优于div，加载和渲染会更快</li></ul><p>1.view标签在渲染时会映射为原生组件，这样可以充分利用原生组件的性能优势，提高渲染和响应速度</p><p>2.事件处理上默认为view标签添加了事件委托，这样可以确保子元素的事件绑定在父元素上，减少了不必要的事件绑定，优化了响应速度 ———————–&gt;主动把话题引向js中的事件委托、事件传播方式…</p></blockquote><h3 id="2-tap、-click、-touch的使用场景是什么？"><a href="#2-tap、-click、-touch的使用场景是什么？" class="headerlink" title="2.@tap、@click、@touch的使用场景是什么？"></a>2.@tap、@click、@touch的使用场景是什么？</h3><blockquote><p>移动端简单的点击和长按 ————- &gt;@tap，@longpress</p><p>移动端复杂的触摸交互（托拽等）——————-&gt;@touchstart、@touchmove、@touchend</p><p>需要发布到web端 ————&gt;@click，移动端也可以，只是有300ms的点击延迟（移动端兼容性差一些）</p></blockquote><h3 id="3-小程序中rpx和web端的px有什么区别？rpx的作用是什么？"><a href="#3-小程序中rpx和web端的px有什么区别？rpx的作用是什么？" class="headerlink" title="3.小程序中rpx和web端的px有什么区别？rpx的作用是什么？"></a>3.小程序中rpx和web端的px有什么区别？rpx的作用是什么？</h3><blockquote><p>实际屏幕宽度/750px（设计稿宽度）的比值 = 1rpx与px的比值</p><p>比如当前屏幕宽度350px，那么比值为0.5，那么此时1rpx=0.5px，</p><p>​                       宽度1500px，比值为2，此时1rpx=2px</p><p>以此类推， 这样就实现了rpx单位跟随实际屏幕大小动态变化，实现了自适应布局（作用）</p></blockquote><h3 id="4-webView组件的作用是什么"><a href="#4-webView组件的作用是什么" class="headerlink" title="4.webView组件的作用是什么?"></a>4.webView组件的作用是什么?</h3><blockquote><p>用于承载并跳转外部页面的组件，有点像Web端的iframe</p></blockquote><h3 id="5-uniapp如何实现跨平台？"><a href="#5-uniapp如何实现跨平台？" class="headerlink" title="5.uniapp如何实现跨平台？"></a>5.uniapp如何实现跨平台？</h3><blockquote><p>uniapp通过预编译的方式将代码转化为各个平台特定的代码实现跨平台。</p><p>具体来说，使用统一的Vue.js语法，通过编译工具（例如HBuilder）将代码转化为各个平台支持的代码，例如：</p><p>微信小程序转化为微&gt;信小程序的API</p><p>H5转化为Web端技术</p><p>Android和Ios转化为原生API</p></blockquote><h3 id="6-如何在uniapp中实现路由跳转以及传参？"><a href="#6-如何在uniapp中实现路由跳转以及传参？" class="headerlink" title="6.如何在uniapp中实现路由跳转以及传参？"></a>6.如何在uniapp中实现路由跳转以及传参？</h3><blockquote><p><strong>跳转方式</strong></p><ul><li>uni.reLaunch ———————–&gt; 关闭所有页面，跳转到任意一个页面（场景：退出登录）</li><li>uni.redirectTo ———————-&gt; 关闭当前页面，跳转到非Tab页（场景：登录）</li><li>uni.swichTab ———————–&gt; 关闭所有非Tab页，跳转到Tab页（场景：不再回到非Tab页）</li><li>uni.navigateTo ———————&gt; 保留当前页面，跳转到非Tab页（场景：在非Tab页来回跳转）</li><li>uni.navigateBack ——————&gt; uni.navigateTo跳回的API</li></ul><p><strong>传参</strong></p><p>用query参数的方式传参，再在onLoad钩子函数里的参数来获取</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">uni.<span class="hljs-title function_">navigateTo</span>(&#123;<span class="hljs-attr">url</span>: <span class="hljs-string">`/pages/webView/index?title=滑块验证码&amp;path=<span class="hljs-subst">$&#123;<span class="hljs-built_in">encodeURIComponent</span>(url)&#125;</span>`</span>&#125;)<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">onLoad</span>(<span class="hljs-params">options</span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(options.<span class="hljs-property">title</span>)<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><h3 id="7-uniapp有哪些生命周期函数？"><a href="#7-uniapp有哪些生命周期函数？" class="headerlink" title="7.uniapp有哪些生命周期函数？"></a>7.uniapp有哪些生命周期函数？</h3><blockquote><p>onLoad ————— &gt; 页面加载中调用（类似Created，在这里初始化一些数据）</p><p>onReady ————- &gt; 页面渲染完成时调用（类似Mounted，在这里处理页面渲染后的操作）</p><p>onShow ————– &gt; 页面上的数据更新时调用（类似Updated）</p><p>onHide ————— &gt; 页面隐藏（保存）时调用（类似beforeRouteLeave守卫钩子）</p><p>onUnload ————&gt;  页面销毁时调用（类似destoryed）</p></blockquote><h3 id="8-都是Vuejs，为什么uniapp的生命周期函数没有像Web端那样有created这样Vue实例以及实例挂载的概念？"><a href="#8-都是Vuejs，为什么uniapp的生命周期函数没有像Web端那样有created这样Vue实例以及实例挂载的概念？" class="headerlink" title="8.都是Vuejs，为什么uniapp的生命周期函数没有像Web端那样有created这样Vue实例以及实例挂载的概念？"></a>8.都是Vuejs，为什么uniapp的生命周期函数没有像Web端那样有created这样Vue实例以及实例挂载的概念？</h3><blockquote><p>因为uniapp重心是满足移动端的需求，而移动端强调页面的交互与跳转，不需要有组件挂载的概念，简化了生命周期，也能提高性能</p></blockquote><h3 id="9-uniApp支持哪些数据持久化方式？"><a href="#9-uniApp支持哪些数据持久化方式？" class="headerlink" title="9. uniApp支持哪些数据持久化方式？"></a>9. uniApp支持哪些数据持久化方式？</h3><blockquote><p><strong>本地存储：</strong> uni.setStorageSync</p><p><strong>文件存储：</strong>uni.saveFile和uni.getFileInfo（文件肯定是异步，格式和本地存储一样）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 保存文件</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">saveFileExample</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 假设你有一个文件路径</span><br>    <span class="hljs-keyword">const</span> filePath = <span class="hljs-string">&#x27;/path/to/your/file.txt&#x27;</span>; <span class="hljs-comment">// 请替换为实际文件路径</span><br><br>    uni.<span class="hljs-title function_">saveFile</span>(&#123;<br>        <span class="hljs-attr">tempFilePath</span>: filePath,<br>        <span class="hljs-attr">success</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">res</span>) &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;文件保存成功:&#x27;</span>, res.<span class="hljs-property">savedFilePath</span>);<br>            <span class="hljs-comment">// 接下来获取该文件的信息</span><br>            <span class="hljs-title function_">getFileInfo</span>(res.<span class="hljs-property">savedFilePath</span>);<br>        &#125;,<br>        <span class="hljs-attr">fail</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">error</span>) &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;文件保存失败:&#x27;</span>, error);<br>        &#125;<br>    &#125;);<br>&#125;<br><br><span class="hljs-comment">// 获取文件信息</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getFileInfo</span>(<span class="hljs-params">filePath</span>) &#123;<br>    uni.<span class="hljs-title function_">getFileInfo</span>(&#123;<br>        <span class="hljs-attr">filePath</span>: filePath,<br>        <span class="hljs-attr">success</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">res</span>) &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;文件信息:&#x27;</span>, res);<br>        &#125;,<br>        <span class="hljs-attr">fail</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">error</span>) &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;获取文件信息失败:&#x27;</span>, error);<br>        &#125;<br>    &#125;);<br>&#125;<br><br><span class="hljs-comment">// 调用保存文件的方法</span><br><span class="hljs-title function_">saveFileExample</span>();<br></code></pre></td></tr></table></figure><p><strong>数据库：</strong>wx.cloud.database（更大的数据需求，增删改查操作）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 首先在主入口文件中初始化 cloud</span><br>uni.<span class="hljs-property">cloud</span>.<span class="hljs-title function_">init</span>(&#123;<br>    <span class="hljs-attr">env</span>: <span class="hljs-string">&#x27;your-env-id&#x27;</span>, <span class="hljs-comment">// 更改为您自己的云环境 ID</span><br>&#125;);<br><br><span class="hljs-comment">// 插入数据到云数据库</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">addDataToDatabase</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> db = uniCloud.<span class="hljs-title function_">database</span>();<br>    <span class="hljs-keyword">const</span> collection = db.<span class="hljs-title function_">collection</span>(<span class="hljs-string">&#x27;your-collection-name&#x27;</span>); <span class="hljs-comment">// 更改为您的集合名称</span><br><br>    <span class="hljs-keyword">const</span> data = &#123;<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;张三&#x27;</span>,<br>        <span class="hljs-attr">age</span>: <span class="hljs-number">25</span>,<br>        <span class="hljs-attr">createdAt</span>: uniCloud.<span class="hljs-property">database</span>.<span class="hljs-title function_">serverDate</span>() <span class="hljs-comment">// 存储当前时间</span><br>    &#125;;<br><br>    collection.<span class="hljs-title function_">add</span>(data).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;数据插入成功:&#x27;</span>, res);<br>    &#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;数据插入失败:&#x27;</span>, err);<br>    &#125;);<br>&#125;<br><br><span class="hljs-comment">// 调用添加数据的方法</span><br><span class="hljs-title function_">addDataToDatabase</span>();<br></code></pre></td></tr></table></figure></blockquote><h3 id="10-如何在uniapp中进行本地存储以及获取数据？"><a href="#10-如何在uniapp中进行本地存储以及获取数据？" class="headerlink" title="10.如何在uniapp中进行本地存储以及获取数据？"></a>10.如何在uniapp中进行本地存储以及获取数据？</h3><blockquote><p><strong>同步</strong></p><p>uni.setStorageSync(“key”,value) ————— 设置</p><p>uni.getStorageSync(“key”) ———————– 获取</p><p>uni.removeStorageSync(“key”)—————— 删除</p><p><strong>异步</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs JS">uni.<span class="hljs-title function_">setStorage</span>(&#123;<br>    <span class="hljs-attr">key</span>: <span class="hljs-string">&quot;key&quot;</span>,<br>    <span class="hljs-attr">data</span>: data,<br>    <span class="hljs-attr">success</span>: <span class="hljs-function">() =&gt;</span> &#123;<br>       <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;数据存储成功&#x27;</span>);<br>    &#125;,<br>    <span class="hljs-attr">fail</span>: <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>       <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;数据存储失败&#x27;</span>,err);<br>    &#125;<br>&#125;) <br></code></pre></td></tr></table></figure><p>获取、删除同理</p></blockquote><h3 id="11-为什么本地存储有同步异步的概念，而Web端没有？"><a href="#11-为什么本地存储有同步异步的概念，而Web端没有？" class="headerlink" title="11.为什么本地存储有同步异步的概念，而Web端没有？"></a>11.为什么本地存储有同步异步的概念，而Web端没有？</h3><blockquote><p>因为uniapp需要考虑各个平台的内存限制，避免因为存储的数据量过于复杂而导致阻塞带来的用户体验不佳的情况</p></blockquote><h3 id="12-在uniapp中什么是条件编译？"><a href="#12-在uniapp中什么是条件编译？" class="headerlink" title="12.在uniapp中什么是条件编译？"></a>12.在uniapp中什么是条件编译？</h3><blockquote><p>就是利用注释的方式可以根据不同的平台运行相应的代码，使用方法如下：</p><p>注释包括：#ifdef/#ifndef、#endif</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> MP-WEIXIN ----------------- 如果定义的是微信小程序</span><br>...<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>MP———&gt; mini program小程序，出微信以外，还有以下平台</p><p>MP-ALIPAY——-支付宝小程序</p><p>H5 ——————H5页面</p></blockquote><h3 id="13-uniapp中通讯方式有哪些？"><a href="#13-uniapp中通讯方式有哪些？" class="headerlink" title="13.uniapp中通讯方式有哪些？"></a>13.uniapp中通讯方式有哪些？</h3><blockquote><p><strong>父子通信</strong></p><p>和Web端一样，用props和emit</p><p><strong>跨级通信</strong></p><p>使用uni.emit和uni.on全局事件总线</p></blockquote><h3 id="14-与原生开发相比，uniapp的性能如何？"><a href="#14-与原生开发相比，uniapp的性能如何？" class="headerlink" title="14.与原生开发相比，uniapp的性能如何？"></a>14.与原生开发相比，uniapp的性能如何？</h3><blockquote><p>uniapp在大多数情况下接近原生开发，通过编译优化（代码分包）和硬件加速（使用原生API处理一些图形计算处理），可以在多个平台可以流畅的运行。但是在一些性能要求极高的场景下，例如复杂的游戏等一下计算量大的应用，和原生开发的性能还是有差距的。</p></blockquote><h3 id="15-什么是uniapp代码分包，如何分包？"><a href="#15-什么是uniapp代码分包，如何分包？" class="headerlink" title="15.什么是uniapp代码分包，如何分包？"></a>15.什么是uniapp代码分包，如何分包？</h3><blockquote><p>uniapp中的代码分包的概念类似于webpack中的代码分割，只是代码分包仅是针对小程序加载优化，而webpack是针对wen应用。</p><p>如何分包？在uni.config.js中配置subPackages</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">subPackages</span>: [<br>    &#123;<br>      <span class="hljs-attr">root</span>: <span class="hljs-string">&#x27;subPackageA&#x27;</span>,<br>      <span class="hljs-attr">pages</span>: [<br>        <span class="hljs-string">&#x27;index/index&#x27;</span>, <span class="hljs-comment">// subPackageA 下的 index/index.vue 会被分到这个包</span><br>        <span class="hljs-string">&#x27;detail/detail&#x27;</span>, <span class="hljs-comment">// subPackageA 下的 detail/detail.vue 也会被分到这个包</span><br>      ],<br>    &#125;,<br>    &#123;<br>      <span class="hljs-attr">root</span>: <span class="hljs-string">&#x27;subPackageB&#x27;</span>,<br>      <span class="hljs-attr">pages</span>: [<br>        <span class="hljs-string">&#x27;home/home&#x27;</span>,<br>        <span class="hljs-string">&#x27;profile/profile&#x27;</span>,<br>      ],<br>    &#125;,<br>  ],<br>&#125;;<br></code></pre></td></tr></table></figure></blockquote><h3 id="16-如何在uniapp中进行网络请求？"><a href="#16-如何在uniapp中进行网络请求？" class="headerlink" title="16.如何在uniapp中进行网络请求？"></a>16.如何在uniapp中进行网络请求？</h3><blockquote><p>uni有一个内置的专门网络请求的api：request（很像ajax），如果有特殊处理需要自行封装</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js">uni.<span class="hljs-title function_">request</span>(&#123;<br>    <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;https://example.com/api&#x27;</span>,<br>    <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;GET&#x27;</span>,<br>    <span class="hljs-title function_">success</span>(<span class="hljs-params">res</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res.<span class="hljs-property">data</span>);<br>    &#125;,<br>    <span class="hljs-title function_">fail</span>(<span class="hljs-params">err</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err);<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>通常需要利用axios的适配器适配uniapp的网络请求，这样就可以 利用axios请求接口，但是内部实际上用的是uni.request，实现了虽然用axios请求接口，但是也能保证uniapp正常使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;axios&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; uni &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@dcloudio/uni-app&#x27;</span>;<br><br>axios.<span class="hljs-property">defaults</span>.<span class="hljs-property">adapter</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">config</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    uni.<span class="hljs-title function_">request</span>(&#123;<br>      <span class="hljs-attr">url</span>: config.<span class="hljs-property">url</span>,<br>      <span class="hljs-attr">method</span>: config.<span class="hljs-property">method</span>,<br>      <span class="hljs-attr">data</span>: config.<span class="hljs-property">data</span>,<br>      <span class="hljs-attr">header</span>: config.<span class="hljs-property">headers</span>,<br>      <span class="hljs-attr">success</span>: <span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>        <span class="hljs-title function_">resolve</span>(res.<span class="hljs-property">data</span>);<br>      &#125;,<br>      <span class="hljs-attr">fail</span>: <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>        <span class="hljs-title function_">reject</span>(err);<br>      &#125;<br>    &#125;);<br>  &#125;);<br>&#125;;<br></code></pre></td></tr></table></figure></blockquote><h3 id="17-uniapp中的scroll-view组件的作用？"><a href="#17-uniapp中的scroll-view组件的作用？" class="headerlink" title="17.uniapp中的scroll-view组件的作用？"></a>17.uniapp中的scroll-view组件的作用？</h3><blockquote><p>就是一个用于展示有滚动条列表的组件，和虚拟列表技术（性能优化方面）还相差甚远</p></blockquote><h3 id="18-如何解决uniapp中不同平台的适配问题？"><a href="#18-如何解决uniapp中不同平台的适配问题？" class="headerlink" title="18.如何解决uniapp中不同平台的适配问题？"></a>18.如何解决uniapp中不同平台的适配问题？</h3><blockquote><p>虽然uniapp有平台兼容性，但是只局限于样式风格上、功能使用上保持一致，对于页面布局的适配还得要使用原来移动端的一些适配方法，比如媒体查询、vw/vh、rem/em等</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>前端框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>uniapp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js:map和foreach的区别</title>
    <link href="/2024/07/30/js-map%E5%92%8Cforeach%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2024/07/30/js-map%E5%92%8Cforeach%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<p><strong>前言</strong></p><p>自己在开发中 由于 对map函数的理解不够深，导致数组中的元素莫名其妙变为undefined，找了半天错误才发现是map函数用错了</p><p><strong>误区：把map函数当foreach函数用</strong></p><p>原来我对map函数的理解仅仅局限于 这个函数仅仅是返回一个新的数据，不在原数组操作数据</p><p>却不知道 既然是要返回一个新数组，那么当前这个<strong>item就一定要return出去</strong>，否则无法返回一个新的数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">this</span>.<span class="hljs-property">tableData</span>.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">item</span>)=&gt;</span>&#123;<br>    <span class="hljs-keyword">if</span>(...)&#123; item.<span class="hljs-property">xxx</span> = aaa &#125;<br>    <span class="hljs-keyword">return</span> item<br>&#125;)<br></code></pre></td></tr></table></figure><p>这也让我慢慢理解了为什么有一个万能的foreach还要设计出一个map函数，我想不仅仅是不想修改原数组，而是更方便用于 <strong>元素的计算</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">this</span>.<span class="hljs-property">tableData</span>.<span class="hljs-title function_">foreach</span>(<span class="hljs-function">(<span class="hljs-params">item</span>)=&gt;</span>&#123;<br>    item.<span class="hljs-property">xxx</span> = item.<span class="hljs-property">xxx</span> * <span class="hljs-number">2</span> ----------------&gt;这种重复的代码，看着不美观<br>&#125;)<br><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">tableData</span>.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">item</span>=&gt;</span> item.<span class="hljs-property">xxx</span> * <span class="hljs-number">2</span>) ----------&gt; 简洁美观<br>(注意 箭头函数若 函数体只有一条语句，才可以不用写<span class="hljs-keyword">return</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>常用函数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue项目的通用业务逻辑</title>
    <link href="/2024/07/05/vue%E9%A1%B9%E7%9B%AE%E7%9A%84%E9%80%9A%E7%94%A8%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91/"/>
    <url>/2024/07/05/vue%E9%A1%B9%E7%9B%AE%E7%9A%84%E9%80%9A%E7%94%A8%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91/</url>
    
    <content type="html"><![CDATA[<h1 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h1><p>–root</p><p>  –permission.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> router <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./router&quot;</span>;<br><span class="hljs-keyword">import</span> store <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./store&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Message</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;element-ui&quot;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">NProgress</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;nprogress&quot;</span>; <span class="hljs-comment">// progress bar</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;nprogress/nprogress.css&quot;</span>; <span class="hljs-comment">// progress bar style</span><br><span class="hljs-keyword">import</span> &#123; getToken &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@/utils/auth&quot;</span>; <span class="hljs-comment">// get token from cookie</span><br><span class="hljs-keyword">import</span> getPageTitle <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@/utils/get-page-title&quot;</span>;<br><br><span class="hljs-title class_">NProgress</span>.<span class="hljs-title function_">configure</span>(&#123; <span class="hljs-attr">showSpinner</span>: <span class="hljs-literal">false</span> &#125;); <span class="hljs-comment">// NProgress Configuration</span><br><br><span class="hljs-keyword">const</span> whiteList = [<span class="hljs-string">&quot;/login&quot;</span>, <span class="hljs-string">&quot;/car&quot;</span>]; <span class="hljs-comment">// no redirect whitelist</span><br><br><span class="hljs-comment">// 1.，每次路由切换首先根据token判断用户是否登录</span><br><span class="hljs-keyword">let</span> hasRoles = <span class="hljs-literal">true</span>;<br><br>router.<span class="hljs-title function_">beforeEach</span>(<span class="hljs-keyword">async</span> (to, <span class="hljs-keyword">from</span>, next) =&gt; &#123;<br>  <span class="hljs-title class_">NProgress</span>.<span class="hljs-title function_">start</span>();<br>  <span class="hljs-variable language_">document</span>.<span class="hljs-property">title</span> = <span class="hljs-title function_">getPageTitle</span>(to.<span class="hljs-property">meta</span>.<span class="hljs-property">title</span>); <span class="hljs-comment">// 标签卡title拼接</span><br>  <span class="hljs-keyword">const</span> token = <span class="hljs-title function_">getToken</span>();<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;执行+&#x27;</span>+token);<br><br>  <span class="hljs-comment">// let roles; //声明用户权限列表变量</span><br><br>  <span class="hljs-keyword">if</span> (token) &#123;<br>    <span class="hljs-keyword">if</span> (to.<span class="hljs-property">path</span> === <span class="hljs-string">&quot;/login&quot;</span>) &#123;<br>      <span class="hljs-title function_">next</span>(&#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/&quot;</span> &#125;); <span class="hljs-comment">// 已登录时跳转登录页 跳转到首页</span><br>      <span class="hljs-title class_">NProgress</span>.<span class="hljs-title function_">done</span>();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">const</span> hasGetUserlnfo = store.<span class="hljs-property">state</span>.<span class="hljs-property">user</span>.<span class="hljs-property">name</span>; <span class="hljs-comment">//解决每次路由变化都派发请求的问题</span><br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(hasGetUserlnfo);<br>        <span class="hljs-keyword">if</span> (hasGetUserlnfo &amp;&amp; store.<span class="hljs-property">state</span>.<span class="hljs-property">permission</span>.<span class="hljs-property">routes</span>.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) &#123;<br>          <span class="hljs-comment">//5.23修改</span><br>          <span class="hljs-comment">// 若不做该限定 则静态路由中没有登录后所要跳转的路由时会出现空白</span><br>          <span class="hljs-comment">// 即权限已经通过接口获取完毕，但侧边栏所使用的最终路由表还没有存储到vuex中</span><br>          <span class="hljs-comment">// 此操作即保证用户已登录，信息存储到了vuex中且最终路由表已经生成，再实现跳转</span><br><br>          <span class="hljs-comment">//已经有登录的用户信息再跳转别的页面将不在获取用户信息</span><br>          <span class="hljs-title function_">next</span>();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-keyword">const</span> &#123; roles &#125; = <span class="hljs-keyword">await</span> store.<span class="hljs-title function_">dispatch</span>(<span class="hljs-string">&quot;user/getInfo&quot;</span>); <span class="hljs-comment">//获取登录用户的类型，及roles权限</span><br>          <span class="hljs-keyword">const</span> accessRoutes = <span class="hljs-keyword">await</span> store.<span class="hljs-title function_">dispatch</span>(<br>            <span class="hljs-string">&quot;permission/generateRoutes&quot;</span>,<br>            roles<br>          );<br>          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(roles);<br>          <span class="hljs-keyword">if</span> (hasRoles) &#123;<br>            router.<span class="hljs-title function_">addRoutes</span>(accessRoutes); <span class="hljs-comment">// 关键步骤！！注意版本 建议vue-router使用4以下版本</span><br>            hasRoles = <span class="hljs-literal">false</span>; <span class="hljs-comment">//解决动态路由刷新问题</span><br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(to);<br>            <span class="hljs-title function_">next</span>(&#123; ...to, <span class="hljs-attr">replace</span>: <span class="hljs-literal">true</span> &#125;); <span class="hljs-comment">// replace: true, 导航中将留下 history 记录</span><br>          &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-title function_">next</span>();<br>          &#125;<br>        &#125;<br>      &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>        <span class="hljs-comment">// 删除token，跳转登录页面</span><br>        <span class="hljs-variable language_">window</span>.<span class="hljs-property">sessionStorage</span>.<span class="hljs-title function_">clear</span>();<br>        <span class="hljs-variable language_">window</span>.<span class="hljs-property">localStorage</span>.<span class="hljs-title function_">clear</span>();<br>        <span class="hljs-keyword">await</span> store.<span class="hljs-title function_">dispatch</span>(<span class="hljs-string">&quot;user/resetToken&quot;</span>);<br>        <span class="hljs-comment">// await store.dispatch(&quot;user/logout&quot;);</span><br>        <span class="hljs-title class_">Message</span>.<span class="hljs-title function_">error</span>(error || <span class="hljs-string">&quot;请重新登录&quot;</span>);<br>        <span class="hljs-title function_">next</span>(<span class="hljs-string">`/login`</span>);<br>        <span class="hljs-title class_">NProgress</span>.<span class="hljs-title function_">done</span>();<br>      &#125;<br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">/* 没有token*/</span><br>    <span class="hljs-keyword">if</span> (whiteList.<span class="hljs-title function_">indexOf</span>(to.<span class="hljs-property">path</span>) !== -<span class="hljs-number">1</span>) &#123;<br>      <span class="hljs-comment">//白名单列表</span><br>      <span class="hljs-title function_">next</span>();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-title function_">next</span>(<span class="hljs-string">`/login`</span>);<br>      <span class="hljs-title class_">NProgress</span>.<span class="hljs-title function_">done</span>();<br>    &#125;<br>  &#125;<br>&#125;);<br><br>router.<span class="hljs-title function_">afterEach</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-title class_">NProgress</span>.<span class="hljs-title function_">done</span>();<br>&#125;);<br><br></code></pre></td></tr></table></figure><p>总结：获取 用户信息的roles生成动态路由</p><p>—store</p><p>  —permission.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; asyncRoutes, constantRoutes &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@/router&quot;</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Use meta.role to determine if the current user has permission</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> <span class="hljs-variable">roles</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> <span class="hljs-variable">route</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">hasPermission</span>(<span class="hljs-params">roles, route</span>) &#123;<br>  <span class="hljs-keyword">if</span> (route.<span class="hljs-property">meta</span> &amp;&amp; route.<span class="hljs-property">meta</span>.<span class="hljs-property">roles</span>) &#123;<br>    <span class="hljs-keyword">return</span> roles.<span class="hljs-title function_">some</span>(<span class="hljs-function">(<span class="hljs-params">role</span>) =&gt;</span> route.<span class="hljs-property">meta</span>.<span class="hljs-property">roles</span>.<span class="hljs-title function_">includes</span>(role));<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Filter asynchronous routing tables by recursion</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> routes asyncRoutes</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> <span class="hljs-variable">roles</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">filterAsyncRoutes</span>(<span class="hljs-params">routes, roles</span>) &#123;<br>  <span class="hljs-keyword">const</span> res = [];<br>  routes.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">route</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> tmp = &#123; ...route &#125;;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">hasPermission</span>(roles, tmp)) &#123;<br>      <span class="hljs-keyword">if</span> (tmp.<span class="hljs-property">children</span>) &#123;<br>        tmp.<span class="hljs-property">children</span> = <span class="hljs-title function_">filterAsyncRoutes</span>(tmp.<span class="hljs-property">children</span>, roles);<br>      &#125;<br>      res.<span class="hljs-title function_">push</span>(tmp);<br>    &#125;<br>  &#125;);<br><br>  <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-keyword">const</span> state = &#123;<br>  <span class="hljs-attr">routes</span>: [],<br>  <span class="hljs-attr">addRoutes</span>: [],<br>&#125;;<br><br><span class="hljs-keyword">const</span> mutations = &#123;<br>  <span class="hljs-attr">SET_ROUTES</span>: <span class="hljs-function">(<span class="hljs-params">state, routes</span>) =&gt;</span> &#123;<br>    state.<span class="hljs-property">addRoutes</span> = routes;<br>    state.<span class="hljs-property">routes</span> = constantRoutes.<span class="hljs-title function_">concat</span>(routes);<br>  &#125;,<br>&#125;;<br><br><span class="hljs-keyword">const</span> actions = &#123;<br>  <span class="hljs-title function_">generateRoutes</span>(<span class="hljs-params">&#123; commit &#125;, roles</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">let</span> accessedRoutes;<br>      <span class="hljs-keyword">if</span> (roles.<span class="hljs-title function_">includes</span>(<span class="hljs-string">&quot;admin&quot;</span>)) &#123;<br>        accessedRoutes = asyncRoutes || [];<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        accessedRoutes = <span class="hljs-title function_">filterAsyncRoutes</span>(asyncRoutes, roles);<br>      &#125;<br>      <span class="hljs-keyword">const</span> roleDesc = <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&quot;roleDesc&quot;</span>);<br>      <span class="hljs-keyword">if</span>(roleDesc)&#123;<br>        <span class="hljs-keyword">const</span> roleDescArray = roleDesc.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;,&quot;</span>);<br>        <span class="hljs-keyword">if</span> (<br>          roles.<span class="hljs-title function_">includes</span>(<span class="hljs-string">&quot;teacher&quot;</span>) &amp;&amp;<br>          roleDescArray &amp;&amp;<br>          roleDescArray.<span class="hljs-property">length</span> &lt; <span class="hljs-number">4</span><br>        ) &#123;<br>          <span class="hljs-comment">// 是老师身份的时候 且只有部分权限的时候</span><br>          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;roleDescArray&quot;</span>, roleDescArray);<br><br>          <span class="hljs-keyword">if</span> (!roleDescArray.<span class="hljs-title function_">includes</span>(<span class="hljs-string">&quot;4&quot;</span>)) &#123;<br>            accessedRoutes = accessedRoutes.<span class="hljs-title function_">filter</span>(<br>              <span class="hljs-function">(<span class="hljs-params">route</span>) =&gt;</span> route.<span class="hljs-property">url</span> !== <span class="hljs-string">&quot;/student&quot;</span><br>            );<br>          &#125;<br>          <span class="hljs-keyword">if</span> (!roleDescArray.<span class="hljs-title function_">includes</span>(<span class="hljs-string">&quot;3&quot;</span>)) &#123;<br>            accessedRoutes = accessedRoutes.<span class="hljs-title function_">filter</span>(<br>              <span class="hljs-function">(<span class="hljs-params">route</span>) =&gt;</span> route.<span class="hljs-property">url</span> !== <span class="hljs-string">&quot;/questionfeedback&quot;</span><br>            );<br>          &#125;<br>          <span class="hljs-keyword">if</span> (!roleDescArray.<span class="hljs-title function_">includes</span>(<span class="hljs-string">&quot;2&quot;</span>)) &#123;<br>            accessedRoutes = accessedRoutes.<span class="hljs-title function_">filter</span>(<br>              <span class="hljs-function">(<span class="hljs-params">route</span>) =&gt;</span> route.<span class="hljs-property">url</span> !== <span class="hljs-string">&quot;/publicproblem&quot;</span><br>            );<br>          &#125;<br>          <span class="hljs-keyword">if</span> (roleDescArray.<span class="hljs-property">length</span> === <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-comment">// 只有一个权限的时候且没有1这个权限的时候</span><br>            <span class="hljs-keyword">if</span> (!roleDescArray.<span class="hljs-title function_">includes</span>(<span class="hljs-string">&quot;1&quot;</span>)) &#123;<br>              accessedRoutes = accessedRoutes.<span class="hljs-title function_">filter</span>(<br>                <span class="hljs-function">(<span class="hljs-params">route</span>) =&gt;</span> route.<span class="hljs-property">url</span> !== <span class="hljs-string">&quot;/dashboard&quot;</span><br>              );<br>            &#125;<br>          &#125;<br>        &#125;<br>      &#125;<br>      <span class="hljs-title function_">commit</span>(<span class="hljs-string">&quot;SET_ROUTES&quot;</span>, accessedRoutes);<br>      <span class="hljs-title function_">resolve</span>(accessedRoutes);<br>    &#125;);<br>  &#125;,<br>&#125;;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-attr">namespaced</span>: <span class="hljs-literal">true</span>,<br>  state,<br>  mutations,<br>  actions,<br>&#125;;<br><br></code></pre></td></tr></table></figure><p>总结：在store中生成动态路由的函数，并把动态路由存放在store中</p><p>—router</p><p>  –index.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vue</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Router</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue-router&quot;</span>;<br><br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">use</span>(<span class="hljs-title class_">Router</span>);<br><br><span class="hljs-comment">/* Layout */</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Layout</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@/layout&quot;</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * constantRoutes</span><br><span class="hljs-comment"> * a base page that does not have permission requirements</span><br><span class="hljs-comment"> * all roles can be accessed</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> constantRoutes = [<br>  &#123;<br>    <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/login&quot;</span>,<br>    <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&quot;@/views/Login/index&quot;</span>),<br>    <span class="hljs-attr">hidden</span>: <span class="hljs-literal">true</span>,<br>  &#125;,<br>  &#123;<br>    <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/404&quot;</span>,<br>    <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&quot;@/views/404&quot;</span>),<br>    <span class="hljs-attr">hidden</span>: <span class="hljs-literal">true</span>,<br>  &#125;,<br>  &#123;<br>    <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/demo&quot;</span>,<br>    <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&quot;@/views/demo&quot;</span>),<br>    <span class="hljs-attr">hidden</span>: <span class="hljs-literal">true</span>,<br>  &#125;<br>];<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * asyncRoutes</span><br><span class="hljs-comment"> * the routes that need to be dynamically loaded based on user roles</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> asyncRoutes = [<br>  &#123;<br>    <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/&quot;</span>,<br>    <span class="hljs-attr">url</span>: <span class="hljs-string">&quot;/dashboard&quot;</span>,<br>    <span class="hljs-attr">component</span>: <span class="hljs-title class_">Layout</span>,<br>    <span class="hljs-attr">redirect</span>: <span class="hljs-string">&quot;/dashboard&quot;</span>,<br>    <span class="hljs-attr">meta</span>: &#123;<br>      <span class="hljs-attr">roles</span>: [<span class="hljs-string">&quot;admin&quot;</span>, <span class="hljs-string">&quot;teacher&quot;</span>, <span class="hljs-string">&quot;norole&quot;</span>], <span class="hljs-comment">// you can set roles in root nav</span><br>    &#125;,<br>    <span class="hljs-attr">children</span>: [<br>      &#123;<br>        <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;dashboard&quot;</span>,<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Dashboard&quot;</span>,<br>        <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&quot;@/views/dashboard/index&quot;</span>),<br>        <span class="hljs-attr">meta</span>: &#123;<br>          <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;人工批改服务&quot;</span>,<br>          <span class="hljs-attr">roles</span>: [<span class="hljs-string">&quot;admin&quot;</span>, <span class="hljs-string">&quot;teacher&quot;</span>, <span class="hljs-string">&quot;norole&quot;</span>],<br>        &#125;,<br>      &#125;,<br>      &#123;<br>        <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/correctionDetail&quot;</span>,<br>        <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&quot;@/views/dashboard/CorrectionDetail&quot;</span>),<br>        <span class="hljs-attr">hidden</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-attr">meta</span>: &#123;<br>          <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;人工批改详情&quot;</span>,<br>          <span class="hljs-attr">roles</span>: [<span class="hljs-string">&quot;admin&quot;</span>, <span class="hljs-string">&quot;teacher&quot;</span>, <span class="hljs-string">&quot;norole&quot;</span>],<br>          <span class="hljs-attr">activeMenu</span>: <span class="hljs-string">&quot;/dashboard&quot;</span>,<br>        &#125;,<br>      &#125;,<br>    ],<br>  &#125;,<br>  &#123;<br>    <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/publicproblem&quot;</span>,<br>    <span class="hljs-attr">url</span>: <span class="hljs-string">&quot;/publicproblem&quot;</span>,<br>    <span class="hljs-attr">component</span>: <span class="hljs-title class_">Layout</span>,<br>    <span class="hljs-attr">redirect</span>: <span class="hljs-string">&quot;/publicproblem/list&quot;</span>,<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;PublicProblem&quot;</span>,<br>    <span class="hljs-attr">meta</span>: &#123; <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;公共答疑库&quot;</span>, <span class="hljs-attr">roles</span>: [<span class="hljs-string">&quot;admin&quot;</span>, <span class="hljs-string">&quot;teacher&quot;</span>] &#125;,<br>    <span class="hljs-attr">children</span>: [<br>      &#123;<br>        <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;list&quot;</span>,<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;list&quot;</span>,<br>        <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&quot;@/views/publicproblem/index&quot;</span>),<br>        <span class="hljs-attr">meta</span>: &#123; <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;公共答疑库&quot;</span>, <span class="hljs-attr">roles</span>: [<span class="hljs-string">&quot;admin&quot;</span>, <span class="hljs-string">&quot;teacher&quot;</span>] &#125;,<br>      &#125;,<br>      &#123;<br>        <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;new&quot;</span>,<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;new&quot;</span>,<br>        <span class="hljs-attr">hidden</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&quot;@/views/publicproblem/new&quot;</span>),<br>        <span class="hljs-attr">meta</span>: &#123;<br>          <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;新建&quot;</span>,<br>          <span class="hljs-attr">roles</span>: [<span class="hljs-string">&quot;admin&quot;</span>, <span class="hljs-string">&quot;teacher&quot;</span>],<br>          <span class="hljs-attr">activeMenu</span>: <span class="hljs-string">&quot;/publicproblem/list&quot;</span>,<br>        &#125;,<br>      &#125;,<br>      &#123;<br>        <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;labels&quot;</span>,<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;labels&quot;</span>,<br>        <span class="hljs-attr">hidden</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&quot;@/views/publicproblem/labels&quot;</span>),<br>        <span class="hljs-attr">meta</span>: &#123;<br>          <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;标签管理&quot;</span>,<br>          <span class="hljs-attr">roles</span>: [<span class="hljs-string">&quot;admin&quot;</span>, <span class="hljs-string">&quot;teacher&quot;</span>],<br>          <span class="hljs-attr">activeMenu</span>: <span class="hljs-string">&quot;/publicproblem/list&quot;</span>,<br>        &#125;,<br>      &#125;,<br>    ],<br>  &#125;,<br>  &#123;<br>    <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/questionfeedback&quot;</span>,<br>    <span class="hljs-attr">url</span>: <span class="hljs-string">&quot;/questionfeedback&quot;</span>,<br>    <span class="hljs-attr">component</span>: <span class="hljs-title class_">Layout</span>,<br>    <span class="hljs-attr">redirect</span>: <span class="hljs-string">&quot;/questionfeedback/list&quot;</span>,<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;QuestionFeedback&quot;</span>,<br>    <span class="hljs-attr">meta</span>: &#123; <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;题目反馈&quot;</span>, <span class="hljs-attr">roles</span>: [<span class="hljs-string">&quot;admin&quot;</span>, <span class="hljs-string">&quot;teacher&quot;</span>] &#125;,<br>    <span class="hljs-attr">children</span>: [<br>      &#123;<br>        <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;list&quot;</span>,<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;list&quot;</span>,<br>        <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&quot;@/views/questionfeedback/index&quot;</span>),<br>        <span class="hljs-attr">meta</span>: &#123; <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;题目反馈&quot;</span>, <span class="hljs-attr">roles</span>: [<span class="hljs-string">&quot;admin&quot;</span>, <span class="hljs-string">&quot;teacher&quot;</span>] &#125;,<br>      &#125;,<br>      &#123;<br>        <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;detail&quot;</span>,<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;detail&quot;</span>,<br>        <span class="hljs-attr">hidden</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&quot;@/views/questionfeedback/detail&quot;</span>),<br>        <span class="hljs-attr">meta</span>: &#123;<br>          <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;查看详情&quot;</span>,<br>          <span class="hljs-attr">roles</span>: [<span class="hljs-string">&quot;admin&quot;</span>, <span class="hljs-string">&quot;teacher&quot;</span>],<br>          <span class="hljs-attr">activeMenu</span>: <span class="hljs-string">&quot;/questionfeedback/list&quot;</span>,<br>        &#125;,<br>      &#125;,<br>    ],<br>  &#125;,<br>  &#123;<br>    <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/student&quot;</span>,<br>    <span class="hljs-attr">url</span>: <span class="hljs-string">&quot;/student&quot;</span>,<br>    <span class="hljs-attr">component</span>: <span class="hljs-title class_">Layout</span>,<br>    <span class="hljs-attr">redirect</span>: <span class="hljs-string">&quot;/student/list&quot;</span>,<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Student&quot;</span>,<br>    <span class="hljs-attr">meta</span>: &#123; <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;学生问题&quot;</span>, <span class="hljs-attr">roles</span>: [<span class="hljs-string">&quot;admin&quot;</span>, <span class="hljs-string">&quot;teacher&quot;</span>] &#125;,<br>    <span class="hljs-attr">children</span>: [<br>      &#123;<br>        <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;list&quot;</span>,<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;list&quot;</span>,<br>        <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&quot;@/views/student/index&quot;</span>),<br>        <span class="hljs-attr">meta</span>: &#123; <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;学生问题&quot;</span>, <span class="hljs-attr">roles</span>: [<span class="hljs-string">&quot;admin&quot;</span>, <span class="hljs-string">&quot;teacher&quot;</span>] &#125;,<br>      &#125;,<br>      &#123;<br>        <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;detail&quot;</span>,<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;detail&quot;</span>,<br>        <span class="hljs-attr">hidden</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&quot;@/views/student/detail&quot;</span>),<br>        <span class="hljs-attr">meta</span>: &#123;<br>          <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;查看详情&quot;</span>,<br>          <span class="hljs-attr">roles</span>: [<span class="hljs-string">&quot;admin&quot;</span>, <span class="hljs-string">&quot;teacher&quot;</span>],<br>          <span class="hljs-attr">activeMenu</span>: <span class="hljs-string">&quot;/student/list&quot;</span>,<br>        &#125;,<br>      &#125;,<br>    ],<br>  &#125;,<br>  &#123;<br>    <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/teacher&quot;</span>,<br>    <span class="hljs-attr">component</span>: <span class="hljs-title class_">Layout</span>,<br>    <span class="hljs-attr">redirect</span>: <span class="hljs-string">&quot;/teacher/list&quot;</span>,<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Teacher&quot;</span>,<br>    <span class="hljs-attr">meta</span>: &#123; <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;批改老师管理&quot;</span>, <span class="hljs-attr">roles</span>: [<span class="hljs-string">&quot;admin&quot;</span>] &#125;,<br>    <span class="hljs-attr">children</span>: [<br>      &#123;<br>        <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;list&quot;</span>,<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;list&quot;</span>,<br>        <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&quot;@/views/teacher/index&quot;</span>),<br>        <span class="hljs-attr">meta</span>: &#123; <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;批改老师列表&quot;</span>, <span class="hljs-attr">roles</span>: [<span class="hljs-string">&quot;admin&quot;</span>] &#125;,<br>      &#125;,<br>      &#123;<br>        <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;teacherList&quot;</span>,<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;teacherList&quot;</span>,<br>        <span class="hljs-attr">hidden</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&quot;@/views/teacher/list&quot;</span>),<br>        <span class="hljs-attr">meta</span>: &#123;<br>          <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;老师批改列表详情&quot;</span>,<br>          <span class="hljs-attr">roles</span>: [<span class="hljs-string">&quot;admin&quot;</span>],<br>          <span class="hljs-attr">activeMenu</span>: <span class="hljs-string">&quot;/teacher/list&quot;</span>,<br>        &#125;,<br>      &#125;,<br>      &#123;<br>        <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;detail&quot;</span>,<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;detail&quot;</span>,<br>        <span class="hljs-attr">hidden</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&quot;@/views/teacher/detail&quot;</span>),<br>        <span class="hljs-attr">meta</span>: &#123;<br>          <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;查看详情&quot;</span>,<br>          <span class="hljs-attr">roles</span>: [<span class="hljs-string">&quot;admin&quot;</span>],<br>          <span class="hljs-attr">activeMenu</span>: <span class="hljs-string">&quot;/teacher/list&quot;</span>,<br>        &#125;,<br>      &#125;,<br>    ],<br>  &#125;,<br><br>  <span class="hljs-comment">/** when your routing map is too long, you can split it into small modules **/</span><br>  <span class="hljs-comment">// componentsRouter,</span><br><br>  <span class="hljs-comment">// 404 page must be placed at the end !!!</span><br>  &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;*&quot;</span>, <span class="hljs-attr">redirect</span>: <span class="hljs-string">&quot;/404&quot;</span>, <span class="hljs-attr">hidden</span>: <span class="hljs-literal">true</span> &#125;,<br>];<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">createRouter</span> = (<span class="hljs-params"></span>) =&gt;<br>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Router</span>(&#123;<br>    <span class="hljs-comment">// mode: &#x27;history&#x27;, // require service support</span><br>    <span class="hljs-attr">scrollBehavior</span>: <span class="hljs-function">() =&gt;</span> (&#123; <span class="hljs-attr">y</span>: <span class="hljs-number">0</span> &#125;),<br>    <span class="hljs-attr">routes</span>: constantRoutes,<br>  &#125;);<br><br><span class="hljs-keyword">const</span> router = <span class="hljs-title function_">createRouter</span>();<br><br><span class="hljs-comment">// Detail see: https://github.com/vuejs/vue-router/issues/1234#issuecomment-357941465</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">resetRouter</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> newRouter = <span class="hljs-title function_">createRouter</span>();<br>  router.<span class="hljs-property">matcher</span> = newRouter.<span class="hljs-property">matcher</span>; <span class="hljs-comment">// reset router</span><br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> router;<br><br></code></pre></td></tr></table></figure><p>总结：给生成动态路由函数 匹配的路由数组</p><blockquote><p>注意：这种是 后端只返回角色信息，然后生成路由由 前端完成（前端要做的较多）</p><p>​            —–适合多个角色，把 数据库表 只要存储 角色，前端 只需登陆有遍历一下 所有角色</p><p>​           也可以，整个展示在菜单的路由信息全部 由后端返回，这样前端直接 展示即可 </p><p>​           —- 适合只要有一个角色，所有路由信息只存在 一张表中，不会因为多个角色有多个重复路由</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>前端框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue3项目查漏补缺</title>
    <link href="/2024/05/14/Vue3%E9%A1%B9%E7%9B%AE%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/"/>
    <url>/2024/05/14/Vue3%E9%A1%B9%E7%9B%AE%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>之前一直都是在搞Vue2的项目，现在在慢慢接触Vue3的项目，虽然说Vue3新特性我学过，但是实践的却很少，因此有很多新的东西需要总结学习下，有新的东西学习，就一定要输出！</p><h3 id="Nuxt-js框架"><a href="#Nuxt-js框架" class="headerlink" title="Nuxt.js框架"></a>Nuxt.js框架</h3><p>服务端渲染是项目趋势，，因为它将原本在浏览器处理Js的工作放在了服务端去做，有两个最大的好处：</p><ul><li>提高首屏加载速度（消费者的体验很重要）</li><li>提高SEO（面向消费者的App，非常有必要）</li></ul><h3 id="Tailwind-css"><a href="#Tailwind-css" class="headerlink" title="Tailwind.css"></a>Tailwind.css</h3><p>是一个CSS框架，它有以下特点：</p><ul><li>原子类（一个类名只代表较少的样式特性，如<code>text-center</code>、<code>bg-blue-500</code> ）</li><li>可读性高、易于理解（类名都是怎么易于理解怎么命名的）</li><li>可复用性强、冗余代码少（类名易于理解方便了复用效率）</li></ul><h3 id="Pnpm"><a href="#Pnpm" class="headerlink" title="Pnpm"></a>Pnpm</h3><p>相比npm，以下载包速度快著称，也能避免磁盘中包重复下载</p><p><strong>那么相比npx呢？如何选择？</strong></p><p>都能保证 磁盘中的相同包不会重复，只有一份</p><p>不需要执行node命令、对包的版本没有最新版本的要求 ———— pnpm，因为更快</p><p>需要执行node命令、对包的版本没有最新版本、包需要该版本 ———npx，功能多</p><p>综上所述：推荐使用npx，功能多，速度也不慢</p><p><strong>如何设置限制使用pnpm或npx安装依赖？</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// @ts-check</span><br><span class="hljs-keyword">if</span> (!<span class="hljs-regexp">/pnpm/</span>.<span class="hljs-title function_">test</span>(process.<span class="hljs-property">env</span>.<span class="hljs-property">npm_execpath</span> || <span class="hljs-string">&#x27;&#x27;</span>)) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">warn</span>(<span class="hljs-string">`使用pnpm安装依赖`</span>)<br>    process.<span class="hljs-title function_">exit</span>(<span class="hljs-number">1</span>)<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>React知识点</title>
    <link href="/2024/04/11/React%E5%AD%A6%E4%B9%A0/"/>
    <url>/2024/04/11/React%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>由于本人之前已有扎实的Vue框架基础，本篇将会通过与Vue框架的对比来达到快速学习的目的</p><h1 id="npx"><a href="#npx" class="headerlink" title="npx"></a>npx</h1><p>npx和npm相比，除了和npm一样都可以下载Packages之外，还有以下区别：</p><p>安装范围小：用npx安装的包是临时安装的，用完之后会自己删除</p><p>功能多样：还可以 直接执行 下载的package中的可以执行脚本，例如：npx mocha</p><p> 最常用的操作：npx create-reeact-app my-app（创建的同时执行项目）</p><p> 充当nvm的功能，指定nodejs的版本，例如：npx <a href="mailto:&#110;&#111;&#x64;&#x65;&#x40;&#49;&#50;&#x2e;&#x32;&#48;&#x2e;&#48;">&#110;&#111;&#x64;&#x65;&#x40;&#49;&#50;&#x2e;&#x32;&#48;&#x2e;&#48;</a> -v</p><p>总结：开发者希望npx一个工具方便多个用途</p><ul><li>安装依赖</li><li>不让包污染磁盘空间，保证 包在磁盘中只有一份且包是最新的</li><li>如果不要最新的包，还可以用它来改版本</li></ul><h1 id="什么是JSX？如何解析的？"><a href="#什么是JSX？如何解析的？" class="headerlink" title="什么是JSX？如何解析的？"></a>什么是JSX？如何解析的？</h1><p>JSX是Js和XML（HTML）的缩写，指它能 将js和html包裹在一起（html在js内部），这样既有了HTML的声明式模板的能力，也有了js的可编程能力</p><p>它 是 通过解析工具Babel 使jsx文件转化为 浏览器可以识别的文件</p><h1 id="React是如何处理js表达式的？"><a href="#React是如何处理js表达式的？" class="headerlink" title="React是如何处理js表达式的？"></a>React是如何处理js表达式的？</h1><p>我们知道在Vue中是用插值语法是双括号，而React中是一个括号，里面可以放js表达式，比如常量、变量、有返回值的函数，还有对象，写对象和Vue不一样</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// Vue</span><br>&lt;div :style=<span class="hljs-string">&#x27;&#123;color:red&#125;&#x27;</span>&gt;<br>          <span class="hljs-variable language_">this</span> is a react app<br>        &lt;/div&gt;<br><br><span class="hljs-comment">// React</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">return</span> (<br>        <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;&#123;color:red&#125;&#125;</span>&gt;</span></span><br><span class="language-xml">          this is a react app</span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    )<br>&#125;<br><br><span class="hljs-comment">// 总结：Vue中的:换成了React中的&#123;&#125;，然后里面js表达式再加一层&#123;&#125;</span><br></code></pre></td></tr></table></figure><h1 id="如何实现列表渲染？"><a href="#如何实现列表渲染？" class="headerlink" title="如何实现列表渲染？"></a>如何实现列表渲染？</h1><p>使用js中map方法作为一个js表达式嵌入到{}中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> list = [<br>  &#123; <span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;1001&#x27;</span>, <span class="hljs-attr">value</span>: <span class="hljs-string">&#x27;Angular&#x27;</span>&#125;,<br>  &#123; <span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;1002&#x27;</span>, <span class="hljs-attr">value</span>: <span class="hljs-string">&#x27;React&#x27;</span>&#125;,<br>  &#123; <span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;1003&#x27;</span>, <span class="hljs-attr">value</span>: <span class="hljs-string">&#x27;Vue&#x27;</span>&#125;,<br>]<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;&#123;color:</span>&#x27;<span class="hljs-attr">red</span>&#x27;&#125;&#125;&gt;</span></span><br><span class="language-xml">       &#123;</span><br><span class="language-xml">          list.map(item=&gt;<span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;item.id&#125;</span>&gt;</span>&#123;item.value&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>)</span><br><span class="language-xml">       &#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span>;<br><br><span class="hljs-comment">// 总结：React重点是js，html是顺带展示的</span><br></code></pre></td></tr></table></figure><h1 id="如何实现条件渲染？"><a href="#如何实现条件渲染？" class="headerlink" title="如何实现条件渲染？"></a>如何实现条件渲染？</h1><h2 id="简单逻辑"><a href="#简单逻辑" class="headerlink" title="简单逻辑"></a><strong>简单逻辑</strong></h2><p>利用 &amp;&amp; 或 三元运算符</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> isLogin = <span class="hljs-literal">false</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;&#123;</span> <span class="hljs-attr">color:</span> &quot;<span class="hljs-attr">red</span>&quot; &#125;&#125;&gt;</span></span><br><span class="language-xml">      &#123;/* 简单逻辑使用 &amp;&amp; 判断 */&#125;</span><br><span class="language-xml">      &#123;isLogin &amp;&amp; <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span> 首页 <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>&#125;</span><br><span class="language-xml">      &#123;!isLogin &amp;&amp; <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>loading...<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>&#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span>;<br></code></pre></td></tr></table></figure><h3 id="复杂逻辑"><a href="#复杂逻辑" class="headerlink" title="复杂逻辑"></a><strong>复杂逻辑</strong></h3><p>利用 if语句/ switch语句写在函数里返回，然后调用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> articleType = <span class="hljs-number">3</span>; <span class="hljs-comment">// 0 1 3</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getArticleTemplate</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">if</span> (articleType === <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>我是无图文章<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span>;<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (articleType === <span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>我是一图模式<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span>;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>我是三图模式<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;&#123;</span> <span class="hljs-attr">color:</span> &quot;<span class="hljs-attr">red</span>&quot; &#125;&#125;&gt;</span></span><br><span class="language-xml">      &#123;/* 复杂逻辑用写成函数的if解决 */&#125;</span><br><span class="language-xml">      &#123;getArticleTemplate()&#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span>;<br></code></pre></td></tr></table></figure><h1 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h1><p>要点如下：</p><ul><li>事件命名规则：on+事件名 ———- 区分于 Vue</li><li>函数也是js表达式，写在 {} 内 ———- 区分于 Vue</li><li>传参是正常的js规则<ul><li>一定要写成箭头函数：为了和函数定义保持一致，书名只是个结构，（）用于传参，千万不要直接写函数名，那是直接调用（都不会区分什么时候触发事件）</li><li>要获取当前事件对象 ———- 直接写函数名即可（不要写括号，那是调用），因为默认有参数$event</li><li>既要事件对象 又要 自定义参数，则（这里是存事件对象的）=&gt;fun(e,自定义参数)</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br><br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleClick</span> = (<span class="hljs-params">e,params</span>) =&gt; &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;触发了点击事件,参数为: &#x27;</span>,e,<span class="hljs-string">&#x27;形参为: &#x27;</span>,params);<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;&#123;</span> <span class="hljs-attr">color:</span> &quot;<span class="hljs-attr">red</span>&quot; &#125;&#125;&gt;</span></span><br><span class="language-xml">       <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;(e)</span> =&gt;</span> handleClick(e,&#x27;我是参数&#x27;)&#125;&gt;触发<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span>;<br></code></pre></td></tr></table></figure><h1 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h1><ul><li>和函数声明一样</li><li>首字母要大写，这个是 和 函数做区分的 依据</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Button</span>(<span class="hljs-params"></span>) &#123;<br>   <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>我是按钮组件<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>&#125;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">Span</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>   <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>我是span组件<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;&#123;</span> <span class="hljs-attr">color:</span> &quot;<span class="hljs-attr">red</span>&quot; &#125;&#125;&gt;</span></span><br><span class="language-xml">       <span class="hljs-tag">&lt;<span class="hljs-name">Button</span>/&gt;</span></span><br><span class="language-xml">       <span class="hljs-tag">&lt;<span class="hljs-name">Span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Span</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span>;<br></code></pre></td></tr></table></figure><h1 id="useState"><a href="#useState" class="headerlink" title="useState"></a>useState</h1><h3 id="基础使用"><a href="#基础使用" class="headerlink" title="基础使用"></a><strong>基础使用</strong></h3><ul><li>用来设置响应式数据，有点像Vue3的ref、reactive，左边是变量名，右边是值</li><li>xxx,setXXX是响应式数据配套的，后者用于修改</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleClick</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">setCount</span>(count + <span class="hljs-number">1</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;&#123;</span> <span class="hljs-attr">color:</span> &quot;<span class="hljs-attr">red</span>&quot; &#125;&#125;&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;handleClick&#125;</span>&gt;</span>点击+1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&#123;count&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span>;<br></code></pre></td></tr></table></figure><h3 id="修改状态的规则"><a href="#修改状态的规则" class="headerlink" title="修改状态的规则"></a><strong>修改状态的规则</strong></h3><ul><li>得用setXXX包装的方法来修改才能触发响应式更新，手动更新是没用的 — 内部方法实现了响应式</li><li>用新数据替换而不是在原来的基础上修改 —– 就是为了避免不用setXXX来修改数据</li></ul><h3 id="复杂对象State的使用"><a href="#复杂对象State的使用" class="headerlink" title="复杂对象State的使用"></a><strong>复杂对象State的使用</strong></h3><ul><li>用全新的对象替换-&gt;用…和新的属性，结合来使用</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br><br>  <span class="hljs-keyword">const</span> [obj,setObj] = <span class="hljs-title function_">useState</span>(&#123; <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;jacezhou&#x27;</span>&#125;)<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleObj</span>(<span class="hljs-params"></span>) &#123;<br>     <span class="hljs-title function_">setObj</span>(&#123;<br>      ...obj,<br>      <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;JaceZhou&#x27;</span><br>     &#125;)<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;&#123;</span> <span class="hljs-attr">color:</span> &quot;<span class="hljs-attr">red</span>&quot; &#125;&#125;&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;handleObj&#125;</span>&gt;</span>修改对象<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&#123;obj.name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span>;<br><br></code></pre></td></tr></table></figure><h1 id="样式写法"><a href="#样式写法" class="headerlink" title="样式写法"></a>样式写法</h1><ul><li>行内<ul><li>可以单独把样式对象写在外面</li></ul></li><li>类名<ul><li>写在css文件里在js文件里引入</li><li>类名尽量 原子化（类名 见名知意、一个类选择器只有一个样式、方便复用）</li></ul></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css">// index<span class="hljs-selector-class">.css</span><br><span class="hljs-selector-class">.bg-blue</span> &#123;<br>    <span class="hljs-attribute">background-color</span>: blue;<br>&#125;<br><br><span class="hljs-selector-class">.font-bold</span> &#123;<br>    <span class="hljs-attribute">font-weight</span>: bold;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;./styles/index.css&quot;</span>;<br><br><span class="hljs-keyword">const</span> style = &#123;<br>  <span class="hljs-attr">color</span>: <span class="hljs-string">&quot;red&quot;</span>,<br>  <span class="hljs-attr">fontSize</span>: <span class="hljs-string">&quot;36px&quot;</span>,<br>&#125;;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;style&#125;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>我是测试文字1<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;bg-blue font-bold&quot;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>我是测试文字2<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span>;<br></code></pre></td></tr></table></figure><h1 id="demo练习-导航Tab点击出现高亮"><a href="#demo练习-导航Tab点击出现高亮" class="headerlink" title="demo练习-导航Tab点击出现高亮"></a>demo练习-导航Tab点击出现高亮</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 导航 Tab 数组</span><br><span class="hljs-keyword">const</span> tabs = [<br>  &#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;hot&quot;</span>, <span class="hljs-attr">text</span>: <span class="hljs-string">&quot;最热&quot;</span> &#125;,<br>  &#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;time&quot;</span>, <span class="hljs-attr">text</span>: <span class="hljs-string">&quot;最新&quot;</span> &#125;,<br>];<br><span class="hljs-comment">// 把Tab每次点击的type用useState记录下来，因为每次点值会不一样，值不一样会影响模板展示</span><br><span class="hljs-keyword">const</span> [tabType,setTabType] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">&#x27;hot&#x27;</span>)<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">handleTabType</span> = (<span class="hljs-params">type</span>) =&gt; &#123;<br>   <span class="hljs-title function_">setTabType</span>(type)<br>&#125;<br><br> &lt;li className=<span class="hljs-string">&quot;nav-sort&quot;</span>&gt;<br>            &#123;<span class="hljs-comment">/* 高亮类名： active</span><br><span class="hljs-comment">                1.$&#123;&#125;模板字符串，指的是写在字符串里的js表达式，不仅仅是变量，变量只是js表达式的一种</span><br><span class="hljs-comment">            */</span>&#125;<br>            &#123; tabs.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">item</span>=&gt;</span>(<br>               <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span>=&gt;</span> handleTabType(item.type)&#125; className=&#123;`nav-item $&#123; tabType === item.type &amp;&amp; &#x27;active&#x27; &#125;`&#125;&gt;&#123;item.text&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br>            ))&#125;<br>&lt;/li&gt;<br></code></pre></td></tr></table></figure><h3 id="优化版-类名使用classnames插件"><a href="#优化版-类名使用classnames插件" class="headerlink" title="优化版-类名使用classnames插件"></a><strong>优化版-类名使用classnames插件</strong></h3><p>参数一：静态类名，参数二：{动态类名：条件}</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&#123;classnames(</span>&#x27;<span class="hljs-attr">nav-item</span>&#x27;,&#123;<span class="hljs-attr">active:tabType</span> === <span class="hljs-string">item.type&#125;)&#125;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br></code></pre></td></tr></table></figure><h1 id="表单输入框双向绑定"><a href="#表单输入框双向绑定" class="headerlink" title="表单输入框双向绑定"></a>表单输入框双向绑定</h1><ul><li>就是v-model的原理，数据驱动+事件绑定</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> [value,setValue] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">&#x27;&#x27;</span>)<br>&lt;input value=&#123;value&#125; onChange=&#123;<span class="hljs-function">(<span class="hljs-params">e</span>)=&gt;</span><span class="hljs-title function_">setValue</span>(e.<span class="hljs-property">target</span>.<span class="hljs-property">value</span>)&#125; /&gt;<br></code></pre></td></tr></table></figure><h1 id="Ref的使用"><a href="#Ref的使用" class="headerlink" title="Ref的使用"></a>Ref的使用</h1><ul><li>React中没有this对象，只能从外部导入钩子函数，利用它的current属性获取dom对象</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; useRef &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> inputDom = <span class="hljs-title function_">useRef</span>(<span class="hljs-literal">null</span>);<br><br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleClick</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">dir</span>(inputDom.<span class="hljs-property">current</span>);<br>  &#125;;<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;inputDom&#125;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">input</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;handleClick&#125;</span>&gt;</span>点击获取Dom<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span>;<br></code></pre></td></tr></table></figure><h1 id="组件通信"><a href="#组件通信" class="headerlink" title="组件通信"></a>组件通信</h1><h3 id="父子通信（props）"><a href="#父子通信（props）" class="headerlink" title="父子通信（props）"></a><strong>父子通信</strong>（props）</h3><p><strong>内容</strong></p><ul><li>由 :xxx -&gt; xxx={} </li><li>和Vue3的setup一样从形参中去拿props属性</li><li>默认不让子组件修改父组件数据</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Son</span>(<span class="hljs-params">props</span>) &#123;<br>     <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>我是子组件，传递过来数据：&#123;props.name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> name = <span class="hljs-string">&#x27;我是传递的数据&#x27;</span><br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>我是父组件内容<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Son</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&#123;name&#125;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Son</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span>;<br></code></pre></td></tr></table></figure><p><strong>结构</strong></p><ul><li>类似Vue2中的插槽,，只是React把它作为children放进了props对象内</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Son</span>(<span class="hljs-params">props</span>) &#123;<br>     <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>我是子组件，传递过来数据：&#123;props.children&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> name = <span class="hljs-string">&#x27;我是传递的数据&#x27;</span><br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>我是父组件内容<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Son</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>我是子组件内部的额外结构<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">Son</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span>;<br></code></pre></td></tr></table></figure><h3 id="子传父"><a href="#子传父" class="headerlink" title="子传父"></a>子传父</h3><ul><li><p>对比Vue，没有了 :on、:emit这种关键字</p></li><li><p> 传递的回调也是放在props中的</p></li></ul>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Son</span>(<span class="hljs-params">&#123;onGetSonMessage&#125;</span>) &#123;<br>   <span class="hljs-keyword">const</span> msg = <span class="hljs-string">&#x27;我是自组件的数据&#x27;</span><br>   <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span>=&gt;</span>onGetSonMessage(msg)&#125;&gt;点击子组件发送数据<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [message, <span class="hljs-title class_">SetMessage</span>] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">&quot;我是传递的数据&quot;</span>);<br><br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">onGetSonMessage</span> = (<span class="hljs-params">newMsg</span>) =&gt; &#123;<br>    <span class="hljs-title class_">SetMessage</span>(newMsg);<br>  &#125;;<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>我是父组件内容：&#123;message&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Son</span> <span class="hljs-attr">onGetSonMessage</span>=<span class="hljs-string">&#123;onGetSonMessage&#125;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Son</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span>;<br></code></pre></td></tr></table></figure><h3 id="兄弟组件传值"><a href="#兄弟组件传值" class="headerlink" title="兄弟组件传值"></a>兄弟组件传值</h3><p><strong>状态提升</strong>：在共同的 父组件 中设置响应式状态，接收A的数据-&gt;传递给B</p><ul><li>状态：A传递的数据修改，B也能相应</li><li>提升：提升到父组件中</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">SonA</span>(<span class="hljs-params">&#123;onGetSonAMessage&#125;</span>) &#123;<br>   <span class="hljs-keyword">const</span> msg = <span class="hljs-string">&#x27;我是自组件A的数据&#x27;</span><br>   <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span>=&gt;</span>onGetSonAMessage(msg)&#125;&gt;点击子组件发送数据<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">SonB</span>(<span class="hljs-params">&#123;messageFromA&#125;</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>等待来自A的数据：&#123;messageFromA&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [messageFromA, <span class="hljs-title class_">SetMessageFromA</span>] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">&quot;&quot;</span>);<br><br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">onGetSonAMessage</span> = (<span class="hljs-params">newMsg</span>) =&gt; &#123;<br>    <span class="hljs-title class_">SetMessageFromA</span>(newMsg);<br>  &#125;;<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">SonA</span> <span class="hljs-attr">onGetSonAMessage</span>=<span class="hljs-string">&#123;onGetSonAMessage&#125;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">SonA</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">SonB</span> <span class="hljs-attr">messageFromA</span>=<span class="hljs-string">&#123;messageFromA&#125;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">SonB</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span>;<br></code></pre></td></tr></table></figure><h3 id="跨层机制（Context）"><a href="#跨层机制（Context）" class="headerlink" title="跨层机制（Context）"></a>跨层机制（Context）</h3><ul><li>用createContext创造一个对象xxx，首字母要大写</li><li>顶层组件使用xxx.Provide 将底层组件包裹</li><li>在底层组件中使用useContext获取</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs js">### <span class="hljs-number">1.</span> 创建 <span class="hljs-title class_">Context</span> 文件（例：<span class="hljs-title class_">MyContext</span>.<span class="hljs-property">js</span>）：<br><span class="hljs-keyword">import</span> &#123; createContext &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">MyContext</span> = <span class="hljs-title function_">createContext</span>();<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">MyContext</span>;<br><br><br>### <span class="hljs-number">2.</span> 在 <span class="hljs-title class_">Parent</span> 组件中设置 <span class="hljs-title class_">Context</span> <span class="hljs-title class_">Provider</span>：<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">MyContext</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./MyContext&#x27;</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">Parent</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-comment">// 定义共享的 state</span><br>  <span class="hljs-keyword">const</span> sharedState = &#123;<br>    <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;Hello from Parent&#x27;</span>,<br>    <span class="hljs-attr">updateMessage</span>: <span class="hljs-function"><span class="hljs-params">newMessage</span> =&gt;</span> <span class="hljs-title function_">setSharedState</span>(<span class="hljs-function"><span class="hljs-params">prevState</span> =&gt;</span> (&#123; ...prevState, <span class="hljs-attr">message</span>: newMessage &#125;))<br>  &#125;;<br><br>  <span class="hljs-keyword">const</span> [sharedState, setSharedState] = <span class="hljs-title function_">useState</span>(&#123;<br>    <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br>    <span class="hljs-attr">updateMessage</span>: <span class="hljs-function">() =&gt;</span> &#123;&#125;<br>  &#125;);<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">MyContext.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;sharedState&#125;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Child</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">MyContext.Provider</span>&gt;</span></span><br>  );<br>&#125;;<br><br>### <span class="hljs-number">3.</span> 在 <span class="hljs-title class_">Child</span> 组件中使用 <span class="hljs-title class_">Context</span> <span class="hljs-title class_">Consumer</span>：<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useContext &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">MyContext</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./MyContext&#x27;</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">Child</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> context = <span class="hljs-title function_">useContext</span>(<span class="hljs-title class_">MyContext</span>);<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Message from Parent: &#123;context.message&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> context.updateMessage(&#x27;Updated message&#x27;)&#125;&gt;Update Message<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect"></a>useEffect</h1><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>简单来说，就是Vue中 mounted+updated+watch 的结合，Vue3中的watchEffect借鉴了useEffect。</p><p>参数一：回调函数，参数二：依赖数组（数组内部传依赖项）</p><ul><li>当没有传第二个参数 —- &gt; mounted+updated</li><li>传入第二个参数—-&gt; mounted+watch </li><li>第二个参数决定了 渲染完成后续 执行回调的时机</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; useEffect, useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br><br>  <span class="hljs-keyword">const</span> [msg, setMsg] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);<br><br>  <span class="hljs-comment">// 1.无依赖项时，回调在 渲染完成 + 组件DOM更新时 执行 ----- mounted+updated</span><br>  <span class="hljs-comment">// useEffect(() =&gt; &#123;</span><br>  <span class="hljs-comment">//   console.log(&quot;副作用函数执行了&quot;);</span><br>  <span class="hljs-comment">// &#125;);</span><br><br>  <span class="hljs-comment">// 2.依赖项为空数组时，仅在渲染完成时执行 ----- mounted</span><br>  <span class="hljs-comment">// useEffect(() =&gt; &#123;</span><br>  <span class="hljs-comment">//   console.log(&quot;副作用函数执行了&quot;);</span><br>  <span class="hljs-comment">// &#125;,[]);</span><br><br>  <span class="hljs-comment">// 3.依赖项 明确指明 变量，在渲染完成时执行 +变量变化时执行 ------ mounted + watch</span><br>   <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;副作用函数执行了&quot;</span>);<br>  &#125;,[msg]);<br><br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleClick</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-title function_">setMsg</span>(msg + <span class="hljs-number">1</span>);<br>  &#125;;<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;handleClick&#125;</span>&gt;</span>+&#123;msg&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span>;<br></code></pre></td></tr></table></figure><h3 id="副作用清除"><a href="#副作用清除" class="headerlink" title="副作用清除"></a>副作用清除</h3><ul><li>在 ueseEffect 内部 再返回一个新的函数，在这里面写清楚副作用逻辑</li><li>原因：ueseEffect 内部返回的函数 通常是在组件卸载时 执行，因此可以在这里写清楚副作用逻辑</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; useEffect, useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Son</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>    <br>    <span class="hljs-keyword">const</span> timer = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>       <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;执行了副作用&#x27;</span>);<br>    &#125;,<span class="hljs-number">1000</span>)<br><br>    <span class="hljs-comment">// 在useEffect内部返回的函数 用来清除副作用，一般是当前组件卸载时执行</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-function">()=&gt;</span>&#123;<br>       <span class="hljs-built_in">clearInterval</span>(timer)<br>    &#125; <br><br>  &#125;,[])<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br><br>  <span class="hljs-keyword">const</span> [show,setShow] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">true</span>)<br><br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleClick</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-title function_">setShow</span>(<span class="hljs-literal">false</span>)<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      &#123; show &amp;&amp; <span class="hljs-tag">&lt;<span class="hljs-name">Son</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Son</span>&gt;</span>&#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;handleClick&#125;</span>&gt;</span>卸载<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span>;<br></code></pre></td></tr></table></figure><h1 id="自定义hook"><a href="#自定义hook" class="headerlink" title="自定义hook"></a>自定义hook</h1><ul><li>就是 自定义逻辑 抽取和封装，熟悉一下 hook  的使用方式即可</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">useToggle</span>(<span class="hljs-params">params</span>) &#123;<br>   <span class="hljs-keyword">const</span> [show,setShow] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">false</span>)<br><br>   <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleClick</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-title function_">setShow</span>(!show)<br>   &#125;<br><br>   <span class="hljs-keyword">return</span> &#123;<br>      show,<br>      handleClick<br>   &#125;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <br>  <span class="hljs-keyword">const</span> &#123; show,handleClick &#125; = <span class="hljs-title function_">useToggle</span>()<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      &#123; show &amp;&amp; <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>我是切换的内容<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>&#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;handleClick&#125;</span>&gt;</span>切换<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span>;<br></code></pre></td></tr></table></figure><h1 id="Reacthook的使用规则"><a href="#Reacthook的使用规则" class="headerlink" title="Reacthook的使用规则"></a>Reacthook的使用规则</h1><ul><li>只能写在组件内或自定义hooks内 <ul><li> 自定义hooks要写成功能难免会调用现成的hook </li><li> 后续都是 组件化 开发，基本不会写在组件外</li></ul></li><li>只能写在组件或自定义hooks 的顶层，不能写在if、for等逻辑的内部<ul><li>hooks说白了就是一个功能的 封装，想想js中功能模块化，在使用时也是在最上面 Import 的</li></ul></li></ul><h1 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a>Redux</h1><h2 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h2><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a><strong>流程</strong></h3><p>使用流程不复杂，但是写法复杂，下面流程总结下：</p><p><strong>1.准备好子模块的store里的reducer</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; createSlice &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@reduxjs/toolkit&quot;</span>;<br><br><span class="hljs-comment">// React在Store这块对比Vue似乎只保留了存数据的State和更改数据的reducers，对应Vue的mutations</span><br><span class="hljs-keyword">const</span> counterStore = <span class="hljs-title function_">createSlice</span>(&#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;counter&quot;</span>,<br>  <span class="hljs-comment">// 初始化State</span><br>  <span class="hljs-attr">initialState</span>: &#123;<br>    <span class="hljs-attr">count</span>: <span class="hljs-number">0</span>,<br>  &#125;,<br>  <span class="hljs-attr">reducers</span>: &#123;<br>    <span class="hljs-comment">// 类似Vue中的Mutations，也是自带state给你修改数据的</span><br>    <span class="hljs-title function_">increment</span>(<span class="hljs-params">state</span>) &#123;<br>        state.<span class="hljs-property">count</span>++;<br>    &#125;,<br>    <span class="hljs-title function_">decrement</span>(<span class="hljs-params">state</span>) &#123;<br>        state.<span class="hljs-property">count</span>--;<br>    &#125;,<br>    <span class="hljs-comment">// 如果需要函数传参的话，需要从action.payload中去获取</span><br>    <span class="hljs-title function_">addToNum</span>(<span class="hljs-params">state,action</span>)&#123;<br>        state.<span class="hljs-property">count</span> += action.<span class="hljs-property">payload</span><br>    &#125;,<br>  &#125;,<br>&#125;);<br><br><span class="hljs-comment">// 向外暴露有用的配置项:reducer（用于引入总Store）、actions（给组件dispatch使用）</span><br><span class="hljs-keyword">const</span> &#123; increment,decrement,addToNum &#125; = counterStore.<span class="hljs-property">actions</span><br><br><span class="hljs-keyword">export</span> &#123;<br>    increment,<br>    decrement.<br>    addToNum<br>&#125;<br><br><span class="hljs-keyword">const</span> counterReducer = counterStore.<span class="hljs-property">reducer</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> counterReducer<br></code></pre></td></tr></table></figure><p><strong>2.将子模块引入总Store</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; configureStore &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@reduxjs/toolkit&quot;</span>;<br><span class="hljs-keyword">import</span> counterReducer <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./modules/counterStore&quot;</span>;<br><br><span class="hljs-comment">// 这里相当于Vuex中的modules，虽然模块名字可以随意命名，但是本质要的还是reducer，于是命名是reducer</span><br><span class="hljs-keyword">const</span> store = <span class="hljs-title function_">configureStore</span>(&#123;<br>    <span class="hljs-comment">// 前面的命名表示 模块的名字，虽然本质上拿到的是reducer，但向外暴露的是模块名字</span><br>    <span class="hljs-attr">reducer</span>:&#123;<br>        <span class="hljs-attr">counter</span>: counterReducer<br>    &#125;<br>&#125;)<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> store<br></code></pre></td></tr></table></figure><p><strong>3.总store安装到App上</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">ReactDOM</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react-dom/client&quot;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./App&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Provider</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react-redux&quot;</span>;<br><span class="hljs-keyword">import</span> store <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./store&quot;</span>;<br><br><span class="hljs-keyword">const</span> root = <span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">createRoot</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;root&quot;</span>));<br>root.<span class="hljs-title function_">render</span>(<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Provider</span> <span class="hljs-attr">store</span>=<span class="hljs-string">&#123;store&#125;</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">Provider</span>&gt;</span></span><br>);<br></code></pre></td></tr></table></figure><p><strong>4.使用useDispath发送具体请求</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; useSelector, useDispatch &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react-redux&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; increment, decrement,addToNum &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./store/modules/counterStore&quot;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// useSelector用来获取state中的数据，选择哪个state的数据来使用，</span><br>  <span class="hljs-keyword">const</span> &#123; count &#125; = <span class="hljs-title function_">useSelector</span>(<span class="hljs-function">(<span class="hljs-params">state</span>) =&gt;</span> state.<span class="hljs-property">counter</span>);<br>  <span class="hljs-comment">// useDispatch用来提出触发reducer中的函数</span><br>  <span class="hljs-keyword">const</span> dispatch = <span class="hljs-title function_">useDispatch</span>()<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> dispatch(increment())&#125;&gt;+<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&#123;count&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> dispatch(decrement())&#125;&gt;-<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> dispatch(addToNum(10))&#125;&gt;+10<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span>;<br></code></pre></td></tr></table></figure><h3 id="Redux的命名由来？"><a href="#Redux的命名由来？" class="headerlink" title="Redux的命名由来？"></a><strong>Redux的命名由来？</strong></h3><p>re-&gt;react</p><p>dux-&gt;受到Flux（一种架构）的启发，它就是这样管理数据的</p><h3 id="reducer的命名由来？"><a href="#reducer的命名由来？" class="headerlink" title="reducer的命名由来？"></a><strong>reducer的命名由来？</strong></h3><p>er-&gt;是Redux的一个子项，因此引入总Store的关键成分就是reducer</p><h3 id="必备的-reduxjs-toolkit和react-redux包的作用是什么？"><a href="#必备的-reduxjs-toolkit和react-redux包的作用是什么？" class="headerlink" title="必备的@reduxjs/toolkit和react-redux包的作用是什么？"></a>必备的@reduxjs/toolkit和react-redux包的作用是什么？</h3><p>@reduxjs/toolkit：redux工具包，里面有很多工具函数，可以让redux使用起来方便、有条理</p><p>react-redux：用于连接 react项目和redux，因为redux原本是可以单独使用的</p><h2 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h2><p>直接写不同点，相同的就不写了</p><h3 id="流程-1"><a href="#流程-1" class="headerlink" title="流程"></a>流程</h3><p><strong>1.在子store中准备给外界调用的包含操作的函数，内部需要再返回个函数（只有函数才能处理异步操作，普通对象不行）</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; createSlice &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@reduxjs/toolkit&quot;</span>;<br><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;axios&quot;</span>;<br><br><span class="hljs-keyword">const</span> channelStore = <span class="hljs-title function_">createSlice</span>(&#123;<br>    <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;channel&#x27;</span>,<br>    <span class="hljs-attr">initialState</span>:&#123;<br>        <span class="hljs-attr">channelList</span>:[]<br>    &#125;,<br>    <span class="hljs-attr">reducers</span>: &#123;<br>        <span class="hljs-title function_">setChannels</span>(<span class="hljs-params">state,action</span>)&#123;<br>           state.<span class="hljs-property">channelList</span> = action.<span class="hljs-property">payload</span><br>        &#125;<br>    &#125;<br>&#125;)<br><br><span class="hljs-keyword">const</span> &#123; setChannels &#125; = channelStore.<span class="hljs-property">actions</span><br><span class="hljs-keyword">const</span> url = <span class="hljs-string">&#x27;http://geek.itheima.net/v1_0/channels&#x27;</span><br><span class="hljs-comment">// 暴露给外界的函数，真正的异步操作由 redux 内部来操作，外界不需要关心如何处理异步操作</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">fetchChannelList</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">async</span> (dispatch)=&gt;&#123;<br>       <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> axios.<span class="hljs-title function_">get</span>(url)<br>       <span class="hljs-title function_">dispatch</span>(<span class="hljs-title function_">setChannels</span>(res.<span class="hljs-property">data</span>.<span class="hljs-property">data</span>.<span class="hljs-property">channels</span>))<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">export</span> &#123; fetchChannelList &#125;<br><br><span class="hljs-keyword">const</span> channnelReducer = channelStore.<span class="hljs-property">reducer</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> channnelReducer<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; configureStore &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@reduxjs/toolkit&quot;</span>;<br><span class="hljs-keyword">import</span> counterReducer <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./modules/counterStore&quot;</span>;<br><span class="hljs-keyword">import</span> channnelReducer <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./modules/channelStore&quot;</span>;<br><br><span class="hljs-comment">// 这里相当于Vuex中的modules，虽然模块名字可以随意命名，但是本质要的还是reducer，于是命名是reducer</span><br><span class="hljs-keyword">const</span> store = <span class="hljs-title function_">configureStore</span>(&#123;<br>  <span class="hljs-attr">reducer</span>: &#123;<br>    <span class="hljs-attr">counter</span>: counterReducer,<br>    <span class="hljs-attr">channel</span>: channnelReducer,<br>  &#125;,<br>&#125;);<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> store;<br></code></pre></td></tr></table></figure><p><strong>2.派发异步函数</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; useEffect &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; useSelector, useDispatch &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react-redux&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; fetchChannelList &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./store/modules/channelStore&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; increment, decrement, addToNum &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./store/modules/counterStore&quot;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// useSelector用来获取state中的数据，选择哪个state的数据来使用</span><br>  <span class="hljs-keyword">const</span> &#123; count &#125; = <span class="hljs-title function_">useSelector</span>(<span class="hljs-function">(<span class="hljs-params">state</span>) =&gt;</span> state.<span class="hljs-property">counter</span>);<br>  <span class="hljs-keyword">const</span> &#123; channelList &#125; = <span class="hljs-title function_">useSelector</span>(<span class="hljs-function">(<span class="hljs-params">state</span>) =&gt;</span> state.<span class="hljs-property">channel</span>);<br>  <span class="hljs-comment">// useDispatch用来提出触发reducer中的函数</span><br>  <span class="hljs-keyword">const</span> dispatch = <span class="hljs-title function_">useDispatch</span>();<br><br>  <span class="hljs-comment">// 正好结合useEffect请求异步数据</span><br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-title function_">dispatch</span>(<span class="hljs-title function_">fetchChannelList</span>());<br>  &#125;);<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      &#123;/* 注意actions的increment、decrement是一个函数，执行的返回值作为参数来dispatch */&#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> dispatch(increment())&#125;&gt;+<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&#123;count&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> dispatch(decrement())&#125;&gt;-<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> dispatch(addToNum(10))&#125;&gt;+10<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      &#123;/* 展示异步请求的数据 */&#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><br><span class="language-xml">        &#123;channelList.map(item =&gt; </span><br><span class="language-xml">           <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;item.id&#125;</span>&gt;</span> &#123;item.name&#125; <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="language-xml">        )&#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span>;<br></code></pre></td></tr></table></figure><h3 id="从actions中获取的函数和reducers中的函数名字是一样的，有什么联系？"><a href="#从actions中获取的函数和reducers中的函数名字是一样的，有什么联系？" class="headerlink" title="从actions中获取的函数和reducers中的函数名字是一样的，有什么联系？"></a>从actions中获取的函数和reducers中的函数名字是一样的，有什么联系？</h3><p>actions中获取的函数和reducers中的函数会通过createSlice自动关联，是一一对应的，但是它俩并不相等，两者联系如下：</p><ul><li>同步操作</li></ul><p>​       dispatch需要派发一个action对象，而从actions中获取的函数（action creator函数）的会返回这样的action对象（包含type、payload属性），它根据type值，找到对应reducers中的函数，并执行对应的reducers函数逻辑</p><ul><li><p>异步操作</p><p>另外函数执行的内容有需要交给 中间件 来执行，而中间件又只收函数的形式，因为中间件只负责执行</p><p>————————————————-解释了为什么内部必须得再返回一个函数</p></li></ul><h3 id="为什么不直接把异步操作放到reducers中的函数执行，要在外面另外声明个函数？"><a href="#为什么不直接把异步操作放到reducers中的函数执行，要在外面另外声明个函数？" class="headerlink" title="为什么不直接把异步操作放到reducers中的函数执行，要在外面另外声明个函数？"></a>为什么不直接把异步操作放到reducers中的函数执行，要在外面另外声明个函数？</h3><p>因为redux在设计时，就是想让reducers中的函数职责单一：只负责对state中的数据进行处理，那么其他的操作只能另外放在一个函数中执行了，而这另外函数执行的内容有需要交给 中间件 来执行，而中间件又只收函数的形式，因为中间件只负责执行</p>]]></content>
    
    
    <categories>
      
      <category>前端框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ElementuUI</title>
    <link href="/2024/04/07/ElementuUI/"/>
    <url>/2024/04/07/ElementuUI/</url>
    
    <content type="html"><![CDATA[<h1 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h1><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a><strong>验证</strong></h3><ul><li><p>验证项 只能作用于 :model 中的数据</p></li><li><p>验证项的 <strong>命名以及类型</strong> 需要 === 表单v-model绑定的变量（类型默认string，整数的话 表单项需要用v-model.number来和验证项的 type=’integer’进行比较）</p></li><li><p>触发时机：change事件要注意 一定得是 v-model值发生变化才会触发</p><p>所以 change事件 一般用于 select选项框（随便选一个值都会变），而blur事件是用于input的</p><p>change事件如果设置了不为空的验证，需要在最后按钮提交的时候，进行手动验证，才会有反应！</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">this</span>.<span class="hljs-property">$refs</span>[formName].<span class="hljs-title function_">validate</span>(<span class="hljs-function">(<span class="hljs-params">valid</span>) =&gt;</span> &#123;<br>             <span class="hljs-keyword">if</span> (valid) &#123;<br>                 <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;submit!&#x27;</span>);<br>             &#125; <span class="hljs-keyword">else</span> &#123;<br>                 <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;error submit!!&#x27;</span>);<br>                 <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>             &#125;&#125;);<br></code></pre></td></tr></table></figure></li><li><p>有全部验证和单独验证两种</p><ul><li><p>如果把rules写在了e-form上，那么就需要针对每个都要写 验证规则</p></li><li><p>单独验证就写在 el-form-item上，例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">el-form-item</span> <span class="hljs-attr">prop</span>=<span class="hljs-string">&quot;和v-model一样&quot;</span> <span class="hljs-attr">:rules</span>=<span class="hljs-string">&quot;[</span></span><br><span class="hljs-string"><span class="hljs-tag">                                        &#123;...&#125;,</span></span><br><span class="hljs-string"><span class="hljs-tag">                                        &#123;...&#125;</span></span><br><span class="hljs-string"><span class="hljs-tag">                                        ]&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">el-form-item</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="布局"><a href="#布局" class="headerlink" title="布局"></a><strong>布局</strong></h3><p>label-width和label-position这两个属性很重要。</p><p>label-width：标签的长度，一般设置100px</p><p>label-position：标签有长度，但是文字不一定有那么长，这时可以设置文字在标签容器内的位置，left|right|top</p><h3 id="单选框"><a href="#单选框" class="headerlink" title="单选框"></a><strong>单选框</strong></h3><ul><li>v-model绑定的值 需要是 数字类型，这样初始化才能自动选中 对应选项</li></ul><h3 id="时间选择器"><a href="#时间选择器" class="headerlink" title="时间选择器"></a><strong>时间选择器</strong></h3><ul><li><p>如何只显示 年月日，并且v-model绑定的数据也是 年月日？</p><p>直接加format=”yyyy-MM-dd” value-format=”yyyy-MM-dd”</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;el-date-picker v-model=&quot;form.specificCycle&quot; type=&quot;date&quot; placeholder=&quot;选择日期&quot; <br>                format=&quot;yyyy-MM-dd&quot; value-format=&quot;yyyy-MM-dd&quot;&gt;<br>&lt;/el-date-picker&gt;<br></code></pre></td></tr></table></figure></li></ul><h3 id="发送验证码按钮"><a href="#发送验证码按钮" class="headerlink" title="发送验证码按钮"></a><strong>发送验证码按钮</strong></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">el-button</span> <span class="hljs-attr">:disabled</span>=<span class="hljs-string">&quot;countdown &gt; 0&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;startCountdown&quot;</span>&gt;</span><br> &#123;&#123; countdown &gt; 0 ? countdown + &#x27;秒&#x27; : &#x27;发送验证码&#x27; &#125;&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">el-button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script&gt;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br><span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;<br> <span class="hljs-keyword">return</span> &#123;<br>   <span class="hljs-attr">countdown</span>: <span class="hljs-number">0</span>,<br>   <span class="hljs-attr">timer</span>: <span class="hljs-literal">null</span><br> &#125;;<br>&#125;,<br><span class="hljs-attr">methods</span>: &#123;<br> <span class="hljs-title function_">startCountdown</span>(<span class="hljs-params"></span>) &#123;<br>   <span class="hljs-variable language_">this</span>.<span class="hljs-property">countdown</span> = <span class="hljs-number">59</span>;<br>   <span class="hljs-variable language_">this</span>.<span class="hljs-property">timer</span> = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>     <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">countdown</span> &gt; <span class="hljs-number">0</span>) &#123;<br>       <span class="hljs-variable language_">this</span>.<span class="hljs-property">countdown</span>--;<br>     &#125; <span class="hljs-keyword">else</span> &#123;<br>       <span class="hljs-built_in">clearInterval</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">timer</span>);<br>       <span class="hljs-variable language_">this</span>.<span class="hljs-property">timer</span> = <span class="hljs-literal">null</span>;<br>     &#125;<br>   &#125;, <span class="hljs-number">1000</span>);<br> &#125;<br>&#125;,<br><span class="hljs-title function_">beforeDestroy</span>(<span class="hljs-params"></span>) &#123;<br> <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">timer</span>) &#123;<br>   <span class="hljs-built_in">clearInterval</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">timer</span>);<br>   <span class="hljs-variable language_">this</span>.<span class="hljs-property">timer</span> = <span class="hljs-literal">null</span>;<br> &#125;<br>&#125;,<br><span class="hljs-attr">watch</span>: &#123;<br>    <span class="hljs-attr">countdown</span>: &#123;<br>        <span class="hljs-title function_">handler</span>(<span class="hljs-params">newVal</span>) &#123;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">countdown</span> = newVal<br>        &#125;<br>    &#125;<br>&#125;<br>&#125;;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h3 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h3><ul><li><p>调整内置样式：需要加     ::v-deep</p><p>将el-form-item的label加粗（只有写一个::v-deep即可，更深层的内部样式不需要再加了）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">  ::v-deep .el-form-item__label &#123;<br>          <span class="hljs-attribute">font-weight</span>:bold<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="label内容换行"><a href="#label内容换行" class="headerlink" title="label内容换行"></a><strong>label内容换行</strong></h3><ul><li>加上 ：或 v-bind，用于允许识别特殊字符</li><li>双引号里面需要 加 单引号 ‘’，否则 右边就是个字符串，无法识别，再加一层单引号 才可以识别</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">el-form-item</span> <span class="hljs-attr">:label</span>=<span class="hljs-string">&quot;&#x27;内容/n(换行)&#x27;&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">el-form-item</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"> <span class="hljs-comment">/* 过于长的label分两行展示样式，尽量文字紧凑 */</span><br><br><span class="hljs-selector-class">.fold_label</span> ::v-deep .el-form-item__label &#123;<br>    <span class="hljs-attribute">white-space</span>: pre-line;<br>    <span class="hljs-attribute">margin-top</span>: -<span class="hljs-number">4px</span>;<br>    <span class="hljs-attribute">line-height</span>: <span class="hljs-number">20px</span>;<br>    <span class="hljs-attribute">text-justify</span>: distribute-all-lines;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="输入框长度限制"><a href="#输入框长度限制" class="headerlink" title="输入框长度限制"></a>输入框长度限制</h3><p>加上 show-word-limit、type=”text/textarea”、    maxlength=”10” 即可</p><ul><li><p>但是 在 disabled 状态下，字符限制 会消失，解决方案：</p><p>去掉show-word-limit，直接 用插槽的方式自己做（记住插槽使用方式）</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">el-input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;form.productTags&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;请输入&quot;</span></span><br><span class="hljs-tag">                            <span class="hljs-attr">:disabled</span>=<span class="hljs-string">&quot;operator == &#x27;edit&#x27;&quot;</span> <span class="hljs-attr">maxlength</span>=<span class="hljs-string">&quot;6&quot;</span>&gt;</span><br>                            <span class="hljs-tag">&lt;<span class="hljs-name">template</span> #<span class="hljs-attr">suffix</span>&gt;</span><br>                                <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;character-count&quot;</span>&gt;</span>&#123;&#123; form.productTags.length &#125;&#125;/6<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>                            <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br>                        <span class="hljs-tag">&lt;/<span class="hljs-name">el-input</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="输入框回车事件"><a href="#输入框回车事件" class="headerlink" title="输入框回车事件"></a>输入框回车事件</h3><p>因为ElementUI的input本身没有按键回车事件，因此 这时候需要借助js的原生事件，即</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">el-input</span> @<span class="hljs-attr">keyup.enter.native</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">el-input</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="校验密码格式"><a href="#校验密码格式" class="headerlink" title="校验密码格式"></a>校验密码格式</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js"> <span class="hljs-attr">rulesForPasswordEdit</span>: &#123;<br>  <span class="hljs-attr">new</span>: [<br>    &#123; <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;请输入新密码&#x27;</span>, <span class="hljs-attr">trigger</span>: <span class="hljs-string">&#x27;blur&#x27;</span> &#125;,<br>    &#123; <span class="hljs-attr">validator</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">validatePassword</span>, <span class="hljs-attr">trigger</span>: <span class="hljs-string">&#x27;blur&#x27;</span> &#125;<br>  ],<br>  <span class="hljs-attr">newRepeat</span>: [<br>    &#123; <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;请再次1输入新密码&#x27;</span>, <span class="hljs-attr">trigger</span>: <span class="hljs-string">&#x27;blur&#x27;</span> &#125;,<br>    &#123; <span class="hljs-attr">validator</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">validateConfirmPassword</span>, <span class="hljs-attr">trigger</span>: <span class="hljs-string">&#x27;blur&#x27;</span> &#125;<br>  ]<br>&#125;<br> <span class="hljs-title function_">validatePassword</span>(<span class="hljs-params">rule, value, callback</span>) &#123;<br>  <span class="hljs-comment">// 密码必须包含数字和大小写字母任意两种组合，长度6-16位</span><br>  <span class="hljs-keyword">const</span> regExp = <span class="hljs-regexp">/^(?=.*[0-9])(?=.*[a-z])(?=.*[A-Z])[0-9a-zA-Z]&#123;6,16&#125;$/</span>;<br>  <span class="hljs-keyword">if</span> (!regExp.<span class="hljs-title function_">test</span>(value)) &#123;<br>    <span class="hljs-title function_">callback</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;密码格式不正确&#x27;</span>));<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-title function_">callback</span>();<br>  &#125;<br>&#125;,<br><span class="hljs-title function_">validateConfirmPassword</span>(<span class="hljs-params">rule, value, callback</span>) &#123;<br>  <span class="hljs-keyword">if</span> (value !== <span class="hljs-variable language_">this</span>.<span class="hljs-property">formData</span>.<span class="hljs-property">password</span>) &#123;<br>    <span class="hljs-title function_">callback</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;两次密码输入不一致&#x27;</span>));<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-title function_">callback</span>();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h1><h3 id="属性列宽度"><a href="#属性列宽度" class="headerlink" title="属性列宽度"></a><strong>属性列宽度</strong></h3><ul><li><p>直接在el-table-column上的**width=”纯数字”**加即可，改一个其他会列会自适应缩小</p></li><li><p>不要在el-table-column上来加布局，就算是行内样式也不一定能生效，因为它内置可能有优先级更高的布局，解决办法：里面重新设置一个div来设置布局</p></li><li><p><template slot-scope="scope"></template></p><p>一定要紧挨着el-table-column否则scope不生效</p></li><li><p>el-table-column实现可拖拽式操作</p><ol><li><p>import Sortable from “sortablejs”;—-需要用的组件内</p></li><li><p>在需要拖拽的位置添加点击方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * <span class="hljs-doctag">@description</span>: 拖拽操作</span><br><span class="hljs-comment">  * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">*</span>&#125;</span><br><span class="hljs-comment">  * key-&gt;el-table的class名字</span><br><span class="hljs-comment">  * tableDataForSort-&gt;要拖拽的list</span><br><span class="hljs-comment">  */</span><br> <span class="hljs-title function_">handleRow</span>(<span class="hljs-params">key</span>) &#123;<br>     <span class="hljs-keyword">let</span> tbody = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<br>         <span class="hljs-string">`.<span class="hljs-subst">$&#123;key&#125;</span> .el-table__body-wrapper tbody`</span><br>     );<br>     <span class="hljs-keyword">if</span> (!tbody) <span class="hljs-keyword">return</span>;<br>     <span class="hljs-keyword">let</span> list = [...<span class="hljs-variable language_">this</span>.<span class="hljs-property">tableDataForSort</span>];<br>     <span class="hljs-keyword">let</span> that = <span class="hljs-variable language_">this</span>;<br>     <span class="hljs-keyword">let</span> options = &#123;<br>         <span class="hljs-attr">animation</span>: <span class="hljs-number">500</span>, <span class="hljs-comment">//动画时长</span><br>         <span class="hljs-title function_">onEnd</span>(<span class="hljs-params">&#123; newIndex, oldIndex &#125;</span>) &#123;<br>             <span class="hljs-keyword">if</span> (newIndex !== oldIndex) &#123;<br>                 <span class="hljs-keyword">const</span> currRow = list.<span class="hljs-title function_">splice</span>(oldIndex, <span class="hljs-number">1</span>)[<span class="hljs-number">0</span>];<br>                 list.<span class="hljs-title function_">splice</span>(newIndex, <span class="hljs-number">0</span>, currRow);<br>                 that.<span class="hljs-property">tableDataForSort</span> = [];<br>                 that.$nextTick(<span class="hljs-function">() =&gt;</span> &#123;<br>                     that.<span class="hljs-property">tableDataForSort</span> = list;<br>                 &#125;);<br>             &#125;<br>         &#125;,<br>     &#125;;<br>     <span class="hljs-title class_">Sortable</span>.<span class="hljs-title function_">create</span>(tbody, options);<br> &#125;<br></code></pre></td></tr></table></figure></li></ol></li></ul><h3 id="属性列span内容过长加上略号"><a href="#属性列span内容过长加上略号" class="headerlink" title="属性列span内容过长加上略号"></a>属性列span内容过长加上略号</h3><p>在span上加上下面代码</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;// 不设置会影响相邻元素<br><span class="hljs-attribute">white-space</span>: nowrap;//不换行<br><span class="hljs-attribute">overflow</span>: hidden<span class="hljs-meta">!important</span>;//可能有内置样式<br><span class="hljs-attribute">text-overflow</span>: ellipsis<span class="hljs-meta">!important</span>;<br></code></pre></td></tr></table></figure><h1 id="布局-1"><a href="#布局-1" class="headerlink" title="布局"></a>布局</h1><p><strong>如何实现除了flex布局的justify-content以外的任意位置布局？</strong></p><p>使用el-col 的 :span属性，一共分为了24个span，某个盒子想要占多少个span，直接在上面写上，一般配合el-row一起使用</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">el-row</span>&gt;</span><br>// 各12，等于平分 <br><span class="hljs-tag">&lt;<span class="hljs-name">el-col</span> <span class="hljs-attr">:span</span>=<span class="hljs-string">&quot;12&quot;</span>&gt;</span><br>1<br><span class="hljs-tag">&lt;/<span class="hljs-name">el-col</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">el-col</span> <span class="hljs-attr">:span</span>=<span class="hljs-string">&quot;12&quot;</span>&gt;</span><br>1<br><span class="hljs-tag">&lt;/<span class="hljs-name">el-col</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">el-row</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>文字的布局直接使用text-align，盒子的布局才用flex那些</strong></p><h1 id="弹框"><a href="#弹框" class="headerlink" title="弹框"></a>弹框</h1><p><strong>点击弹框被模态框覆盖怎么办？</strong>（被遮罩层覆盖）</p><p>直接在el-dialog上设置属性：:modal-append-to-body=’false’</p><ul><li><p>如何内部有消息确认框confirm，此时确认框点击结束后此时又会唤起遮罩层，如何解决？</p><p>dialog上面加上:modal=”false”，是最好的解决方法，直接关闭dialog的遮罩层（网上有个加append-to-body属性的，但是这样会导致内部自己设置的样式被覆盖，因为这个属性是直接将dialog追加在body后面的，此时已经设置过样式了，但是晚了）</p></li></ul><p><strong>如何在标题和内容内容之间加一个分割线？</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">::v-deep .<span class="hljs-property">el</span>-dialog__body &#123;<br>  border-<span class="hljs-attr">top</span>: 1px solid #ccc;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>UI框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ElementuUI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端高频面试题(进阶)</title>
    <link href="/2024/02/15/%E5%89%8D%E7%AB%AF%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-%E8%BF%9B%E9%98%B6/"/>
    <url>/2024/02/15/%E5%89%8D%E7%AB%AF%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-%E8%BF%9B%E9%98%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><h3 id="盒子快速居中的方法（字节）"><a href="#盒子快速居中的方法（字节）" class="headerlink" title="盒子快速居中的方法（字节）"></a>盒子快速居中的方法（字节）</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//  方法太多，但是找个最快的方法，只需两步！！！</span><br>&lt;head&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="language-css"><span class="language-xml">     <span class="hljs-selector-class">.con</span>&#123;</span></span><br><span class="language-css"><span class="language-xml">       <span class="hljs-attribute">width</span>: <span class="hljs-number">500px</span>;</span></span><br><span class="language-css"><span class="language-xml">       <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;</span></span><br><span class="language-css"><span class="language-xml">       <span class="hljs-attribute">background-color</span>: aquamarine;</span></span><br><span class="language-css"><span class="language-xml">       <span class="hljs-attribute">margin</span>: auto;----------- 第二步</span></span><br><span class="language-css"><span class="language-xml">     &#125;</span></span><br><span class="language-css"><span class="language-xml">     <span class="hljs-comment">/* (1) 父元素要有长和宽，子元素才有空间水平和垂直居中，否则会自适应为子元素的长和宽，也是为了节省空间</span></span></span><br><span class="hljs-comment"><span class="language-css"><span class="language-xml">        (2) 浏览器屏幕不知道多大，只能用100%的写法</span></span></span><br><span class="hljs-comment"><span class="language-css"><span class="language-xml">        </span></span></span><br><span class="hljs-comment"><span class="language-css"><span class="language-xml">        (3) 在有空间并且在flex布局下，直接写margin:auto可以直接水平、垂直居中</span></span></span><br><span class="hljs-comment"><span class="language-css"><span class="language-xml">     */</span></span></span><br><span class="language-css"><span class="language-xml">     <span class="hljs-selector-tag">body</span>,<span class="hljs-selector-tag">html</span>&#123;</span></span><br><span class="language-css"><span class="language-xml">       <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;</span></span><br><span class="language-css"><span class="language-xml">       <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;</span></span><br><span class="language-css"><span class="language-xml">       <span class="hljs-attribute">display</span>: flex;-------------- 第一步</span></span><br><span class="language-css"><span class="language-xml">     &#125;</span></span><br><span class="language-css"><span class="language-xml">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></span><br>&lt;/head&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;con&quot;</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>快速居中定位<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><blockquote><p>不推荐，父元素设置宽高100%都不行，必须要html、body同时设置，而且还要保证被居中的元素的父元素要和body一样大、或者没有父元素</p></blockquote><h3 id="padding和margin的区别（深信服、字节）"><a href="#padding和margin的区别（深信服、字节）" class="headerlink" title="padding和margin的区别（深信服、字节）"></a>padding和margin的区别（深信服、字节）</h3><p>在于作用的对象不同，前者作用域自身，后者作用于外部对象（为什么答这一点？找到最容易混淆的、面试官最想听到的，不要说定义这种废话）</p><h3 id="vm和百分比的区别（字节）"><a href="#vm和百分比的区别（字节）" class="headerlink" title="vm和百分比的区别（字节）"></a>vm和百分比的区别（字节）</h3><p>前者有继承关系（针对父元素），后者只和设备的屏幕有关系</p><h3 id="行内和块级元素（字节）"><a href="#行内和块级元素（字节）" class="headerlink" title="行内和块级元素（字节）"></a>行内和块级元素（字节）</h3><p>前者 大小（宽和高） 由 内容 决定，后者 宽度（因为是块级，管不到高度） 有继承关系（不设置看父元素，就是往外撑大）</p><h3 id="如何让谷歌浏览器支持小字体（字节）"><a href="#如何让谷歌浏览器支持小字体（字节）" class="headerlink" title="如何让谷歌浏览器支持小字体（字节）"></a>如何让谷歌浏览器支持小字体（字节）</h3><p>由于谷歌浏览器字体默认最小12px，想要更小，就要使用缩放</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">// 为了兼容所有浏览器，都要设置一遍，上面是 WebKit 内核浏览器，下面是现代所有浏览器的，弥补下其他浏览器<br>-web-<span class="hljs-attribute">transform</span>: <span class="hljs-built_in">scale</span>(<span class="hljs-number">0.5</span>)<br>transform: <span class="hljs-built_in">scale</span>(<span class="hljs-number">0.5</span>)<br></code></pre></td></tr></table></figure><h1 id="Js"><a href="#Js" class="headerlink" title="Js"></a>Js</h1><h3 id="var和let（字节）"><a href="#var和let（字节）" class="headerlink" title="var和let（字节）"></a>var和let（字节）</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 1. var有声明提升---先上车后补票</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a) <span class="hljs-comment">// undefined</span><br><span class="hljs-keyword">var</span> a = <span class="hljs-string">&#x27;Jace Zhou&#x27;</span><br><br><span class="hljs-comment">// 2.var有声明覆盖---套牌车</span><br><span class="hljs-keyword">var</span> name2 = <span class="hljs-string">&#x27;2&#x27;</span><br><span class="hljs-keyword">var</span> name2 = <span class="hljs-string">&#x27;3&#x27;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name2) <span class="hljs-comment">// 3</span><br><br><span class="hljs-comment">// 3.var没有局部作用域---红杏出墙</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fun2</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>    <br>  &#125;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i) <span class="hljs-comment">// 5</span><br>&#125;<br>----------------------------以后都要用<span class="hljs-keyword">let</span>，<span class="hljs-keyword">let</span>可以解决上面所有的问题<br></code></pre></td></tr></table></figure><blockquote><p>思路：全局-&gt;局部，都是有关声明</p></blockquote><h3 id="深拷贝与浅拷贝"><a href="#深拷贝与浅拷贝" class="headerlink" title="深拷贝与浅拷贝"></a>深拷贝与浅拷贝</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 基本数据类型，只有赋值，严格上；来说没有拷贝概念，要说也是 深拷贝(互不打扰)</span><br><span class="hljs-keyword">let</span> a = <span class="hljs-number">1</span><br><span class="hljs-keyword">let</span> b = a<br>b = <span class="hljs-number">2</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a,b)<span class="hljs-comment">// 1,2</span><br><br><span class="hljs-comment">// 数组和对象都是浅拷贝(藕断丝连)</span><br><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br><span class="hljs-keyword">let</span> arrNew = arr<br>arrNew.<span class="hljs-title function_">push</span>(<span class="hljs-number">4</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr,arrNew)<span class="hljs-comment">// 都是[1,2,3,4]</span><br><br><span class="hljs-comment">// 配合解构赋值，解构赋值是一维的深拷贝，多维就是浅拷贝---因为多维内层地址是一样的</span><br><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br><span class="hljs-keyword">let</span> arrNew = [...arr]<br>arrNew[<span class="hljs-number">0</span>].<span class="hljs-title function_">push</span>(<span class="hljs-number">4</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr,arrNew)<span class="hljs-comment">// 123; 1234</span><br><br><span class="hljs-keyword">let</span> arr = [[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]]<br><span class="hljs-keyword">let</span> arrNew = [...arr]<br>arrNew[<span class="hljs-number">0</span>].<span class="hljs-title function_">push</span>(<span class="hljs-number">7</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr,arrNew)<span class="hljs-comment">// 都是 1,2,3,4,5,6,7</span><br><br><span class="hljs-comment">// 引用类型的深拷贝如何使用？</span><br><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br><span class="hljs-keyword">let</span> arrNew = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(arr)) <span class="hljs-comment">// 能解决80%的深拷贝，而且JSON方法还有这个好处：原来是什么结构(这里是数组)，转换后还是什么结构,这也是为什么叫拷贝了</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arrNew);<br><br>  <span class="hljs-comment">// 剩下20%指的是 函数类型 无法拷贝，因为JSON只能处理纯数据的，包含逻辑的无法处理</span><br>  <span class="hljs-comment">// 如何手写深拷贝数据 ----------- 针对引用数据类型</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">deepClone</span>(<span class="hljs-params">source</span>)&#123;<br>  <span class="hljs-keyword">const</span> targetObject = source.<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Array</span> ? [] : &#123;&#125;<br>  <span class="hljs-comment">// in 可以搞数组也可以搞对象</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> keys <span class="hljs-keyword">in</span> source) &#123;<br>    <span class="hljs-comment">// 这里还要判断是不是自己的属性是因为只要拷贝自身属性,而不要原型上的</span><br>    <span class="hljs-keyword">if</span> (source.<span class="hljs-title function_">hasOwnProperty</span>(keys)) &#123;<br>      <span class="hljs-comment">// source[keys] 不管是对象还是数组都是可以通过[key]获取值的</span><br>      <span class="hljs-keyword">if</span> (source[keys] &amp;&amp; <span class="hljs-keyword">typeof</span> source[keys] === <span class="hljs-string">&#x27;object&#x27;</span>) &#123; <br>          targetObject[keys] = <span class="hljs-title function_">deepClone</span>(source[keys])<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>          targetObject[keys] = source[keys]<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> targetObject<br>&#125;<br><br><span class="hljs-comment">// 阿里三层代码文化：</span><br><span class="hljs-number">1.</span>运行代码 -- 能用就行<br><span class="hljs-number">2.</span>容错代码 -- 有健壮性<br><span class="hljs-number">3.</span>维护型代码 -- 方便维护<br></code></pre></td></tr></table></figure><blockquote><p>最不缺的就是Vue工程师，如何增加竞争力？React、node、数据结构与算法、工程化、浏览器</p></blockquote><h3 id="this指向"><a href="#this指向" class="headerlink" title="this指向"></a>this指向</h3><blockquote><p>复习+查漏补缺</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// (1)普通this，指向上一层的调用者，可以结合看当前的在哪个作用域</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fun</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>) <br>&#125;<br><span class="hljs-title function_">fun</span>()-------------- <span class="hljs-variable language_">window</span>，因为<span class="hljs-title function_">fun</span>()=&gt;<span class="hljs-variable language_">window</span>.<span class="hljs-title function_">fun</span>()<br><br><span class="hljs-keyword">let</span> obj = &#123;<br>    <span class="hljs-attr">a</span>:<span class="hljs-number">1</span>,<br>    <span class="hljs-attr">b</span>:&#123;<br>        <span class="hljs-attr">fun</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)<br>        &#125;<br>    &#125;<br>&#125;<br>obj.<span class="hljs-property">b</span>.<span class="hljs-title function_">fun</span>()-----------------b，永远指向上一层的调用者，可以结合看当前的在哪个作用域<br><br><span class="hljs-comment">// (2)箭头函数，没有当前箭头函数的作用域和this，始终指向 函数声明时 所在作用于下的this的值，即忽略本该有的作用域和this，往外去找！  -------这里 函数声明时 所在作用于下的this的值会往外去找：window</span><br><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fun</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>       <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>)<br>    &#125;,<span class="hljs-number">500</span>)<br>&#125;<br><span class="hljs-title function_">fun</span>(&#123;<span class="hljs-attr">a</span>:<span class="hljs-number">2</span>&#125;) ------------------ <span class="hljs-number">1</span>，不看当前箭头函数的作用域，往外一层看<br><span class="hljs-comment">// (3)注意！外面要用var定义，不能用let定义！因为let定义的是块级作用域，只供它后面代码直接使用，而全局作用域只能是var定义的，往外找的也是全局作用域的值！------------ 不太对，暂时还是默认let和var是一样的全局作用域，虽然不知为什么用let定义是打印undefined</span><br><br><span class="hljs-comment">// (4)如何改变this指向？call、apply、bind</span><br>fun.<span class="hljs-title function_">call</span>(&#123;<span class="hljs-attr">a</span>:<span class="hljs-number">2</span>&#125;)<span class="hljs-comment">// -------2 将fun交给&#123;a:2&#125;这个对象</span><br><br><span class="hljs-comment">// (5)call、apply、bind的区别？</span><br>call---&gt;参数是对象，apply---&gt;参数是数组<br>call、apply改变<span class="hljs-variable language_">this</span>指向之后还会调用一次函数，而bind只会改变<span class="hljs-variable language_">this</span>指向不会调用函数<br></code></pre></td></tr></table></figure><h3 id="new关键字"><a href="#new关键字" class="headerlink" title="new关键字"></a>new关键字</h3><p><strong>new的一瞬间做了什么？let person = new Person()</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// (1)创建一个空对象（初始化备用对象）</span><br><span class="hljs-keyword">let</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>()<br><span class="hljs-comment">// (2)设置原型（有通道拿到你所有的数据）</span><br>obj.<span class="hljs-property">_proto_</span> = <span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span><br><span class="hljs-comment">// (3)更改this指向（供别人调用）</span><br><span class="hljs-keyword">let</span> result = <span class="hljs-title class_">Person</span>.<span class="hljs-title function_">call</span>(obj)————————<span class="hljs-title class_">Person</span>在改变指向之后会执行函数，又因为是构造函数，会返回一个新创建的对象（和obj类似，obj是备用的）<br><span class="hljs-comment">// (4)判断返回值类型</span><br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> (result) == <span class="hljs-string">&#x27;object&#x27;</span>)&#123;<br>      person = result <br>&#125;<span class="hljs-keyword">else</span>&#123;<br>      person = obj<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>补充知识点：只有用new关键字的函数名，这时这个函数才是一个构造函数</p></blockquote><h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><p><strong>let obj1 = Object.create(null)和let obj2 = {}有什么区别？</strong></p><blockquote><p>结果都是一个空对象，只是前者没有原形链，后者有。</p><p>如何区分使用场景？如果不需要用到原形链上的数据，就第一种，比如在for循环中 第二种还会遍历原型上的数据，效率会低下</p></blockquote><h3 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h3><p><strong>如何实现一个事件委托？</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;ul id=<span class="hljs-string">&quot;ul&quot;</span>&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>0<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>4<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>5<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br>&lt;/ul&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;btn&quot;</span>&gt;</span>点击添加li<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-comment">//  将li委托到ul上，由于ul是包含li的，因为点击li就等于点击ul，就能触发事件</span></span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-keyword">let</span> ul = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;ul&#x27;</span>)</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-comment">// event是当前事件的对象</span></span></span><br><span class="language-javascript"><span class="language-xml">  ul.<span class="hljs-property">onclick</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>)&#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// 此event就是可以获取ul上的属性</span></span></span><br><span class="language-javascript"><span class="language-xml">    event = event || <span class="hljs-variable language_">window</span>.<span class="hljs-property">event</span> <span class="hljs-comment">// 旧版浏览器是window.event，为了兼容</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">let</span> target = event.<span class="hljs-property">target</span> <span class="hljs-comment">// target为目标节点</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// nodeName就是目标节点的节点类型，这里是li，默认必须要是大写</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">if</span>(target.<span class="hljs-property">nodeName</span> == <span class="hljs-string">&#x27;LI&#x27;</span>)&#123;</span></span><br><span class="language-javascript"><span class="language-xml">       <span class="hljs-title function_">alert</span>(target.<span class="hljs-property">innerHTML</span>)</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-comment">// 按钮动态添加li，还能够触发</span></span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-keyword">let</span> btn = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;btn&#x27;</span>)</span></span><br><span class="language-javascript"><span class="language-xml">  btn.<span class="hljs-property">onclick</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;</span></span><br><span class="language-javascript"><span class="language-xml">     <span class="hljs-keyword">let</span> li = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;li&#x27;</span>)</span></span><br><span class="language-javascript"><span class="language-xml">     li.<span class="hljs-property">textContent</span> = ul.<span class="hljs-property">children</span>.<span class="hljs-property">length</span></span></span><br><span class="language-javascript"><span class="language-xml">     ul.<span class="hljs-title function_">appendChild</span>(li)</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p><strong>事件委托的好处（为什么要用事件委托）？</strong></p><ul><li>减少绑定次数，提高了性能</li><li>可处理动态元素（添加和删除），方便管理和维护</li></ul><h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><p><strong>概念+用法</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 以送女朋友礼物为例</span><br>      <span class="hljs-keyword">let</span> isRemember = <span class="hljs-literal">true</span><br>      <span class="hljs-keyword">let</span> birthGift = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123; <span class="hljs-comment">// 一开始new Promise就是提供resolve,reject处理异步问题</span><br>        <span class="hljs-keyword">if</span>(isRemember)&#123;<br>             <span class="hljs-keyword">let</span> lvBag = &#123;<br>                <span class="hljs-attr">color</span>: <span class="hljs-string">&#x27;gold&#x27;</span>,<br>                <span class="hljs-attr">price</span>: <span class="hljs-string">&#x27;$999&#x27;</span><br>             &#125;<br>             <span class="hljs-title function_">resolve</span>(lvBag)<br>          &#125;<span class="hljs-keyword">else</span>&#123;<br>             <span class="hljs-keyword">let</span> err = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;加班去了，忘了！&#x27;</span>)<br>             <span class="hljs-title function_">reject</span>(err)<br>          &#125;<br>      &#125;)<br>      <span class="hljs-comment">// 普通调用</span><br>      <span class="hljs-comment">// function fn() &#123;</span><br>      <span class="hljs-comment">//   birthGift</span><br>      <span class="hljs-comment">//   .then((fullfilled)=&gt;&#123;</span><br>      <span class="hljs-comment">//      console.log(fullfilled);</span><br>      <span class="hljs-comment">//   &#125;)</span><br>      <span class="hljs-comment">//   .catch((rejected)=&gt;&#123;</span><br>      <span class="hljs-comment">//      console.log(rejected);</span><br>      <span class="hljs-comment">//   &#125;)</span><br>      <span class="hljs-comment">// &#125;</span><br>      <span class="hljs-comment">// fn()</span><br><br>      <span class="hljs-comment">// 链式调用,如果原本then的回调返回的也是promise，那么可以继续then，承上启下</span><br>      <span class="hljs-keyword">let</span> <span class="hljs-title function_">supplyGift</span> = (<span class="hljs-params">lv</span>) =&gt; &#123;<br>          <span class="hljs-keyword">let</span> lip = &#123;<br>             <span class="hljs-attr">color</span>:<span class="hljs-string">&#x27;red&#x27;</span>,<br>             <span class="hljs-attr">price</span>: <span class="hljs-string">&#x27;$888&#x27;</span><br>          &#125;<br>          <span class="hljs-comment">// 整合作为最后的数据给他人使用</span><br>          <span class="hljs-keyword">let</span> msg = &#123;<br>             lv,<br>             lip,<br>             <span class="hljs-attr">msg</span>:<span class="hljs-string">`将收到包包颜色: <span class="hljs-subst">$&#123;lv.color&#125;</span>, 口红颜色: <span class="hljs-subst">$&#123;lip.color&#125;</span>`</span><br>          &#125;<br>          <span class="hljs-comment">// resolve是promise的静态方法，不需要new</span><br>          <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(msg)<br>      &#125;<br>      <span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>) &#123;<br>        birthGift<br>        .<span class="hljs-title function_">then</span>(supplyGift)<br>        .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">fullfilled</span>)=&gt;</span>&#123;<br>           <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(fullfilled);<br>        &#125;)<br>        .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">rejected</span>)=&gt;</span>&#123;<br>           <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(rejected.<span class="hljs-property">message</span>);<br>        &#125;)<br>      &#125;<br>      <span class="hljs-title function_">fn</span>()<br></code></pre></td></tr></table></figure><blockquote><p>下面是关于promise的一些自己的思考：</p><p>（1）到底什么是异步？</p><p>简单来说就是 不会因为要执行当前的任务 而暂时阻塞影响到下面任务的执行</p><p>（2）异步是怎么实现的？</p><p>通过事件循环机制：碰到异步操作先放入队列中，先继续执行主线程代码，主线程代码执行完毕之后，再从队列中拿异步操作出来执行，所以说异步并不是说和主线程代码同步执行，而是先执行同步代码，再执行异步代码。</p><p>（3）事件循环机制处理的对象包括哪些，它们的顺序是什么？</p><p>包括 宏任务和微任务。</p><p>宏任务：定时器、IO操作（后端特有）、网络请求、setImmediate(后端特有）、requestAnimationFrame（用于浏览器执行下一帧动画的函数） ————– 耗时的操作</p><p>微任务：promise().then、process.nextTick（后端特有） ————–紧急的操作</p><p>执行顺序：第一个宏任务（主线程）-&gt;微任务-&gt;宏任务</p><p>（4）可以说说setImmediate于setTimeout的区别吗？</p><p>setImmediate中的Immediate是立刻的意思，但是并不是说setImmediate比定时器限制性，相反定时器是在事件循环的第一个阶段：timers阶段，而setImmediate是在事件循环的最后阶段：check阶段，一般来说是 定时器（时间设置为0的话）比setImmediate先执行，但是 可能在timers阶段用来处理定时器的线程不够了，定时器未能及时执行，此时就可以 使用setImmediate在后面的check帮它执行</p><p>（5）宏任务和微任务是前端和后端都有的概念吗？为什么你这里标注了有些是后端特有的？</p><p>因为，前端浏览器的事件循环机制和Nodejs事件循环机制是不同的，不是一个东西，但是概念类似，也都有宏任务和微任务的概念，只是处理的任务不同，浏览器的事件循环机制是一般处理网络请求等，而后端处理io操作等；</p><p>（6）回到promise，从基本使用来看，promise其实也就是在做一个数据传递的工作，那为什么还要用promise？</p><p>因为异步操作的数据返回的时间是不定的，而promise它是解决异步操作的优雅的解决方案。哪里体现优雅了？最优雅的是 写法上不用像以前的回调地狱那样代码冗长、可读性差；相反，promise的then方法易于理解、可读性强。</p><p>（7）为什么then方法里面的参数是一个函数，而不直接通过then的返回值获取数据？</p><p>既然要获取返回的数据，那肯定是要对数据进行处理的，而不是简单返回，如果设计成let result = then()，还要在外面写数据处理的逻辑，那直接在then函数的参数里面 1）接收数据 2）对数据进行处理 3）数据来了，函数还能自动执行，那不是一举三得？这个也是回调函数的优点。</p><p>（8）在底层then方法的回调函数是什么时候添加的，又是什么时候调用的？是调用then方法的时候调用的吗？</p><p>不是，看似是调用then方法时调用的，其实是在 then方法实现中 添加，而在resolve/reject方法中 调用的，为什么？我们的需求是 要在状态改变（pending-&gt;fullfiled、pending-&gt;rejected）时，调用回调函数，最源头来看，什么时候状态改变？就是调用resolve/reject时；为什么 在 then方法实现中 添加？因为then方法在调用时 回调函数的声明才传进来，这里是最先接触到回调函数的，一传进来就立马缓存下来。</p><p><u>思路:</u> 异步概念-&gt;如何实现异步，涉及到事件循环机制-&gt;事件循环机制有什么，如何运作-&gt;回到promise</p></blockquote><p><strong>手写一个promise（美团、字节）</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">myPromise</span>(<span class="hljs-params">excutor</span>) &#123;<br>          <span class="hljs-comment">// 1.Promise构造函数的基本结构(变量和函数)</span><br>          <span class="hljs-keyword">let</span> self = <span class="hljs-variable language_">this</span> <span class="hljs-comment">// self便于理解</span><br>          self.<span class="hljs-property">status</span> = <span class="hljs-string">&#x27;pending&#x27;</span><br>          <span class="hljs-comment">// resolve,reject函数传递数据后的缓存</span><br>          self.<span class="hljs-property">value</span> = <span class="hljs-string">&#x27;&#x27;</span><br>          self.<span class="hljs-property">reason</span> = <span class="hljs-string">&#x27;&#x27;</span><br>          <span class="hljs-comment">// 添加缓存数组</span><br>          self.<span class="hljs-property">fullfilledCallbacks</span> = []<br>          self.<span class="hljs-property">rejectedCallbacks</span> = []<br><br>          <span class="hljs-comment">// 4.开始处理resolve、reject，需要这两函数传值</span><br>          <span class="hljs-keyword">function</span> <span class="hljs-title function_">resolve</span>(<span class="hljs-params">value</span>)&#123;<br>              <span class="hljs-comment">// 需要判断是pendning，因为操作是不可逆的，只能从pending-&gt;fullfilled</span><br>              <span class="hljs-keyword">if</span>(self.<span class="hljs-property">status</span> == <span class="hljs-string">&#x27;pending&#x27;</span>)&#123;<br>                <span class="hljs-comment">// 缓存值(后面会用到)，更改状态</span><br>                 self.<span class="hljs-property">value</span> = value<br>                 self.<span class="hljs-property">status</span> = <span class="hljs-string">&#x27;fullfilled&#x27;</span><br><br>                <span class="hljs-comment">// 7.状态改变时调用回调(仅调用，这时还没有链式串起来)</span><br>                self.<span class="hljs-property">fullfilledCallbacks</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">callback</span>) =&gt;</span> <span class="hljs-title function_">callback</span>(value))<br>              &#125;<br>          &#125;<br><br>          <span class="hljs-keyword">function</span> <span class="hljs-title function_">reject</span>(<span class="hljs-params">reason</span>) &#123;<br>            <span class="hljs-keyword">if</span>(self.<span class="hljs-property">status</span> == <span class="hljs-string">&#x27;pending&#x27;</span>)&#123;<br>                <span class="hljs-comment">// 缓存值，更改状态</span><br>                 self.<span class="hljs-property">reason</span> = reason<br>                 self.<span class="hljs-property">status</span> = <span class="hljs-string">&#x27;rejected&#x27;</span><br><br>                 self.<span class="hljs-property">rejectedCallbacks</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">callback</span>) =&gt;</span> <span class="hljs-title function_">callback</span>(reason))<br>              &#125;<br>          &#125;<br><br>          self.<span class="hljs-property">resolve</span> = resolve<br>          self.<span class="hljs-property">reject</span> = reject<br><br>          <span class="hljs-comment">// excutor是一个函数，它有两个函数参数resolve,reject，用于控制状态</span><br>          <span class="hljs-comment">// 在这里要立即执行，以便执行传入Promise的回调</span><br>          <span class="hljs-keyword">try</span> &#123;<br>              <span class="hljs-title function_">excutor</span>(resolve,reject)<br>          &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>            <span class="hljs-comment">// 有错误刚好利用自带的处理错误的函数，返回给回调函数</span><br>              <span class="hljs-title function_">reject</span>(error)<br>          &#125;<br>      &#125;<br><br>      <span class="hljs-comment">// 2.不管什么状态，都可以通过then方法来获取结果，即then方法是所有promise实例必须有的，可以放入原型中</span><br>      myPromise.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">then</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">onFullFilled,onRejected</span>) &#123;<br>        <span class="hljs-keyword">let</span> self = <span class="hljs-variable language_">this</span><br>        <span class="hljs-comment">// 5.要处理传过来的resolve、reject，是就用，不是就继续resolve、reject给下一次执行回调</span><br>         onFullFilled = <span class="hljs-keyword">typeof</span> onFullFilled === <span class="hljs-string">&#x27;function&#x27;</span> ?<br>        <span class="hljs-comment">//  5.1 不是函数的情况写的有点粗糙，运行有点问题:undefined，但是这不是重点，重点是知道会传给下一次就行了</span><br>         onFullFilled : <span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>)&#123; self.<span class="hljs-title function_">resolve</span>(data) &#125;<br>         onRejected = <span class="hljs-keyword">typeof</span> onRejected === <span class="hljs-string">&#x27;function&#x27;</span> ?<br>         onRejected : <span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>)&#123; self.<span class="hljs-title function_">reject</span>(data) &#125;<br><br>        <span class="hljs-comment">// 6.将回调缓存 1.0版本，不能支持链式调用，因为没有返回Promise对象，因为只有返回Promise对象才能调用then</span><br>        <span class="hljs-comment">//  let self = this</span><br>        <span class="hljs-comment">//  if(self.status == &#x27;pending&#x27;)&#123;</span><br>        <span class="hljs-comment">//     self.fullfilledCallbacks.push(onFullFilled)</span><br>        <span class="hljs-comment">//     self.rejectedCallbacks.push(onRejected)</span><br>        <span class="hljs-comment">//  &#125;</span><br>        <span class="hljs-comment">// 9.下面是2.0版本，加了链式调用判断，若不需链式调用，直接resolve(x)执行函数</span><br>        <span class="hljs-comment">// 为什么又要重新定义self?上面的用不了?</span><br>        <span class="hljs-keyword">if</span>(self.<span class="hljs-property">status</span> === <span class="hljs-string">&#x27;fullfilled&#x27;</span>)&#123;<br>          <span class="hljs-comment">// 9.1返回Promise是为了链式调用</span><br>          <span class="hljs-comment">// 9.2为什么是返回new myPromise而不是Promise?</span><br>          <span class="hljs-comment">// 现在都是自己手写Promise源码，你这调用现成的还算什么手写promise</span><br>           <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title function_">myPromise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>               <span class="hljs-keyword">try</span> &#123;<br>                  <span class="hljs-keyword">let</span> x = <span class="hljs-title function_">onFullFilled</span>(self.<span class="hljs-property">value</span>)<br>                  x <span class="hljs-keyword">instanceof</span> myPromise ? x.<span class="hljs-title function_">then</span>(resolve,reject) : <span class="hljs-title function_">resolve</span>(x)<span class="hljs-comment">// 注意传的是x，而不是self.value</span><br>               &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>                  <span class="hljs-title function_">reject</span>(error)<br>               &#125;<br><br>           &#125;)<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(self.<span class="hljs-property">status</span> === <span class="hljs-string">&#x27;rejected&#x27;</span>)&#123;<br>           <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title function_">myPromise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>              <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">let</span> x = <span class="hljs-title function_">onRejected</span>(self.<span class="hljs-property">reason</span>)<br>                x <span class="hljs-keyword">instanceof</span> myPromise ? x.<span class="hljs-title function_">then</span>(resolve,reject) : <span class="hljs-title function_">resolve</span>(x)<br>              &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>                <span class="hljs-title function_">reject</span>(error)<br>              &#125;<br>           &#125;)<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(self.<span class="hljs-property">status</span> === <span class="hljs-string">&#x27;pending&#x27;</span>)&#123;<br>          <span class="hljs-comment">// 9.3为什么pending还要加Promise?因为可能是第一次调用这时状态没有变化，但是后续可能会链式调用</span><br>           <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title function_">myPromise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>              <span class="hljs-comment">// 9.4为什么这里push里面不是直接传onFullFilled?</span><br>              <span class="hljs-comment">// 因为要根据判断是否链式调用，直接传onFullFilled就是直接执行，没有链式调用的</span><br>               self.<span class="hljs-property">fullfilledCallbacks</span>.<span class="hljs-title function_">push</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>                  <span class="hljs-keyword">let</span> x = <span class="hljs-title function_">onFullFilled</span>(self.<span class="hljs-property">value</span>)<br>                  x <span class="hljs-keyword">instanceof</span> myPromise ? x.<span class="hljs-title function_">then</span>(resolve,reject) : <span class="hljs-title function_">resolve</span>(x)<br>               &#125;)<br><br>               self.<span class="hljs-property">rejectedCallbacks</span>.<span class="hljs-title function_">push</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>                  <span class="hljs-keyword">let</span> x = <span class="hljs-title function_">onRejected</span>(self.<span class="hljs-property">reason</span>)<br>                  x <span class="hljs-keyword">instanceof</span> myPromise ? x.<span class="hljs-title function_">then</span>(resolve,reject) : <span class="hljs-title function_">reject</span>(x)<br>               &#125;)<br>           &#125;)<br>        &#125;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 为什么三种状态都要进行判断?</span><br><span class="hljs-comment">         * 因为无论是第一次还是后续链式调用传过来的函数可能返回Promise可能不反回，这个说不准</span><br><span class="hljs-comment">         * 因此每次都要判断是否继续链式调用</span><br><span class="hljs-comment">         * */</span>  <br><br>      &#125;<br><br>      myPromise.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">catch</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">fn</span>)&#123;<br>        <span class="hljs-comment">// 10.直接用then方法，因为then里面有对rejected状态的处理</span><br>        <span class="hljs-comment">// 10.1 就这么记忆:原型上的函数的this是可以追踪到构造函数的</span><br>         <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">then</span>(<span class="hljs-literal">null</span>,fn)<br>      &#125;<br><br>      <span class="hljs-comment">// 3.无法执行?在构造函数添加excutor来立即执行</span><br>      <span class="hljs-keyword">let</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title function_">myPromise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>         <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;测试数据&#x27;</span>);<br><br>          <span class="hljs-comment">//  8.验证: 处理异步操作</span><br>          <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>              <span class="hljs-title function_">resolve</span>(<span class="hljs-number">99</span>)<br>          &#125;,<span class="hljs-number">2000</span>)<br>      &#125;)<br>      <span class="hljs-comment">// p1.then((data)=&gt;&#123;console.log(data);&#125;)</span><br>      p1.<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">data1</span>)=&gt;</span>&#123;  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(&#123;<span class="hljs-attr">data1</span>:data1,<span class="hljs-attr">data2</span>:<span class="hljs-string">&#x27;链式数据&#x27;</span>&#125;)&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">dataTotal</span>)=&gt;</span>&#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(dataTotal);&#125;)<br></code></pre></td></tr></table></figure><p><img src="/2024/02/15/%E5%89%8D%E7%AB%AF%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-%E8%BF%9B%E9%98%B6/%E6%89%8B%E5%86%99promise%E7%BB%93%E6%9E%9C.png" alt="结果"></p><h1 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h1><h3 id="从哪方面可以性能优化？"><a href="#从哪方面可以性能优化？" class="headerlink" title="从哪方面可以性能优化？"></a>从哪方面可以性能优化？</h3><ul><li>加载<ol><li>使用CDN加载静态资源（CDN会将资源缓存在各个服务器中，获取资源时会寻找最近的服务器节点）</li><li>减小文件大小（webpack等工具进行压缩，比如去除空格换行）</li><li>减少http请求（精灵图的图片合并、文件合并等）</li><li>SSR服务端渲染</li><li>懒加载</li></ol></li><li>减少DOM操作，减少回流和重绘、文档碎片（一个临时文档，可以把所有文档操作添加入文档碎片，最后合并到文档中，只会有一次回流和重绘）</li></ul><p><img src="/2024/02/15/%E5%89%8D%E7%AB%AF%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-%E8%BF%9B%E9%98%B6/%E6%80%A7%E8%83%BD%E4%BD%93%E7%B3%BB.png" alt="性能体系"></p><p><img src="/2024/02/15/%E5%89%8D%E7%AB%AF%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-%E8%BF%9B%E9%98%B6/%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88.png" alt="技术方案"></p><h3 id="懒加载原理"><a href="#懒加载原理" class="headerlink" title="懒加载原理"></a>懒加载原理</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;style&gt;<br>    <span class="hljs-comment">/* 图片一定要设置宽和高，否则图片会变形、布局会混乱，导致一些意外的问题 */</span><br>     img&#123;<br>       <span class="hljs-attr">width</span>: 400px;<br>       <span class="hljs-attr">height</span>: 400px;<br>       <span class="hljs-attr">display</span>: block;<br>       margin-<span class="hljs-attr">bottom</span>: 50px;<br>     &#125;<br>  &lt;/style&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>   &lt;img src=&quot;./images/loading.gif&quot; data-src=&quot;./images/perf.png&quot;&gt;<br>   &lt;img src=&quot;./images/loading.gif&quot; data-src=&quot;./images/tech.png&quot;&gt;<br>   &lt;img src=&quot;./images/loading.gif&quot; data-src=&quot;./images/jechen.png&quot;&gt;<br>   &lt;img src=&quot;./images/loading.gif&quot; data-src=&quot;./images/web Worker.png&quot;&gt;<br><br>   &lt;script&gt;<br>      let num = document.getElementsByTagName(&quot;img&quot;).length // 4<br>      let img = document.getElementsByTagName(&quot;img&quot;) // 4个节点<br>      let n = 0 // 用于防止下次加载再次重新加载<br> <br>      lazyLoad()<br>      window.onscroll = lazyLoad<br><br>      function lazyLoad()&#123;<br>         let seeHeight = document.documentElement.clientHeight // 可视高度(屏幕高度)<br>         let scrollTop = document.documentElement.scrollTop || document.body.scrollTop // 滚动条上面空隙高度(为了加载下面的图片)<br>         for(let i = n;i&lt;num;i++)&#123;<br>           if(img[i].offsetTop &lt; (seeHeight + scrollTop))&#123;<br>              if(img[i].getAttribute(&quot;src&quot;) == &quot;./images/loading.gif&quot;)&#123;<br>                 img[i].src = img[i].getAttribute(&quot;data-src&quot;)<br>              &#125;<br>              n = i+1; // 防止下次重复加载<br>           &#125;<br>         &#125;<br>      &#125;<br>   &lt;/script&gt; <br></code></pre></td></tr></table></figure><blockquote><p>下面贴一张前端工程师的发展之路：</p><p><img src="/2024/02/15/%E5%89%8D%E7%AB%AF%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-%E8%BF%9B%E9%98%B6/%E5%89%8D%E7%AB%AF%E5%8F%91%E5%B1%95%E4%B9%8B%E8%B7%AF.png" alt="前端发展之路"></p><p>第一年：10k，第二年15k，第三年18k，第五年20k </p><p>（工作年限是参考，关键还得看你的技术，进门容易，进阶难）</p><p><img src="/2024/02/15/%E5%89%8D%E7%AB%AF%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-%E8%BF%9B%E9%98%B6/%E5%A4%A7%E5%89%8D%E7%AB%AF%E6%97%B6%E4%BB%A3%E7%9A%84%E6%8A%80%E6%9C%AF%E5%9B%BE%E8%B0%B1.png" alt="大前端时代的技术图谱"></p><p>其中，5、6是加分项，大厂必备。若果能把这6项都搞懂了，至少20k以上</p><p><img src="/2024/02/15/%E5%89%8D%E7%AB%AF%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-%E8%BF%9B%E9%98%B6/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%89%8D%E6%B2%BF%E5%9C%B0%E8%96%AA%E8%B5%84.png" alt="程序员前言阵地"></p><p>大佬对于跳槽的看法：如果 跳槽后在试用期的工资 = 前一家公司的全薪，再跳，否则划不来（涨一两千）</p></blockquote><h1 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h1><h3 id="Vue底层原理"><a href="#Vue底层原理" class="headerlink" title="Vue底层原理"></a>Vue底层原理</h3><p><strong>前后端分离的根本原因是什么？</strong></p><p>因为MVVM模式中的VM（viewmodel），即视图模型，它相当于MVC模式的C-controller，可以临时存放数据了，不完全依赖后端了（数据只能传给后端），这时才有了前后端分离。</p><p><strong>Vue的历史？</strong></p><blockquote><p>Vue1.0版本：</p><p>此时没有虚拟DOM，每个数据都有一个watcher</p><p>优点：一对一更新，效率高，不需要中间步骤</p><p>缺点：更新节点太多时，会大量操作DOM，违背数据驱动初心</p><p>Vue2.0版本：</p><p>引入了虚拟DOM的概念</p></blockquote><p><strong>v-model的实现原理？</strong></p><p>事件绑定+数据劫持</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;input type=<span class="hljs-string">&quot;text&quot;</span> id=<span class="hljs-string">&quot;input&quot;</span>&gt;<br>&lt;br&gt;<br>内容: <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;span&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-keyword">let</span> obj = &#123;&#125;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-comment">// 数据劫持</span></span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(obj,<span class="hljs-string">&#x27;username&#x27;</span>,&#123;</span></span><br><span class="language-javascript"><span class="language-xml">     <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>)&#123;</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;取值&#x27;</span>);<span class="hljs-comment">// 正常来说，是需要一个另外在Js定义的中间变量来返回出去,然后在set里面修改这个变量的</span></span></span><br><span class="language-javascript"><span class="language-xml">     &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">     <span class="hljs-title function_">set</span>(<span class="hljs-params">val</span>)&#123;</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;span&#x27;</span>).<span class="hljs-property">innerText</span> = val</span></span><br><span class="language-javascript"><span class="language-xml">     &#125;</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;)</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-comment">// 绑定事件</span></span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;input&#x27;</span>).<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;keyup&#x27;</span>,<span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      obj.<span class="hljs-property">username</span> = event.<span class="hljs-property">target</span>.<span class="hljs-property">value</span></span></span><br><span class="language-javascript"><span class="language-xml">  &#125;)</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p><strong>Vue2.0的响应式原理？</strong></p><blockquote><p>简单来说：数据劫持（劫持数据）+发布订阅模式（将劫持的数据应用到模板）</p><p>js代码实现如下：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 订阅器模型</span><br><span class="hljs-keyword">let</span> dep = &#123;<br>  <span class="hljs-comment">// 订阅者</span><br>  <span class="hljs-attr">clientList</span>: &#123;&#125;,<br>  <span class="hljs-comment">// 添加订阅者,key为用户唯一id,fn是这个用户的某个订阅内容的回调----fn相当于wacher主动添加到Dep中</span><br>  <span class="hljs-attr">listen</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">key, fn</span>) &#123;<br>     (<span class="hljs-variable language_">this</span>.<span class="hljs-property">clientList</span>[key] || (<span class="hljs-variable language_">this</span>.<span class="hljs-property">clientList</span>[key] = [])).<span class="hljs-title function_">push</span>(fn)<br>  &#125;,<br>  <span class="hljs-comment">// 推送方法：针对某个用户的订阅内容，循环执行订阅内容的回调以添加(填充)消息</span><br>  <span class="hljs-comment">// 调用时相当于Dep通知wacher更新数据(调用fn)</span><br>  <span class="hljs-attr">trigger</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 从arguments中获取函数传递过来的参数，有下面可知第一个参数是指哪个用户，于是用shift</span><br>    <span class="hljs-keyword">let</span> key = <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">shift</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">arguments</span>),<br>      fns = <span class="hljs-variable language_">this</span>.<span class="hljs-property">clientList</span>[key]<br>    <br>    <span class="hljs-comment">// 若该用户没有订阅内容，则不推送</span><br>    <span class="hljs-keyword">if</span> (!fns || fns.<span class="hljs-property">length</span> == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    <br>    <span class="hljs-comment">// 否则循环填充用户对应的各个订阅内容，这个改变this指向是因为在填充内容是要用到当前上下文的数据</span><br>    <span class="hljs-comment">// arguments是订阅内容回调执行的所需参数</span><br>    <span class="hljs-comment">// 这个循环等于如下写法：</span><br>    <span class="hljs-comment">// for (let i = 0; i &lt; fns.length; i++)&#123;</span><br>    <span class="hljs-comment">//   let fn = fns[i];</span><br>    <span class="hljs-comment">//   fn.apply(this,arguments)</span><br>    <span class="hljs-comment">// &#125;</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, fn; fn = fns[i++];)&#123;<br>       <span class="hljs-comment">// arguments就相当于下面的text参数，注意用apply而不是call，这里arguments是类数组</span><br>       fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>,<span class="hljs-variable language_">arguments</span>)<br>    &#125;<br>  &#125;<br>&#125;<br><span class="hljs-comment">// 数据劫持</span><br><span class="hljs-keyword">let</span> dataHijack = <span class="hljs-keyword">function</span> (<span class="hljs-params">&#123; data, dataTarget, targetView, selector &#125;</span>) &#123;<br>  <span class="hljs-keyword">let</span> value = <span class="hljs-string">&#x27;&#x27;</span>,<span class="hljs-comment">// 数据劫持的临时变量</span><br>    el = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(selector) <span class="hljs-comment">// 获取选择器</span><br>  <br>    <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(data,dataTarget,&#123;<br>      <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;取值&#x27;</span>);<br>        <span class="hljs-keyword">return</span> value<br>      &#125;,<br>      <span class="hljs-title function_">set</span>(<span class="hljs-params">val</span>) &#123;<br>        value = val<br>        <span class="hljs-comment">// 推送消息，通知订阅者，给targetView这个用户推送消息val</span><br>        dep.<span class="hljs-title function_">trigger</span>(targetView,val)<br>      &#125;<br>    &#125;)<br>  <br>  <span class="hljs-comment">// 添加订阅者,targetView看作是订阅者id,它订阅的内容就是更新text</span><br>  dep.<span class="hljs-title function_">listen</span>(targetView, <span class="hljs-keyword">function</span> (<span class="hljs-params">text</span>) &#123;<br>      el.<span class="hljs-property">innerHTML</span> = text<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>引入上述js并使用如下</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 引入js并使用</span><br>  订阅者<span class="hljs-number">1</span>的视图: <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;span-view1&quot;</span>&gt;</span>111<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br>  订阅者<span class="hljs-number">2</span>的视图: <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;span-view2&quot;</span>&gt;</span>222<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./index.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">       <span class="hljs-comment">// 用于拦截的对象，也是用于更新视图的中间对象</span></span></span><br><span class="language-javascript"><span class="language-xml">       <span class="hljs-keyword">let</span> obj = &#123;&#125;</span></span><br><span class="language-javascript"><span class="language-xml">       </span></span><br><span class="language-javascript"><span class="language-xml">       <span class="hljs-title function_">dataHijack</span>(&#123;</span></span><br><span class="language-javascript"><span class="language-xml">         <span class="hljs-attr">data</span>: obj,</span></span><br><span class="language-javascript"><span class="language-xml">         <span class="hljs-attr">dataTarget</span>: <span class="hljs-string">&#x27;one&#x27;</span>,<span class="hljs-comment">//订阅者需要的属性</span></span></span><br><span class="language-javascript"><span class="language-xml">         <span class="hljs-attr">targetView</span>: <span class="hljs-string">&#x27;userTest1&#x27;</span>,<span class="hljs-comment">//订阅者名字1</span></span></span><br><span class="language-javascript"><span class="language-xml">         <span class="hljs-attr">selector</span>: <span class="hljs-string">&#x27;.span-view1&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml">       &#125;)</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">       <span class="hljs-title function_">dataHijack</span>(&#123;</span></span><br><span class="language-javascript"><span class="language-xml">         <span class="hljs-attr">data</span>: obj,</span></span><br><span class="language-javascript"><span class="language-xml">         <span class="hljs-attr">dataTarget</span>: <span class="hljs-string">&#x27;two&#x27;</span>,<span class="hljs-comment">//临时添加的属性</span></span></span><br><span class="language-javascript"><span class="language-xml">         <span class="hljs-attr">targetView</span>: <span class="hljs-string">&#x27;userTest2&#x27;</span>,<span class="hljs-comment">//订阅者名字2</span></span></span><br><span class="language-javascript"><span class="language-xml">         <span class="hljs-attr">selector</span>: <span class="hljs-string">&#x27;.span-view2&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml">       &#125;)</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">       <span class="hljs-comment">// 如下操作以及在浏览器手动更改值 会自动修改到模板上</span></span></span><br><span class="language-javascript"><span class="language-xml">       obj.<span class="hljs-property">one</span> = <span class="hljs-string">&#x27;测试值1&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml">       obj.<span class="hljs-property">two</span> = <span class="hljs-string">&#x27;测试值2&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><blockquote><p>Vue3的响应式原理：见———————-&gt;Vue2和Vue3响应式数据的处理的不同</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>面试题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端综合</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端高频面试题-基础</title>
    <link href="/2024/01/03/%E5%89%8D%E7%AB%AF%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%9F%BA%E7%A1%80/"/>
    <url>/2024/01/03/%E5%89%8D%E7%AB%AF%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><h3 id="1-说一下CSS盒模型"><a href="#1-说一下CSS盒模型" class="headerlink" title="1.说一下CSS盒模型"></a><strong>1.说一下CSS盒模型</strong></h3><blockquote><p>是什么：在HTML上任何一个元素都可以看成一个CSS盒模型，包含四个属性属性：margin、border、padding、content</p><p>分类以及区别：有两种，标准盒模型和IE盒模型，区别在于计算盒子的宽高</p><p>​                           对于标准盒模型来说，它的width和height和content一致</p><p>​                           但是对于IE盒模型来说，它的width和height包括border、padding、content</p><p>如何设置：通过属性box-sizing来设置两种模型：content-box-&gt;标准盒模型（只包含content）</p><p>​                                                                                    border-box-&gt;IE盒模型（多了border等一些一些属性）</p></blockquote><h3 id="2-CSS选择器的优先级"><a href="#2-CSS选择器的优先级" class="headerlink" title="2.CSS选择器的优先级"></a>2.CSS选择器的优先级</h3><blockquote><p>是什么：它是CSS三大特性之一，三大特性是：继承性、层叠性（相同优先级选择哪个）、优先级</p><p>（如何记忆三大特性？继承性 &gt; 优先级 &gt; 层叠性，首先拿继承过来的 以及 现有的 选择器 按照优先级来排，最后如果有相同优先级的，看层叠性）</p><p>有什么：!important（强制生效，可修改默认样式）&gt; 行内标签 &gt; id选择器 &gt; 类选择器（包括 属性值类选择器：[class=’属性名’]；*[class^=’prefix-‘],=，*是通配符，^=表时匹配前缀，伪类选择器 :hover） &gt; 标签选择器 &gt; 全局选择器（*{}）</p></blockquote><h3 id="3-隐藏元素的方法有哪些？"><a href="#3-隐藏元素的方法有哪些？" class="headerlink" title="3.隐藏元素的方法有哪些？"></a>3.隐藏元素的方法有哪些？</h3><blockquote><ol><li>display:none（不占空间，彻底消除）</li><li>visibility:hidden或opacity:0（占空间，仅仅是视觉上看不到）</li><li>clip-path裁剪（占空间，裁剪时相当于复制一份裁再展示）</li><li>绝对定位，比如 left: -9999px; （脱离文档流，不占空间）</li></ol></blockquote><h3 id="4-px和rem的区别是什么？"><a href="#4-px和rem的区别是什么？" class="headerlink" title="4.px和rem的区别是什么？"></a>4.px和rem的区别是什么？</h3><blockquote><p>px是指像素，而rem的全称是”root em”，root是指它是以html为参照物的，em是另外一个单位，它是以父元素的字体大小为参照物，如果默认父元素fontsize:169px，1em = 16px，父元素变它就变，综上所述： rem是指以html的font-size为参照物的大小单位，html的font-size大，1rem就大</p><p>使用em或rem单位的好处是什么？</p><p>可以用在多个地方需要相同字体大小的场景，而且便于维护：想要一起变，只要改基准的font-size即可</p></blockquote><h3 id="5-重绘和重排有什么区别？"><a href="#5-重绘和重排有什么区别？" class="headerlink" title="5.重绘和重排有什么区别？"></a>5.重绘和重排有什么区别？</h3><blockquote><p>重排（回流）是指 元素的布局，例如位置和大小，发生变化后元素的重新排列（元素的删除添加、用js改变大小）</p><p>重绘是指 外观比如元素的颜色等发生变化的重新绘制</p><p>回流必定发生重绘，重绘不一定发生回流</p><p>重绘和重排涉及到浏览器渲染机制，可以说下吗？</p><ul><li>解析HTML生成DOM树</li><li>同时解析CSS样式生成CSSOM树</li><li>解析js，比如事件等</li><li>将DOM树和CSSOM树合并成渲染树（render tree）</li><li>触发 重排-&gt;重绘-&gt;展示页面</li></ul></blockquote><h3 id="6-无宽高让一个元素水平垂直居中的方式有哪些？"><a href="#6-无宽高让一个元素水平垂直居中的方式有哪些？" class="headerlink" title="6.无宽高让一个元素水平垂直居中的方式有哪些？"></a>6.无宽高让一个元素水平垂直居中的方式有哪些？</h3><blockquote><ol><li><p>flex或者grid（为什么放在一起，首先是最常用的，而且使用起来几乎一样，grid仅仅是just-content换成了just-item，且都设置为center）</p></li><li><p>绝对定位+transform:tranlate(-50%,-50%)–&gt;如果子元素的宽高知道，那么就可以margin-left、margin-top设置一半就可以了</p></li><li><p>绝对定位+margin（使用时）</p><p>父元素相对定位，子元素绝对定位，并且把 上下左右设置为0（margin:auto就有空间填充了），margin:auto（可以放开手脚）</p></li></ol><p>直接记 无宽高的，这样不管问到有没有宽高的，都回答这个</p></blockquote><h3 id="7-CSS中哪些元素可以继承？哪些不可以？"><a href="#7-CSS中哪些元素可以继承？哪些不可以？" class="headerlink" title="7.CSS中哪些元素可以继承？哪些不可以？"></a>7.CSS中哪些元素可以继承？哪些不可以？</h3><blockquote><p>以下属性可以继承，其他的基本不可以：</p><ol><li>字体类属性：font-size</li><li>文字类属性：line-height</li><li>可见性属性：visibility:hidden</li><li>列表类属性：list-style</li><li>表格类属性：border-color</li></ol><p>为什么，如何记忆？这些文字、用于展示文字的列表、表格 都是最常用的，常用的都有继承性，不太常用的就不需要有继承性</p></blockquote><h3 id="8-有没有用过预处理器？"><a href="#8-有没有用过预处理器？" class="headerlink" title="8.有没有用过预处理器？"></a>8.有没有用过预处理器？</h3><blockquote><p>是什么：它们是一种工具，在CSS的基础上增加了一些新的特性，比如变量、混入以及导入等，增强了样式的可维护性、可重用性以及可拓展性</p><p>有什么以及区别：有sass、scss、less三种，下面说一下它们的区别，除了上面说的特性以外，sass只支持严格的缩进写法，而scss、less支持大括号；而less相对于scss又更加简单直观，比如去除掉了scss中混入的使用的写法（原来在scss混入需要在前面加@minin，然后再用@include引入，less全部去掉了）</p></blockquote><h3 id="9-精灵图和base64的区别是什么？"><a href="#9-精灵图和base64的区别是什么？" class="headerlink" title="9.精灵图和base64的区别是什么？"></a>9.精灵图和base64的区别是什么？</h3><blockquote><p>精灵图：它可以利用 将多个图片合并成一张图片 的特性，从而减少图片HTTP的请求，达到提高页面加载性能的目的，但是不便于维护（图片的修改需要重新生成精灵图），缺乏灵活性</p><p>base64：它可以将图片的二进制转化为64位的字符串，随着页面的渲染一同渲染不需要额外的HTTP请求，也提高了页面加载性能，但是增加了文件体积（大约增加1/3），如果要和后端交互可以不需要额外设置请求头（multipart/form-data）</p><p>使用场景：</p><p>精灵图：适合图片较多且图片不用修改的场景</p><p>base64：适合图片较少的场景</p><p>如何实现的？（原理）</p><p>精灵图：合并图只能通过自己编辑合并，然后就是通过图片的background-position修改需要展示哪个小图片</p><p>base64：可通过canvas的toDataURL方法将图片转换为64位字符串</p><p><u>回答A与B区别的模板：</u></p><p><u>A是什么，有什么优点、缺点</u></p><p><u>B是什么，有什么优点、缺点</u></p><p><u>根据 各自 优缺点，回答 使用场景</u></p><p><u>往深处挖掘：各自实现的原理是什么？</u></p></blockquote><h3 id="10-canvas是什么？"><a href="#10-canvas是什么？" class="headerlink" title="10.canvas是什么？"></a>10.canvas是什么？</h3><blockquote><p>canvas是一个可编程的画布，通过js代码可以绘制图形、处理图像以及渲染动画等</p></blockquote><h3 id="11-svg格式了解多少？"><a href="#11-svg格式了解多少？" class="headerlink" title="11.svg格式了解多少？"></a>11.svg格式了解多少？</h3><blockquote><p>优点：它内部是基于数学矢量的计算（内部实现）—-&gt;可缩放还不失真、体积小（不像像素图象还要存储颜色信息，它是渲染时才绘制颜色）、下载速度快</p><p>​           它是基于XML的文本（实际存储形式）—-&gt;可修改颜色、半径等，灵活性高</p><p>​           可以转化为base64来引入（如何使用）</p></blockquote><h3 id="12-H5C3（HTML5、CSS3）的语义化的理解"><a href="#12-H5C3（HTML5、CSS3）的语义化的理解" class="headerlink" title="12.H5C3（HTML5、CSS3）的语义化的理解"></a>12.H5C3（HTML5、CSS3）的语义化的理解</h3><blockquote><p>就是在写 HTML标签时，规范使用如下标签：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">nav</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">nav</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">aside</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">aside</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">header</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">header</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">main</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">main</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">footer</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">footer</span>&gt;</span><br></code></pre></td></tr></table></figure><p>有如下好处：</p><p>对于程序员来说：易读、易于理解，开发者一起便于维护，提高开发效率</p><p>对于搜索引擎来说：可以提高搜索引擎优化（SEO）效果（层次明确也便于搜索引擎提取关键信息，比如搜索引擎会更关注main标签的内容）</p></blockquote><h3 id="13-H5C3有哪些新特性？"><a href="#13-H5C3有哪些新特性？" class="headerlink" title="13.H5C3有哪些新特性？"></a>13.H5C3有哪些新特性？</h3><blockquote><p>HTML5：思路-&gt;从语义化标签入手，每个语义化里面可能会装什么内容-&gt;header-&gt;aside-&gt;main</p><ul><li>语义化标签</li><li>本地存储（放在header中的个人头像信息，需要从这获取）</li><li>音频标签video（放在header中的背景音乐，可以切换音乐）</li><li>浏览器提供了 地理位置 API（aside中可作为选项供用户查看）</li><li>画布canvas（main中显示可视化图形，类似echarts）</li></ul><p>CSS3：思路-&gt;选择（选择器）哪个盒子（模型）添加  样式-&gt;布局、边框 包围-&gt;动画</p><ul><li><p>盒子模型</p></li><li><p>选择器</p></li><li><p>flex布局（水平垂直居中）</p></li><li><p>边框、阴影效果（阴影盒子）</p></li><li><p>动画效果（盒子内部有什么动画–鸡你太美）</p><p>即 一个带阴影的盒子内部有个鸡你太美的动画</p></li></ul></blockquote><h3 id="14-rem是如何做到适配的？"><a href="#14-rem是如何做到适配的？" class="headerlink" title="14.rem是如何做到适配的？"></a>14.rem是如何做到适配的？</h3><blockquote><p>利用rem根据html的font-size大小作为基准为单位的特性。比如 移动端屏幕宽度（或高度）不一样，那么我就可以 把html的font-size大小设置为 当前屏幕的宽度，这样在 当前屏幕的div大小，就可以用rem表示（0.5rem屏幕的一半），这样不管什么宽度的屏幕，都可以设置成 屏幕的一半宽度（例子）。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- em是针对父元素的适配单位，而rem是只针对html(root即根部)的适配单位</span><br><span class="hljs-comment">    比如html的fontSize为50px，然后body的字体设置为50%，那么这个1em/1rem就为25px</span><br><span class="hljs-comment">--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">  <span class="hljs-selector-id">#box</span>&#123;</span><br><span class="language-css">     <span class="hljs-attribute">width</span>: <span class="hljs-number">0.5rem</span>;</span><br><span class="language-css">     <span class="hljs-attribute">height</span>: <span class="hljs-number">0.5rem</span>;</span><br><span class="language-css">     <span class="hljs-attribute">background-color</span>: red;</span><br><span class="language-css">  &#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 方法就是 html根元素的字体大小 = 屏幕区的宽</span><br><span class="hljs-comment">    目的是想把 1rem设置成整个屏幕的宽，那下次某个盒子想要设置成占整个屏幕多大比例，那直接 1rem/x</span><br><span class="hljs-comment">    比如 某个盒子想要占屏幕的一半，那设置完之后就可以设置宽高为0.5rem-&gt;特指整个屏幕的一半，这样不管是什么分辨率都可以设置 </span><br><span class="hljs-comment">    Ps：这里的字体大小默认是 指的是rem或em的单位</span><br><span class="hljs-comment">   --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;</span><br>    <br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&#x27;text/javascript&#x27;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"> <span class="hljs-variable language_">window</span>.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">     <span class="hljs-comment">// 整个屏幕的宽</span></span><br><span class="language-javascript">     <span class="hljs-keyword">var</span> width = <span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>.<span class="hljs-property">clientWidth</span></span><br><span class="language-javascript"></span><br><span class="language-javascript">     <span class="hljs-keyword">var</span> htmlNode = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;html&#x27;</span>)</span><br><span class="language-javascript"></span><br><span class="language-javascript">     htmlNode.<span class="hljs-property">style</span>.<span class="hljs-property">fontSize</span> = width + <span class="hljs-string">&#x27;px&#x27;</span></span><br><span class="language-javascript"></span><br><span class="language-javascript">     <span class="hljs-comment">// 以上三个步骤是为了当前屏幕单位 都为1rem</span></span><br><span class="language-javascript"></span><br><span class="language-javascript"> &#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure></blockquote><h3 id="15-解决了哪些移动端兼容问题？"><a href="#15-解决了哪些移动端兼容问题？" class="headerlink" title="15.解决了哪些移动端兼容问题？"></a>15.解决了哪些移动端兼容问题？</h3><blockquote><ol><li><p>安卓环境input框的placeholder文字设置行高（为了垂直居中）之后会偏上</p><p>解决方法：input框有placeholder属性时不要设置行高，安卓环境可能自己默认样式就是偏高的</p></li><li><p>IOS取消自动输入英文首字母大写</p><p>解决方法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">autocorrect</span>=<span class="hljs-string">&#x27;off&#x27;</span> <span class="hljs-attr">autocapitalize</span>=<span class="hljs-string">&#x27;off&#x27;</span> /&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>移动端在字体小于12px时，会显示异常（模糊、不清晰）</p><p>解决方法：使用transform先放大一倍，再缩小一倍。这边看似什么也没做，但里面涉及到了字体渲染时会用到的技术：抗锯齿化技术，在字体过小时因像素丢失字体的边缘是会呈现锯齿状而变的模糊，因此需要将字体重新渲染时会使用抗锯齿化技术使得字体边缘变得平滑，这里先放大再缩小等于 重新抗锯齿化 一次。</p></li><li><p>IOS在input框设置disabled之后字体显示异常（比较灰暗）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">input</span><span class="hljs-selector-attr">[type=button]</span>&#123;<br>  <span class="hljs-attribute">opacity</span>:<span class="hljs-number">1</span>// 把字体显示正常:不透明度=&gt;<span class="hljs-number">1</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>IOS在设置 overflow:auto/scroll 添加滚动条滑动时，会卡顿，就是 屏幕跟不上手动滑动的频率。</p><p>-webkit-overflow-scrolling: touch —————— 内置滚动改为触摸事件</p></li><li><p>IOS在填写文本时，碰到数字会自动识别成电话号码</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&#x27;format-detection&#x27;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&#x27;telephone=no&#x27;</span> /&gt;</span><br></code></pre></td></tr></table></figure></li></ol><p>​          meta：元标签，用来全局设置一些东西的，name设置什么，content内容是什么</p><p><u>思路</u>：登陆页面填写input（前-中【异常用小字体检验】-后）-&gt;登陆后划到最底端进行评论</p></blockquote><h3 id="16-display-none-、-visibility-hidden-和-opacity-0-之间的区别？"><a href="#16-display-none-、-visibility-hidden-和-opacity-0-之间的区别？" class="headerlink" title="16.display:none 、 visibility:hidden 和 opacity:0 之间的区别？"></a>16.display:none 、 visibility:hidden 和 opacity:0 之间的区别？</h3><blockquote><ul><li><p>是否占空间</p><p>display:none不占</p><p>visibility:hidden占</p><p>opacity:0占</p></li><li><p>是否继承</p><p>display:none无法继承（父元素都没了）</p><p>visibility:hidden可以继承（通过设置子元素 visibility:visible 来显示子元素）</p><p>opacity:0可以继承（ <u>但是  不能设置子元素 opacity:1 来先重新显示</u>）</p></li><li><p>事件绑定</p><p>display:none无法触发</p><p>visibility:hidden无法触发</p><p>opacity:0可以触发</p></li><li><p>动画</p><p>display:none无法触发transition</p><p>visibility:hidden无法触发transition</p><p>opacity:0可以触发transition</p></li></ul><p><u>思路</u>：都是指看不见，display:none啥都没了不谈了，另外两个 看不到又占空间 还不如继承给别人用（子元素可能会有要显示的需求）呢，在真正用的时候，一个是手动使用（事件），另一个是自动使用（动画）</p><p>程度：display（直接无了） &gt; visibility（功能性失效） &gt; opacity（继承很特殊）</p></blockquote><h3 id="17-弹性布局flex1-0增加了那些属性？"><a href="#17-弹性布局flex1-0增加了那些属性？" class="headerlink" title="17.弹性布局flex1.0增加了那些属性？"></a>17.弹性布局flex1.0增加了那些属性？</h3><blockquote><p>gap：弹性布局元素之间的间距</p><p>flex-basis：主轴方向各元素的初始大小，主轴方向为水平，那就是指宽度（此时高度由内容决定），主轴方向为垂直，就是指高度（此时宽度由内容决定）</p></blockquote><h3 id="18-数据大屏适配方案有哪些？"><a href="#18-数据大屏适配方案有哪些？" class="headerlink" title="18.数据大屏适配方案有哪些？"></a>18.数据大屏适配方案有哪些？</h3><blockquote><p>常用的是以下两种：</p><ol><li>vw和vh（和下面的rem类似）：<ul><li>是什么：它是只视口的宽高，就是不管屏幕尺寸多少，那么100vh和100vw那就是占满整个屏幕的宽高的</li><li>如何适配：利用实际屏幕和UI稿的大小比例，计算所有元素应当是多少vw和vh</li><li>优点：可以动态针对某个元素进行计算，有针对性；当UI稿和实际屏幕尺寸不一致的时候，不会出现留白情况</li><li>缺点：需要针对每个标签进行计算</li></ul></li><li>scale缩放：<ul><li>是什么：利用transform的scale属性整体按比例进行缩放</li><li>如何适配：<ul><li>按什么比例缩放：按照宽和高较小的缩放比例缩放，比如 实际屏幕宽/UI稿设计宽 = 2.5， 实际屏幕高/UI稿设计高 = 3，为了不让元素顶出去顶出去，最终按照2.5比例缩放</li><li>缩放基点问题：正常缩放是按照原来盒子中心进行缩放，如果直接缩放，也会有元素顶出去顶出去（默认基准在左上角），应该要把基点放到屏幕正中心，如何做到？先利用定位top:50%，left:50%把盒子左上角放到中间，再把缩放基准按照这个左上角缩放，缩放完毕后，再利用translate:(-50%,-50%)把盒子拉回原处</li></ul></li><li>优点：代码少，简单；不用做单独做额外的适配</li><li>缺点：UI稿和实际屏幕比例不同会出现一定的流白（当只适配一个屏幕时，直接把UI设计稿的长宽比设计成和实际屏幕的长宽比，这样 实际屏幕宽/UI稿设计宽 =  实际屏幕高/UI稿设计高，不会出现流白）</li></ul></li></ol><p>Ps：屏幕尺寸有====&gt;4：3、16：9（最常见）、21：9等</p></blockquote><h3 id="19-移动端屏幕适配的方案有哪些？"><a href="#19-移动端屏幕适配的方案有哪些？" class="headerlink" title="19.移动端屏幕适配的方案有哪些？"></a>19.移动端屏幕适配的方案有哪些？</h3><blockquote><ol><li><p>rem+动态计算html的fontSize（把屏幕宽或高设置为html的fontSize，而得出其他元素的多少rem）</p><p>也可以利用媒体查询根据不同设备的宽度给出对应的fontSize值，它可以根据屏幕宽度（大多数都只看宽度的适应性）动态设置fontSize</p></li><li><p>vw和vh</p></li></ol></blockquote><h3 id="20-相对定位、绝对定位和固定定位是什么？该如何使用？"><a href="#20-相对定位、绝对定位和固定定位是什么？该如何使用？" class="headerlink" title="20.相对定位、绝对定位和固定定位是什么？该如何使用？"></a>20.相对定位、绝对定位和固定定位是什么？该如何使用？</h3><blockquote><p>相对定位：相对于元素的原始位置偏移，不脱离文档流，会保留原来位置的空间。</p><p>场景：由于有保留原来空间的特性，这会影响其他元素的布局，因此基本不用它来定位，只用作绝对定位的基准位置（用在父元素上）</p><p>绝对定位：相对于最近的父元素来偏移，脱离文档流，场景：相对父元素定位</p><p>固定定位：相对于浏览器窗口偏移，脱离文档流，场景：悬浮导航栏</p></blockquote><h3 id="21-盒子模型的Content属性是什么？如果父元素不设置宽高会怎么样？"><a href="#21-盒子模型的Content属性是什么？如果父元素不设置宽高会怎么样？" class="headerlink" title="21.盒子模型的Content属性是什么？如果父元素不设置宽高会怎么样？"></a>21.盒子模型的Content属性是什么？如果父元素不设置宽高会怎么样？</h3><blockquote><p>Content是指盒子实际显示的内容，这个内容有width和height两个属性</p><p>如果父元素不设置宽高，那么父元素宽高会根据子元素大小撑开，分析如下：</p><p>因为行内元素是不能设置宽高的，它的大小仅有本身的字体大小或行高决定（名字也可以看出就适合作为子元素），所以肯定是块级元素，而块级元素就是为了容纳其他元素的，如果宽高大于子元素，那么正常容纳，如果不如子元素大，则自动撑开</p></blockquote><h1 id="Js"><a href="#Js" class="headerlink" title="Js"></a>Js</h1><h3 id="1-Js由哪三部分组成？"><a href="#1-Js由哪三部分组成？" class="headerlink" title="1.Js由哪三部分组成？"></a>1.Js由哪三部分组成？</h3><blockquote><ol><li>ECMA script：它是js的核心，描述了js的语法，比如var、数组等</li><li>文档对象模型（DOM）：它把HTML页面看成标签构成的文档，提供API可以与页面交互</li><li>浏览器对象模型（BOM）：可提供与浏览器相关的API，与浏览器窗口交互</li></ol></blockquote><h3 id="2-Js有哪些内置对象"><a href="#2-Js有哪些内置对象" class="headerlink" title="2.Js有哪些内置对象?"></a>2.Js有哪些内置对象?</h3><blockquote><p>Boolean、Number、String、Array、Function、Object、Math、Date…</p><p>记忆技巧？数据类型-&gt;最常用的数据处理（Math、Date）</p><p>最常用的几个以及对应方法:</p><p>String：slice（切割）、split（根据一个分隔符返回一个数组）、toString</p><p>Array：splice（最强数组方法，可增、删、改）、filter（过滤）</p><p>Math：max()、min()、abs()、sqrt()</p><p>Date：getYear()…</p></blockquote><h3 id="3-操作数组的方法有哪些（常用）？"><a href="#3-操作数组的方法有哪些（常用）？" class="headerlink" title="3.操作数组的方法有哪些（常用）？"></a>3.操作数组的方法有哪些（常用）？</h3><blockquote><p>改变原数组：push()、pop()、unshift()、shift()、splice()、reverse()、sort()</p><p>记忆技巧？后（增删）、前（增删）、任意位置（增删）、简单排序（颠倒）、复杂排序</p><p>不改变原数组：filter（过滤器）、reduce（累加器）、map（元素任意处理）、join（连接成字符串）</p><p>记忆技巧？过滤获取部分-&gt;累加获取更多-&gt;reduce是map的特殊实现-&gt;数据处理完了连接成字符串来使用</p></blockquote><h3 id="4-对数据类型的检测方式有哪些？"><a href="#4-对数据类型的检测方式有哪些？" class="headerlink" title="4.对数据类型的检测方式有哪些？"></a>4.对数据类型的检测方式有哪些？</h3><blockquote><p>typeof ———————- 只能针对基本数据类型</p><p>intance of——————-只能针对引用类型</p><p>constructor—————–可以针对基本数据类型、引用类型，但是如果 原型被手动篡改 ，将判断错误（通过找原型名字）</p><p>Object.prototype.toString.call—万能方法，优先使用，可以针对基本数据类型、引用类型，基本不会出错，除非篡改 this指向或重写toString方法（很少会）（toString-&gt;结果是字符，call改变this获取后面的上下文环境的类型）</p><p>如何记忆？前两者都只针对一个，过于局限，后两者都是和原型有关系，且 通用，只是constructor 有可能原型只想被篡改，推荐用Object.prototype.toString.call，这也是放在Object.prototype上的原因</p></blockquote><h3 id="5-请你说说闭包"><a href="#5-请你说说闭包" class="headerlink" title="5.请你说说闭包"></a>5.请你说说闭包</h3><blockquote><p>什么是闭包？是一个对象，key-value形式</p><p>形成条件？1）函数嵌套2）内部函数引用外部函数变量3）外部函数执行时</p><p>优缺点？优点：延长外部函数局部变量的生命周期；缺点：容易造成内存泄露</p><p>如何避免内存泄露？即使销毁。如何销毁？若外部函数执行后没有新的指向（赋值为一个变量）会自动成为垃圾对象被销毁，如果有新的指向，需要手动设置为null</p><p>使用场景？函数的防抖与节流</p></blockquote><h3 id="6-请你说说内存泄露"><a href="#6-请你说说内存泄露" class="headerlink" title="6.请你说说内存泄露"></a>6.请你说说内存泄露</h3><blockquote><p>什么是内存泄露？指分配了内存，不使用时内存无法被释放的情况。</p><p>有哪些常见的内存泄露？</p><ul><li>不使用的全局变量（声明在函数外的都算，或者函数内部没有用var、let或const定义的，否则局部作用域一结束就会被回收）</li><li>闭包的不正确使用（没有手动置空）</li><li>定时器未清除</li></ul></blockquote><h3 id="7-事件委托是什么？"><a href="#7-事件委托是什么？" class="headerlink" title="7.事件委托是什么？"></a>7.事件委托是什么？</h3><blockquote><p>什么是 事件委托？就是利用 事件冒泡 将子元素的事件 绑定到父元素上</p><p>事件委托有什么好处？减少绑定的次数，提高性能</p><p>如何阻止事件委托？</p><ol><li>addEventListen(‘事件名’,function(event){ event.stopPropagation })</li><li>addEventListen(‘事件名’,回调,false) // false为事件冒泡，true为事件捕获</li></ol><p>阻止事件委托的使用场景？子元素可以有自己的事件，不需要触发父元素事件</p><p>什么是事件捕获？</p><p>事件冒泡是从内向外传播，而事件捕获相反，由外向内传播，它们都是事件传播的方式。以下是例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;body&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;outer&quot;</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;inner&quot;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;btn&quot;</span>&gt;</span>Click me!<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">   <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;btn&#x27;</span>).<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Button clicked&#x27;</span>);</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;);</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;inner&#x27;</span>).<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Inner div clicked (bubbling)&#x27;</span>);</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;);</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;outer&#x27;</span>).<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Outer div clicked (bubbling)&#x27;</span>);</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;);</span></span><br><span class="language-javascript"><span class="language-xml">    </span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;outer&#x27;</span>).<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Outer div clicked (capturing)&#x27;</span>);</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;, <span class="hljs-literal">true</span>);<span class="hljs-comment">// 注意这边设置为tryue表示开启事件捕获阶段</span></span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;inner&#x27;</span>).<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Inner div clicked (capturing)&#x27;</span>);</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;, <span class="hljs-literal">true</span>);<span class="hljs-comment">// 注意这边设置为tryue表示开启事件捕获阶段</span></span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br>&lt;/body&gt;<br><br><span class="hljs-comment">// 结果</span><br><span class="hljs-title class_">Outer</span> div clicked (capturing)<br><span class="hljs-title class_">Inner</span> div clicked (capturing)<br><span class="hljs-title class_">Button</span> clicked<br><span class="hljs-title class_">Inner</span> div clicked (bubbling)<br><span class="hljs-title class_">Outer</span> div clicked (bubbling)<br></code></pre></td></tr></table></figure><p>事件触发的顺序遵循事件传播的三个阶段：默认传播分为三个阶段为 事件捕获阶段-&gt;目标阶段-&gt;事件冒泡阶段，和事件添加的顺序无关（即使先添加事件冒泡，还是先打印捕获），但是要注意，js事件传播方式默认是事件冒泡，也就是说 由内向外，除非手动开启事件捕获阶段</p></blockquote><h3 id="8-基本数据类型和引用数据类型的区别是什么？"><a href="#8-基本数据类型和引用数据类型的区别是什么？" class="headerlink" title="8.基本数据类型和引用数据类型的区别是什么？"></a>8.基本数据类型和引用数据类型的区别是什么？</h3><blockquote><p>各有什么：</p><p>基本数据类型：String、Number、Boolean、null、undefined和Symbol（唯一的值，可以用作对象的Key）</p><p>引用数据类型：Array、Function、Object</p><p>区别：存储位置的不同</p><p>基本数据类型的值和引用数据类型的地址 存放在栈内存中，而引用类型的值 存放在 堆内存中</p></blockquote><h3 id="9-说一下原型链"><a href="#9-说一下原型链" class="headerlink" title="9.说一下原型链"></a>9.说一下原型链</h3><blockquote><p>什么是原型？原型是用来为所有实例共享属性和方法的（一般是方法），通过prototype将方法放在原型上，不用全部存放在构造函数上了。</p><p>实例如何访问到原型的方法？通过隐式原型_proto_______，因为它指向构造函数的原型，因此可以访问到</p><p>原型链又是什么？在通过_proto_______往原型上找时可能没找到，此时又会向原型的原型去找，这样一直往上找的路径像一条链一样，故称原型链，下面附一张图：</p></blockquote><p><img src="/2024/01/03/%E5%89%8D%E7%AB%AF%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%9F%BA%E7%A1%80/%E5%8E%9F%E5%9E%8B%E9%93%BE.png" alt="原型链"></p><h3 id="10-new关键字做了什么"><a href="#10-new关键字做了什么" class="headerlink" title="10.new关键字做了什么"></a>10.new关键字做了什么</h3><blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">newFun</span>(<span class="hljs-params">Fun,args</span>)&#123;<br> <span class="hljs-comment">// 1. 创建一个空对象</span><br>    <span class="hljs-keyword">let</span> obj = &#123;&#125;<br> <span class="hljs-comment">// 2. 将空对象的__proto___指向(为了获取构造函数的属性和方法)</span><br>    obj.<span class="hljs-property">__proto__</span> = <span class="hljs-title class_">Fun</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span><br> <span class="hljs-comment">// 3. 改变this指向，将Fun的this指向到obj身上，并把构造函数需要的参数传过来</span><br>    <span class="hljs-keyword">let</span> result = <span class="hljs-title class_">Fun</span>.<span class="hljs-title function_">apply</span>(obj,args)<br> <span class="hljs-comment">// 4.判断返回的结果，若为 对象，则返回该对象(如果该构造函数有返回实例对象，就直接用)，否则返回临时对象</span><br>    <span class="hljs-keyword">return</span> result instance <span class="hljs-keyword">of</span> <span class="hljs-string">&#x27;object&#x27;</span> ? result : obj<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params">name</span>)&#123;<br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name <br>&#125;<br><br>fn.<span class="hljs-property">protptype</span>.<span class="hljs-property">say</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;hi&#x27;</span>)<br>&#125;<br><br><span class="hljs-keyword">let</span> p1 = <span class="hljs-title function_">newFun</span>(fn,<span class="hljs-string">&#x27;张三&#x27;</span>) <span class="hljs-comment">// 这里就是用newFun来代替new关键字，就是new的内部实现</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p1.<span class="hljs-property">name</span>) <span class="hljs-comment">// 张三</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p1)<br></code></pre></td></tr></table></figure></blockquote><h3 id="11-Js是如何实现继承的？"><a href="#11-Js是如何实现继承的？" class="headerlink" title="11.Js是如何实现继承的？"></a>11.Js是如何实现继承的？</h3><blockquote><p>有四种方式：</p><ul><li><p>通过原型链的方式：将子类构造函数 原型 指向 父类的实例</p><p>子类.prototype = new 父类()</p><p>为什么是指向父类的实例而不是原型？</p><p>因为实例有原型链，指向实例就可以一直往上找想要的数据，而不是只在父类上找</p><p>缺点：无法传递参数给父亲进行动态父类数据初始化</p></li><li><p>借用父类构造函数：在子类构造函数内，调用父类构造函数并用call更改this指向，指向子类</p><p>function child(){</p><p>​      parent.call(this,’参数’)</p><p>}</p><p>为什么？调用父类构造函数是为了初始化，更改this指向是为了让子类使用</p><p>优缺点：改进了原型链的方式可以传参，但是无法共享父类数据，函数都是在构造函数中定义的</p></li><li><p>组合式：结合以上两种方式，即：</p><p>子类.prototype = new 父类()</p><p>function child(){</p><p>​      parent.call(this,’参数’)</p><p>}</p><p>优缺点：解决了上面的问题，但是又会调用两次父类构造函数</p></li><li><p>用ES6的class的entends和super关键字，必须先调用super，再初始化子类数据，在子类内部使用super.数据 获取继承过来的数据</p><p>class 子类 entends 父类{</p><p>​      constructor(参数){</p><p>​             super(参数)</p><p>​             初始化子类数据</p><p>​      }</p><p>}</p><p>本质：extends内部做了将子类和父类原型链关联的操作，而super类似call调用传参并改this，只是不需要调用两次父类构造函数</p><p>优缺点：更加完善，但是不是所有浏览器都支持ES6的class</p><p>为什么一定要必须先调用super，再初始化子类数据？</p><p>因为要确保父类先初始化完毕后，这样子类才能继承过来使用，否则父类的数据都没有值的。</p></li></ul></blockquote><h3 id="12-Js设计原理是什么？（Js怎么处理代码的）"><a href="#12-Js设计原理是什么？（Js怎么处理代码的）" class="headerlink" title="12.Js设计原理是什么？（Js怎么处理代码的）"></a>12.Js设计原理是什么？（Js怎么处理代码的）</h3><blockquote><p>包含以下几个部分：Js引擎、执行上下文、调用栈、事件循环、回调函数</p><p>Js引擎-&gt;编译成可执行代码，让代码去执行</p><p>执行上下文-&gt;可调用浏览器的API</p><p>调用栈-&gt;Js单线程就是不断地从调用栈取出代码来执行，比如函数压栈</p><p>事件循环和回调-&gt;处理异步问题，当调用栈为空时，再去除事件队列中的回调函数，不断循环</p><p>思路：先编译能识别代码-&gt;需要用到API-&gt;在调用栈执行代码-&gt;碰到异步问题 用事件循环和回调解决</p></blockquote><h3 id="13-Js中关于this指向问题"><a href="#13-Js中关于this指向问题" class="headerlink" title="13.Js中关于this指向问题"></a>13.Js中关于this指向问题</h3><blockquote><ol><li><p>一般来说，this永远指向最后调用它的对象（可能层级太多），比如单独函数调用fn()，其实也是window.fn()；如果没有调用者，那就只想全局作用域下的this（浏览器window，Nodejs为global）</p></li><li><p>new fn()，这里面涉及到this指向的改变，指向了实例</p></li><li><p>说到this指向更改，call、apply、bind都可以改变，区别后面会说，但是不能是箭头函数，因为箭头函数本身就没有this的概念，更不用说更改</p></li><li><p>箭头函数是没有this的，直接忽略箭头函数那段代码，然后看当前this在哪，默认来看this指向  箭头函数的外层函数的this（父作用域下的this），没有外层函数就window，其实就是当箭头函数不存在</p></li><li><p>说到箭头函数这样的特殊函数，还有个特殊函数：匿名函数，永远指向window（匿名函数没有构造函数来实例化），因为默认没有调用者</p><hr><p>以上是ES5的this指向，下面说说ES6以及以后：</p><p>由于现在前端js越往后越趋向于后端的面向对象的理念，需要像后端这种类中的this自动绑定到当前上下文</p></li></ol><p>思路：一般性this指向-&gt;特殊例子new，因为new没有调用者，涉及this更改-&gt;如何更改?call、apply、bind，但是不是箭头函数-&gt;那就说箭头函数-&gt;和箭头函数一样的特殊函数</p></blockquote><h3 id="14-script标签中defer和async的区别是什么？"><a href="#14-script标签中defer和async的区别是什么？" class="headerlink" title="14.script标签中defer和async的区别是什么？"></a>14.script标签中defer和async的区别是什么？</h3><blockquote><p>两者都属异步解析script脚本的方式，不同的是：</p><p><strong>执行顺序</strong>：需要保证执行脚本的顺序 -&gt; defer，否则 -&gt;async</p><p><strong>执行时机</strong></p><p>defer：会等待页面解析、渲染完毕才会执行（依赖DOM），优点是 保证了js执行顺序</p><p>async：不会等待页面处理完毕，和页面处理 并行处理（不依赖DOM），优点是 执行效率会更高</p><p>如何记忆？看翻译：defer-&gt;推迟（即使已经解析好），async-&gt;异步（一般是指并行。解析好就执行）</p><p>下面附代码例子：注意修饰的是script脚本！</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Defer Example<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">defer</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;script1.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">defer</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;script2.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>    <br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Async Example<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">async</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;script1.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">async</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;script2.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br></code></pre></td></tr></table></figure></blockquote><h3 id="15-定时器最小执行时间各为多少？"><a href="#15-定时器最小执行时间各为多少？" class="headerlink" title="15.定时器最小执行时间各为多少？"></a>15.定时器最小执行时间各为多少？</h3><blockquote><p>setTimeout最小执行时间为4ms</p><p>setInterval最小执行时间为10ms</p><p>以上是HTML5规定的，不同浏览器可能有误差，但是至少得要有4ms</p><p>为什么要这么规定？</p><p>为了浏览器的性能，如果最小执行时间是0ms，且有多个这样的定时器的话，那么在短时间内就会执行大量的任务，这对浏览器的性能造成负面影响。</p></blockquote><h3 id="16-call、apply和bind有什么区别"><a href="#16-call、apply和bind有什么区别" class="headerlink" title="16.call、apply和bind有什么区别"></a>16.call、apply和bind有什么区别</h3><blockquote><p>都是用于改变this指向和执行函数的，区别如下：</p><ul><li><p>call、apply和bind的区别在于：call、apply会立刻执行函数（一般都是xxx.call（新的上下文环境对象,…args-&gt;其余简单参数），前面就是当前函数），而bind不会，bind第一次执行会返回一个改变了this指向的新的函数，再在第二次执行才会执行函数（使用场景例子：一些延迟执行的场景，先绑定，后面再执行）</p></li><li><p>call和apply的区别在于：前者参数传递的是对象，后者是数组。又call比apply性能要好，且数组可以用扩展运算符放入对象中，因此call用的比较多</p></li></ul></blockquote><h3 id="17-在使用递归的时候有没有遇到什么问题？"><a href="#17-在使用递归的时候有没有遇到什么问题？" class="headerlink" title="17.在使用递归的时候有没有遇到什么问题？"></a>17.在使用递归的时候有没有遇到什么问题？</h3><blockquote><p>递归是指：在函数中自己调用自己</p><p>问题：一定要有return的出口，否则无限制地调用函数，会导致调用栈溢出</p></blockquote><h3 id="18-如何实现一个深拷贝？"><a href="#18-如何实现一个深拷贝？" class="headerlink" title="18.如何实现一个深拷贝？"></a>18.如何实现一个深拷贝？</h3><blockquote><p>有三种方式实现深拷贝：</p><ol><li><p>用扩展运算符，缺点：只能实现第一层的深拷贝，多层就是浅拷贝了，因为涉及到多层展开仍然是个对象，地址还是一样的</p></li><li><p>json.parse(json.stringfy())，先转换为json字符串，再转换为对象，缺点：无法针对函数转换，因为函数转换为字符串就是个函数名，无法把内部逻辑转换</p></li><li><p>手写一个深拷贝，以解决上面的问题：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">deepClone</span>(<span class="hljs-params">source</span>)&#123;<br>    <span class="hljs-keyword">let</span> newObj = source.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> == <span class="hljs-string">&#x27;object&#x27;</span> ? &#123;&#125; : []<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> keys <span class="hljs-keyword">in</span> source)&#123;<br>        <span class="hljs-comment">// 要判断下Source上的属性是否是继承自原型的,因为只要拷贝自身属性,而不要原型上的</span><br>        <span class="hljs-keyword">if</span>(source.<span class="hljs-title function_">hasOwnproperty</span>(keys))&#123;<br>            <span class="hljs-keyword">let</span> value = source[keys]<br>            <span class="hljs-comment">// 数组也是一种特殊的对象，因此这里判断都是object    </span><br>            <span class="hljs-keyword">if</span>(value &amp;&amp; value.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> == <span class="hljs-string">&#x27;object&#x27;</span>)&#123;<br>                newObj[keys] = <span class="hljs-title function_">deepClone</span>(value)<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                newObj[keys] = value<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol></blockquote><h3 id="19-说一下Js事件循环"><a href="#19-说一下Js事件循环" class="headerlink" title="19.说一下Js事件循环"></a>19.说一下Js事件循环</h3><blockquote><p>是什么：Js事件循环是Js处理异步操作的机制，下面说说这个机制的过程是什么</p><p>过程：Js主线程碰到同步任务时，会放在执行栈（专门用来执行任务的数据结构，先进来的后执行，执行完毕移除栈顶任务）中来执行，一旦碰到异步任务，就会添加放在任务队列中，等到执行栈中任务执行完毕，就会从任务队列中去除异步任务到执行栈中执行，就这样一旦执行栈为空便从任务队列去取异步任务来执行，循环往复的过程就是事件循环。</p><p>什么是异步？</p><p>就是 不会因为要执行当前的任务 而阻塞下面任务的执行。</p><p>异步任务分为哪些？</p><p>宏任务：定时器、requestAnimationFrame（下一次动画帧执行函数）、网络请求、setImmediate（任务添加到当前宏任务的末尾—后端特有）、IO操作（文件读写—后端特有）</p><p>如何记忆？在定时器、动画中进行网络请求，让后端在setImmediate处理IO操作</p><p>微任务：promise(回调).then()、process.nextTick（把任务添加到当前微任务的末尾–后端特有）</p><p>宏任务和微任务的处理顺序是什么？</p><p>浏览器端：第一个宏任务（主线程）-&gt;微任务-&gt;宏任务（微任务优先级比宏任务优先级高，因为微任务一般处理紧急任务，而宏任务一般处理耗时的操作），每个宏任务之间会进行一次页面渲染</p><p>Nodejs：在6个阶段，每一个阶段完成后都会去执行一批微任务（有的话）</p><p>你这里面说有些是后端特有的是什么意思？</p><p>因为在前端浏览器和后端Nodejs都有一个事件循环机制，功能是类似的，都有宏任务和微任务，只是 浏览器端的事件循环机制是处理前端异步操作的，后端Nodejs的事件循环机制是处理后端异步操作的（注意：Nodejs本身是单线程的，但是可能会碰到一些事件循环机制处理不了的一些需要大量计算的异步任务，这时候可能会借助多线程的模块处理）。</p><p>setImmediate和setTimeout（时间延迟设置为0）的区别是什么？</p><p>setImmediate是会让任务添加到当前事件循环的末尾来执行。两者区别在于：setTimeout是在事件循环的第一个阶段timer，处理的，而setImmediate则在末尾check阶段，如果setTimeout延迟为0ms的话，setTimeout会比setImmediate先执行。</p><p>如何记忆？事件循环机制阶段的不同</p><p>为什么要用到任务队列来处理异步操作？</p><p>因为Js是单线程的，没有多线程来处理异步操作，只能先放在队列中稍后执行。</p><p>​    为什么Js是单线程的？</p><p>​    因为多线程会带来很多同步问题，比如死锁（举例子就说路面上的堵车，都在等待其他人腾出空间，但是也腾不出空间而造成的僵局）。</p><p><u>思路：</u>是什么-&gt;过程-&gt;涉及到异步-&gt;异步任务（有后端特有的任务以及区别）-&gt;任务队列</p></blockquote><h3 id="20-什么是防抖和节流"><a href="#20-什么是防抖和节流" class="headerlink" title="20.什么是防抖和节流"></a>20.什么是防抖和节流</h3><blockquote><p>这两者都是避免频繁触发事件来提高性能的。</p><p>防抖：防止不必要的操作（抖动），来节省资源，只在必要的时刻（<u>集中触发的最后<strong>一次</strong></u>）触发</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">debounce</span>(<span class="hljs-params">fn,delay</span>)&#123;<br> <span class="hljs-keyword">var</span> timer;<br> <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>)&#123;<br>     <span class="hljs-comment">// 只要在delay内多次触发，前一次即将到达delay的时间要执行fn时，就会被下一次给clear掉了</span><br>     <span class="hljs-comment">// 只要时间到达了dalay，就被看做是确定要触发了，比如用户输入停下来了，用户停下来之前都不会触发</span><br>     <span class="hljs-built_in">clearTimeout</span>(timer)<br>     timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>     <span class="hljs-title function_">fn</span>()<br>    &#125;,delay)<br> &#125;<br>&#125;<br><br><span class="hljs-comment">// 为了好的效果，delay不能设置太小-&gt;触发仍会频繁，也不能设置太大-&gt;用户输入完了等半天，要预估好 用户操作大致要花多长时间</span><br></code></pre></td></tr></table></figure><p>使用场景：用户输入框、搜索框</p><p>节流：直接通过<u>降低</u><u>频率</u>来避免频繁触发事件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">throttle</span>(<span class="hljs-params">fn,delay</span>)&#123;<br> <span class="hljs-keyword">var</span> lastTime;<br> <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>     <span class="hljs-keyword">var</span> nowTime = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>()<br>     <span class="hljs-comment">// 规定在delay内执行一次，比防抖容易理解</span><br>     <span class="hljs-keyword">if</span>(now - lastTime &gt; delay)&#123;<br>         <span class="hljs-title function_">fn</span>()<br>         lastTime = nowTime<br>     &#125;<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用场景：滚动条 设置 图片懒加载 的事件（也可以通过判断高度来实现–用得更多）</p><p>用 花钱 来比喻：防抖是 只去买有用的生活必需品，节流是 针对奢侈品 少买。</p></blockquote><h3 id="21-什么是json？"><a href="#21-什么是json？" class="headerlink" title="21.什么是json？"></a>21.什么是json？</h3><blockquote><p>json是一个字符串的数据格式，用大括号包裹，内容是键值对的形式，并用逗号分隔。</p><p>它经常用在前后端数据交互时传输数据、配置文件比如package.json</p><p>数据交互时如果不是json数据，可以使用序列化（JSON.stringfy）和反序列化（JSON.parse）进行转换，当然这两个函数还可以用来实现深拷贝。</p></blockquote><h3 id="22-函数内部有执行上下文环境吗？"><a href="#22-函数内部有执行上下文环境吗？" class="headerlink" title="22.函数内部有执行上下文环境吗？"></a>22.函数内部有执行上下文环境吗？</h3><blockquote><p>有，但是它是虚拟地存在于栈中，在函数内是无法打印出来的，如果在函数打印this，它会往外面找，也就是全局作用域下的this-&gt;window。</p><p>但是一旦在函数内添加了属性和方法，内部会添加到的栈中，想要访问也可以通过this拿出来。</p></blockquote><h3 id="23-传统函数和箭头函数该如何去使用才可以避免this指向问题？"><a href="#23-传统函数和箭头函数该如何去使用才可以避免this指向问题？" class="headerlink" title="23.传统函数和箭头函数该如何去使用才可以避免this指向问题？"></a>23.传统函数和箭头函数该如何去使用才可以避免this指向问题？</h3><blockquote><p>因为传统函数会有this指向问题，即按照原来的this指向规则可能会指向到原本不想要的对象上（会因为引用对象（调用者）的变化而变化），因此直接使用箭头函数，取消当前函数的this，按照外部Vue实例内部来访问，但是要注意的是，虽然箭头函数解决了传统函数this指向变化的问题，但是可能带来新的问题：this的指向是固定的，不能用bind、apply、call更改，我们需要用箭头函数结合传统函数来灵活地修改this执行（例子如下）</p><p>传统函数this会因为引用对象（调用者）的变化而变化的的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = &#123; <br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Obj&#x27;</span>,<br>  <span class="hljs-attr">method</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>  &#125;,<br>&#125;;<br><br><span class="hljs-keyword">const</span> globalFunction = obj.<span class="hljs-property">method</span>;<br><br>obj.<span class="hljs-title function_">method</span>(); <span class="hljs-comment">// 输出：Obj，这里的 this 指向 obj 对象</span><br><span class="hljs-title function_">globalFunction</span>(); <span class="hljs-comment">// 输出：undefined，这里的 this 指向全局对象（在浏览器环境下通常是 window），如果没有定义 name 属性在全局对象上，就会输出 undefined。</span><br></code></pre></td></tr></table></figure><p>直接使用箭头函数替换传统函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Obj&#x27;</span>,<br>  <span class="hljs-attr">method</span>: <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>  &#125;,<br>&#125;;<br><br><span class="hljs-keyword">const</span> globalFunction = obj.<span class="hljs-property">method</span>;<br><br>obj.<span class="hljs-title function_">method</span>(); <span class="hljs-comment">// 输出：undefined，因为这里的 this 指向的是定义 obj 的外层上下文，通常是全局对象，全局对象上没有 name 属性</span><br><span class="hljs-title function_">globalFunction</span>(); <span class="hljs-comment">// 输出：undefined，和上面原因一样</span><br></code></pre></td></tr></table></figure><p>箭头函数+传统函数 灵活修改this</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Obj&#x27;</span>,<br>  <span class="hljs-attr">method</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> that = <span class="hljs-variable language_">this</span>;<br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">arrowFunctionMethod</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(that.<span class="hljs-property">name</span>);<br>    &#125;;<br>    <span class="hljs-keyword">return</span> arrowFunctionMethod;<br>  &#125;,<br>&#125;;<br><br><span class="hljs-keyword">const</span> globalFunction = obj.<span class="hljs-title function_">method</span>();<br><br>obj.<span class="hljs-title function_">method</span>()(); <span class="hljs-comment">// 输出：Obj，这里的箭头函数继承了外层传统函数的 this，而传统函数的 this 指向 obj 对象</span><br><span class="hljs-title function_">globalFunction</span>(); <span class="hljs-comment">// 输出：Obj，原因同上</span><br></code></pre></td></tr></table></figure></blockquote><h1 id="ES"><a href="#ES" class="headerlink" title="ES"></a>ES</h1><h3 id="1-ES5和ES6有什么区别？"><a href="#1-ES5和ES6有什么区别？" class="headerlink" title="1.ES5和ES6有什么区别？"></a>1.ES5和ES6有什么区别？</h3><blockquote><p>ES是指ECMAScript，它是Js的组成部分，另外两个部分是BOM、DOM</p><p>ES5-&gt;ECMAScript5，即在2009年ECMAScript第五次修订，也称为ECMAScript2009</p><p>ES6-&gt;ECMAScript6，即在2015年ECMAScript第六次修订，也称为ECMAScript2015</p></blockquote><h3 id="2-ES6有哪些新特性？"><a href="#2-ES6有哪些新特性？" class="headerlink" title="2.ES6有哪些新特性？"></a>2.ES6有哪些新特性？</h3><blockquote><p><strong>变量的声明</strong></p><p>新增了let和const，有以下特性：</p><ul><li>没有变量提升</li><li>会有暂时性死区的问题（不能先使用再声明）（暂时性指的是如果在声明后使用变量就可以解除；死区指的是在声明变量之前的区域，在这个区域使用变量会报错，比喻成死区）</li><li>不能重复定义</li><li>有块级作用域</li></ul><p><u>思路</u>：针对var的特性的不足来，从var的声明（变量提升-&gt;数量一多-&gt;重复声明；范围一广-&gt;也会覆盖-&gt;全局作用域）</p><p><strong>基本数据类型</strong></p><p>新增了一个Symbol类型，特性如下：</p><ul><li><p>独一无二的属性</p></li><li><p>不想被发现的特性</p></li></ul><p>针对第二点，可以是的数据私有化：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> _age = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;age&#x27;</span>);<br><span class="hljs-keyword">const</span> _getAge = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;getAge&#x27;</span>);<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">age</span>) &#123;<br>    <span class="hljs-variable language_">this</span>[_age] = age;<br>  &#125;<br><br>  [_getAge]() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>[_age];<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> john = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-number">30</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(john.<span class="hljs-property">_age</span>); <span class="hljs-comment">// undefined，私有属性无法直接访问</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(john.<span class="hljs-title function_">_getAge</span>()); <span class="hljs-comment">// TypeError，私有方法无法直接调用</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(john[_age]); <span class="hljs-comment">// undefined，通过 Symbol 访问私有属性也无法获取到</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(john[_getAge]()); <span class="hljs-comment">// 输出: 30，只有通过对应 Symbol 的方法才能获取私有属性值</span><br></code></pre></td></tr></table></figure><p><u>思路</u>：有不想被发现的特性-&gt;私有化</p><p><strong>数组</strong></p><p>数组在定义时：</p><p>可以用到 解构赋值和扩展运算，对数据 进行 拆分赋值 和合并</p><p>数组在处理数据时：</p><p>可以用到 for循环遍历，有 of（item-&gt;单个元素） 和 in（item-&gt;下标） 之分</p><p>处理数据有更便捷、自带的函数：</p><p>Set-&gt;自动去重；</p><p>Map-&gt;键可任意，是键值对的合集（数组），可配合forEach遍历（ 和数组关联起来了）</p><p><u>思路</u>：数组定义时，元素的拆分-&gt;解构赋值与合并-&gt;扩展运算符；数组定义后要遍历处理数据-&gt;for的in和of-&gt;自带函数更方便地处理-&gt;set和map的好处</p><p><strong>导入外部模块</strong></p><p>新增class-&gt;继承（见上面继承方式）</p><p>新增暴露和导入，将写的class导入，首先有几种暴露方式：</p><ul><li>分别暴露（每个数据写个export）</li><li>统一暴露（最后用个对象{}包裹）</li><li>默认暴露（边暴露便定义并写在一个对象中）</li></ul><p>导入方式：</p><ul><li>导入所有（import * as 别名）</li><li>解构赋值方式（import {挑选}）</li><li>默认导入（import 别名）—–只针对默认暴露</li></ul><p><u>思路</u>：class一般专门定义在一个js文件中，再倒入使用</p><p><strong>函数</strong></p><p>函数的形参，可以用到解构赋值，目的是更快速地拿到对象中的属性</p><p>​                           会用到默认参数，此参数用于一般不会更改的情况</p><p>​                           会用到扩展运算符的rest参数，通常叫…args</p><p>新增箭头函数，先说下它的参数：</p><ul><li>没有普通函数的arguments（当前函数的所有参数，是个数组），取而代之的是args（通常配合解构…一起使用），功能一样，和简写的箭头函数更搭配（注意arguments、args是默认名字，如果形参没有定义名字，就用这个）</li></ul><p>再说下 关于this指向带来的特性：</p><ul><li>它完全没有this的概念</li><li>没有this就不能当作构造函数new一个实例，因为new涉及到this的更改，都没有this，也无法更改</li><li>不能作为构造函数，就没有原型，因为原型是构造函数才有的</li><li>不能用call、apply、bind更改this指向</li><li>this指向外层最近的函数的指向（父作用域下的this），就是直接忽视箭头函数</li></ul><p><u>思路</u>：普通函数：形参的处理-&gt;解构赋值-&gt;默认参数-&gt;扩展运算符；</p><p>​            特殊函数（函数的简写）：由外到内</p><p>​                  外：形参</p><p>​                  内：没有this的概念-&gt;没有new的概念（要改变this）-&gt;没有作为构造函数-&gt;没有原型；那怎么改？就算 call、apply、bind也无法改变；那this怎么看？指向它最近外层函数的this（就是忽视整个箭头函数即可）</u></p><p><strong>对象</strong></p><p>对象的属性和函数新增简写形式：</p><ul><li>已经有属性和函数，直接写属性名和函数名即可，不需要写冒号:</li><li>对于函数的声明可以直接写成函数形式：fn(){}</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> a = &#123;<br>    属性,<br>    函数<span class="hljs-number">1</span>,<br>    <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>)&#123;...&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><u>思路</u>：不需要冒号来简写</p><p><strong>发送异步请求</strong></p><p>新增Promise</p><p>目的：解决回调地狱的问题</p><p>什么是回调地狱？</p><p>在promise之前，如果碰到有多个异步任务有依赖关系，这时候只能通过嵌套的回调函数来实现，这就形成了 回调地狱，可读性差（要看很多行）-&gt;可维护性差（难以查找来修改）</p><p>有什么：自身包括 resolve、reject、all、allSettled、race方法</p><p>​               all、allSettled的区别？都是传入数组，存放着所有promise，返回一个新的promise结果（相当于then），前者是 有一个失败，就返回失败，后者 返回所有promise的结果，无论成功还是失败。</p><p>​              race方法-&gt;哪个promise先执行完毕就返回哪个promise的结果，race-&gt;找竞速为第一名的</p><p>​                             使用场景：超时机制-&gt;网络请求超过一定时间就弹出错误信息，就是看成功还是失败看哪个先来。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fetchWithTimeout</span>(<span class="hljs-params">url, timeout</span>) &#123;<br>  <span class="hljs-comment">// 创建一个待定的 Promise 对象，该对象在超时后返回一个默认值或错误信息</span><br>  <span class="hljs-keyword">let</span> timeoutPromise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;Request timed out&#x27;</span>));<br>    &#125;, timeout);<br>  &#125;);<br><br>  <span class="hljs-comment">// 发起请求的 Promise 对象</span><br>  <span class="hljs-keyword">let</span> fetchPromise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-title function_">fetch</span>(url)<br>      .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> response.<span class="hljs-title function_">json</span>())<br>      .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;<br>        <span class="hljs-title function_">resolve</span>(data);<br>      &#125;)<br>      .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>        <span class="hljs-title function_">reject</span>(error);<br>      &#125;);<br>  &#125;);<br><br>  <span class="hljs-comment">// 使用 Promise.race() 等待任意一个 Promise 对象完成</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">race</span>([fetchPromise, timeoutPromise]);<br>&#125;<br><br><span class="hljs-comment">// 使用示例</span><br><span class="hljs-title function_">fetchWithTimeout</span>(<span class="hljs-string">&#x27;https://api.example.com/data&#x27;</span>, <span class="hljs-number">5000</span>)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Request succeeded:&#x27;</span>, data);<br>  &#125;)<br>  .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Request failed:&#x27;</span>, error.<span class="hljs-property">message</span>);<br>  &#125;);<br><br></code></pre></td></tr></table></figure><p>​               原型上包括 then、catch方法</p><p>如何使用的？</p><p>将异步操作用Promsie包裹，成功用resolve把值传递出，此时状态由pending-&gt;resolved，否则用reject传递失败结果，状态由pending-&gt;rejected，最后用then、catch的回调函数获取结果</p><p>为什么值传递出去，then方法里就可以获取到？原理是什么？</p><p>内部实现用到了发布订阅模式。在Promise的内部会针对状态成功和状态失败的回调函数的数组，在then方法里，会把传进来的回调函数添加到回调数组中（这时就是订阅了，为了以后获得消息），然后再在Promise构造函数内部的Resolve和Reject函数里会逐一执行刚刚的回调函数数组，并且会把resolve和reject传过来的value参数传入回调函数中（这时就是发布了），最终在链式调用then时就可以获得依次执行回调的结果了。</p><p>——&gt;链式是如何实现的？（比较难，说个大致了解即可）</p><p>我说个大致了解啊：刚刚说了用于链式调用的各个回调被存放在回调数组中，怎么实现在调用then的时候按顺序执行呢？就是在每次执行回调时先判断下返回值是否为Promise，是的话用then继续调用，不是的话就resolve出去。</p><p><u>思路</u>：目的-&gt;有什么（先介绍有什么才能更好地说明如何使用）-&gt;如何使用-&gt;原理</p><p><strong>数据回来展示</strong></p><p>新增模板字符串，可以把变量 插入 字符串中</p><p><u>整体思路</u>：定义数据（基本类型、数组、函数、对象）-&gt;引入外部数据-&gt;处理数据-&gt;发送异步请求-&gt;返回数据来展示</p></blockquote><h3 id="3-Promise和Async、Await的区别是什么？"><a href="#3-Promise和Async、Await的区别是什么？" class="headerlink" title="3.Promise和Async、Await的区别是什么？"></a>3.Promise和Async、Await的区别是什么？</h3><blockquote><p>共同点：都是处理异步操作的解决方案。</p><p>使用区别：Promise-&gt;见上面；而Async修饰一个返回Promise对象的异步函数，Await则可以等待一个Promise对象的解决</p><p>后者优势：最大的优势就是 Async、Await可以像编写同步代码一样处理异步操作，更加易读、易于理解。</p></blockquote><h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1><h3 id="1-Ajax是什么？如何实现的？"><a href="#1-Ajax是什么？如何实现的？" class="headerlink" title="1.Ajax是什么？如何实现的？"></a>1.Ajax是什么？如何实现的？</h3><blockquote><p>定义：它是一个实现交互式网页的技术，可以在<strong>保证页面不刷新</strong>的情况下（以前用的是JSP，用a标签跳转会刷新页面），和服务器交互数据并更新部分内容</p><p><u>思路</u>：什么技术-&gt;功能（页面不刷新-&gt;用户体验好，更新部分内容-&gt;场景用得多）</p><p>实现过程（<u>思路</u>）：利用xmlHttpRequest对象，向服务器发送请求并返回数据，最终用Js更新页面部分内容，具体如下：</p><ol><li>创建一个xmlHttpRequest对象</li><li>利用该对象的open函数打开连接</li><li>利用该对象的send函数向服务器发送数据</li><li>利用onreadystate change事件监听通信状态</li><li>服务器返回数据</li><li>利用Js将数据更新到页面上</li></ol><p>onload事件和onreadystatechange事件有什么区别？</p><p>onload事件是在请求成功时触发，而onreadystatechange事件是在请求的整个过程的状态（更全：请求-&gt;连接-&gt;发送数据-&gt;返回数据）变化了都会触发，简而言之，处理成功的结果用onload，处理请求的请求过程中的中间状态用onreadystatechange。</p><p><u>思路</u>：顾名思义，load-&gt;加载完成，statechange-&gt;中间状态改变</p></blockquote><h3 id="2-get和post有什么区别？"><a href="#2-get和post有什么区别？" class="headerlink" title="2.get和post有什么区别？"></a>2.get和post有什么区别？</h3><blockquote><p>使用场景：get一般用于获取数据，post一般用于提交数据</p><p>参数位置：get放在URL中，post则放在body中</p><p>参数编码：get只能用类似于键值对的方式进行编码，而post支持很多种（json格式、纯文本格式、二进制-&gt;上传文件）</p><p>安全性：get把参数放在URL中，安全性比post要差</p><p>参数限制：由于URL长度有限制，于是get的参数是由长度限制的，而post没有</p><p>缓存：get由于一般只是获取服务器数据，因此设有缓存机制来提高性能（会把URL和对应的的数据缓存下来，下次发送相同的请求，就把缓存的数据直接拿过来），而post提交数据会改变服务器数据，因此没有缓存机制。</p><p><u>思路</u>：使用场景-&gt;使用过程（传递的参数-&gt;安全性(1)-&gt;参数的限制(2)-&gt;参数如何编码的-&gt;数据回来 是否可缓存）</p></blockquote><h3 id="3-HTTP协议规定的请求头和响应头各包含什么？"><a href="#3-HTTP协议规定的请求头和响应头各包含什么？" class="headerlink" title="3.HTTP协议规定的请求头和响应头各包含什么？"></a>3.HTTP协议规定的请求头和响应头各包含什么？</h3><blockquote><p>不用全部说，说几个常用的</p><p>请求头：</p><ul><li>User-Agent：通常指浏览器标识，指浏览器代理用户的标识（我是谁）</li><li>Referer：表示浏览器URL，用于防盗（我从哪来，避免其他网站获取网页资源）</li><li>Host（发给谁）</li><li>Authortization：权限信息（出示身份才能获取）</li><li>Content-Type（准备发送什么类型的数据）</li><li>Cookie（用什么存储-自动携带，存储个性化配置等）</li><li>Accept（希望返回什么类型的数据）</li><li>if-mdified-since或者if-none-match（得到数据后是否请求缓存—协商缓存）</li></ul><p>响应头：</p><ul><li>Server（我是谁）</li><li>Location（发给谁）</li><li>Content-Type（相应什么类型的数据）</li><li>Set-Cookie（用什么存储）</li><li>Expires/Cache-Control-强缓存、Lasted-Modified（比对时间是否被修改过）/Etag-协商缓存（决定是否让浏览器缓存下来）</li><li>Access-Control-Allow-Origin：设置允许的跨域来源（如果你是跨域的，下一次访问允许谁能访问）</li></ul><p><u>思路：</u>从发送请求到响应请求的流程考虑</p><p>说一下协商缓存的流程：</p><p>一开始从客户端发送一个请求给服务器，服务器会返回Last-modified字段给客户端，客户端收到字段后，赋值给If-modifiied-since，在下一次发送请求时服务器会再一次返回Last-modified，这时候拿上次的If-modifiied-since进行比对，如果时间一致，则说明数据没被修改，就进行缓存，否则重新获取新的数据</p></blockquote><h3 id="4-说一下同源策略"><a href="#4-说一下同源策略" class="headerlink" title="4.说一下同源策略"></a>4.说一下同源策略</h3><blockquote><p><a href="http://www.example.com:3000/vue.js">http://www.example.com:3000/vue.js</a></p><p>协议   域名   子域名              端口号   资源</p><p>同源策略是指 协议、域名、端口号这三者有一个不同，就会收到跨域限制，即无法请求数据，这么做的目的以及好处是 避免来自不同域之间通信时受到攻击，从而降低风险。</p><p>如何实现跨域？有以下四种方式。</p><ol><li><p>jsonp</p><p>定义：通过利用script标签不受跨域限制的特点（因为外部脚本的来源经常来自不同的域，如果限制，无法满足动态加载的需求），利用script发送get请求实现跨域。</p><p>缺点：但是不推荐使用，因为不能完全保证script内的请求代码没有恶意代码来窃取隐私信息从而形成XSS攻击。</p><p>配合者：需要客户端和服务器端同时配置才可以，服务端配置和cors一样。</p></li><li><p>cors</p><p>只需要在服务器端配置响应头的选项，比如Access-Control-Allow-Origin等，因为浏览器是默认支持cors的。</p><p>有如上的优点，推荐使用这种方式的</p></li><li><p>websocket</p><p>它是一种可以实现实时的全双工通信的方式，一旦连接建立，客户端和服务器端可以相互发送请求。由于双向通信通常需要在不同域之间进行（在线游戏、实时协作工具），因此websocket没有跨域限制，可以利用websocket进行跨域请求。</p></li><li><p>反向代理</p><p>它是利用在客户端和目标服务器之间添加一个中转站用来代理服务器（代理客户端是正向代理，代理服务器就是反向代理）操作来实现的跨域。</p><p>如何实现的？</p><p>这个中转站通常和客户端是同源的，这保证了客户端和中转站不受跨域限制，而中转站和目标服务器 都是服务器，服务器之间通信不会涉及到像浏览器端有用户的隐私数据，因为服务器之间是没有类似跨域限制这种限制的，这保证了中转站和目标服务器可以通畅无阻，最终实现了客户端与目标服务器的跨域请求。</p></li></ol></blockquote><h3 id="5-什么是无感登录？"><a href="#5-什么是无感登录？" class="headerlink" title="5.什么是无感登录？"></a>5.什么是无感登录？</h3><blockquote><p>就是 避免频繁登录给 用户带来不好的体验，最典型的就是 token过期后，会自动获取新的token并重新跳转</p><p>如何实现？</p><ul><li>在前端响应器中，判断状态码如果是401-&gt;token过期，则重新调用获取token的接口，并且重新请求页面地址 ———– 推荐第一种</li><li>也可以 用定时器，定时器 定时刷新token，但是时间不好把控，时间太短浪费网络资源</li></ul></blockquote><h3 id="6-如何实现大文件上传？"><a href="#6-如何实现大文件上传？" class="headerlink" title="6.如何实现大文件上传？"></a>6.如何实现大文件上传？</h3><blockquote><p>大文件上传通常会碰到 上传速度慢、网络中断 的问题</p><p>针对上面的问题，通常有以下两个策略：</p><ul><li><p>分片上传：</p><ol><li><p>将大文件按照一定规则分片（利用fs.splice），可以固定大小平分，这样的话最后一片大小会比较小，需要单独处理（如下）（有了分片个数和已发送分片就可以制作进度条了）；也可以根据网络情况分片（如下使用浏览器自带的API），网络情况差就分得小一些，根据网络负载能力来。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">splitFile</span>(<span class="hljs-params">file, chunkSize</span>) &#123;<br>  <span class="hljs-keyword">const</span> fileSize = file.<span class="hljs-property">size</span>;<br>  <span class="hljs-keyword">const</span> totalChunks = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">ceil</span>(fileSize / chunkSize);<span class="hljs-comment">// 个数</span><br>  <span class="hljs-keyword">const</span> chunks = [];<br>  <br>  <span class="hljs-keyword">let</span> start = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">let</span> end = chunkSize;<br>    <br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; totalChunks; i++) &#123;<br>  <span class="hljs-keyword">let</span> chunk;<br>  <br>  <span class="hljs-comment">// 最后一块单独处理</span><br>  <span class="hljs-keyword">if</span> (i === totalChunks - <span class="hljs-number">1</span>) &#123;<br>    chunk = file.<span class="hljs-title function_">slice</span>(start);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    chunk = file.<span class="hljs-title function_">slice</span>(start, end);<br>  &#125;<br>  <br>  chunks.<span class="hljs-title function_">push</span>(chunk);<br>  <br>  start = end;<br>  end = start + chunkSize;<br>&#125;<br>    <br>  <span class="hljs-keyword">return</span> chunks;<br>&#125;<br><br><span class="hljs-comment">// 示例用法</span><br><span class="hljs-keyword">const</span> file = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;fileInput&#x27;</span>).<span class="hljs-property">files</span>[<span class="hljs-number">0</span>];<br><span class="hljs-keyword">const</span> chunkSize = <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>; <span class="hljs-comment">// 1MB</span><br><span class="hljs-keyword">const</span> chunks = <span class="hljs-title function_">splitFile</span>(file, chunkSize);<br></code></pre></td></tr></table></figure><blockquote><p>检测网络情况：</p><p>在前端（客户端）可以通过浏览器提供的API如<code>navigator.connection</code>或第三方库来获取当前网络类型、效果和速度等信息。例如，<code>navigator.connection.type</code>可以返回网络类型（如wifi、4G、3G等），<code>navigator.connection.effectiveType</code>可以返回网络效果（如”slow-2g”、”4g”等），<code>navigator.connection.downlink</code>可以返回当前网络的下载速度。</p></blockquote></li><li><p>将分片一个个上传，同时，记录每个分片的序列号，用于给服务端检查是否有遗漏的，保证完整性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 客户端</span><br><span class="hljs-keyword">let</span> sequenceNumber = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">processFileBlock</span>(<span class="hljs-params">fileBlock</span>) &#123;<br>  <span class="hljs-comment">// 递增计数器</span><br>  sequenceNumber++;<br><br>  <span class="hljs-comment">// 将序列号与文件块一同发送给服务端</span><br>  <span class="hljs-title function_">sendFileBlock</span>(fileBlock, sequenceNumber);<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">sendFileBlock</span>(<span class="hljs-params">fileBlock, sequenceNumber</span>) &#123;<br>  <span class="hljs-comment">// 发送文件块和序列号给服务端</span><br>  <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-comment">// 服务端</span><br><span class="hljs-keyword">let</span> expectedSequenceNumber = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">receiveFileBlock</span>(<span class="hljs-params">fileBlock, sequenceNumber</span>) &#123;<br>  <span class="hljs-comment">// 根据接收到的序列号与期望的序列号进行比对</span><br>  <span class="hljs-keyword">if</span> (sequenceNumber === expectedSequenceNumber + <span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-comment">// 序列号正确，处理文件块</span><br>    <span class="hljs-title function_">processFileBlock</span>(fileBlock);<br><br>    <span class="hljs-comment">// 更新期望的序列号</span><br>    expectedSequenceNumber++;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 序列号不匹配，要求重传缺失的文件块</span><br>    <span class="hljs-title function_">requestMissingFileBlock</span>(expectedSequenceNumber + <span class="hljs-number">1</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>服务端在检查完所有的分片之后，利用fs模块的可读流和可写流进行合并</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);<br><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);<br><br><span class="hljs-comment">// 分片文件所在的目录</span><br><span class="hljs-keyword">const</span> chunkDir = <span class="hljs-string">&#x27;path/to/chunk-directory&#x27;</span>;<br><span class="hljs-comment">// 合并后的文件名和目录</span><br><span class="hljs-keyword">const</span> finalFile = <span class="hljs-string">&#x27;path/to/final-file.ext&#x27;</span>;<br><br><span class="hljs-comment">// 读取分片文件夹中的所有分片文件</span><br><span class="hljs-keyword">const</span> chunkFiles = fs.<span class="hljs-title function_">readdirSync</span>(chunkDir);<br><br><span class="hljs-comment">// 按照分片序号进行排序</span><br>chunkFiles.<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> <span class="hljs-title class_">Number</span>(a.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;-&#x27;</span>)[<span class="hljs-number">1</span>]) - <span class="hljs-title class_">Number</span>(b.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;-&#x27;</span>)[<span class="hljs-number">1</span>]));<br><br><span class="hljs-comment">// 创建一个可写流，用于写入合并后的文件</span><br><span class="hljs-keyword">const</span> writeStream = fs.<span class="hljs-title function_">createWriteStream</span>(finalFile);<br><br><span class="hljs-comment">// 逐个读取分片文件并写入到合并文件中</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; chunkFiles.<span class="hljs-property">length</span>; i++) &#123;<br>  <span class="hljs-keyword">const</span> chunkPath = path.<span class="hljs-title function_">join</span>(chunkDir, chunkFiles[i]);<br><br>  <span class="hljs-comment">// 使用 fs.createReadStream 创建一个可读流</span><br>  <span class="hljs-keyword">const</span> readStream = fs.<span class="hljs-title function_">createReadStream</span>(chunkPath);<br><br>  readStream.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;end&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-comment">// 当读取结束后，删除当前分片文件</span><br>    fs.<span class="hljs-title function_">unlinkSync</span>(chunkPath);<br>  &#125;);<br><br>  <span class="hljs-comment">// 将读取的分片文件写入到合并文件中</span><br>  readStream.<span class="hljs-title function_">pipe</span>(writeStream, &#123; <span class="hljs-attr">end</span>: <span class="hljs-literal">false</span> &#125;);<br>&#125;<br><br><span class="hljs-comment">// 在合并完成后，关闭可写流</span><br>writeStream.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;finish&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-comment">// 合并完成，进行一些后续的操作</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;分片合并完成&#x27;</span>);<br>&#125;);<br><br><span class="hljs-comment">// 关闭可写流</span><br>writeStream.<span class="hljs-title function_">end</span>();<br></code></pre></td></tr></table></figure></li></ol></li><li><p>断点续传：</p><p>怎么判断网络中断？</p><p>它可以检测网络是否中断（心跳机制-定时发送亲求检查网络情况），来决定是否中断请求（如下），并且下一次在中断分片出继续上传，无需从头开始上传（根据上面分片的序列号即可）。</p><p>心跳机制：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs js">  <span class="hljs-comment">// 定义心跳请求的URL</span><br>  <span class="hljs-keyword">const</span> heartbeatUrl = <span class="hljs-string">&#x27;https://example.com/heartbeat&#x27;</span>;<br>  <br>  <span class="hljs-comment">// 定义心跳间隔时间（毫秒）</span><br>  <span class="hljs-keyword">const</span> heartbeatInterval = <span class="hljs-number">3000</span>;<br>  <br>  <span class="hljs-keyword">let</span> heartbeatTimer;<br>  <br>  <span class="hljs-comment">// 发送心跳请求</span><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">sendHeartbeat</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">fetch</span>(heartbeatUrl)<br>      .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span> (!response.<span class="hljs-property">ok</span>) &#123;<br>          <span class="hljs-title function_">handleNetworkError</span>();<br>        &#125;<br>      &#125;)<br>      .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>        <span class="hljs-title function_">handleNetworkError</span>();<br>      &#125;);<br>  &#125;<br>  <br>  <span class="hljs-comment">// 处理网络中断</span><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleNetworkError</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Network connection lost.&#x27;</span>);<br>    <span class="hljs-comment">// 进行其他处理，如中断上传、保存已上传的文件块信息等</span><br>  &#125;<br>  <br>  <span class="hljs-comment">// 开始心跳检测</span><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">startHeartbeat</span>(<span class="hljs-params"></span>) &#123;<br>    heartbeatTimer = <span class="hljs-built_in">setInterval</span>(sendHeartbeat, heartbeatInterval);<br>  &#125;<br>  <br>  <span class="hljs-comment">// 停止心跳检测</span><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">stopHeartbeat</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-built_in">clearInterval</span>(heartbeatTimer);<br>  &#125;<br>  <br>  <span class="hljs-comment">// 示例：开始心跳检测</span><br><span class="hljs-title function_">startHeartbeat</span>();<br></code></pre></td></tr></table></figure><p>如何手动中断请求？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js">  <span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;axios&#x27;</span>;<br>  <br>  <span class="hljs-comment">// 创建取消令牌，告诉cancelTokenSource.cancel方法哪个请求要取消</span><br>  <span class="hljs-keyword">const</span> cancelTokenSource = axios.<span class="hljs-property">CancelToken</span>.<span class="hljs-title function_">source</span>();<br>  <br>  <span class="hljs-comment">// 发起请求</span><br>  axios.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;https://example.com/upload&#x27;</span>, file, &#123;<br>    <span class="hljs-attr">cancelToken</span>: cancelTokenSource.<span class="hljs-property">token</span><br>  &#125;)<br>    .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> &#123;<br>      <span class="hljs-comment">// 请求成功的处理逻辑</span><br>    &#125;)<br>    .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">thrown</span> =&gt;</span> &#123;<br>      <span class="hljs-keyword">if</span> (axios.<span class="hljs-title function_">isCancel</span>(thrown)) &#123;<br>        <span class="hljs-comment">// 中断请求的处理逻辑</span><br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 其他网络错误的处理逻辑</span><br>      &#125;<br>    &#125;);<br>  <br>  <span class="hljs-comment">// 当需要中断上传时</span><br>cancelTokenSource.<span class="hljs-title function_">cancel</span>(<span class="hljs-string">&#x27;取消上传&#x27;</span>);<br></code></pre></td></tr></table></figure><p>结合上面两种方法，实现了大文件上传，既保证了上传速度（分片数据小），又保证了文件的完整性（序列号）</p></li></ul><p><u>思路</u>：秒传-&gt;web worker计算文件md5，因为hash值计算比较耗时，放在主线程会阻塞-&gt;slice进行切片-&gt;给每个chunk添加chunk指纹-&gt;上传时询问该chunk是否已上传-&gt;后端用文件流合并；</p><p>​           断点续传：由于网络原因自动重传（在catch里面判断是否是Network问题）以及手动暂停（xhr.abort=&gt;axios.cancelToken），再手动重传，重传是记录已经上传的chunk数组，然后重传到所有chunk里遍历，找到没有上传的</p><hr><p>大文件上传最主要的是文件的分片以及后端的合并，这期间有很多细节：</p><p>1.妙传：为了提高用户体验以及节省后台资源，如果一个文件已经上传过了，就不用再上传了，后台应该直接显示已上传。</p><p>如何判断文件已上传？</p><p>需要给文件添加一个唯一标识，利用spark-mdb计算二进制文件的Hash值，每一次上传成功，就在后台保存一份。</p><p>如果文件太大而导致计算Hash太久阻塞当前线程怎么办？</p><p>利用Web Worker，它是一个H5的一个特性，可以将一些耗时的任务放在另外一个线程，异步的执行，在postmessage中传递文件，在onmessage中获取它的Hash值</p><p>2.分片上传：利用Blob对象的slice方法给文件进行切割，可以设置分片大小，然后循环放入一个分片数组，记录当前分片Index和总分片数，可以得到当前的上传的进度</p><p>如果因为网络等原因停止上传怎么办，如何断点续传？</p><p>需要给每一个分片都要添加唯一标识，还是利用spark-mdb计算分片的Hash值，每一次上传前都询问一下后端当前分片是否上传，如果上传了就直接下一个，否则就上传</p><p>3.设置并发限制，避免页面卡死</p><p>由于谷歌浏览器正常最多只有6个并发请求数量，避免一次性请求过多，需要设置一下并发限制。可以设置一个max=4，每次请求都max–，只有max&gt;0才可以请求，一旦一个分片上传成功，max++即可</p></blockquote><h3 id="7-如果请求的数据没有过来该怎么办？"><a href="#7-如果请求的数据没有过来该怎么办？" class="headerlink" title="7.如果请求的数据没有过来该怎么办？"></a>7.如果请求的数据没有过来该怎么办？</h3><blockquote><p>如果可以不用展示，那就 隐藏，等数据来了再展示</p><p>如果必须要展示，可以 设置 默认值</p><p>——————-Vue3中的Suspense组件配合插槽 就实现了，有数据和没数据时该如何处理</p></blockquote><h3 id="8-如何封装一个axios？"><a href="#8-如何封装一个axios？" class="headerlink" title="8.如何封装一个axios？"></a>8.如何封装一个axios？</h3><blockquote><ol><li>下载axios模块</li><li>创建一个axios实例，初始化配置，比如baseUrl</li><li>配置请求（config加token等）、相应拦截器（把res用promise返回出去）</li><li>export暴露出去</li><li>用import引进来封装各个接口（url、method等）并使用</li></ol></blockquote><h1 id="Npm"><a href="#Npm" class="headerlink" title="Npm"></a>Npm</h1><h3 id="1-npm的底层环境是什么？"><a href="#1-npm的底层环境是什么？" class="headerlink" title="1.npm的底层环境是什么？"></a>1.npm的底层环境是什么？</h3><blockquote><p>npm是指 node package manage，node包管理器，底层环境是Nodejs</p><p>一旦安装了Nodejs，npm也会一并安装，它包含网站—查阅包的地方、命令行—-下载包的地方、注册表—存储包的地方，下载完了便会显示在package.json文件中。</p><p><u>思路</u>：是什么-&gt;环境-&gt;npm如何使用一套流程</p></blockquote><h3 id="2-pnpm相比于npm优势在哪？"><a href="#2-pnpm相比于npm优势在哪？" class="headerlink" title="2.pnpm相比于npm优势在哪？"></a>2.pnpm相比于npm优势在哪？</h3><blockquote><ul><li><p><strong>更快</strong>：支持并行下载</p></li><li><p><strong>更节省空间：</strong>同一个包在磁盘中只存在一份，避免包的重复下载</p></li></ul></blockquote><h1 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h1><h3 id="1-浏览器存储方式有哪些？"><a href="#1-浏览器存储方式有哪些？" class="headerlink" title="1.浏览器存储方式有哪些？"></a>1.浏览器存储方式有哪些？</h3><blockquote><p>Cookie、sessionStorage、localStorage、indexedDB</p><p>大小限制：Cookie（4KB）&lt; 【sessionStorage、localStorage】（5MB）&lt; indexedDB（浏览器上的数据库，比较大）</p><p>存储内容：【Cookie、sessionStorage、localStorage】-&gt;只能字符串，indexedDB-&gt;任意类型</p><p>存储时间：sessionStorage &lt;【 Cookie（任意设置）、localStorage（一直保存在浏览器） 】除非用户或者程序员手动清除&lt; indexedDB （除非手动清除）</p></blockquote><h3 id="2-token是存储在cookie中还是localStorage中？"><a href="#2-token是存储在cookie中还是localStorage中？" class="headerlink" title="2.token是存储在cookie中还是localStorage中？"></a>2.token是存储在cookie中还是localStorage中？</h3><blockquote><p>什么是token？token是验证身份的令牌，是指用户验证登陆后服务器把凭证经过加密等方式得到的字符串序列</p><p>存在cookie中和存在localStorage中有什么不一样？</p><p>存在cookie中：登陆后默认会自动将cookie（如果存储在cookie中的话）一同并入请求选项中（想着已经登陆了后续自动帮你配上，不用手动添加cookie），缺点是会受到跨域限制（默认cookie中的内容是只能同源，除非设置SameSite: none），而且还会受到CSRF攻击。</p><p>存在localStorage中：需要手动从localStorage获取token并添加至请求选项中，但是会受到XSS攻击。</p><p>存在哪里更好？</p><p>localStorage，因为存在cookie中，也有被XSS攻击的可能性，因为XSS是js脚本注入，只要通过document.cookie就能拿到，综上所述，存在cookie中，既会受到CSRF攻击又会受到XSS攻击，内存还小，有跨域限制，而存在localStorage中，只有可能有XSS攻击，只要有充足预防措施即可。</p><p>为什么不放在sessionStorage中？</p><p>因为放在sessionStorage中每个标签数据是独立的，无法实现共享。</p><p><u>思路</u>：是什么-&gt;介绍特点-&gt;如何选择</p></blockquote><h3 id="3-什么是XSS攻击和CSRF攻击以及如何预防？"><a href="#3-什么是XSS攻击和CSRF攻击以及如何预防？" class="headerlink" title="3.什么是XSS攻击和CSRF攻击以及如何预防？"></a>3.什么是XSS攻击和CSRF攻击以及如何预防？</h3><blockquote><p>XSS攻击：指跨站脚本，攻击者将恶意脚本注入到受害者网站中，来窃取隐私信息发送到攻击者自己的网站中</p><p>预防XSS：既然是脚本注入，1）一开始可以防止注入，把用户输入的一些字符串（&lt;&gt;等）进行转义2）设置HTTP头中的安全标记，如Content-Security-Policy（CSP），可以指定哪些资源可被加载（可以指定只加载当前域名脚本），从而减少XSS攻击的风险</p><p>CSRF攻击：指跨站请求伪装，字面意思就知道 是攻击者伪装成用户发送请求，执行恶意操作，比如利用电子邮件、社交媒体发送链接引诱用户去点击</p><p>预防CSRF：在敏感操作的请求中加入CSRF令牌，该令牌是服务器生成的随机值，需要和用户会话关联，攻击者无法伪造</p></blockquote><h3 id="4-token登录流程？"><a href="#4-token登录流程？" class="headerlink" title="4.token登录流程？"></a>4.token登录流程？</h3><blockquote><ol><li>客户端输入完账号密码请求登录</li><li>服务器收到请求，验证账号密码</li><li>验证通过后将凭证经过加密等方式生成token返回给客户端</li><li>客户端收到token后，后续的请求都需要带上token</li><li>服务器只有验证了token才会返回数据</li></ol></blockquote><h3 id="5-你了解过JWT吗？"><a href="#5-你了解过JWT吗？" class="headerlink" title="5.你了解过JWT吗？"></a>5.你了解过JWT吗？</h3><blockquote><p>先说一下为什么会出现这样的技术：对于传统的认证方式来说，服务器端生成完token后还需要在服务器端自己保存一份以便下次验证使用，但是如果在在分布式应用中，一个应用程序的各个服务可能分布在各个服务器上，为了每个服务正常访问，都需要保存一份token信息，这增加了服务器的开销，这是第一点；第二，对于没有保存token信息的服务器来说，等于就闲置了，这就导致了负载不均衡的问题。</p><p>而JWT的出现解决了以上的问题：它叫json web token，指在web应用中以json的形式存储认证信息，有如下特点：</p><ol><li>无状态性：服务端不需要存储验证信息来验证</li><li>安全性比较高：JWT是有专门的加密算法</li></ol><p>下面结合JWT的典型使用场景：单点登录来说明JWT的使用流程和原理：</p><p>在单点登录场景中，通常涉及到分布式应用，比如一个企业想要登录一次就可以访问多个子系统，那单点登录会有一个认证中心，所有用户登录后会先在认证中心处进行验证：</p><p>那JWT涉及到三个部分：头部、载荷、签名，认证中心验证信息后会对JWT的头部和载荷并通过64base加密并结合私钥（认证中心自己用于生成签名的私钥）生成签名（token）的部分，同时生成一份公钥，并把整个JWT返回给用户，下次用户访问不同的服务都要带上这个JWT，不同的服务获取到JWT先解密头部和载荷，并且结合公钥计算，看最后的结果是否等于签名的值，如果相等，则说明验证通过，说明JWT在传输过程中保持完整（安全性考虑），否则回到验证中心去验证。</p><p><u>你了解过…吗？答题模版</u></p><p><u>知道一个知识点 为什么会有它（为什么），就等于知道了它的定义、应用场景；知道了它的内部实现（如何），就等于深刻理解了它的所有特点</u></p></blockquote><h3 id="6-页面渲染的过程是什么？"><a href="#6-页面渲染的过程是什么？" class="headerlink" title="6.页面渲染的过程是什么？"></a>6.页面渲染的过程是什么？</h3><blockquote><ol><li>解析HTML标签生成DOM树</li><li>解析CSS样式生成CSSOM</li><li>解析js代码，处理事件等和HTML有关联的操作</li><li>将DOM树和CSSOM树合成渲染树</li><li>根据渲染树计算页面布局（元素的位置和大小）—- 回流</li><li>给元素绘制颜色 —- 重绘</li><li>将绘制好的元素渲染到页面上</li></ol></blockquote><h3 id="7-DOM树和渲染树有什么区别？"><a href="#7-DOM树和渲染树有什么区别？" class="headerlink" title="7.DOM树和渲染树有什么区别？"></a>7.DOM树和渲染树有什么区别？</h3><blockquote><p>最关键的区别就是 DOM树是HTML文档的抽象表示，而渲染树是 最后实际用于渲染页面的树结构，这样一来会带来以下的不同：</p><ul><li>渲染树不包含像header、meta还有隐藏元素 这样与最终准备渲染到页面无关的标签，而DOM树包含</li></ul></blockquote><h3 id="8-说一下浏览器的缓存策略"><a href="#8-说一下浏览器的缓存策略" class="headerlink" title="8.说一下浏览器的缓存策略"></a>8.说一下浏览器的缓存策略</h3><blockquote><p>分为两种，强缓存和协商缓存。</p><p>强缓存：由服务器端触发，浏览器端收到通知则将html、css、image等缓存下来，下次加载页面直接从缓存中获取</p><p>协商缓存：缓存之前需向服务器端发送缓存请求，一旦服务器端同意，才缓存</p><p>如何触发？针对HTTP的版本触发方法不一样，如下：</p><p>强缓存：</p><ul><li>HTTP1.0，服务端响应头用 Expires触发，设置浏览器缓存到什么时候</li><li>HTTP1.1以及以后，服务端响应头用 CacheControl触发，由于可能服务器在不同国家地区有时差，设置绝对时间不准确，可以用CacheControl设置相对时间，即多长时间内会缓存</li></ul><p>协商缓存：</p><ul><li>HTTP1.0，请求头：If-Modified-Since，响应头：Last-Modified，通过匹配修改时间是否一直来判断是否缓存，一致则缓存，否则并不缓存</li><li>HTTP1.1以及以后，请求头：If-None-Match，响应头：ETag（Entity，非常笼统的概念，概括为页面的资源，看成一个实体），由于修改时间不一致内容不一定不一致，为了提高性能，直接匹配 修改的值（ETag）本身，如果值相等，则缓存，否则不缓存</li></ul><p><strong>协商缓存服务器端会返回304状态码</strong>，表示可缓存。</p></blockquote><h3 id="9-什么是搜索引擎优化（SEO）？"><a href="#9-什么是搜索引擎优化（SEO）？" class="headerlink" title="9.什么是搜索引擎优化（SEO）？"></a>9.什么是搜索引擎优化（SEO）？</h3><blockquote><p>搜索引擎优化（SEO）是指提高网页在搜索引擎结果中的排名的一系列技术。</p><p>如何优化？从原理上来说，搜索引擎分析的是HTML标签的内容和格式，只要 能帮助搜索引擎分析HTML的都可以优化，有如下几种方式（暂时）：</p><ul><li>技术提升：优化页面加载的速度，网页速度提升了，搜索引擎可以更快地去解析内容，从而更快地显示在排名中</li><li>优化HTML结构，尽量使用语义化标签（见上面），便于搜索引擎分析</li><li>优化关键词，即 内容尽量包含 搜索较多的关键词（要合理自然地分配到各个标签中，比如h1、h2，不能过于堆砌，否则会被搜索引擎认为是作弊），便于搜索引擎直接获取想要的内容</li></ul></blockquote><h3 id="10-浏览器的安全机制是什么？"><a href="#10-浏览器的安全机制是什么？" class="headerlink" title="10.浏览器的安全机制是什么？"></a>10.浏览器的安全机制是什么？</h3><blockquote><p>基本上有以下四种安全机制：</p><ol><li><p>同源策略：是浏览器最基本的安全机制，用来限制不同源（协议、域名、端口）之间的网络请求，减少了被攻击的可能性</p></li><li><p>HTTPS协议：</p><p>2.1 HTTPS加载的页面如果应用内部加载的一些资源比如图片使用HTTP加载的，那么浏览器会出现警告，因为HTTP资源不安全</p><p>2.2 相对于HTTP本质上是加了一层SSL的加密协议，使得客户端和服务端在传输过程中是不可见的，即使被第三方拦截，也无法被获取</p></li><li><p>预防XSS和CSRF攻击：见上面</p></li><li><p>沙箱机制：</p><ul><li>什么叫沙箱？是指当前的某一块代码放在一个受限的环境中，限制它访问 特定的资源，比如不允许访问文件系统等一些敏感的地方。这么做不仅保护用户隐私，而且就算当前这块代码出现错误或崩溃，只会被沙箱环境隔离，并不会影响整个浏览器，极大地保证了浏览器的稳定性。</li></ul></li></ol></blockquote><h1 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h1><h3 id="1-Webpack具体做了什么事情，各有什么好处？"><a href="#1-Webpack具体做了什么事情，各有什么好处？" class="headerlink" title="1.Webpack具体做了什么事情，各有什么好处？"></a>1.Webpack具体做了什么事情，各有什么好处？</h3><blockquote><ol><li>生成依赖图：webpack会找到入口文件（Vue中就是main.js），分析代码中的依赖关系，最终生成依赖图，此依赖图展现了各个模块以及依赖关系</li><li>代码转换：对于每个模块，会利用各种加载器（loader），比如babel-loader可将ES6语法-&gt;ES5语法（CommonJs）、scss-loader可将Scss等预处理文件-&gt;Css文件、url-loader可将图片URL-&gt;dataURL（转换为base64编码）</li><li>代码分割（可选）：可能模块比较多，代码分割可以将代码按模块分类单独放在各个文件里，实现按需加载，比如按需加载首屏加载所需代码，提高首屏加载速度</li><li>资源优化：会对各个模块的代码进一步的优化，比如代码压缩合并（针对单个模块，去除换行、空格、把公共代码单独放入一个文件）等，目的是减少单个文件体积，提高加载速度</li><li>模块打包：如果不进行代码分割，按理来说所有的js代码都会打包在bundle.js（Vue中叫vendor.js）文件里，其中bundle.js文件会包含渲染函数（render函数），Vue在加载应用时就会执行render函数来渲染页面</li></ol></blockquote><h3 id="2-Webpack打包后主要生成了哪些文件？"><a href="#2-Webpack打包后主要生成了哪些文件？" class="headerlink" title="2.Webpack打包后主要生成了哪些文件？"></a>2.Webpack打包后主要生成了哪些文件？</h3><blockquote><ol><li>index.html：项目主要的HTML文件，也就是单页面应用的主页面</li><li>图片和其他静态资源（字体）</li><li>bundle.js以及其他模块js文件</li><li>css样式文件</li></ol><p>在index.html里会引入图片、bundle.js、css文件来加载应用</p></blockquote><h3 id="3-Webpack打包和不打包的区别？"><a href="#3-Webpack打包和不打包的区别？" class="headerlink" title="3.Webpack打包和不打包的区别？"></a>3.Webpack打包和不打包的区别？</h3><blockquote><p>webpack打包后有以下优点是不打包所没有额度</p><ol><li><p>更好地支持</p><p>webpack在第一阶段会代码转换，利用babel等工具把一些语法转换为浏览器能识别的语法，会将ES6语法-&gt;ES5语法（CommonJs）、Scss等预处理文件-&gt;Css文件、图片-&gt;dataURL（转换为base64编码）</p></li><li><p>提高加载速度</p><p>webpack在代码分割、资源优化阶段可以大大减小包的大小，从而提高加载速度</p></li></ol></blockquote><h3 id="4-Webpack的基本配置文件（webpack-config-js）中的entry、output、module、plugins等核心选项分别用来做什么？"><a href="#4-Webpack的基本配置文件（webpack-config-js）中的entry、output、module、plugins等核心选项分别用来做什么？" class="headerlink" title="4.Webpack的基本配置文件（webpack.config.js）中的entry、output、module、plugins等核心选项分别用来做什么？"></a>4.Webpack的基本配置文件（webpack.config.js）中的entry、output、module、plugins等核心选项分别用来做什么？</h3><blockquote><p>entry：入口文件，可以为一个或多个 —- 生成依赖图</p><p>output：输出配置，比如路径</p><p>module：配置loader处理css文件、style文件等，优化构建速度，比如css-loader、style-loader、file-loader，一句话：帮助webpack转化文件的 —- 代码转化</p><p>plugins：用一些第三方的插件做一些辅助性的处理，比如CleanWebpackPlugin，可以每次构建前清空构建目录 — 代码分割和压缩</p></blockquote><h3 id="5-如何通过Webpack配置实现代码拆分（code-splitting）等优化和懒加载（lazy-loading）？"><a href="#5-如何通过Webpack配置实现代码拆分（code-splitting）等优化和懒加载（lazy-loading）？" class="headerlink" title="5.如何通过Webpack配置实现代码拆分（code splitting）等优化和懒加载（lazy loading）？"></a>5.如何通过Webpack配置实现代码拆分（code splitting）等优化和懒加载（lazy loading）？</h3><blockquote><p><strong>Webpack的所有优化都是在optimization配置项下</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">optimization</span>:&#123;<br>    <span class="hljs-comment">// 代码分割</span><br>    <span class="hljs-attr">splitChunks</span>:&#123;<br>        <span class="hljs-attr">cacheGroups</span>:&#123;<br>            <span class="hljs-comment">// 提取公共模块</span><br>            <span class="hljs-attr">common</span>:&#123;chunk名字以及目录&#125;,<br>            <span class="hljs-comment">// 按照组件分块</span><br>            <span class="hljs-attr">components</span>:&#123;chunk名字以及目录&#125;<br>        &#125;<br>    &#125;,<br>    <span class="hljs-comment">// Tree Shaking ----- 代码压缩的范畴</span><br>    <span class="hljs-attr">minimize</span>:<span class="hljs-literal">true</span>,<br>    <span class="hljs-comment">// 压缩Js和Css文件,注意terserPlugin需要安装webpack对应版本，比如webpack4-&gt;terserPlugin4,webpack默认安装5版本的</span><br>    <span class="hljs-attr">minimizer</span>:&#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title function_">terserPlugin</span>(&#123;<br>            <span class="hljs-comment">// 缓存js文件</span><br>            <span class="hljs-attr">cache</span>:<span class="hljs-literal">true</span>，<br>            <span class="hljs-attr">terserOptions</span>:&#123;<br>               <span class="hljs-comment">// 去除console、debugger语句</span><br>               <span class="hljs-attr">compress</span>:&#123;<br>                  <span class="hljs-attr">drop_console</span>:<span class="hljs-literal">true</span><br>                  <span class="hljs-attr">drop_debugger</span>:<span class="hljs-literal">true</span><br>               &#125;<br>            &#125;<br>        &#125;),<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">OptimizeCSSAssetsPlugin</span>(&#123;<br>            <span class="hljs-comment">// 有三种模式default(去除空格等)、medium(浏览器兼容,比如加上其他浏览器前缀,谷歌和Safari都是-webkit-,而火狐是-moz-)、advanced(针对重复选择器去重等)</span><br>            <span class="hljs-attr">cssProcessorPluginOptions</span>: &#123;<br>                 <span class="hljs-attr">preset</span>: [<span class="hljs-string">&#x27;default&#x27;</span>, &#123; <span class="hljs-attr">discardComments</span>: &#123; <span class="hljs-attr">removeAll</span>: <span class="hljs-literal">true</span> &#125; &#125;]<br>              &#125;<br>        &#125;),<br>        <span class="hljs-comment">// 需要配合服务端配置才可以(ngix)</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">CompressWebpackPlugin</span>(&#123;<br>            <span class="hljs-attr">test</span>:<span class="hljs-regexp">/\.(js|html|css)$/</span>,压缩的文件类型<br>            <span class="hljs-attr">threhold</span>:<span class="hljs-number">10240</span>,<span class="hljs-comment">//单位B,超过10KB就进行压缩</span><br>        &#125;)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>懒加载：</strong></p><p>一旦代码中使用了import的语法，webpack自动会进行懒加载处理</p></blockquote><h3 id="6-Webpack中的哪些配置选项或插件可以帮助提高构建速度？"><a href="#6-Webpack中的哪些配置选项或插件可以帮助提高构建速度？" class="headerlink" title="6.Webpack中的哪些配置选项或插件可以帮助提高构建速度？"></a>6.Webpack中的哪些配置选项或插件可以帮助提高构建速度？</h3><blockquote><p>在module配置项中添加thread-loader可开启多线程处理</p><p>还有一些css-loader、style-loader、file-loader</p><hr><p>补充：devtool和resolve选项的作用devtool：配置映射源（source-map）,指是否需要在浏览器中看到原始代码还是构建后的代码，如果是开发阶段，那就设置，cheap-module-source-map，开发环境设置nosources-source-map（不设置映射源）。</p><p>resolve：模块的解析方式，比如extensions-设置后缀名，这里配置的后缀名可以直接Import不用写出来；设置@为src目录名</p></blockquote><h3 id="7-你对Vite构建工具有哪些了解？它与Webpack相比有什么优势？"><a href="#7-你对Vite构建工具有哪些了解？它与Webpack相比有什么优势？" class="headerlink" title="7.你对Vite构建工具有哪些了解？它与Webpack相比有什么优势？"></a>7.你对Vite构建工具有哪些了解？它与Webpack相比有什么优势？</h3><blockquote><p>Vite是新一代前端构建工具，相较于Webpack，它最主要的就是直接按需编译服务器的代码（热更新的时候也是只重新编译变化二的文件），导致项目的运行会更快</p></blockquote><h1 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h1><h3 id="1-v-show和v-if的区别"><a href="#1-v-show和v-if的区别" class="headerlink" title="1.v-show和v-if的区别"></a>1.v-show和v-if的区别</h3><blockquote><p>两者都是用来显示隐藏元素的，区别如下：</p><ol><li>从原理上来看：v-show是通过控制display的值来显示和隐藏的；而v-if是通过对DOM元素的添加和删除实现显示和隐藏的</li><li>从性能上来说，v-show性能优于v-if，有以下原因：<ul><li>既然v-if是直接对DOM操作的，性能较低，效率低，而v-show效率高</li><li>如果DOM标签包含事件，v-if的显示和隐藏会涉及事件的绑定以及解绑；如果DOM标签包含组件，v-if还会涉及到组件的编译、实例化、渲染以及挂载。而v-show仅仅是简单的CSS样式切换。</li></ul></li></ol></blockquote><h3 id="2-如何理解MVVM的？"><a href="#2-如何理解MVVM的？" class="headerlink" title="2.如何理解MVVM的？"></a>2.如何理解MVVM的？</h3><blockquote><p>它是一种软件架构（相当于文章的大纲）模式，全称是Model-View-ViewModel，这三个部分实现了</p><ol><li>前端可以临时存储数据（前后端分离之前都是用的MVC模式，数据只能依赖后端，通过C-Controller分发数据）</li><li>将数据和视图进行双向绑定：用户可以修改View数据，ViewModel可监听到并通知Model数据的修改；同时，ViewModel也可以将Model数据的修改更新到View上。整个过程是自动地，无需认为操作。</li></ol><p>Ps：这个问题后续估计会提问：v-model的实现原理（MVVM的具体技术）、响应式原理，面试官不问就不用说那么多，对于MVVM就讲个 定义-&gt;历史（与MVC的关系）-&gt;功能。</p></blockquote><h3 id="3-v-for中的key有什么作用？"><a href="#3-v-for中的key有什么作用？" class="headerlink" title="3.v-for中的key有什么作用？"></a>3.v-for中的key有什么作用？</h3><blockquote><p>key是DOM元素的唯一标识</p><p>作用：主要就是用来辅助虚拟DOM比对新旧节点来复用DOM元素，提高性能，否则就会胡乱地就地复用，增加不必要的重新渲染。</p><p>使用key的注意点：要确保key值唯一，并且不要使用自带的index作为key值（仍然会出现胡乱地就地复用，比如列表原来index 0-1-2，在首部添加一个元素，会把后面的元素往后顶，但index值不变，0-1-2-3，出现了混乱复用）</p><p><u>思路</u>：在回答xxx有什么作用时，模板：定义-&gt;作用（先解释是什么，再说有什么作用）-&gt;如何使用</p></blockquote><h3 id="4-说一下你对生命周期的理解"><a href="#4-说一下你对生命周期的理解" class="headerlink" title="4.说一下你对生命周期的理解"></a>4.说一下你对生命周期的理解</h3><blockquote><ol><li>beforeCreate：实例创建之前，此时 数据、方法无法访问</li><li>created：实例创建完成，已经完成了<strong>数据监测</strong>（数据劫持–数据的准备工作），可以修改数据但是不会更新到页面，因为还没挂载</li><li>beforeMount：挂载之前，完成了<strong>模板编译</strong>（具体见下面），生成了虚拟DOM，即将渲染页面</li><li>mounted：页面已经渲染完成并挂载到页面，可以访问DOM元素也可以发送异步请求（目的是得到数据给页面展示，由于页面已经初始化就可以把数据放心放在页面了–但是可能会<strong>卡顿</strong>，见下面）</li><li>beforeUpdate：页面更新之前，数据是新的，但页面是旧的</li><li>Updated：页面已经更新完毕，此时不要修改数据，已经为时已晚</li><li>beforeDestory：销毁之前，这里可以销毁定时器等</li><li>destoryed：已销毁</li></ol><p>keep-alive组件缓存专属（通常用在路由组件的缓存）：</p><ul><li>activiated：激活时</li><li>deactiviated：销毁时（处理定时器一些需要销毁的东西）</li></ul></blockquote><h3 id="5-模板编译的原理"><a href="#5-模板编译的原理" class="headerlink" title="5.模板编译的原理"></a>5.模板编译的原理</h3><blockquote><ol><li>解析模板生成AST（抽象语法树 Abstract Async Tree），它是一种树状结构，描述了模板中模板字符串、指令等模板语法之间的关系</li><li>对AST进行静态标记（Vue3才提出来的内容），指出哪些元素是静态的，告知虚拟DOM哪些元素不需进行比对，为虚拟DOM的工作减轻了负担 </li><li>针对AST生成render函数，一旦执行render函数，就会生成虚拟DOM</li></ol></blockquote><h3 id="6-Vue3生命周期有哪些变化？"><a href="#6-Vue3生命周期有哪些变化？" class="headerlink" title="6.Vue3生命周期有哪些变化？"></a>6.Vue3生命周期有哪些变化？</h3><blockquote><ol><li>用setup函数代替了beforeCreate和created（如果要打印sepup函数和beforeCreate，sepup比beforeCreate还先执行）</li><li>其他函数前面都加上了on，更易于理解</li><li>beforeDestory、destoryed -&gt;onBeforeUnMounted、onUnMounted，与挂载一一对应</li></ol></blockquote><h3 id="7-父子生命周期函数的执行顺序"><a href="#7-父子生命周期函数的执行顺序" class="headerlink" title="7.父子生命周期函数的执行顺序"></a>7.父子生命周期函数的执行顺序</h3><blockquote><ul><li><p>实例化、挂载</p><p>父beforeCreate-&gt;父created-&gt;父beforeMount-&gt;子beforeCreate-&gt;子created-&gt;子beforeMount-&gt;子mounted-&gt;父mounted（必须要实例所有内容包括子组件准备完毕才能挂载）</p></li><li><p>父组件更新</p><p>父beforeUpdate-&gt;父Updated</p></li><li><p>子组件更新</p><p>父beforeUpdate-&gt;子beforeUpdate-&gt;子Updated-&gt;父Updated</p></li><li><p>子组件销毁</p><p>父beforeDestory-&gt;子beforeDestory-&gt;子destoryed -&gt;父destoryed </p></li></ul><p><u>原则</u>：子组件是父组件的一部分，因此碰到子组件会连带父组件，反过来不会</p></blockquote><h3 id="8-在created和mounted中请求数据有什么不同？"><a href="#8-在created和mounted中请求数据有什么不同？" class="headerlink" title="8.在created和mounted中请求数据有什么不同？"></a>8.在created和mounted中请求数据有什么不同？</h3><blockquote><p>created：在页面渲染之前</p><p>mounted：在页面渲染之后</p><p>使用场景：如果请求的数据 和DOM有关—-&gt;放在created中</p><p>​                                               和DOM无关—–&gt;放在mounted中</p><p>推荐放在created，有以下理由：</p><ul><li>更早地获取到服务端数据，减少loading时间（卡顿）</li><li>服务端渲染SSR（见下面）不支持mounted，可以保持统一性</li></ul></blockquote><h3 id="9-什么是服务端渲染（SSR）？"><a href="#9-什么是服务端渲染（SSR）？" class="headerlink" title="9.什么是服务端渲染（SSR）？"></a>9.什么是服务端渲染（SSR）？</h3><blockquote><p>就是 将浏览器端执行js代码的工作 放在服务端来做，服务端处理完，返回HTML字符串给浏览器，这么做有以下好处：</p><ul><li>浏览器减少了负担，加快了首屏加载速度</li><li>由于页面加载速度快了，也有助于SEO</li></ul></blockquote><h3 id="10-Vue中修饰符有哪些？"><a href="#10-Vue中修饰符有哪些？" class="headerlink" title="10.Vue中修饰符有哪些？"></a>10.Vue中修饰符有哪些？</h3><blockquote><ol><li>事件修饰符<ul><li><p>.capture：事件捕获模式，先触发当前事件再触发内部事件（传播方式默认是事件冒泡）</p></li><li><p>.self：只会触发当前事件，不会被事件传播而影响被触发</p></li><li><p>.stop：阻止事件冒泡</p></li><li><p>.once：有且仅触发一次</p></li><li><p>.passive（消极-任由继续往后找）：不阻止/触发默认行为</p></li><li><p>.prevent：阻止默认行为</p></li><li><p>.native：仅触发原生事件，这些事件Vue没有，因为不常用</p><p>使用场景：由于自定义组件只能触发自定义事件，想要触发原生js事件就要加上.native</p></li></ul></li><li>v-model修饰符<ul><li>.number：将输入转化为数字</li><li>.trim：出入完去掉空格</li><li>.lazy：可以等输入完再触发事件（请求），类似函数防抖</li></ul></li><li>键盘修饰符<ul><li>.keyup</li><li>.keydown</li></ul></li><li>系统修饰符<ul><li>.ctrl</li><li>.alt</li></ul></li><li>鼠标修饰符<ul><li>.left</li><li>.middle</li><li>.right</li></ul></li></ol><p><u>思路</u>：事件修饰符（寻找亲戚：事件传播-近邻，默认行为-远亲，原生-远远亲）-&gt;键盘相关（表单（输入是为了触发请求，而lazy可以懒触发）-&gt;特殊）-&gt;鼠标</p></blockquote><h3 id="11-elementUI怎么做表单验证的？"><a href="#11-elementUI怎么做表单验证的？" class="headerlink" title="11.elementUI怎么做表单验证的？"></a>11.elementUI怎么做表单验证的？</h3><blockquote><ul><li>内置规则：在表单添加rules属性，rules中的每个表单项规则按照文档来</li><li>自定义规则：比如自己写个邮件验证的规则，然后放入validator属性中</li></ul></blockquote><h3 id="12-Vue中的组件通信有哪些？"><a href="#12-Vue中的组件通信有哪些？" class="headerlink" title="12.Vue中的组件通信有哪些？"></a>12.Vue中的组件通信有哪些？</h3><blockquote><ul><li><p>父子通信</p><p>props：父-&gt;子，$emit：子-&gt;父</p><p>$parent、$children：强制性获取父组件（如果有多个，那么是最近的一个父组件，如果有很多级都不推荐用这个了）、子组件们（$children是个数组而$parent不是）的实例进行通信，获取到实例的属性或方法可以互传</p><p>$refs：几乎等同于$children，相比$children，优点是可以针对性获取实例，独立性更高</p></li><li><p>跨级通信</p><p>$attrs、$listeners：为了解决利用props的A-&gt;B-&gt;C逐层传递的臃肿问题而出现，A可以把多个数据、回调同时传递给B，B直接再把$attrs、$listeners传递给C即可，不需要先接受再命名传递（注意$attrs是除了B的props以外的数据，因为A可能有专门传递给B用的数据）</p><p>provide、inject（Vue2、Vue3都可以使用，不是Vue3特有的）：只能由上往下跨级传递，不能由下往上且不能同级传递，需统一数据流方向，否则不方便维护</p></li><li><p>同级通信</p><p>eventBus/发布订阅：和provide、inject一样有维护不便的问题</p><p>vuex</p></li></ul></blockquote><h3 id="13-为什么Vue中尽量使用箭头函数而不是传统函数？"><a href="#13-为什么Vue中尽量使用箭头函数而不是传统函数？" class="headerlink" title="13.为什么Vue中尽量使用箭头函数而不是传统函数？"></a>13.为什么Vue中尽量使用箭头函数而不是传统函数？</h3><blockquote><p>因为 传统函数 内部访问this默认指向的是 window，而箭头函数往外找this是找的是当前Vue实例的this，如果非要用传统函数，可以在外面手动定义一个新的this值为当前Vue实例 或者 直接用bind修改为当前Vue实例</p><p>问题如下图：</p><p><img src="/2024/01/03/%E5%89%8D%E7%AB%AF%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%9F%BA%E7%A1%80/Vue%E4%B8%AD%E4%BC%A0%E7%BB%9F%E5%87%BD%E6%95%B0this%E6%8C%87%E5%90%91.png" alt="传统函数this指向问题"></p><p>解决方法1：将当前对象的this保存为一个变量</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  data () &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-attr">left</span>: -<span class="hljs-number">9999</span>,<br>      <span class="hljs-attr">bottom</span>: -<span class="hljs-number">9999</span><br>    &#125;<br>  &#125;,<br>  <span class="hljs-attr">methods</span>: &#123;<br>    <span class="hljs-attr">cancelMask</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">var</span> that = <span class="hljs-variable language_">this</span>;<br>      <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        that.<span class="hljs-property">bottom</span> = <span class="hljs-number">0</span>;<br>        that.<span class="hljs-property">left</span> = <span class="hljs-number">0</span>;<br>      &#125;, <span class="hljs-number">500</span>);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>解决方法2：是用箭头函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  data () &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-attr">left</span>: -<span class="hljs-number">9999</span>,<br>      <span class="hljs-attr">bottom</span>: -<span class="hljs-number">9999</span><br>    &#125;<br>  &#125;,<br>  <span class="hljs-attr">methods</span>: &#123;<br>    <span class="hljs-attr">cancelMask</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">bottom</span> = <span class="hljs-number">0</span>;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">left</span> = <span class="hljs-number">0</span>;<br>      &#125;, <span class="hljs-number">500</span>);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2024/01/03/%E5%89%8D%E7%AB%AF%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%9F%BA%E7%A1%80/Vue%E4%B8%AD%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0this%E6%8C%87%E5%90%91.png" alt="是用箭头函数解决问题"></p></blockquote><h3 id="14-keep-alive组件是什么？如何使用的"><a href="#14-keep-alive组件是什么？如何使用的" class="headerlink" title="14.keep-alive组件是什么？如何使用的?"></a>14.keep-alive组件是什么？如何使用的?</h3><blockquote><p>它是Vue内置组件，可以对组件进行缓存，在组件进行切换时不需要销毁。</p><p>用keep-alive包裹组件，并利用include、exclude指定哪些组件需要缓存和不需要缓存的组件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;keep-live :include=组件数组 :exclude=组件数组&gt;<br>...<br>&lt;/keep-live&gt;<br></code></pre></td></tr></table></figure><p>好处就是 缓存活跃的组件，不需要重新渲染，提高性能以及用户体验</p></blockquote><h3 id="15-Vue路由怎么传参的？"><a href="#15-Vue路由怎么传参的？" class="headerlink" title="15.Vue路由怎么传参的？"></a>15.Vue路由怎么传参的？</h3><blockquote><ul><li><p>params参数：用于传递一些必要的参数，没有这个参数路由都无法匹配，例如用户ID，商品ID，必须要这个参数才能正常加载组件的</p><p>需要在路由配置动态URL片段，如/user/:id，刷新后params参数会丢失，因为刷新后路由初始化，路由都无法匹配了，参数当然也没了</p></li><li><p>query参数：用于传递一些非必要的参数，比如搜索框的关键字，可以传也可以不传，不传就搜索所有数据</p><p>刷新后路由能正常匹配，于是查询字符串的query参数也能保存，类似于get参数会显示在URL上</p><p>params参数、query参数都可以通过对象的形式传参，获取方式也类似</p></li><li><p>props传参：用于传递组件自身需要的一些复杂属性，比如父子通过路由传值</p><p>要在路由文件中加上props，再在子组件中用props接受，这种方式更加灵活，可以选择传什么类型的参数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 传递params参数 </span><br><span class="hljs-keyword">const</span> routes = [<br>   &#123;<br>     <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/user/:id&#x27;</span>,<br>     <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;user&#x27;</span>,<br>     <span class="hljs-attr">component</span>: <span class="hljs-title class_">UserComponent</span>,<br>     <span class="hljs-attr">props</span>: <span class="hljs-literal">true</span><br>   &#125;<br> ];<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;template&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>User ID: &#123;&#123; id &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&lt;/template&gt;<br>  <br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">props</span>: [<span class="hljs-string">&#x27;id&#x27;</span>]</span></span><br><span class="language-javascript"><span class="language-xml">&#125;;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 对象形式传参 更灵活</span><br><span class="hljs-keyword">const</span> routes = [<br>   &#123;<br>     <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/user/:id&#x27;</span>,<br>     <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;user&#x27;</span>,<br>     <span class="hljs-attr">component</span>: <span class="hljs-title class_">UserComponent</span>,<br>     <span class="hljs-attr">props</span>: <span class="hljs-function"><span class="hljs-params">route</span> =&gt;</span> (&#123;<br>       <span class="hljs-attr">userId</span>: route.<span class="hljs-property">params</span>.<span class="hljs-property">id</span> <span class="hljs-comment">// 这里指明传params参数</span><br>     &#125;)<br>   &#125;<br> ];<br></code></pre></td></tr></table></figure></li></ul></blockquote><h3 id="16-什么是单页面应用（SPA）？"><a href="#16-什么是单页面应用（SPA）？" class="headerlink" title="16.什么是单页面应用（SPA）？"></a>16.什么是单页面应用（SPA）？</h3><blockquote><p>是指整个应用只有一个HTML文件，页面的内容会根据用户的交互动态地呈现。</p><p>单页面应用（SPA）主要是利用前端路由来实现的：通过监听路由的URL变化来加载不同的组件，从而实现动态地更新内容。</p></blockquote><h3 id="17-Vue中的hash模式和history模式有什么区别？"><a href="#17-Vue中的hash模式和history模式有什么区别？" class="headerlink" title="17.Vue中的hash模式和history模式有什么区别？"></a>17.Vue中的hash模式和history模式有什么区别？</h3><blockquote><p>两者都是单页面应用的实现方式，即路由变化不会导致页面的刷新而是局部内容的更新</p><p><strong>原理上</strong></p><ul><li><p>hash模式：URL有#，利用onhashchange事件去监听URL的hash部分（也就是#后面的部分）的变化，来去匹配路由规则加载对应的组件（前进和后退也是一样的）</p></li><li><p>history模式：利用HTML5的API——–pushState和replaceState来记录浏览器历史记录栈的内容以及修改URL地址，每一次URL跳转新的路由都会利用pushState将路由和对应页面状态信息添加到浏览器历史记录栈，然后再用replaceState修改当前URL地址</p></li></ul><p><strong>是否会像服务器发送请求</strong></p><ul><li><p>hash模式：路由的变化、匹配和加载组件都是在浏览器进行的，不会向服务器发送请求</p></li><li><p>history模式：在刷新页面的时候会把当前URL当作一个资源请求地址，如果后端没有支持相应的请求，会报404错误</p><p>如何解决？</p><p>在服务器配置一个默认的退回页面，比如登陆页面，这样任何匹配不到的请求都退回到登陆页面</p></li></ul><p><strong>补充：</strong></p><p>Vue中还有一个模式：Memory模式</p><p>会把路由信息放在内存当中，浏览器的URL变化不会有任何反应，也无法使用前进后退功能</p><p>适合非浏览器环境，比如SSR服务端渲染</p></blockquote><h3 id="18-路由是怎么拦截的？"><a href="#18-路由是怎么拦截的？" class="headerlink" title="18.路由是怎么拦截的？"></a>18.路由是怎么拦截的？</h3><blockquote><p>在哪拦截：路由守卫中</p><p>如何拦截？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 1.路由配置中在meta添加自定义属性来判断</span><br>&#123;<br><span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;index.html&#x27;</span>,<br><span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;index&#x27;</span>,<br><span class="hljs-attr">mata</span>:&#123;<br>  <span class="hljs-attr">reuqiredAuth</span>:<span class="hljs-literal">true</span>  <br>&#125;<br>&#125;<br><span class="hljs-comment">// 2.路由守卫中判断</span><br>router.<span class="hljs-title function_">beforeEach</span>(<span class="hljs-function">(<span class="hljs-params"><span class="hljs-keyword">from</span>,to,next</span>)=&gt;</span>&#123;<br> <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">route</span>.<span class="hljs-property">meta</span>.<span class="hljs-property">reuqiredAuth</span>)&#123;<br>   <span class="hljs-keyword">if</span>(store.<span class="hljs-property">state</span>.<span class="hljs-property">token</span>)&#123;<br>     <span class="hljs-title function_">next</span>()<br>  &#125;<br>&#125;<br>&#125;)<br></code></pre></td></tr></table></figure></blockquote><h3 id="19-如果路由中一个路由对象同时有redirect和component，Vue-Router会如何处理？"><a href="#19-如果路由中一个路由对象同时有redirect和component，Vue-Router会如何处理？" class="headerlink" title="19.如果路由中一个路由对象同时有redirect和component，Vue Router会如何处理？"></a>19.如果路由中一个路由对象同时有redirect和component，Vue Router会如何处理？</h3><blockquote><p>会优先使用redirect的组件，因为有重定向会立刻导航并加载重定向路径的组件，而忽视当前的组件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> routes = [<br>&#123;<br> <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/example&#x27;</span>,<br> <span class="hljs-attr">component</span>: <span class="hljs-title class_">ExampleComponent</span>, <span class="hljs-comment">// 示例组件</span><br> <span class="hljs-attr">redirect</span>: <span class="hljs-string">&#x27;/redirected&#x27;</span> <span class="hljs-comment">// 重定向路径</span><br>&#125;,<br>&#123;<br> <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/redirected&#x27;</span>,<br> <span class="hljs-attr">component</span>: <span class="hljs-title class_">RedirectedComponent</span> <span class="hljs-comment">// 重定向后显示的组件</span><br>&#125;<br>]<br></code></pre></td></tr></table></figure><p>会加载RedirectedComponent</p></blockquote><h3 id="20-路由有哪些守卫钩子，又是如何解析的？"><a href="#20-路由有哪些守卫钩子，又是如何解析的？" class="headerlink" title="20.路由有哪些守卫钩子，又是如何解析的？"></a>20.路由有哪些守卫钩子，又是如何解析的？</h3><blockquote><p><strong>分类</strong></p><p>先说下所有的钩子函数：全局守卫、路由独享路由、组件守卫。</p><p><strong>完整的导航解析流程</strong></p><ul><li><p>导航被触发，比如router.push()、router.replace()</p></li><li><p>调用失活组件（上一个组件）的beforeRouteLeave守卫</p></li><li><p>调用全局前置守卫beforeEach，在这可以添加一些登录验证，这是验证是全局的，也就是它针对所有路由</p></li><li><p>调用重用组件的beforeRouteUpdate守卫，这个守卫专门在路由 的组件复用时（页面的输入以及数据都还是上一次的状态）调用，如果有路由的组件复用，调用完该守卫更新完毕就不会调用后面的守卫了</p><p>如何路由切换时进行组件复用？配合路由的自定义属性meta和keeep-alive组件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> routes = [<br>    &#123;<br>        <span class="hljs-comment">// 这种带动态params参数的都建议缓存，因为会多次使用</span><br>        <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/foo/:id&#x27;</span>,<br>        <span class="hljs-attr">component</span>: <span class="hljs-title class_">Foo</span>,<br>        <span class="hljs-attr">meta</span>: &#123; <span class="hljs-attr">keepAlive</span>: <span class="hljs-literal">true</span> &#125; <span class="hljs-comment">// 这个组件会被缓存</span><br>    &#125;,<br>    &#123;<br>        <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/bar&#x27;</span>,<br>        <span class="hljs-attr">component</span>: <span class="hljs-title class_">Bar</span>,<br>        <span class="hljs-attr">meta</span>: &#123; <span class="hljs-attr">keepAlive</span>: <span class="hljs-literal">false</span> &#125; <span class="hljs-comment">// 没有设置 meta.keepAlive 或其值为 false，则组件不会被缓存</span><br>    &#125;<br>    <span class="hljs-comment">// ... 其他路由配置</span><br>];<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;template&gt;<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">keep-alive</span> <span class="hljs-attr">:include</span>=<span class="hljs-string">&quot;cachedViews&quot;</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">router-view</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">router-view</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">keep-alive</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&lt;/template&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;App&#x27;</span>,</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-keyword">return</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">                <span class="hljs-attr">cachedViews</span>: [] <span class="hljs-comment">// 存储需要缓存的组件名</span></span></span><br><span class="language-javascript"><span class="language-xml">            &#125;;</span></span><br><span class="language-javascript"><span class="language-xml">        &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-attr">watch</span>: &#123;</span></span><br><span class="language-javascript"><span class="language-xml">            $route(to, <span class="hljs-keyword">from</span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-comment">// 过滤出需要缓存的组件，即 meta.keepAlive = true 的组件</span></span></span><br><span class="language-javascript"><span class="language-xml">                <span class="hljs-keyword">const</span> keepAliveComponent = to.<span class="hljs-property">matched</span>.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">record</span> =&gt;</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">                    <span class="hljs-keyword">return</span> record.<span class="hljs-property">meta</span> &amp;&amp; record.<span class="hljs-property">meta</span>.<span class="hljs-property">keepAlive</span>;</span></span><br><span class="language-javascript"><span class="language-xml">                &#125;);</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">                <span class="hljs-keyword">if</span> (keepAliveComponent.<span class="hljs-property">length</span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">                <span class="hljs-comment">// 把需要缓存的组件的name放到cachedViews集合里，注意要的是组件的name</span></span></span><br><span class="language-javascript"><span class="language-xml">                    <span class="hljs-variable language_">this</span>.<span class="hljs-property">cachedViews</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">cachedViews</span>.<span class="hljs-title function_">concat</span>(keepAliveComponent.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">record</span> =&gt;</span> record.<span class="hljs-property">name</span>));</span></span><br><span class="language-javascript"><span class="language-xml">                &#125; <span class="hljs-keyword">else</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">                    <span class="hljs-keyword">const</span> index = <span class="hljs-variable language_">this</span>.<span class="hljs-property">cachedViews</span>.<span class="hljs-title function_">indexOf</span>(to.<span class="hljs-property">name</span>);</span></span><br><span class="language-javascript"><span class="language-xml">                    <span class="hljs-keyword">if</span> (index &gt; -<span class="hljs-number">1</span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">                        <span class="hljs-variable language_">this</span>.<span class="hljs-property">cachedViews</span>.<span class="hljs-title function_">splice</span>(index, <span class="hljs-number">1</span>);</span></span><br><span class="language-javascript"><span class="language-xml">                    &#125;</span></span><br><span class="language-javascript"><span class="language-xml">                &#125;</span></span><br><span class="language-javascript"><span class="language-xml">            &#125;</span></span><br><span class="language-javascript"><span class="language-xml">        &#125;</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure></li><li><p>调用路由独享的守卫beforeEnter守卫，路由独享的守卫就这一个，专门为跳转当前路由之前做一些逻辑，比如也可以做登录验证，只是这个验证只针对当前路由</p></li><li><p>下面到了异步组件（使用import关键字加载的组件，在需要时才加载，要分为 路由中和组件中 使用两种）的解析阶段</p><p>异步组件返回的是一个Promise，成功后返回的是一个组件对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 组件中(Vue2)，Vue3需要将下面的代码放入defineAsyncComponent在里面的回调函数</span><br>&lt;script&gt;<br><span class="hljs-comment">// 返回Promise</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">AsyncComponent</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">async</span> () =&gt; &#123;<br>      <span class="hljs-keyword">const</span> <span class="hljs-title class_">MyComp</span> = <span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&quot;./MyComp.vue&quot;</span>);<br>      <span class="hljs-title function_">resolve</span>(<span class="hljs-title class_">MyComp</span>);<br>    &#125;, <span class="hljs-number">3000</span>);<br>  &#125;);<br>&#125;;<br><br><span class="hljs-comment">// 返回Promise</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">AsyncComponent2</span> = (<span class="hljs-params"></span>) =&gt; <span class="hljs-keyword">import</span>(<span class="hljs-string">&quot;./MyComp.vue&quot;</span>)<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-attr">components</span>: &#123;<br>    <span class="hljs-comment">// Vue会调用该函数，并等待 Promise完成，完成之前该组件位置什么也不渲染</span><br>    <span class="hljs-title class_">AsyncComponent</span>,<br>  &#125;,<br>&#125;;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 路由中</span><br>&#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Home&quot;</span>,<br>  <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/&quot;</span>,<br>  <span class="hljs-comment">// webpackChunkName 用于分包，注释就是这样的语法，用于给代码分割命名，具体需要看webPack的性能优化补充</span><br>  <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-comment">/* webpackChunkName: &quot;home&quot; */</span> <span class="hljs-string">&quot;@/views/Home&quot;</span>),<br>  <span class="hljs-attr">meta</span>: &#123; <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;首页&quot;</span> &#125;,<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>调用激活（默认使用了keep-alive组件，否则就是指目标组件）组件的beforeRouteEnter守卫，在该守卫中还没有实例化（有点类似beforeCreate），无法使用this，可准备好异步数据给激活的组件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;template&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>User Profile for &#123;&#123; userId &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&lt;/template&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">return</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">userId</span>: <span class="hljs-literal">null</span>,</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;;</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-title function_">beforeRouteEnter</span>(<span class="hljs-params">to, <span class="hljs-keyword">from</span>, next</span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// 可以通过 to.params 获取路由参数</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">const</span> userId = to.<span class="hljs-property">params</span>.<span class="hljs-property">id</span>;</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// 模拟异步数据加载，例如从 API 获取用户数据</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-comment">// 在这个回调里面已经实例化了 </span></span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-title function_">next</span>(<span class="hljs-function"><span class="hljs-params">vm</span> =&gt;</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-comment">// vm 是组件实例</span></span></span><br><span class="language-javascript"><span class="language-xml">        vm.<span class="hljs-property">userId</span> = userId; <span class="hljs-comment">// 将 userId 赋值给组件实例</span></span></span><br><span class="language-javascript"><span class="language-xml">      &#125;);</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;, <span class="hljs-number">1000</span>);</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">&#125;;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure></li><li><p>调用全局解析守卫beforeResolve，该守卫是解析的最后一步，也可以获取异步数据，只是这个数据一般是可能其他组件也要使用，比如用户的信息放入仓库</p></li><li><p>导航被确认。为什么要确认一下？表示要进入 下面路由的信息已经准备好</p></li><li><p>调用全局后置守卫afterEach，目标路由已经跳转结束，可处理一些收尾工作，比如跳转到目标页面的对应位置</p></li><li><p>目标组件DOM渲染</p></li><li><p>调用全局前置守卫beforeRouteEnter的回调函数next(()=&gt;{})（调用next里面的回调函数时已经实例化），并把实例作为参数传递给组件路由的下一阶段使用（意思就是说组件已经渲染好了进入该组件的钩子也该结束了，可能要去beforeRouteLeave了）</p></li></ul></blockquote><h3 id="21-说一下Vue的动态路由"><a href="#21-说一下Vue的动态路由" class="headerlink" title="21.说一下Vue的动态路由"></a>21.说一下Vue的动态路由</h3><blockquote><p>动态路由是指加了权限控制的路由，最终实现的效果是：不同用户登陆后，显示不同的菜单功能，因为不同用户有不同权限</p><p>如何实现，大致分以下几步：</p><ol><li>登陆后获取用户的权限信息，比如角色信息</li><li>在路由配置中提前写好静态路由（不需要权限就可以访问的）和预制动态路由（admin所有能访问的路由），预制动态路由中必须要加上meta属性，包括icon（菜单图标）、title（菜单标题）、role（角色）等</li><li>用获取到的用户权限信息到预制动态路由中匹配，去找当前角色能访问的菜单功能，并最终重新生成一个新的路由</li><li>利用新的路由进行循环展示sideBar</li></ol></blockquote><h3 id="22-如何解决动态路由在刷新后二次加载路由（动态路由做权限管理碰到的问题）？"><a href="#22-如何解决动态路由在刷新后二次加载路由（动态路由做权限管理碰到的问题）？" class="headerlink" title="22.如何解决动态路由在刷新后二次加载路由（动态路由做权限管理碰到的问题）？"></a>22.如何解决动态路由在刷新后二次加载路由（动态路由做权限管理碰到的问题）？</h3><blockquote><p>使用动态路由做权限管理时通常会出现两个问题：</p><ul><li><p>动态路由添加后刷新 出现404/白屏</p><p><strong>原因：</strong>本来登录后把添加的路由会放入vuex中，然后在跳转首页时在beforeEnter里面会使用router.addRoute配合循环（vue2的addRoutes已经弃用了）动态添加路由，然后next()放行并展示 添加的菜单。但是 刷新后 Vuex数据会丢失（不要用localStorage，因为路由是经常要变动的，放在本地没有意义），于是再进入新添加的路由，进入beforeEnter钩子时获取不到添加的路由地址，于是会出现404/白屏</p></li></ul><p>​       <strong>解决办法：</strong>在beforeEnter中加一个判断，如果vuex的路由为空，则重新生成一下动态路由，再重新添加。但是，要注意的是，由于 <strong>路由是动态添加的，而路由匹配是在beforeEnter之前做的事情</strong>（匹配到了才准备进入），因此next放行是需要使用next({ …to（把目标路由地址展开） replace: true })：其实就是让它再走一遍 路由匹配和beforeEnter，再放行，其中replace是指不希望用户后退使用后退操作，因为可能前一个页面也是动态添加的，那回退也是404/白屏啊</p><ul><li>不同用户登录后，动态路由会重复添加</li></ul><p>​       <strong>原因：</strong>不同用户登录后前一个用户动态添加的路由不会删除</p><p>​       <strong>解决办法：在动态添加路由之前使用空的路由对象的matcher替换当前路由对象的matcher</strong></p><p>​       router.matcher = new Router({ mode: ‘history’, base: ‘s-connect’, routes: [] }).matcher这么做的效果是：把路由配置可以重新替换而不是追加。</p></blockquote><h3 id="23-Vuex数据刷新后会丢失吗？怎么解决？"><a href="#23-Vuex数据刷新后会丢失吗？怎么解决？" class="headerlink" title="23.Vuex数据刷新后会丢失吗？怎么解决？"></a>23.Vuex数据刷新后会丢失吗？怎么解决？</h3><blockquote><p>会，因为Vuex中的数据是放在运行时内存中的，一旦刷新就得重新初始化。</p><p><strong>解决方法</strong>：使用浏览器缓存来存储，比如localStorage，一旦在Vuex获取到数据后便放入localStorage，然后监听浏览器刷新事件，一旦刷新了，在里面就用localStorage的数据</p></blockquote><h3 id="24-Watch和computed的区别？"><a href="#24-Watch和computed的区别？" class="headerlink" title="24.Watch和computed的区别？"></a>24.Watch和computed的区别？</h3><blockquote><p>要看区别主要要从 用途上以及过程上来看：<strong>computed是来计算data中的属性的，而watch是来监听属性并处理一些逻辑的。</strong></p><ol><li>computed函数需要return，而watch不用，因为它不一定需要返回展示</li><li>页面初始化时，computed是会计算的，而watch并不会，因为它不需要像computed立马需要展示computed不支持异步，还是一样需要赶快展示，而watch执行的回调本来就是请求数据去的，这就是异步的</li><li>computed支持缓存，即数据变化时才会重新计算（为了性能），而watch不会，因为依赖用户的交互值，每次都会变</li></ol><p><u>思路</u>：用途+使用的时间顺序</p></blockquote><h3 id="25-Vuex在什么场景下会使用？有什么属性？"><a href="#25-Vuex在什么场景下会使用？有什么属性？" class="headerlink" title="25.Vuex在什么场景下会使用？有什么属性？"></a>25.Vuex在什么场景下会使用？有什么属性？</h3><blockquote><p>场景：在需要数据共享的时候，比如用户信息</p><p>包括以下属性：</p><ul><li>Actions：请求异步数据，执行mutations函数</li><li>Mutations：直接修改state中的数据</li><li>State:存储数据的地方</li><li>Getters：state数据的计算属性</li></ul></blockquote><h3 id="26-Vue双向数据绑定原理是什么（100-会问）？"><a href="#26-Vue双向数据绑定原理是什么（100-会问）？" class="headerlink" title="26.Vue双向数据绑定原理是什么（100%会问）？"></a>26.Vue双向数据绑定原理是什么（100%会问）？</h3><blockquote><p><strong>1、先说一下双向绑定的组成部分：</strong></p><p>它包含view、model、view model三个部分，其中最重要的就是view model，使它实现的view和model的关联，双向绑定的原理最主要的就是view model的原理。</p><p>那view model它又包含两个部分，编译器和监听器，编译器实现view的变化影响model的变化，而model的变化影响view的变化是需要 【监听器+编译器】 一起实现的，后者其实就是指的是响应式。</p><p><strong>2、下面说响应式是怎么实现的（要用到监听器和编译器）：</strong></p><p>一开始该组件的的vue实例在初始化时对data数据进行响应式处理，这个过程发生在监听器中，在defineReactive中的Object.defineproperty进行数据劫持时会为每一个data中的属性创建一个Dep实例（订阅器），这个是依赖管理器，依赖是什么？指的是该数据以及该数据相关的所有数据比如computed计算属性、监听器watch等，为什么要收集？因为要知道哪些数据后面可能要更新。</p><p>然后在编译器里，会开始寻找模版上的动态数据，比如指令、插值语法什么的，并初始化视图，一旦发现模版上有使用data中的动态数据，此时就会调用数据劫持中的getter函数，同时为每一个依赖创建watcher，它是订阅者，来订阅Dep啥时候通知它数据变化了，它会为依赖绑定一个更新函数，为后续的更新做准备，这时Dep就会开始收集响应数据的watcher。一旦数据发生变化了，就会触发数据劫持的getter函数，此时Dep就会通知相应的watcher叫它执行相应的更新函数来实现响应式。watcher是怎么更新的，更新的策略是什么？一般来说，它会主动要求调度者scheduler将自己放到一个执行队列中（同一个数据值更新一次），在下一个事件（nextTick）循环统一进行更新（DOM修改是微任务，DOM更新是宏任务，下一次事件循环指的是宏任务DOM更新，而DOM修改是微任务是微任务是因为需要提前为DOM更新做准备）。这么做有以下好处：</p><ol><li><p>确保更新的顺序（队列先进先出）</p></li><li><p>避免了频繁更新带来的性能问题</p></li></ol><p><strong>3、上面只是说了响应式的原理，下面说说编译器又如何让view的变化来影响model的：</strong></p><p>主要是通过在编译时对于使用到的事件的处理，通过事件可以让用户的操作影响到model中的数据，然后再通过上面的响应式，这就实现了双向绑定。</p></blockquote><h3 id="27-了解虚拟DOM和Diff算法吗？虚拟DOM的优缺点是什么？"><a href="#27-了解虚拟DOM和Diff算法吗？虚拟DOM的优缺点是什么？" class="headerlink" title="27.了解虚拟DOM和Diff算法吗？虚拟DOM的优缺点是什么？"></a>27.了解虚拟DOM和Diff算法吗？虚拟DOM的优缺点是什么？</h3><blockquote><p>我们手动频繁地去更新DOM是非常消耗性能的，因此就有了虚拟DOM，它是利用js对真实DOM的抽象表示，用来比对新旧节点的不同，针对不同点来更新真实DOM，这样就降低了更新DOM的频率，提高了性能。</p><p>而Diff算法就是用来给虚拟DOM比对新旧虚拟DOM的不同的，返回值是一个patch对象，它包含了所有新旧节点的不同之处。</p><p>Ps：可以把整个从头到尾的过程说一遍，从 编译-&gt;生成render函数-&gt;生成虚拟DOM-&gt;Diff算法的具体过程</p><p>优缺点：</p><ul><li>优点：减少DOM操作，提高性能</li><li>缺点：首次加载大量DOM时，还要进行虚拟DOM的计算，产生额外开销</li></ul></blockquote><h3 id="28-Vue和Jquery的区别是什么？"><a href="#28-Vue和Jquery的区别是什么？" class="headerlink" title="28.Vue和Jquery的区别是什么？"></a>28.Vue和Jquery的区别是什么？</h3><blockquote><ol><li>定义：Vue是js框架，用于构建交互式的页面；而Jquery是一个库，用于简化操作DOM、事件处理等</li><li>着重点：Vue是有双向数据绑定的概念的，数据和视图是自定更新的，因此更注重数据的处理，无需关心DOM的更新；而Jquery需要手动获取DOM并处理更新，更注重DOM的处理</li><li>前景：Vue更加流行，而Jquery在慢慢淘汰</li></ol></blockquote><h3 id="29-Vuex的响应式处理是什么？"><a href="#29-Vuex的响应式处理是什么？" class="headerlink" title="29.Vuex的响应式处理是什么？"></a>29.Vuex的响应式处理是什么？</h3><blockquote><p>Vuex是共享数据管理的工具。</p><p>Vuex的响应式处理其实就是 怎么通过修改state的值从而又更新到视图的，也就是把 修改值-&gt;获取值 的过程说一遍（非要说响应式就把响应式原理说一遍）：</p><ol><li>使用Vue.use(vuex)，调用install方法，install方法内部又调用applyMixin方法（其实就是利用mixin混入）将vuex实例挂载到Vue实例身上，这样在任意组件内都可以使用this.$store来访问了</li><li>在Vue组件内去触发dispatch来调用actions的方法，可以异步请求数据存入store，也可以调用mutations来修改state数据</li><li>mutations直接修改state中的数据</li><li>用getters对state中的数据进行计算处理，方便组件直接使用，不需要额外的计算处理</li><li>在组件中把state的数据引入到data中，借助data中数据响应式特点更新到视图中（最关键）</li></ol></blockquote><h3 id="30-Vue中常用到的遍历方法有哪些？"><a href="#30-Vue中常用到的遍历方法有哪些？" class="headerlink" title="30.Vue中常用到的遍历方法有哪些？"></a>30.Vue中常用到的遍历方法有哪些？</h3><blockquote><ul><li><p>forEach———普通遍历</p><p>元素处理</p></li><li><p>filter————-过滤元素</p></li><li><p>reduce———-累加器</p></li><li><p>map————-数据处理</p><p>元素查找和判断</p></li><li><p>findIndex——返回返回满足条件的第一个元素索引</p></li><li><p>some————有一个满足则为true</p></li><li><p>every————全部满足才为true</p></li></ul></blockquote><h3 id="31-Vue-extends-的作用是什么？和高阶组件有什么关系？"><a href="#31-Vue-extends-的作用是什么？和高阶组件有什么关系？" class="headerlink" title="31.Vue.extends()的作用是什么？和高阶组件有什么关系？"></a>31.Vue.extends()的作用是什么？和高阶组件有什么关系？</h3><blockquote><p>Vue.extends()它可以动态地去创建一个组件，并返回一个组件构造器。什么是组件构造器，其实就是组建的一个模板，一个常用的使用场景：方便高阶组件来复用和拓展。高阶组件的概念有点类似React的组件概念，动态返回一个模板页面。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 高阶组件</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">withLoadingIndicator</span>(<span class="hljs-params">WrappedComponent</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">extend</span>(&#123;<br>    <span class="hljs-attr">components</span>: &#123;<br>      <span class="hljs-title class_">WrappedComponent</span><br>    &#125;,<br>    <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-attr">loading</span>: <span class="hljs-literal">true</span>,<br>      &#125;;<br>    &#125;,<br>    <span class="hljs-title function_">mounted</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">loading</span> = <span class="hljs-literal">false</span>;<br>      &#125;, <span class="hljs-number">2000</span>); <span class="hljs-comment">// 模拟异步加载</span><br>    &#125;,<br>    <span class="hljs-attr">template</span>: <span class="hljs-string">`</span><br><span class="hljs-string">      &lt;div&gt;</span><br><span class="hljs-string">        &lt;div v-if=&quot;loading&quot;&gt;Loading...&lt;/div&gt;</span><br><span class="hljs-string">        &lt;div v-else&gt;&lt;WrappedComponent /&gt;&lt;/div&gt;</span><br><span class="hljs-string">      &lt;/div&gt;</span><br><span class="hljs-string">    `</span><br>  &#125;);<br>&#125;<br><br><span class="hljs-comment">// 使用高阶组件</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">MyComponent</span> = &#123;<br>  <span class="hljs-attr">template</span>: <span class="hljs-string">&#x27;&lt;div&gt;数据加载完毕！&lt;/div&gt;&#x27;</span>,<br>&#125;;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">EnhancedComponent</span> = <span class="hljs-title function_">withLoadingIndicator</span>(<span class="hljs-title class_">MyComponent</span>);<br><br><span class="hljs-comment">// 在 Vue 实例中使用</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br>  <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#app&#x27;</span>,<br>  <span class="hljs-attr">components</span>: &#123;<br>    <span class="hljs-title class_">EnhancedComponent</span>,<br>  &#125;,<br>  <span class="hljs-attr">template</span>: <span class="hljs-string">&#x27;&lt;EnhancedComponent /&gt;&#x27;</span>,<br>&#125;);<br></code></pre></td></tr></table></figure></blockquote><h3 id="32-封装一个可复用的组件需要注意什么？"><a href="#32-封装一个可复用的组件需要注意什么？" class="headerlink" title="32.封装一个可复用的组件需要注意什么？"></a>32.封装一个可复用的组件需要注意什么？</h3><blockquote><p>组件设计原则：</p><ul><li>组件原子化，一个组件只干一件事，各司其职</li></ul><p>除了上面的设计原则以外，这个可复用的组件要分父组件还是子组件（数据和事件的处理）：</p><ul><li>作为父组件来复用：<ol><li>把事件写在父组件中，子组件只负责触发事件，低耦合</li></ol></li><li>作为子组件来复用：<ol><li>不要在子组件请求数据，子组件一般只用来展示UI，况且要多次使用要避免多次请求数据，可以放在父组件请求</li><li>对于第一点，取而代之的是提供props来接受数据，数据流明确，便于维护</li></ol></li></ul></blockquote><h3 id="33-Vue的过滤器怎么使用？"><a href="#33-Vue的过滤器怎么使用？" class="headerlink" title="33.Vue的过滤器怎么使用？"></a>33.Vue的过滤器怎么使用？</h3><blockquote><p>Vue的过滤器 其实 就是 angular中的 管道，主要就是针对 文字进行处理，Vue中过滤器有以下两种：</p><ul><li><p>全局过滤器 ———– 任何组件都可以使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">filter</span>(<span class="hljs-string">&#x27;add&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params">v</span>)&#123; -- 全局添加一个名为add的过滤器，小于<span class="hljs-number">10</span>，则添加<span class="hljs-number">0</span><br>       <span class="hljs-keyword">return</span> v &lt; <span class="hljs-number">10</span> ? <span class="hljs-string">&#x27;0&#x27;</span>+v : v<br>&#125;)<br></code></pre></td></tr></table></figure></li><li><p>本地过滤器 ———–当前组件使用</p><p>和methods同级</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">filters</span>:&#123; ------------------------------------------- 不止一个过滤器<br>       <span class="hljs-attr">add</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params">v</span>)&#123; <br>     <span class="hljs-keyword">return</span> v &lt; <span class="hljs-number">10</span> ? <span class="hljs-string">&#x27;0&#x27;</span>+v : v<br>     &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>用法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;&#123; data | add&#125;&#125;<br></code></pre></td></tr></table></figure><p>注意：过滤器在Vue3中已经废除，因为 我们不希望在插值语法的形式太过复杂，不美观，推荐使用computed计算属性 ————- Vue3和Vue2的不同要好好记忆，很可能因为这个题被问到</p></blockquote><h3 id="34-Vue中如何做强制刷新？"><a href="#34-Vue中如何做强制刷新？" class="headerlink" title="34.Vue中如何做强制刷新？"></a>34.Vue中如何做强制刷新？</h3><blockquote><ul><li>location.reload() ————- 浏览器的API，强制重新请求服务器资源，hash模式-&gt;重新加载打包的资源，history模式-&gt;服务器没有URL的请求支持会出现404</li><li>this.router.go(0) ————- 路由器的API，只会重新加载当前组件，无论hash还是history模式，都仅仅是当前路由的重新加载，不会触发整个页面的更新</li></ul></blockquote><h3 id="35-Vue3对于Vue2有什么不同"><a href="#35-Vue3对于Vue2有什么不同" class="headerlink" title="35.Vue3对于Vue2有什么不同?"></a>35.Vue3对于Vue2有什么不同?</h3><blockquote><p>说一两个当然容易，最重要的是要有条理地全部说出来，以下是思路：</p><p>入口文件-&gt;单个组件【Vue实例（生命周期函数-&gt;setup函数-&gt;变量（响应式数据（单个响应式、深浅响应式、与非响应式的转化）、只读）-&gt;组合式API（computed和watch）-&gt;自定义API-&gt;传递数据（provide/inject））-&gt;HTML模板（Fargment-&gt;Suspend-&gt;teleport）-&gt;Style样式（动画）】</p><p>详细总结链接：<a href="https://zhoujie-lovemusic.github.io/2023/08/30/Vue3%E7%9B%B8%E5%AF%B9%E4%BA%8EVue2%E7%9A%84%E4%B8%8D%E5%90%8C%E7%94%A8%E6%B3%95/">https://zhoujie-lovemusic.github.io/2023/08/30/Vue3%E7%9B%B8%E5%AF%B9%E4%BA%8EVue2%E7%9A%84%E4%B8%8D%E5%90%8C%E7%94%A8%E6%B3%95/</a></p></blockquote><h3 id="36-Vue的性能优化有哪些？"><a href="#36-Vue的性能优化有哪些？" class="headerlink" title="36.Vue的性能优化有哪些？"></a>36.Vue的性能优化有哪些？</h3><blockquote><p><strong>组件实例</strong></p><ul><li>按需第三方插件，比如加载UI组件模块</li><li>静态资源（图片、字体等）使用CDN加载（不受浏览器并发的限制、CDN会把静态资源缓存在各个服务器中，查找时会寻找最近的服务器寻找-减少网络延迟、能够负载均衡—&gt;又快又不受带宽影响），就是不使用本地文件加载（它甚至可以针对vue.js、axios一些库添加到CDN中）</li><li>不要把太多的数据放在data中，减少过多的数据劫持添加getter、setter</li><li>对象的层级不要太多，也是减少深层次过多的数据劫持</li><li>对于一些不用的变量（比如定时器），要及时清理（内存+否则会一直执行影响页面性能）</li><li>computed和watch要区分场景使用，比如computed的缓存性能不适合频繁修改数据的</li><li>使用防抖和节流来避免频繁触发事件</li><li>v-for给子元素绑定事件要使用事件委托，绑定一次即可</li></ul><p><strong>模板渲染</strong></p><ul><li>图片懒加载（利用滚动条的滚动事件，在图片滚动到屏幕中的时候再加载）</li><li>图片多使用精灵图和SVG格式的（两者区别见上面）</li><li>区分v-if、v-show的使用场景，避免v-if频繁渲染节点</li><li>v-for要使用唯一的id并且不要和v-if一起使用（会先执行v-for先渲染再判断导致重复渲染），避免重复渲染</li><li>大数据的列表和表格要使用 虚拟列表、虚拟表格技术，可以实现看多少加载多少，翻页时再加载后面的</li></ul><p><strong>组件</strong></p><ul><li>使用异步组件（使用component组件渲染时再加载）</li><li>使用keep-alive组件</li></ul><p><strong>路由</strong></p><ul><li>路由组件懒加载（使用import和webpack代码分割）</li></ul><p><strong>打包</strong></p><ul><li>减少文件体积（合并文件）</li><li>使用服务器端gzip压缩（可以使得静态文件体积减少50%-70%，可以用于webpack打包后的静态文件进一步压缩）</li></ul><p><strong>运行时</strong></p><ul><li>使用服务端渲染SSR或预渲染（一般是不需要与服务端交互的应用，它可以在第一次加载时就把整个引用的HTML返回给浏览器，比如博客等）</li><li>缓存：客户端缓存或服务端缓存 资源文件（后续加载）</li></ul><p><u>思路</u>：编程时（组件实例-&gt;HTML模板-&gt;组件级别-&gt;路由级别）-&gt;打包时-&gt;运行后</p></blockquote><h3 id="37-首屏如何优化？"><a href="#37-首屏如何优化？" class="headerlink" title="37.首屏如何优化？"></a>37.首屏如何优化？</h3><blockquote><p>由于问的是首屏，那么只需关注首屏加载用到的资源文件以及渲染内容，因此要去除一些 上一题性能优化中对于编程时提到的操作，直接关注打包后的资源以及运行的渲染即可。首屏优化分为 用户体验优化和加载速度优化。</p><ol><li><p>使用骨架图（指标不住本，仅仅提高用户体验）</p><p>骨架图是 数据还没到来时显示的页面 大致结构的样式，相比loading样式，用户体验更好</p></li><li><p>优化加载速度（从根本解决问题）</p><ul><li><p>打包</p><p>使用服务器端gzip压缩（可以使得静态文件体积减少50%-70%，可以用于webpack打包后的静态文件进一步压缩）打包后的静态文件</p></li><li><p>服务端渲染（有了SSR就不需要客户端处理js文件直接渲染）</p></li><li><p>加载js文件</p><p>静态资源使用CDN加载（CDN会把静态资源缓存在各个服务器中，查找时会寻找最近的服务器寻找），例如用CDN加载图标库</p></li><li><p>路由</p><ul><li>使用路由懒加载（使用import和webpack代码分割）</li><li>使用动态路由</li></ul></li><li><p>组件（页面加载时）</p><ul><li>非首屏组件异步加载</li><li>不重要的首屏组件延迟加载</li></ul></li><li><p>页面渲染</p><ul><li>图片懒加载</li><li>图片多使用精灵图和SVG格式的（两者区别见上面）</li><li>区分v-if、v-show的使用场景，避免v-if频繁渲染节点</li><li>v-for要使用唯一的id并且不要和v-if一起使用（会先执行v-for先渲染再判断导致重复渲染），避免重复渲染</li><li>大数据的列表和表格要使用 虚拟列表、虚拟表格技术，可以实现看多少加载多少，翻页时再加载后面的</li></ul></li></ul></li></ol><p><u>思路</u>：从打包后加载页面的视角来看</p><hr><p>好像上一题的内容都能说，因为很多优化我完全可以说 在首页会用到啊</p></blockquote><h3 id="38-为什么Vue3比Vue2性能更好？"><a href="#38-为什么Vue3比Vue2性能更好？" class="headerlink" title="38.为什么Vue3比Vue2性能更好？"></a>38.为什么Vue3比Vue2性能更好？</h3><blockquote><p>将从编码、编译、打包三个方面来回答：</p><p>编码方面：</p><ul><li>主要是针对响应式处理进行了改进，由原先的Object.defineProperty变为ES6的Proxy来实现，由于Vue3中的proxy在初始化时使用了懒处理，即嵌套对象一开始指针对第一层进行响应式处理，只有到后面用到深层次的内容再处理，这样可以减少体积和提高加载速度</li></ul><p>编译方面：</p><ul><li>添加静态标记（每种标记表明更新不同内容，静态的不更新，动态的有选择地更新）、静态提升（将静态内容提升到render函数之外，在render函数里面只需对静态内容引用，避免重复处理）提升diff算法的性能</li></ul><p>打包方面：</p><ul><li>使用Tree Shaking对代码打包时去除不使用的代码，从而减小打包体积</li></ul></blockquote><h3 id="39-Vue3为什么要使用proxy（proxy比Object-defineProperty有什么优点）"><a href="#39-Vue3为什么要使用proxy（proxy比Object-defineProperty有什么优点）" class="headerlink" title="39.Vue3为什么要使用proxy（proxy比Object.defineProperty有什么优点）"></a>39.Vue3为什么要使用proxy（proxy比Object.defineProperty有什么优点）</h3><blockquote><ul><li><p>范围更广：</p><p>proxy能代理整个对象，而Object.defineProperty则只能代理某个属性，还需要递归来处理，proxy内部已经进行了递归处理</p></li><li><p>响应式操作更丰富：</p><p>Object.defineProperty只能针对数据的访问、修改响应式处理，而proxy还对删除、添加操作添加了响应式</p></li><li><p>异常处理更灵活：</p><p>proxy内部的Relect封装了try-catch，可自动捕获异常，而Object.defineProperty需要手动在外部添加</p></li><li><p>更安全：</p><p>proxy返回一个新对象，而Object.defineProperty是在原对象进行处理的，这样proxy不修改原数据结构会更加安全</p></li></ul><p><u>思路</u>：proxy对象由 外（范围）-&gt;内（操作-异常处理）-&gt;外（返回新对象）</p></blockquote><h3 id="40-说说你对组件的理解"><a href="#40-说说你对组件的理解" class="headerlink" title="40.说说你对组件的理解"></a>40.说说你对组件的理解</h3><blockquote><p>定义：组件其实是利用Vue.extend创建的一个VueComponent实例，类似于Vue的子类，拥有Vue类似的配置项</p><p>作用：可以将公共部分写在组件里面进行复用</p><p><img src="/2024/01/03/%E5%89%8D%E7%AB%AF%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%9F%BA%E7%A1%80/%E7%BB%84%E4%BB%B6%E5%AE%9E%E4%BE%8B%E4%B8%8EVue%E5%AE%9E%E4%BE%8B%E5%85%B3%E7%B3%BB.png" alt="组件实例与Vue实例关系"></p></blockquote><h3 id="41-为什么组件的data要写成函数形式不能写成对象形式？"><a href="#41-为什么组件的data要写成函数形式不能写成对象形式？" class="headerlink" title="41.为什么组件的data要写成函数形式不能写成对象形式？"></a>41.为什么组件的data要写成函数形式不能写成对象形式？</h3><blockquote><p>如果data写成对象形式，那么同一个组件在复用时，data都指向同一个地址，这样data内容一个修改了，另一个也会跟着修改，这样会造成数据混乱的情况。</p><p>而写成函数形式，每次都返回一个新的对象，这样可以保证数据的独立性，不会相互影响</p></blockquote><h3 id="42-你是如何规划项目文件的？"><a href="#42-你是如何规划项目文件的？" class="headerlink" title="42.你是如何规划项目文件的？"></a>42.你是如何规划项目文件的？</h3><blockquote><p>项目创建后大致结构已经确定，主要是针对src目录进行规划：</p><p>src</p><ul><li>components（公共组件）</li><li>views（路由组件）</li><li>utils（封装axios）</li><li>api</li><li>store</li><li>assets（图标、图片）</li><li>directives（可选，自定义指令）</li><li>styles（自定义样式）</li><li>router</li></ul><p><u>思路</u>：组件-&gt;组件实例（请求数据）-&gt;模板展示（图片、指令）-&gt;样式-&gt;路由（不同组件）</p></blockquote><h3 id="42-了解过nuxt-js框架吗？"><a href="#42-了解过nuxt-js框架吗？" class="headerlink" title="42.了解过nuxt.js框架吗？"></a>42.了解过nuxt.js框架吗？</h3><blockquote><p>它是一个基于Vue的服务端渲染框架，能够简化服务端渲染流程，最终可帮助SEO（主要目的）以及优化首屏加载时间。</p></blockquote><h3 id="43-Vue项目中如何提高SEO？"><a href="#43-Vue项目中如何提高SEO？" class="headerlink" title="43.Vue项目中如何提高SEO？"></a>43.Vue项目中如何提高SEO？</h3><blockquote><p>现在各个前端框架下的页面的内容，大多是根据打包后js来动态生成，这给搜索引擎在抓包时能获取到的信息太少，导致SEO很差，于是就有了服务端渲染和预渲染，他们都能提高首屏加载速度，能让搜索引擎更快地获取到关键信息，从而优化SEO。</p><ul><li>服务端渲染（SSR）：每一次请求后都会在服务端来执行js并渲染当前的页面来生成HTML，直接返回给前端，前端直接展示即可</li><li>预渲染：在请求之前（构建时），就提前把页面生成静态HTML并缓存下来，后续不需要和服务器实时交互数据</li></ul><p>理解：预渲染只针对静态内容，而SSR是针对所有内容，都是服务端来帮助客户端减轻压力的</p></blockquote><h3 id="44-为什么Vue2响应式属性要通过额外的API（-set、-delete）？"><a href="#44-为什么Vue2响应式属性要通过额外的API（-set、-delete）？" class="headerlink" title="44.为什么Vue2响应式属性要通过额外的API（$set、$delete）？"></a>44.为什么Vue2响应式属性要通过额外的API（$set、$delete）？</h3><blockquote><p><strong>对象</strong></p><ol><li>Object.defineProperty无法劫持新增的属性以及删除的属性</li><li>如果用Object.defineProperty遍历对象的每个属性添加响应式，效率会很低；而新增API可以手动的有选择性地添加相应是</li></ol><p><strong>数组</strong></p><ol><li>通过索引访问值和修改数组长度是无法触发响应式更新</li></ol></blockquote><h3 id="45-为什么Vue对于数组没有使用defineProperty-实现响应式？"><a href="#45-为什么Vue对于数组没有使用defineProperty-实现响应式？" class="headerlink" title="45.为什么Vue对于数组没有使用defineProperty 实现响应式？"></a>45.为什么Vue对于数组没有使用defineProperty 实现响应式？</h3><blockquote><p>如果对数组每一个元素都是用defineProperty进行数据劫持，性能会很低下，于是重写了7个方法，<strong>在方法内部调用Array原始方法之后再统一用Dep的notify通知依赖去更新</strong></p></blockquote><h3 id="46-Vue使用了哪些设计模式？"><a href="#46-Vue使用了哪些设计模式？" class="headerlink" title="46.Vue使用了哪些设计模式？"></a>46.Vue使用了哪些设计模式？</h3><blockquote><ol><li><p>单例模式：vuex和vue router创建后会判断只有一个实例才会创建</p></li><li><p>观察者模式：响应式原理</p></li><li><p>发布订阅模式：$emit以及$on，还有promise原理</p></li><li><p>装饰器模式：@写在方法上面添加额外功能，一般对于防抖和节流可以封装成装饰器来使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;template&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;handleClick&quot;</span>&gt;</span>Click Me<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>&lt;/template&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">function</span> <span class="hljs-title function_">debounce</span>(<span class="hljs-params">delay</span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">target, key, descriptor</span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-keyword">const</span> originalMethod = descriptor.<span class="hljs-property">value</span>;</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> originalMethod !== <span class="hljs-string">&#x27;function&#x27;</span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`@debounce decorator can only be applied to methods, not <span class="hljs-subst">$&#123;<span class="hljs-keyword">typeof</span> originalMethod&#125;</span>`</span>);</span></span><br><span class="language-javascript"><span class="language-xml">        &#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-keyword">let</span> timer;</span></span><br><span class="language-javascript"><span class="language-xml">        descriptor.<span class="hljs-property">value</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">...args</span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-keyword">if</span> (timer) <span class="hljs-built_in">clearTimeout</span>(timer);</span></span><br><span class="language-javascript"><span class="language-xml">            timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">                originalMethod.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args);</span></span><br><span class="language-javascript"><span class="language-xml">            &#125;, delay);</span></span><br><span class="language-javascript"><span class="language-xml">        &#125;;</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-keyword">return</span> descriptor;</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;;</span></span><br><span class="language-javascript"><span class="language-xml">&#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-attr">methods</span>: &#123;</span></span><br><span class="language-javascript"><span class="language-xml">        @<span class="hljs-title function_">debounce</span>(<span class="hljs-number">500</span>)</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-title function_">handleClick</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Button clicked!&#x27;</span>);</span></span><br><span class="language-javascript"><span class="language-xml">        &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">&#125;;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure></li><li><p>策略模式：对于minin混入的代码，有默认的混入策略：用引进来的替换原本的（如果重名的话）</p></li><li><p>工厂模式：根据参数生成实例，例如Vue.component(…)</p></li></ol><p><u>思路</u>：组件实例-&gt;引入文件-&gt;数据-&gt;事件-&gt;引入外部-&gt;整个组件</p></blockquote><h3 id="47-MVC和MVVM的区别"><a href="#47-MVC和MVVM的区别" class="headerlink" title="47.MVC和MVVM的区别"></a>47.<strong>MVC和MVVM的区别</strong></h3><blockquote><p>MVC它是传统的架构模式，一般是后端来用的。MVC是指Model、View、Controller三层，用户在VieW层请求数据，Controller负责转发用户的请求并把数据分发给Model中，最后由Model将数据再展示到View中，这是一个三角形闭环。</p><p>说到MVVM，需要说一下它的由来。</p><p>以前我们是将业务层逻辑（从Controller获取数据）还有展示逻辑（利用jquery）都嵌入在页面中，随着的项目的越来越复杂，代码会变得非常地臃肿，可维护性很差。这时就出现了MVVM架构模式。MVVM是前端的架构模式，分为Model、View、ViewModel，ViewModel实现了Model和View的双向绑定，它是没有像MVC的Controller那样有处理业务逻辑这一层的，它更专注于View层，而且Model和View之间是相互独立的，非常低耦合，Model和View并不知道它们的关系，这个关系交给ViewModel来负责，数据一到Model就会自动更新到View中。这样的模式不仅可以将前端页面和后端逻辑分开，各司其职，还可以做到自动更新，大大提高了开发效率。 </p><p>注意：Vue并没有完全遵循MVVM模式，因为Vue允许用$ref来操作view</p></blockquote><h3 id="48-Vue响应式原理中wacher是如何更新页面的（nextTick原理）？"><a href="#48-Vue响应式原理中wacher是如何更新页面的（nextTick原理）？" class="headerlink" title="48.Vue响应式原理中wacher是如何更新页面的（nextTick原理）？"></a>48.Vue响应式原理中wacher是如何更新页面的（nextTick原理）？</h3><blockquote><p>见26</p></blockquote><h3 id="49-Vue中有哪些指令？"><a href="#49-Vue中有哪些指令？" class="headerlink" title="49.Vue中有哪些指令？"></a>49.Vue中有哪些指令？</h3><blockquote><p><strong>渲染</strong></p><ul><li><p>编译阶段</p><p>v-pre ———不编译（针对一些静态标签内容，可以直接加上，提高性能，减轻编译负担）</p><p>v-cloak —–编译时显示的内容，避免页面闪动（网速慢等原因导致编译时出现的情况）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;!<span class="hljs-variable constant_">DOCTYPE</span> html&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Vue v-cloak Example<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="language-css"><span class="language-xml">        <span class="hljs-selector-attr">[v-cloak]</span> &#123;</span></span><br><span class="language-css"><span class="language-xml">            <span class="hljs-attribute">display</span>: none;</span></span><br><span class="language-css"><span class="language-xml">        &#125;</span></span><br><span class="language-css"><span class="language-xml">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span> <span class="hljs-attr">v-cloak</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.jsdelivr.net/npm/vue@2&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#app&#x27;</span>,</span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-attr">data</span>: &#123;</span></span><br><span class="language-javascript"><span class="language-xml">                <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;Hello, Vue!&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml">            &#125;</span></span><br><span class="language-javascript"><span class="language-xml">        &#125;);</span></span><br><span class="language-javascript"><span class="language-xml">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span><br></code></pre></td></tr></table></figure></li><li><p>展示阶段</p><p>v-show </p><p>v-for</p></li><li><p>展示后</p><p>v-once —–只展示一次</p></li></ul><p><strong>数据</strong></p><ul><li><p>固定HTML内容</p><p>v-text —– 只展示最终文字</p><p>v-html —- 一股脑地把HTML全部插入</p></li><li><p>data中数据</p><p>v-bind </p><p>v-model </p></li></ul><p><strong>事件</strong></p><p>v-on</p></blockquote><h3 id="50-怎样理解-Vue-的单项数据流？"><a href="#50-怎样理解-Vue-的单项数据流？" class="headerlink" title="50.怎样理解 Vue 的单项数据流？"></a>50.怎样理解 Vue 的单项数据流？</h3><blockquote><p>它指的是 数据总是从父组件传入子组件，而不允许子组件修改父组件的数据，这么做的目的是 避免子组件意外修改父组件的数据带来的问题</p><p>其中，虽然v-model可以修改，但是不推荐，开发环境也会报警告</p><p>如何处理？利用$emi触发事件来修改</p></blockquote><h3 id="51-v-if-和-v-for-为什么不建议一起使用？"><a href="#51-v-if-和-v-for-为什么不建议一起使用？" class="headerlink" title="51.v-if 和 v-for 为什么不建议一起使用？"></a>51.v-if 和 v-for 为什么不建议一起使用？</h3><blockquote><p>因为 v-for会在v-if之前解析，如果 v-if 条件不满足，那么又要销毁元素，这样就很影响性能</p><p>如何解决？</p><p>用计算属性计算 替换 v-if 判断逻辑，提前把数据筛选好即可</p></blockquote><h3 id="52-v-model原理？"><a href="#52-v-model原理？" class="headerlink" title="52.v-model原理？"></a>52.v-model原理？</h3><blockquote><p>v-model他只是v-bind和v-on的语法糖，v-bind实现了数据驱动试图，v-on实现了视图驱动数据，最终实现了双向数据绑定。</p><p>它会根据不同的元素标签使用不同的绑定的数据类型以及事件类型：</p><ul><li>text/textarea——– value值和input事件</li><li>select—————— value值和change事件</li><li>radio——————- checked值和change事件</li></ul></blockquote><h3 id="53-事件绑定原理？"><a href="#53-事件绑定原理？" class="headerlink" title="53.事件绑定原理？"></a>53.事件绑定原理？</h3><blockquote><p>可以对 双向数据绑定的原理 进行补充</p><p>需要先说明事件分类：原生事件、组件事件</p><p>原生事件是通过addEventListener方法实现的，而组件事件是通过$on实现的。</p><p>关系：如果需要在组件上使用原生事件，需要事件修饰符.native</p><p>下面说说组件事件用得到$on和$emit原理（原生事件是自带的，不好说）：$on和$emit维护了一个事件中心，使用了发布订阅者模式，$on是订阅者，在$on的时候将事件名放入事件中心，等待订阅内容，而$emit是发布者，在$emit的时候提供$on需要的事件</p></blockquote><h1 id="Echarts"><a href="#Echarts" class="headerlink" title="Echarts"></a>Echarts</h1><h3 id="1-echarts有用过吗？常用的组件有哪些？"><a href="#1-echarts有用过吗？常用的组件有哪些？" class="headerlink" title="1.echarts有用过吗？常用的组件有哪些？"></a>1.echarts有用过吗？常用的组件有哪些？</h3><blockquote><ol><li>legend（图例）（指明每个图长啥样）</li><li>title</li><li>toolbox（工具栏，一些操作：缩放、下载等）</li><li>yAxis</li><li>xAxis</li><li>series（name、type、data、markPoint、markLine）</li><li>toolTip</li></ol><p><u>思路</u>（折线图为例）：</p><ul><li>外框：从上往下，从左往右（图例-&gt;标题-&gt;工具栏-&gt;Y轴-&gt;X轴）</li><li>内容：画出来再对比（哪根线-&gt;图的类型-&gt;数据-&gt;标注-&gt;标线-&gt;提示框）</li></ul></blockquote><h1 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h1><h3 id="1-前端中产品的性能是指什么？如何衡量？"><a href="#1-前端中产品的性能是指什么？如何衡量？" class="headerlink" title="1.前端中产品的性能是指什么？如何衡量？"></a>1.前端中产品的性能是指什么？如何衡量？</h3><blockquote><p>当我们用性能去描述一个互联网产品的时候，主要看的是：</p><ul><li>首屏加载速度</li><li>用户操作流畅度（稳定性）</li><li>用户操作响应速度</li></ul><p>由于速度的快慢用个人主观感受来看因人而异，无法测量，因此业内制定了专业客观的、可测量的性能指标（如下）</p></blockquote><h3 id="2-性能优化指标有哪些？"><a href="#2-性能优化指标有哪些？" class="headerlink" title="2.性能优化指标有哪些？"></a>2.性能优化指标有哪些？</h3><blockquote><ul><li><p>首屏加载速度</p><p>FCP（页面加载到第一个元素渲染成功的时间）</p><p>LCP（页面加载到最大的元素渲染成功的时间） —————- 优秀 2.5 &lt; 中等（需要优化）&lt; 4 （差）</p></li><li><p>用户操作流畅度</p><p>CLS（累计布局偏移）：如果应用不稳定，页面布局是会慢慢偏移的</p></li><li><p>用户操作响应速度</p><p>FID（First Input delay）：第一次交互并成功相应的时间</p></li></ul></blockquote><h3 id="3-性能优化分析工具有哪些？"><a href="#3-性能优化分析工具有哪些？" class="headerlink" title="3.性能优化分析工具有哪些？"></a>3.性能优化分析工具有哪些？</h3><blockquote><p>最主流：lighthouse（谷歌浏览器已经自带，通过F12便可以查看，点击生成报告，页面会重新加载并被分析，最后可以得出各个指标的值，而且下面还会有针对某个文件的优化建议，很方便）</p><p>webVitals：Edge可以用，可以直接挂在网页上，网页处理完毕，直接打开看所有参数，很方便</p></blockquote><h3 id="4-虚拟表格技术如何实现？"><a href="#4-虚拟表格技术如何实现？" class="headerlink" title="4.虚拟表格技术如何实现？"></a>4.虚拟表格技术如何实现？</h3><blockquote><p>就是通过在有限的窗口自定义想要渲染的item条数，然后在滚动过程中通过计算来替换视野中的数据</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">相对定位</span>;<span class="hljs-attr">overflow:auto</span> <span class="hljs-attr">:style</span>=<span class="hljs-string">&#x27;height:$&#123;想要展示的个数*一个item高度&#125;&#x27;</span>&gt;</span>// 可视区<br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">:style</span>=<span class="hljs-string">&#x27;height:$&#123;实际个数*一个item高度&#125;&#x27;</span>&gt;</span>// 占位，为了显现出滚动条<br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">绝对定位</span> <span class="hljs-attr">:style</span>=<span class="hljs-string">&#x27;top:$&#123;第一个元素离top偏移量&#125;&#x27;</span>&gt;</span>// 渲染区域<br>            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> &gt;</span>// 每一行<br>                循环展示<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>下面是滚动时的事件，替换元素：计算第一个元素新下标和偏移量(滚动时第一个元素有偏移量)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">strollEvent</span> = (<span class="hljs-params">event</span>)=&gt;&#123;<br>    <span class="hljs-comment">// 利用节流节省性能</span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-title function_">nowTime</span>() - lastTime)&#123;<br>         <span class="hljs-keyword">const</span> &#123;strollTop&#125; = event.<span class="hljs-property">target</span><br>         第一个元素新下标 = strollTop/一个item高度<br>         第一个元素偏移量 = strollTop<br>         更新lastTime<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>渲染个数少、节流 =&gt;双重提高性能（其实是渲染数据太多才慢的）</p></blockquote><h1 id="移动端"><a href="#移动端" class="headerlink" title="移动端"></a>移动端</h1><h3 id="1-什么是uni-app？"><a href="#1-什么是uni-app？" class="headerlink" title="1.什么是uni-app？"></a>1.什么是uni-app？</h3><blockquote><p>uni-app（unify）是一个基于Vue.js的跨平台开发框架（支持Web端、移动端（IOS、android）、小程序），它提供了一套统一的代码开发和发布流程，开发者只需开发一份代码，同时将应用发布到多个平台，大大提高了开发效率。</p></blockquote><h3 id="2-uni-app有没有做过分包？"><a href="#2-uni-app有没有做过分包？" class="headerlink" title="2.uni-app有没有做过分包？"></a>2.uni-app有没有做过分包？</h3><blockquote><p>uni-app分包和webpack的按照模块来代码分割 概念是类似的。</p><p>举例子：小程序会默认下载主包并启动页面，只有加载到分包的内容时才会下载对应的分包并加载</p><p>好处：提高下载速度和页面加载速度</p><p>如何分包：</p><p>subPackages里面配置 分包路径以及分包页面</p></blockquote><h3 id="3-如何利用Cordova对Vue项目进行打包？"><a href="#3-如何利用Cordova对Vue项目进行打包？" class="headerlink" title="3.如何利用Cordova对Vue项目进行打包？"></a>3.如何利用Cordova对Vue项目进行打包？</h3><blockquote><p>安装Cordova-&gt;创建一个Cordova项目-&gt;Cordova添加平台-&gt;将Vue在build之后的静态文件放入www文件夹-&gt;cordova run android</p></blockquote><h3 id="4-原生App、WebApp、混合App、h5有什么区别？"><a href="#4-原生App、WebApp、混合App、h5有什么区别？" class="headerlink" title="4.原生App、WebApp、混合App、h5有什么区别？"></a>4.原生App、WebApp、混合App、h5有什么区别？</h3><blockquote><p><strong>原生App：</strong></p><p>​      所有的api还有UI一整套都是用的android/ios官方提供的</p><p>​      优点：系统稳定，流畅度高</p><p>​      缺点：无法跨平台</p><p><strong>WebApp（就是我们用的网站，app-application）：</strong></p><p>​      用的是Web应用开发的技术（html、css、js）开发的移动端应用</p><p>​      优点：可跨平台</p><p>​      缺点：无法调用原生App的接口</p><p><strong>混合App（uniapp、cordova）：</strong></p><p>​      综合了原生App和混合App优点，一部分用WebApp的技术，一部分用原生App的接口</p><p><strong>h5</strong></p><p>​      单纯用html5技术开发的应用，更注重动画和交互效果，web和app都可以运行</p></blockquote><h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><h3 id="1-git从拉取代码到推送代码的流程是什么？"><a href="#1-git从拉取代码到推送代码的流程是什么？" class="headerlink" title="1.git从拉取代码到推送代码的流程是什么？"></a>1.git从拉取代码到推送代码的流程是什么？</h3><blockquote><p>git clone 远程仓库地址</p><p>-&gt;…修改内容</p><p>-&gt;git add .（添加到本地缓存区）</p><p>-&gt;git commit -m ‘feature/内容’（添加到本地仓库）</p><p>-&gt;git pull </p><p>-&gt;…处理可能的冲突</p><p>-&gt;git push </p><hr><p>以上是个人项目或小型项目，如果是大型项目，会要建立自己的分支，有效避免pull、commit的使用错误（相当于用merge来代替pull）：</p><p>git clone 远程仓库地址</p><p>-&gt;git checkout -b ‘自己的分支’（创建并切换到自己的分支）</p><p>-&gt;git pull</p><p>-&gt;add、commit</p><p>-&gt;替换到master再pull一下保证只最新的</p><p>-&gt;再切换到自己的分支</p><p>-&gt;git merge develop（把develop分支合并到当前分支上）</p></blockquote><h3 id="2-会什么要有暂存区？"><a href="#2-会什么要有暂存区？" class="headerlink" title="2.会什么要有暂存区？"></a>2.会什么要有暂存区？</h3><blockquote><p>因为暂存区可以帮助你选择性提交，一次提交只包含一个功能，这样可以让提交历史清晰，便于追踪问题。如果你要做一个功能B，但是在做的过程中发现还有bugA，此时可以把修改bugA先提交一版，然后再提交一版功能B</p></blockquote><h3 id="3-为什么是commit-gt-pull-gt-push，而不是pull-gt-commit-gt-push？"><a href="#3-为什么是commit-gt-pull-gt-push，而不是pull-gt-commit-gt-push？" class="headerlink" title="3.为什么是commit-&gt;pull-&gt;push，而不是pull-&gt;commit-&gt;push？"></a>3.为什么是commit-&gt;pull-&gt;push，而不是pull-&gt;commit-&gt;push？</h3><blockquote><p>因为可能 你和别人共同会修改同一个功能，你可能修改好了忘记commit直接pull，会把别人修改的覆盖你的，因为你不commit那么git是不知道你修改了；而先commit再pull，这是如果有冲突，可以和别人商量要哪个，再push</p><hr><p>解释有问题，具体请看：<a href="https://zhoujie-lovemusic.github.io/2024/09/03/git%E4%B8%AD%E9%82%A3%E4%BA%9B%E6%B6%89%E5%8F%8Amerge%E7%9A%84%E6%93%8D%E4%BD%9C/">https://zhoujie-lovemusic.github.io/2024/09/03/git%E4%B8%AD%E9%82%A3%E4%BA%9B%E6%B6%89%E5%8F%8Amerge%E7%9A%84%E6%93%8D%E4%BD%9C/</a></p></blockquote><h3 id="4-功能写错了并push了，如何回退代码？"><a href="#4-功能写错了并push了，如何回退代码？" class="headerlink" title="4.功能写错了并push了，如何回退代码？"></a>4.功能写错了并push了，如何回退代码？</h3><blockquote><p>一般来说需要回退到 commit之前，然后重新修改，再次commit。</p><ul><li>git reset –soft HEAD^ ————– 回退到上一次commit之前</li><li>git reset –soft commitId ———- 根据commitId ，回退到具体某次提交</li></ul></blockquote><h1 id="HR"><a href="#HR" class="headerlink" title="HR"></a>HR</h1><h3 id="1-你跳槽（离职）的原因是什么？"><a href="#1-你跳槽（离职）的原因是什么？" class="headerlink" title="1.你跳槽（离职）的原因是什么？"></a>1.你跳槽（离职）的原因是什么？</h3><blockquote><p><strong>原则：</strong>不要说上家的不好，说一些 不可抗力、个人发展瓶颈 体现上进心的原因<u>（真诚点不要套路）</u>，最后注意要感恩上一家公司的价值</p><p><strong>踩雷：</strong></p><p>同事相处不和谐 ————–&gt; 沟通能力不行</p><p>领导人品不好 —————–&gt; 不尊重领导</p><p><strong>方向：</strong> <strong>个人发展 技术提升</strong> 家庭问题</p><p><strong>回答</strong>：</p><p>主要是有两方面原因：</p><p>一方面，前公司确实经营不善，发展前景不太好，因为 公司内部有消息说 公司有面临倒闭的风险，那我肯定要早做打算吧，而且我之前刚毕业的时候本来就是想来 南京/苏州 这样的城市来学习实践的，想来见见世面；另一方面，我们公司做的项目，有很多是用angular框架做的，只有少部分使用Vue框架的，而我不太喜欢用这个框架，因为 我个人觉得这个框架 有点庞大，应用加载速度比较慢，影响开发效率，还有一些用法比如 双向绑定用法复杂，我喜欢用Vue框架开发，更简洁，而且也是主流嘛</p></blockquote><h3 id="2-工作到现在碰到的最难的问题是什么？怎么解决的？"><a href="#2-工作到现在碰到的最难的问题是什么？怎么解决的？" class="headerlink" title="2.工作到现在碰到的最难的问题是什么？怎么解决的？"></a>2.工作到现在碰到的最难的问题是什么？怎么解决的？</h3><blockquote><p><strong>原则：</strong>有一定难度的，并且不常见的</p><p><strong>踩雷：</strong></p><p>没有问题 —————— 都没做过什么事情，经历少</p><p>数据请求、页面渲染、路由请求等常见的应该会的 ————————–技术能力差</p><p><strong>思路：</strong></p><ol><li>一开始自行到处查资料去寻求解决办法</li><li>后来实在解决不了的请教同事、组长</li></ol><p><strong>范本：</strong></p><p>“在我的工作经历中，我遇到的最具挑战性的问题是在项目中遇到的性能优化难题。项目中页面加载速度较慢，影响用户体验。为了解决这个问题，我进行了深入的优化工作。首先，我利用开发者工具和性能分析工具对页面进行了详细的性能检测和分析，找到了导致页面加载缓慢的具体原因。然后，我针对性地优化了代码结构，减少了不必要的资源加载和提升了代码执行效率。同时，我还实现了懒加载、缓存和压缩等技术手段，进一步提升了页面加载速度和性能表现。经过持续的努力和测试验证，最终成功地解决了性能优化问题，提升了页面的加载速度，优化了用户体验。这个经历让我深刻意识到在面对困难时，需要耐心、积极主动地寻找解决方案，并不断学习和尝试新的技术，以提升自己的技能水平和解决问题的能力。”</p><p>————-这样的回答能够突出问题的难度和挑战性，同时展现了你对问题的认真分析、积极解决的态度和努力付出。这种回答符合面试官希望听到的体现困难、解决积极的标准要求，有助于展现你作为前端工程师的能力和素质。</p></blockquote><h3 id="3-你的优缺点是什么？"><a href="#3-你的优缺点是什么？" class="headerlink" title="3.你的优缺点是什么？"></a>3.你的优缺点是什么？</h3><blockquote><p>我的<strong>缺点</strong>是 我之前胆子比较小（缺点认知），有点怯场，不太敢在大家面前表达自己的观点，后来 我有私下去问资历比较老的同事咨询建议以及看了一些关于表达的一些书籍（非暴力沟通，感受并合理表达自己的需求请求），慢慢建立了自信，后来为了实践锻炼，我能够在百来人号面前进行主持。———— 以前的缺点</p><p>项目比较急的时候，有点急于求成，乱了自己的节奏，现在已经在慢慢改正，告知自己 急没有用，心静下来事情就解决了</p><p>我的优点是 我觉得我对于Vue框架的应用比较熟练，对原理也有一定了解，对于开发的工作任务的跟进是可以保证的，另外就是我的表达能力 还可以，喜欢与人交流，对于一些问题的处理能够和后端进行及时的沟通</p></blockquote><h3 id="4-如何协同工作？"><a href="#4-如何协同工作？" class="headerlink" title="4.如何协同工作？"></a>4.如何协同工作？</h3><blockquote><p>开发前开会议</p><p>利用一些工具（git）</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>面试题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端综合</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue中的性能优化</title>
    <link href="/2023/12/18/Vue%E4%B8%AD%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <url>/2023/12/18/Vue%E4%B8%AD%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<ol><li><p><strong>组件实例</strong></p><ul><li><p>按需第三方插件，比如加载UI组件模块</p></li><li><p>静态资源使用CDN加载（CDN会把静态资源缓存在各个服务器中，查找时会寻找最近的服务器寻找），例如用CDN加载图标库</p></li><li><p>不要把太多的数据放在data中，减少过多的数据劫持添加getter、setter</p><p><u>为什么？</u></p><p>因为 在实例化时，Vue会对data中的属性用object.defineproperty进行数据劫持使里面的数据都具有响应式的能力，如果把非响应式的数据放入data中，当数据变化时会给模版带俩不必要的重排和重绘，从而降低渲染性能。</p><p><u>那放在哪？</u></p><p>可以放到vm实例身上，并且还可以进一步用Object.freeze()冻结数据，避免多余的数据的处理</p><p><u>Object.freeze()有什么好处？</u></p><ul><li>数据有稳定性：它不能被增、删、改，可以避免程序员意外修改数据带来的错误</li><li>数据有安全性：可以避免不可信源来修改数据</li><li>提高数据的可维护性和可拓展性：使用这个方法可以让程序员知道哪些数据不需要修改，缩小了可维护、拓展的范围</li></ul></li><li><p>对象的层级不要太多，也是减少深层次过多的数据劫持</p></li><li><p>对于一些不用的变量（比如定时器），要及时清理</p></li><li><p>computed和watch要区分场景使用，比如computed的缓存性能不适合频繁修改数据的</p></li><li><p>使用防抖和节流来避免频繁触发事件</p></li><li><p>v-for给子元素绑定事件要使用事件委托，绑定一次即可</p></li></ul><p><strong>模板渲染</strong></p><ul><li>图片懒加载</li><li>图片多使用精灵图和SVG格式的（两者区别见上面）</li><li>区分v-if、v-show的使用场景，避免v-if频繁渲染节点</li><li>v-for要使用唯一的id并且不要和v-if一起使用（会先执行v-for先渲染再判断导致重复渲染），避免重复渲染</li><li>大数据的列表和表格要使用 虚拟列表、虚拟表格技术，可以实现看多少加载多少，翻页时再加载后面的</li></ul><p><strong>组件</strong></p><ul><li>使用异步组件（使用component组件渲染时再加载）</li><li>使用keep-alive组件</li></ul><p><strong>路由</strong></p><ul><li>使用路由懒加载（使用import和webpack代码分割）</li><li>使用动态路由</li></ul><p><strong>打包</strong></p><ul><li>减少文件体积（合并文件）</li><li>使用服务器端gzip压缩（可以使得静态文件体积减少50%-70%，可以用于webpack打包后的静态文件进一步压缩）</li></ul><p><strong>运行时</strong></p><ul><li>使用服务端渲染SSR或预渲染（第一次加载）</li><li>缓存：客户端缓存或服务端缓存 资源文件（后续加载）</li></ul><p><u>思路</u>：编程时（组件实例-&gt;HTML模板-&gt;组件级别-&gt;路由级别）-&gt;打包时-&gt;运行后</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>前端框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue中路由钩子函数</title>
    <link href="/2023/12/15/Vue%E4%B8%AD%E8%B7%AF%E7%94%B1%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0/"/>
    <url>/2023/12/15/Vue%E4%B8%AD%E8%B7%AF%E7%94%B1%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p><strong>分类</strong></p><p>先说下所有的钩子函数：全局守卫、路由独享路由、组件守卫。</p><p><strong>完整的导航解析流程</strong></p><ul><li>导航被触发，比如router.push()、router.replace()</li><li>调用失活组件的beforeRouteLeave守卫</li><li>调用全局前置守卫beforeEach，在这可以添加一些登录验证，这是验证是全局的，也就是它针对所有路由</li><li>调用重用组件的beforeRouteUpdate守卫，这个守卫专门在路由 的组件复用时调用，比如两个路由地址不同，但是对应组件是一样的，如果有路由的组件复用，调用完该守卫更新完毕就不会调用后面的守卫了</li><li>调用路由独享的守卫beforeEnter守卫，路由独享的守卫就这一个，专门为跳转当前路由之前做一些逻辑，比如也可以做登录验证，只是这个验证只针对当前路由</li><li>下面到了异步组件（使用import关键字的懒加载组件）的解析阶段</li><li>调用激活组件的beforeRouteEnter守卫，在该守卫中还没有实例化，无法使用this，可准备好异步数据给激活的组件</li><li>调用全局解析守卫beforeResolve，该守卫是解析的最后一步，也可以获取异步数据，只是这个数据一般是可能其他组件也要使用，比如用户的信息放入仓库</li><li>导航被确认。为什么要确认一下？表示要进入 下面路由的信息已经准备好。</li><li>调用全局后置守卫afterEach，目标路由已经跳转结束，可处理一些收尾工作，比如跳转到目标页面的对应位置</li><li>目标组件DOM渲染</li><li>调用全局前置守卫beforeRouteEnter的回调函数next()，调用此函数时已经实例化，并把实例作为参数传递给组件路由的下一阶段使用（意思就是说组件已经渲染好了进入该组件的钩子也该结束了）</li></ul>]]></content>
    
    
    <categories>
      
      <category>前端框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue中整个初始化过程在做什么（解析、编译、渲染模板）</title>
    <link href="/2023/12/15/Vue%E4%B8%AD%E6%95%B4%E4%B8%AA%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B%E5%9C%A8%E5%81%9A%E4%BB%80%E4%B9%88%EF%BC%88%E8%A7%A3%E6%9E%90%E3%80%81%E7%BC%96%E8%AF%91%E3%80%81%E6%B8%B2%E6%9F%93%E6%A8%A1%E6%9D%BF%EF%BC%89/"/>
    <url>/2023/12/15/Vue%E4%B8%AD%E6%95%B4%E4%B8%AA%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B%E5%9C%A8%E5%81%9A%E4%BB%80%E4%B9%88%EF%BC%88%E8%A7%A3%E6%9E%90%E3%80%81%E7%BC%96%E8%AF%91%E3%80%81%E6%B8%B2%E6%9F%93%E6%A8%A1%E6%9D%BF%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是Vue的初始化？"><a href="#什么是Vue的初始化？" class="headerlink" title="什么是Vue的初始化？"></a><strong>什么是Vue的初始化？</strong></h2><p>初始化可以算是从Vue实例化到页面初次渲染后的过程，大致可以分为<strong>解析-&gt;编译-&gt;渲染模板</strong>这三个过程。</p><h3 id="解析阶段"><a href="#解析阶段" class="headerlink" title="解析阶段"></a><strong>解析阶段</strong></h3><p>Vue解析器开始去<strong>解析模板字符串</strong>，比如插值语法、指令等内容。接着，将解析后的内容<strong>生成抽象语法树</strong>（abstract syntax tree-AST），这是一个方便分析和处理数据的数据结构，它描述了各个元素节点的属性以及它们之间的关系。同时，在生成AST的同时，会进行<strong>静态标记</strong>，即标记哪些节点是静态的，这样在后续的渲染过程中会跳过这些节点，来提高渲染性能。</p><h3 id="编译阶段"><a href="#编译阶段" class="headerlink" title="编译阶段"></a>编译阶段</h3><p>在生成好了AST之后，Vue会<strong>遍历AST</strong>各个节点，来<strong>转换成渲染函数</strong>（render），它包含了最终的渲染逻辑，比如指令的代码指令（比如v-if转换成三元表达式）。</p><h3 id="渲染模板阶段"><a href="#渲染模板阶段" class="headerlink" title="渲染模板阶段"></a>渲染模板阶段</h3><p>渲染函数准备好了，此阶段就去<strong>执行这个渲染函数</strong>，此时它将数据映射到DOM元素上，实现了视图的渲染，初始<strong>虚拟DOM</strong>就此生成，由于是第一次渲染不涉及<strong>diff算法</strong>的比对，因此直接将虚拟DOM的内容patch到<strong>真实DOM</strong>中，由此完成了渲染。</p><h2 id="有许多面试题都涉及初始化的过程"><a href="#有许多面试题都涉及初始化的过程" class="headerlink" title="有许多面试题都涉及初始化的过程"></a>有许多面试题都涉及初始化的过程</h2><h3 id="请说说编译原理"><a href="#请说说编译原理" class="headerlink" title="请说说编译原理"></a>请说说编译原理</h3><p>直接回答<strong>解析阶段+编译阶段，</strong>因为严格上来说，编译阶段是包含解析阶段的，因为解析是为了方便编译的，而生成render函数才是重点。</p><h3 id="什么是自定义指令？请说说原理"><a href="#什么是自定义指令？请说说原理" class="headerlink" title="什么是自定义指令？请说说原理"></a>什么是自定义指令？请说说原理</h3><p>它本质上是装饰器，是Vue对HTML元素的扩展，给HTML添加自定义功能。</p><p>它包含如下几个生命周期钩子：</p><ul><li>bind：只调用一次，在指令绑定的时候执行，通常在此阶段初始化指令的效果。</li><li>inserted：被绑定元素插入其父元素时执行，通常在此阶段添加指令想要的事件。</li><li>update：被绑定元素所在的模板更新时调用，且无论绑定值是否变化都会调用。什么是绑定值？即当前自定义指令执行的条件。</li><li>componentUpdated：被绑定元素所在的模板完成一次更新周期时调用。</li><li>unbind：只调用一次，解绑时调用。什么时候会解绑？组件销毁、v-if条件不满足等。</li></ul><p>原理：</p><ol><li><p>解析指令</p><p>在解析阶段解析指令，并把所有解析的指令保存在directives数组中，这个数组包含指令的各个信息。</p></li><li><p>生成指令代码</p><p>在编译阶段，根据directives数组中的信息并调用genDirectives函数来生成指令代码，这个指令代码其实就是render函数的一部分。</p></li><li><p>注册生命周期钩子</p><p>在编译阶段，将上面介绍的所有钩子注册到一个叫cbs（callbacks）对象中，方便管理</p></li><li><p>执行生命周期钩子</p><p>在渲染模板阶段，模板开始渲染，指令代码被转换成模板上指令对应的内容，同时也开始执行cbs中的生命周期钩子。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>前端框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue中的diff算法以及虚拟DOM优缺点</title>
    <link href="/2023/12/11/Vue%E4%B8%AD%E7%9A%84diff%E7%AE%97%E6%B3%95/"/>
    <url>/2023/12/11/Vue%E4%B8%AD%E7%9A%84diff%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h3 id="什么是diff算法？"><a href="#什么是diff算法？" class="headerlink" title="什么是diff算法？"></a><strong>什么是diff算法？</strong></h3><p><strong>1、先说下diff算法它的简介以及作用：</strong></p><p>它是通过比较新旧DOM树的差异来减少更新的次数，最终提高渲染的性能的一种算法。</p><p><strong>2、它的实现遵循两个原则：</strong></p><ol><li>在比较差异时肯定要遍历旧DOM树，它用的是深度优先遍历，为什么？因为可以更快地把当前节点树给遍历完，不需要像广度优先遍历那样在同层来回切换节点，节省了时间和空间（内存）</li><li>使用双端比较策略来减少遍历的次数</li></ol><p><strong>3、下面说说双端策略的具体实现：</strong></p><p>首先用两个数组存放新旧节点树的节点，真实DOM里面的节点和旧节点树内容一致，新旧节点数组各有头尾两个指针。</p><p>接着，使用四种比较策略：分别是</p><ul><li>旧头与新头</li><li>旧尾与新尾</li><li>旧头与新尾</li><li>旧尾与新头</li></ul><p>在比较时，一旦发现相同的节点，新旧节点的头尾指针会向中间靠拢，此时还会再确认旧节点的位置是否与新节点的一致，如果一致保持不动，否则在真实DOM中移动到新节点对应的位置，这是移动操作；</p><p>如果四种比较策略未找到相同节点，则会在旧节点数组头尾指针的区间内遍历，能找到便还是和刚刚一样移动，唯一的不同就是要把遍历到的节点给置空，为什么？后面会讲。</p><p>如果遍历后也没找到，那么就把这个节点根据新节点数组相应位置插入到真实DOM中，这个是插入操作；</p><p>当新节点数组的头指针大于尾指针时，比较结束，此时会在旧节点树的头尾指针区间遍历一下 看看是否有新节点数组不要的节点，即新节点树没有的节点，没有的就删除真实DOM中相应的节点，这是删除操作。前面有找到的节点置空也是为了减少这个环节遍历的比较次数，提高了性能，这样一来，最终保证了真实DOM和新节点数组的内容一致。</p><p><img src="/2023/12/11/Vue%E4%B8%AD%E7%9A%84diff%E7%AE%97%E6%B3%95/diff.png" alt="双端策略"></p><p><strong>有位大佬把这个过程做成了一个动画，可帮助理解：<a href="https://wanglin2.github.io/VNode_visualization_demo/">https://wanglin2.github.io/VNode_visualization_demo/</a></strong></p><p>有一个问题：如何判断是同一个节点？</p><p>判断当前节点的标签tag和key是否一致，并且这个key要保证唯一性，否则在比较子节点时才会发现不是一个节点，又要重绘和重排（也叫回流），性能低下。</p><p>什么是重绘和回流？</p><p>重绘是指对重新绘制元素的外观，比如样式，性能损耗少，而重排涉及到整个布局的变动，性能损耗大，例如元素的大小和位置，一般来说先进行重排，确定布局了，再重绘，确定外观。</p><p><strong>3、说到key的注意点，顺便说下diff算法的不足</strong></p><ol><li>key如果不唯一会出现胡乱的就地复用，带来多余的重新渲染</li><li>如果遍历的DOM数层级太多，性能也不高</li></ol><h3 id="虚拟DOM优缺点？"><a href="#虚拟DOM优缺点？" class="headerlink" title="虚拟DOM优缺点？"></a><strong>虚拟DOM优缺点？</strong></h3><p><strong>优点：</strong></p><ol><li>跨平台：不依赖于任何平台或浏览器API</li><li>提高渲染性能</li></ol><p><strong>缺点：</strong></p><ol><li>首次渲染页面时，由于多了一层虚拟DOM计算，要慢一些</li></ol>]]></content>
    
    
    <categories>
      
      <category>前端框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue中双向绑定和响应式的关系</title>
    <link href="/2023/12/09/Vue%E4%B8%AD%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E5%92%8C%E5%93%8D%E5%BA%94%E5%BC%8F%E7%9A%84%E5%85%B3%E7%B3%BB/"/>
    <url>/2023/12/09/Vue%E4%B8%AD%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E5%92%8C%E5%93%8D%E5%BA%94%E5%BC%8F%E7%9A%84%E5%85%B3%E7%B3%BB/</url>
    
    <content type="html"><![CDATA[<h3 id="什么是双向绑定？"><a href="#什么是双向绑定？" class="headerlink" title="什么是双向绑定？"></a><strong>什么是双向绑定？</strong></h3><p>当我们用javascript更改model数据时，view会更新，然后用户更新view时，model也会更新。</p><h3 id="双向绑定的原理？"><a href="#双向绑定的原理？" class="headerlink" title="双向绑定的原理？"></a><strong>双向绑定的原理？</strong></h3><p><strong>1、先说一下双向绑定的组成部分：</strong></p><p>它包含view、model、view model三个部分，其中最重要的就是view model，使它实现的view和model的关联，双向绑定的原理最主要的就是view model的原理。</p><p>那view model它又包含两个部分，编译器和监听器，编译器实现view的变化影响model的变化，而model的变化影响view的变化是需要 【监听器+编译器】 一起实现的，后者其实就是指的是响应式。</p><p><strong>2、下面说响应式是怎么实现的（要用到监听器和编译器）：</strong></p><p>一开始该组件的的vue实例在初始化时对data数据进行响应式处理，这个过程发生在监听器中，在defineReactive中的Object.defineproperty进行数据劫持时会为每一个data中的属性创建一个Dep实例（订阅器），这个是依赖管理器，依赖是什么？指的是该数据相关的所有数据比如computed计算属性、监听器watch等，为什么要收集？因为要知道哪些数据后面可能要更新。</p><p>然后在编译器里，会开始寻找模版上的动态数据，比如指令、插值语法什么的，并初始化视图，一旦发现模版上有使用data中的动态数据，此时就会调用数据劫持中的getter函数，这时Dep就会开始收集依赖，同时为每一个依赖创建watcher，它是订阅者，来订阅Dep啥时候通知它数据变化了，它会为依赖绑定一个更新函数，为后续的更新做准备。一旦数据发生变化了，就会触发数据劫持的getter函数，此时Dep就会通知相应的watcher叫它执行相应的更新函数来实现响应式。watcher是怎么更新的，更新的策略是什么？一般来说，watcher更新是异步的，它会主动要求调度者scheduler将自己放到一个执行队列中，再下一个事件循环统一进行更新。这么做有以下好处：</p><ol><li>保证了正确的执行顺序，可以避免执行顺序错乱的问题</li><li>避免了频繁更新带来的性能问题</li></ol><p><strong>3、上面只是说了响应式的原理，下面说说编译器又如何让view的变化来影响model的：</strong></p><p>主要是通过在编译时对于使用到的事件的处理，通过事件可以让用户的操作影响到model中的数据，然后再通过上面的响应式，这就实现了双向绑定。</p><p><img src="/2023/12/09/Vue%E4%B8%AD%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E5%92%8C%E5%93%8D%E5%BA%94%E5%BC%8F%E7%9A%84%E5%85%B3%E7%B3%BB/MVVM.png" alt="MVVM原理图"></p>]]></content>
    
    
    <categories>
      
      <category>前端框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ionic项目中碰到的问题合集</title>
    <link href="/2023/11/22/Ionic%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%A2%B0%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E5%90%88%E9%9B%86/"/>
    <url>/2023/11/22/Ionic%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%A2%B0%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E5%90%88%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<h2 id="打包指令"><a href="#打包指令" class="headerlink" title="打包指令"></a><strong>打包指令</strong></h2><p>npm i cordova（坑：不安装导致一直打包失败）</p><p>ionic cordova platform add android@版本号  添加安卓平台</p><p>ionic cordova platform remove android  移除安卓平台</p><p>ionic cordova build android    打包指令</p><p>ionic cordova build android –prod –release <strong>未签名版</strong></p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a><strong>问题</strong></h2><h3 id="cordova插件使用"><a href="#cordova插件使用" class="headerlink" title="cordova插件使用"></a>cordova插件使用</h3><p>​    插件使用前先注入app.moudle.ts中 在provide中声明</p><h4 id="退出插件"><a href="#退出插件" class="headerlink" title="退出插件"></a>退出插件</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">cordova plugin add cordova-plugin-app-<span class="hljs-keyword">exit</span><br>npm i cordova-plugin-app-<span class="hljs-keyword">exit</span><br>navigator[<span class="hljs-string">&#x27;app&#x27;</span>].exitApp();<br></code></pre></td></tr></table></figure><h4 id="扫码插件"><a href="#扫码插件" class="headerlink" title="扫码插件"></a>扫码插件</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs typescript">ionic cordova plugin add cordova-plugin-cszbar<br>npm install <span class="hljs-meta">@ionic</span>-native/zbar<br><br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">ZBar</span>, <span class="hljs-title class_">ZBarOptions</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@ionic-native/zbar/ngx&#x27;</span>;<br><br><span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> zbar: ZBar</span>) &#123; &#125;<br><br>...<br><br><span class="hljs-keyword">let</span> <span class="hljs-attr">options</span>: <span class="hljs-title class_">ZBarOptions</span> = &#123;<br>      <span class="hljs-attr">flash</span>: <span class="hljs-string">&#x27;off&#x27;</span>,<br>      <span class="hljs-attr">drawSight</span>: <span class="hljs-literal">false</span><br>    &#125;<br><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">zbar</span>.<span class="hljs-title function_">scan</span>(options)<br>   .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> &#123;<span class="hljs-comment">//扫描结果</span><br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result); <span class="hljs-comment">// Scanned code</span><br>   &#125;)<br>   .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(error); <span class="hljs-comment">// Error message</span><br>   &#125;);<br></code></pre></td></tr></table></figure><h4 id="键盘组件"><a href="#键盘组件" class="headerlink" title="键盘组件"></a>键盘组件</h4><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs oxygene">ionic cordova plugin <span class="hljs-keyword">add</span> cordova-plugin-ionic-keyboard<br>npm install @ionic-native/keyboard<br><br>import <span class="hljs-comment">&#123; Keyboard &#125;</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@ionic-native/keyboard/ngx&#x27;</span><span class="hljs-punctuation">;</span><br><br><span class="hljs-keyword">constructor</span><span class="hljs-params">(<span class="hljs-keyword">private</span> keyboard: Keyboard)</span> <span class="hljs-comment">&#123; &#125;</span><br><br>...<br><br><span class="hljs-title function_">this</span>.<span class="hljs-title function_">keyboard</span>.<span class="hljs-title function_">show</span><span class="hljs-params">()</span>;<br><br>this.keyboard.hide()<span class="hljs-punctuation">;</span><br></code></pre></td></tr></table></figure><h4 id="gradle的坑"><a href="#gradle的坑" class="headerlink" title="gradle的坑"></a>gradle的坑</h4><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">依賴下載failed<br><br>將C:\Users\K<span class="hljs-number">19122897</span>.WKSCN\.gradle下的gradle.properties文檔的後面四行注釋<br></code></pre></td></tr></table></figure><h4 id="导航栏不显示"><a href="#导航栏不显示" class="headerlink" title="导航栏不显示"></a>导航栏不显示</h4><p>aap.component.ts中添加如下代碼</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ionic">initializeApp() &#123;<br> this.platform.ready().then(() =&gt; &#123;<br>  this.statusBar.styleDefault();<br>  //顯示狀態欄<br>  if (this.platform.is(&#x27;android&#x27;)) &#123;<br>  this.statusBar.overlaysWebView(false);<br>this.statusBar.backgroundColorByHexString(&#x27;#616161&#x27;);<br> &#125;<br>  this.splashScreen.hide(<br> &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="ionic事件监听"><a href="#ionic事件监听" class="headerlink" title="ionic事件监听"></a>ionic事件监听</h3><h4 id="返回键监听"><a href="#返回键监听" class="headerlink" title="返回键监听"></a>返回键监听</h4><p><a href="https://ionicframework.com/docs/developing/hardware-back-button">https://ionicframework.com/docs/developing/hardware-back-button</a></p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs delphi">import <span class="hljs-comment">&#123; Platform &#125;</span> from <span class="hljs-string">&#x27;@ionic/angular&#x27;</span>;<br><br>...<br><br><span class="hljs-function"><span class="hljs-keyword">constructor</span><span class="hljs-params">(<span class="hljs-keyword">private</span> <span class="hljs-keyword">platform</span>: <span class="hljs-keyword">Platform</span>)</span> <span class="hljs-comment">&#123;</span></span><br><span class="hljs-comment"><span class="hljs-function">  this.platform.backButton.subscribeWithPriority(5, () =&gt; &#123;</span></span><br><span class="hljs-comment"><span class="hljs-function">    console.log(&#x27;Another handler was called!&#x27;);</span></span><br><span class="hljs-comment"><span class="hljs-function">  &#125;</span>);</span><br><br>  this.<span class="hljs-keyword">platform</span>.backButton.subscribeWithPriority(<span class="hljs-number">10</span>, (processNextHandler) =&gt; <span class="hljs-comment">&#123;</span><br><span class="hljs-comment">    console.log(&#x27;Handler was called!&#x27;);</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    processNextHandler();</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">  &#125;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Ionic5-Angular中使用EventEmitter事件驱动实现不同页面通讯"><a href="#Ionic5-Angular中使用EventEmitter事件驱动实现不同页面通讯" class="headerlink" title="Ionic5 Angular中使用EventEmitter事件驱动实现不同页面通讯"></a>Ionic5 Angular中使用EventEmitter事件驱动实现不同页面通讯</h4><p><a href="http://www.ionic.wang/article-index-id-204.html">http://www.ionic.wang/article-index-id-204.html</a></p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">npm install <span class="hljs-comment">--save eventemitter3</span><br></code></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs typescript">在服務中定義<br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Injectable</span>&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@angular/core&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123;<span class="hljs-title class_">EventEmitter</span>&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;eventemitter3&#x27;</span>;<br><span class="hljs-meta">@Injectable</span>(&#123;<br>  <span class="hljs-attr">providedIn</span>: <span class="hljs-string">&#x27;root&#x27;</span><br>&#125;)<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EventService</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-attr">eventEmit</span>: <span class="hljs-built_in">any</span>;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 定义发射事件</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">eventEmit</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">EventEmitter</span>();<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">//監聽</span><br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">EventService</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../services/event.service&#x27;</span>;<br><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">eventService</span>.<span class="hljs-property">eventEmit</span>.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;login&#x27;</span>,<span class="hljs-function">(<span class="hljs-params">result</span>)=&gt;</span>&#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;执行&#x27;</span>);<br>&#125;)<br><br><span class="hljs-comment">//發佈廣播</span><br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">EventService</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../services/event.service&#x27;</span>;<br><span class="hljs-title function_">ionViewDidLeave</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">eventService</span>.<span class="hljs-property">eventEmit</span>.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&#x27;login&#x27;</span>,<span class="hljs-string">&#x27;登录页面退出了&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="解決android10系統上無法訪問http請求"><a href="#解決android10系統上無法訪問http請求" class="headerlink" title="解決android10系統上無法訪問http請求"></a>解決android10系統上無法訪問http請求</h3><p><strong>android:usesCleartextTraffic=”true”</strong></p><p>將E:\mycase\mo\UI\11-18\1\platforms\android\app\src\main目錄下AndroidManifest.xml修改如下</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">application</span> <span class="hljs-attr">android:label</span>=<span class="hljs-string">&quot;Cha.Android&quot;</span> <span class="hljs-attr">android:usesCleartextTraffic</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">application</span>&gt;</span><br><br><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">manifest</span> <span class="hljs-attr">...</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.INTERNET&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">application</span></span><br><span class="hljs-tag">        <span class="hljs-attr">...</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:usesCleartextTraffic</span>=<span class="hljs-string">&quot;true&quot;</span> //<span class="hljs-attr">看这里</span></span><br><span class="hljs-tag">        <span class="hljs-attr">...</span>&gt;</span><br>        ...<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">application</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">manifest</span>&gt;</span><br><br>巨坑 o.0<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Ionic</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发问题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于做人的思考</title>
    <link href="/2023/11/14/%E5%85%B3%E4%BA%8E%E5%81%9A%E4%BA%BA%E7%9A%84%E6%80%9D%E8%80%83/"/>
    <url>/2023/11/14/%E5%85%B3%E4%BA%8E%E5%81%9A%E4%BA%BA%E7%9A%84%E6%80%9D%E8%80%83/</url>
    
    <content type="html"><![CDATA[<p>前两天参加了我亲姐的婚礼，我从我爸身上学到了一些做人的道理。</p><p><strong>永远不要想着占别人便宜，因为别人都是看在眼里的</strong></p><p>老爸在清点收到的红包时发现一个关系很好的朋友红包给了1000，老爸立马说要回200回去，不能多拿别人的钱，让别人说闲话。因为之前他们家儿子结婚老爸给了800（一般人都给的400），他可能觉得很讲义气，这次又多给了200，相当于还这个情，<u>也就是说这个200还不一定是他本意想给的，是出于人情世故，即这里面是可能有不情愿的成分的。</u></p><p>什么叫会做人？<u>就是 不能让别人不舒服来让自己舒服</u>。人与人交往永远是平等的，你让别人不舒服别人为什么要和你交往？也就是说把这200还回去就是为了把对方可能的不舒服给消除，让双方都舒服，这样关系才处得好。</p><p>对方一开始肯定是会说”不要回，我们这么熟的关系要回什么”，<u>记住，这些都是客套话，每个人都要面子的</u>，你要做的就是强硬一点说“要回的，你这给的太多了啊…，你要是不接收我可要生气了啊…”</p><p><strong>做事的细节体现做人的素养</strong></p><p>在接我姐吃回门饭时，老爸开车进小区后，我说车直接停在后门，从后面进比较快，否则要绕一大圈，老爸立马说”要从正大门走的，不能走后门的，要懂规矩”，我才反应过来，看来还是只想着自己了。这里其实还是体现了上面说的，不能让别人不舒服而让自己舒服。</p>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>人情世故</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue中路由的history和hash模式的区别</title>
    <link href="/2023/10/11/Vue%E4%B8%AD%E8%B7%AF%E7%94%B1%E7%9A%84history%E5%92%8Chash%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2023/10/11/Vue%E4%B8%AD%E8%B7%AF%E7%94%B1%E7%9A%84history%E5%92%8Chash%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<p><strong>从原理上来看：</strong></p><p>hash模式是通过hashChange事件来监听URL的hash值（#以及后面的，会存储在location.hash中）的变化来匹配路由规则并加载对应组件的（路由规则以及组件资源在浏览器端的缓存中-bundle.js文件，匹配时会自动去掉#），这个过程是在浏览器端进行的，不会向服务器发送HTTP请求</p><p>而history模式是通过popState事件（历史记录栈顶状态的变化）来监听历史记录的变化（最终获取的是pathname）来匹配路由规则并加载对应组件的（后面和hash模式一样，仅仅是监听的东西不一样），其中，在监听之前，是通过H5的API（H5才出的，因此兼容性没有hash模式好）：pushState（）和replaceState来存储并修改历史记录为监听历史记录做准备</p><p><strong>从用途上来看：</strong></p><p>hash模式始终都不会向服务器发送请求（除了请求组件需要的数据），单页面应用也倾向于使用Hash模式———适合在项目准备上线时设置</p><p>而history模式是 在刷新页面或者手动输入URL 时会向服务器请求资源并重复覆盖浏览器的缓存资源，入宫没有对应的资源，会出现404，但是可以在后端配置返回什么，就可以避免404—————-适合在开发阶段测试数据时使用</p>]]></content>
    
    
    <categories>
      
      <category>前端框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>import type和import的区别</title>
    <link href="/2023/10/11/type%E5%92%8Cimport%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2023/10/11/type%E5%92%8Cimport%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<p><strong>import</strong></p><p>可导入值、类型、模块等任何可导入的东西</p><p><strong>import type</strong></p><p>只能导入 类型数据，比如interface</p><p><strong>import什么都可导入，为什么还要import type？</strong></p><ul><li>代码易于理解：一看就知道导入的内容是什么</li><li>更加规范、严谨：加了关键字后可对导入的内容进行数据检查，若导入的不是类型，会报错</li></ul>]]></content>
    
    
    <categories>
      
      <category>Ts</category>
      
    </categories>
    
    
    <tags>
      
      <tag>知识点</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js中filter和map函数的区别</title>
    <link href="/2023/09/22/js%E4%B8%ADfilter%E5%92%8Cmap%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2023/09/22/js%E4%B8%ADfilter%E5%92%8Cmap%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<p><strong>前言</strong></p><p>这两个函数用的非常多，但是有一定相似之处：都是对数组数据的处理，搞清楚区别很有必要。</p><p><strong>filter</strong></p><p>对数组数据的过滤，找到满足条件的数据即可——–<strong>数据是原数据的子集</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br><br><span class="hljs-keyword">const</span> evenNumbers = numbers.<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">number</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> number % <span class="hljs-number">2</span> === <span class="hljs-number">0</span>; <span class="hljs-comment">// 筛选出偶数</span><br>&#125;);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(evenNumbers); <span class="hljs-comment">// 输出: [2, 4]</span><br></code></pre></td></tr></table></figure><p><strong>map</strong></p><p>对原数组数据进行处理，返回一个新数组——–<strong>一般不是子集，是新数据</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br><br><span class="hljs-keyword">const</span> multipliedNumbers = numbers.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">number</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> number * <span class="hljs-number">2</span>; <span class="hljs-comment">// 将每个数字乘以2</span><br>&#125;);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(multipliedNumbers); <span class="hljs-comment">// 输出: [2, 4, 6, 8, 10]</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>常用函数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>npm看似安装成功但没成功的情形</title>
    <link href="/2023/09/08/npm%E7%9C%8B%E4%BC%BC%E5%AE%89%E8%A3%85%E6%88%90%E5%8A%9F%E4%BD%86%E6%B2%A1%E6%88%90%E5%8A%9F%E7%9A%84%E6%83%85%E5%BD%A2/"/>
    <url>/2023/09/08/npm%E7%9C%8B%E4%BC%BC%E5%AE%89%E8%A3%85%E6%88%90%E5%8A%9F%E4%BD%86%E6%B2%A1%E6%88%90%E5%8A%9F%E7%9A%84%E6%83%85%E5%BD%A2/</url>
    
    <content type="html"><![CDATA[<p><img src="/2023/09/08/npm%E7%9C%8B%E4%BC%BC%E5%AE%89%E8%A3%85%E6%88%90%E5%8A%9F%E4%BD%86%E6%B2%A1%E6%88%90%E5%8A%9F%E7%9A%84%E6%83%85%E5%BD%A2/npm%E5%AE%89%E8%A3%85%E7%BB%93%E6%9E%9C.png" alt="npm安装结果"></p><p>像这种一堆警告而且还没报完的，说明没有安装成功，虽然还有up to date…</p><p><strong>解决方法</strong></p><p>使用cnpm安装</p><blockquote><p>优先还是使用npm，因为镜像仓库和原仓库不完全一致</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Npm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>npm操作问题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue2中父子传值和插槽的区别</title>
    <link href="/2023/09/07/Vue2%E4%B8%AD%E7%88%B6%E5%AD%90%E4%BC%A0%E5%80%BC%E5%92%8C%E6%8F%92%E6%A7%BD%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2023/09/07/Vue2%E4%B8%AD%E7%88%B6%E5%AD%90%E4%BC%A0%E5%80%BC%E5%92%8C%E6%8F%92%E6%A7%BD%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<p><strong>前言</strong></p><p>突然发现父子传值和插槽似乎有类似的功能，但是很迷糊，想要搞清楚一下</p><p><strong>父子传值</strong></p><p>父组件传数据给子组件使用</p><p><strong>插槽</strong></p><p>父组件自定义内容传递到自组建的插槽位置处</p><blockquote><p>顺便复习下种类：默认插槽（有默认位置）、具名插槽（有名字）、作用域插槽（需要子组件作用域内的数据，则向父组件传递，内容准备好了再传给子组件）</p></blockquote><p><strong>区别</strong></p><p>父子传值仅仅是把值给子组件，子组件要怎么使用，父组件并不关心</p><p>而插槽是子组件位置确定了，内容也确定了（父组件提供），即共同确定父子组件整体页面的显示</p>]]></content>
    
    
    <categories>
      
      <category>前端框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue2中父子传值的内部过程</title>
    <link href="/2023/09/07/Vue2%E4%B8%AD%E7%88%B6%E5%AD%90%E4%BC%A0%E5%80%BC%E7%9A%84%E5%86%85%E9%83%A8%E8%BF%87%E7%A8%8B/"/>
    <url>/2023/09/07/Vue2%E4%B8%AD%E7%88%B6%E5%AD%90%E4%BC%A0%E5%80%BC%E7%9A%84%E5%86%85%E9%83%A8%E8%BF%87%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p><strong>前言</strong></p><p>在学习Vue3中的Setup注意点，有专门提到父子传值，内容打破了我固有观念，有必要记录一下。</p><p><strong>广义上来看</strong></p><p>父组件的数据-&gt;子组件用props接受-&gt;props将数据交给vm的data-&gt;子组件到模板中使用</p><p><strong>从狭义上来看</strong></p><p>我们默认子组件是用props接受的，那万一子组件不用props接受呢？真的就用不了吗？</p><p>不，如果没有用props接受，<strong>那么会先存在vm.$attrs中，一旦使用props接受了，再把数据从vm.$attrs移交给props</strong>，后续和广义上的流程一样。</p><p><strong>也就是说：</strong>vm.$attrs相当于一个<strong>暂为保管的中转站</strong>，如果没有props接受，仍然可以用vm,attrs访问，相当于一个<strong>兜底</strong>的作用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;&#123;vm.<span class="hljs-property">atts</span>.数据&#125;&#125;<span class="hljs-comment">//使用方法</span><br></code></pre></td></tr></table></figure><blockquote><p>这种做法在其它部分有类似的地方：插槽</p><p>在子组件没有写<slot>标签时，插槽内容是暂存储在vm.slots里面的</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>前端框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Reactive对比Ref</title>
    <link href="/2023/09/07/Reactive%E5%AF%B9%E6%AF%94Ref/"/>
    <url>/2023/09/07/Reactive%E5%AF%B9%E6%AF%94Ref/</url>
    
    <content type="html"><![CDATA[<ul><li>从定义数据的角度：<ul><li>ref用来定义：<strong>基本数据类型</strong></li><li>reactive用来定义：<strong>引用数据类型（包括数组）</strong></li><li>ref也可以定义引用数据类型，只是它的内部使用的就是reactive的proxy</li></ul></li><li>从实现原理的角度<ul><li>ref通过<strong>Object.defineproperty</strong>的get和set实现响应式</li><li>reactive通过<strong>proxy</strong>实现响应式，通过<strong>reflect</strong>操作原对象的数据</li></ul></li><li>从使用的角度<ul><li>ref定义过的数据：在操作数据时需要**.value**，而访问数据不需要</li><li>reactive定义过的数据：在操作数据和访问数据时都不需要**.value**</li></ul></li></ul><p><strong>规范使用：尽量全都使用reactive</strong></p><p><strong>reactive不是无法对基本数据类型使用吗？</strong></p><p>不，有一个套路：将基本数据类型和引用类型全都包含在一个对象内，类似这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> data = <span class="hljs-title function_">reactive</span>(&#123;<br>    <span class="hljs-attr">material</span>:<span class="hljs-string">&#x27;材料&#x27;</span>,<br>    <span class="hljs-attr">person</span>:&#123;...&#125;,<br>&#125;)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue2中数据代理和数据劫持的关系</title>
    <link href="/2023/09/05/Vue2%E4%B8%AD%E6%95%B0%E6%8D%AE%E4%BB%A3%E7%90%86%E5%92%8C%E6%95%B0%E6%8D%AE%E5%8A%AB%E6%8C%81%E7%9A%84%E5%85%B3%E7%B3%BB/"/>
    <url>/2023/09/05/Vue2%E4%B8%AD%E6%95%B0%E6%8D%AE%E4%BB%A3%E7%90%86%E5%92%8C%E6%95%B0%E6%8D%AE%E5%8A%AB%E6%8C%81%E7%9A%84%E5%85%B3%E7%B3%BB/</url>
    
    <content type="html"><![CDATA[<p><strong>数据代理</strong></p><p>指的是将data中的属性代理到Vue实例中，方便通过Vue实例来访问data中的属性</p><p><strong>数据劫持</strong></p><p>通过Object.defineproperty对即将访问或更新的数据添加getter和setter函数来实现数据的响应</p><p><strong>关系</strong></p><p>先 数据代理，方便访问后，再进行 数据劫持，触发响应式更新。</p>]]></content>
    
    
    <categories>
      
      <category>前端框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue2和Vue3响应式数据的处理的不同</title>
    <link href="/2023/09/04/vue2%E5%92%8Cvue3%E5%93%8D%E5%BA%94%E5%BC%8F%E6%95%B0%E6%8D%AE%E7%9A%84%E5%A4%84%E7%90%86%E7%9A%84%E4%B8%8D%E5%90%8C/"/>
    <url>/2023/09/04/vue2%E5%92%8Cvue3%E5%93%8D%E5%BA%94%E5%BC%8F%E6%95%B0%E6%8D%AE%E7%9A%84%E5%A4%84%E7%90%86%E7%9A%84%E4%B8%8D%E5%90%8C/</url>
    
    <content type="html"><![CDATA[<p><strong>Vue2</strong></p><p>经过Object.defineproperty添加getter和setter来实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> person = &#123;<br>    <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;周杰&#x27;</span><br>&#125;<br><span class="hljs-comment">// 添加age属性</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineproperty</span>(person,<span class="hljs-string">&#x27;age&#x27;</span>,&#123;<br>      <span class="hljs-attr">configurable</span>:<span class="hljs-literal">true</span>;<span class="hljs-comment">//配置后可删除，但是无响应式</span><br>      <span class="hljs-attr">value</span>:<span class="hljs-number">19</span>,<br>      <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>,        <br>      <span class="hljs-attr">writable</span>: <span class="hljs-literal">true</span>,<br>    <br>      <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>)&#123;<br>          <span class="hljs-keyword">return</span> number <span class="hljs-comment">//为了使得age值一样，于是直接返回number</span><br>      &#125;,<br>      <span class="hljs-title function_">set</span>(<span class="hljs-params">value</span>)&#123;<br>          <span class="hljs-variable language_">this</span>.<span class="hljs-property">number</span> = value <span class="hljs-comment">//为了使得同时修改number，直接将值赋值给number</span><br>      &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p><strong>Vue3</strong></p><p>通过reactive它内部的proxy和Reflect（都是window内置对象-ES6新增）来实现（针对引用类型）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title function_">proxy</span>(person,&#123;<br>      <span class="hljs-title function_">get</span>(<span class="hljs-params">target,propName</span>)&#123;<br>          <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(target,propName) <br>      &#125;,<br>      <span class="hljs-comment">// 修改和添加时都会调用，类似 Vue.set或vm.$set()</span><br>      <span class="hljs-title function_">set</span>(<span class="hljs-params">target,propName,value</span>)&#123;<br>          <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">set</span>(target,propName,value) <br>      &#125;,<br>      <span class="hljs-title function_">deleteProperty</span>(<span class="hljs-params">target,propName</span>)&#123;<br>          <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">deleteProperty</span>(target,propName)<span class="hljs-comment">// true/false</span><br>      &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p><strong>Vue3相对于Vue2的实现优点</strong></p><p>Vue2缺点： </p><p>1.无法直接对对象进行添加和删除响应式操作（对象.新属性=值、delete 对象.属性名），只能使用Vue.set()或vm.$set()、Vue.delete()或vm.$delete   —– <strong>对象</strong></p><p>2.无法直接通过索引修改数组自动更新（只能用vm.$set或splice等方法）—– <strong>数组</strong></p><blockquote><p>注意：Vue2中，如果 通过索引修改数组的同时又修改了基本数据类型，那么此时数组仍然可以自动更新到页面 ，因为基本数据类型触发了响应式更新，看到数组有变化了顺带也更新了</p></blockquote><p>3.每次只能某个属性进行相应式修改，如果属性很多，代码会冗余</p><p>4.对同一个属性重复设置会报错，只能在外面手写try—catch，否则运行失败</p><p>Vue3优点：</p><p>弥补了Vue2实现的所有缺点</p><blockquote><p>注意：可以直接修改对象属性，但不能对对象重新赋值，比如：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> job = <span class="hljs-title function_">reactive</span>(&#123;<span class="hljs-attr">type</span>:<span class="hljs-string">&#x27;前端&#x27;</span>,<span class="hljs-attr">salary</span>:<span class="hljs-string">&#x27;10k&#x27;</span>&#125;)<br><br><span class="hljs-comment">// 点击修改job</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">change</span>(<span class="hljs-params"></span>)&#123;<br>    job = &#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;周杰&#x27;</span>,<span class="hljs-attr">age</span>:<span class="hljs-number">18</span>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>因为重新赋值意味着新的引用，而reactive只是对{type:’前端’,salary:’10k’}这个对象赋予响应式更新的能力，并非{name:’周杰’,age:18}</p></blockquote><p><strong>总结：Vue3的proxy用法更方便，使用风格更贴近于原生</strong></p>]]></content>
    
    
    <categories>
      
      <category>前端框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>横向比较</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kafka和Nifi的使用</title>
    <link href="/2023/08/31/kafka%E5%92%8Cnifi%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2023/08/31/kafka%E5%92%8Cnifi%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="Nifi"><a href="#Nifi" class="headerlink" title="Nifi"></a>Nifi</h3><p><strong>1.nifi是什么？</strong></p><p>为了解决不同系统之间数据自动流通的问题的工具</p><p><strong>2.使用场景？</strong></p><p>高效且可被追踪的 将数据 从A搬到B，B搬到C，C搬到A等等</p><p>01视频是为了测试消息消费者是否能转发给下一个消息发布者，当我手动在 消息消费者 那儿发布一则消息，那么 消息消费者 自动转发给了 下一个消息发布这那儿，那我在消息发布者那儿订阅消息，如果能获取到，那就说明 进行了转发操作</p><p>那为什么 地点在同一个位置也可以收到呢？</p><p>因为 同一个地点发布同一个地点订阅当然能收到，在此之前没有 经过转发操作</p><p><strong>3</strong>.<strong>Nifi的一些常见术语</strong></p><p>Flow File：系统中移动的每个对象，包含 属性和内容 两个变量</p><p>Prosess File：对Flow File中的数据进行处理</p><h3 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h3><p>它被设计用于高吞吐量、低延迟和可持久性的数据流处理。Kafka主要用于解决应用程序之间的异步通信、数据传输和事件流处理等后端场景。</p><p>将Kafka作为后端技术的例子包括：</p><ol><li>数据流处理：Kafka常用于在大规模数据流中传递、存储和处理数据，例如实时日志采集、事件处理、数据管道等。</li><li>消息队列：Kafka作为一种高性能的消息队列，可以作为后端的消息中间件，用于解耦和缓冲生产者和消费者之间的通信，支持发布-订阅模式。</li></ol><h3 id="MQTT"><a href="#MQTT" class="headerlink" title="MQTT"></a>MQTT</h3><p>和kafka类似的消息传递系统。</p><h4 id="下面是一个消息的传递实例：MQTT-gt-nifi-gt-kafka-gt-nifi-gt-MQTT"><a href="#下面是一个消息的传递实例：MQTT-gt-nifi-gt-kafka-gt-nifi-gt-MQTT" class="headerlink" title="下面是一个消息的传递实例：MQTT-&gt;nifi-&gt;kafka-&gt;nifi-&gt;MQTT"></a>下面是一个消息的传递实例：MQTT-&gt;nifi-&gt;kafka-&gt;nifi-&gt;MQTT</h4><h6 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h6><p>1）创建按一个consumer并配置（和练习的一样）</p><p>2）创建一个Extract Text（拖下来后在里面搜），用于对资料的截取，并配置如下</p><p><img src="/2023/08/31/kafka%E5%92%8Cnifi%E7%9A%84%E4%BD%BF%E7%94%A8/%E9%85%8D%E7%BD%AE1.png" alt="配置"></p><p>3）将前两个processor连接起来，1）-&gt; 2），这样在consumer那儿 pub资料后，资料会流到2）来进行截取资料</p><p>4）新建一个 ReplaceText（在里面搜），并进行如下配置，目的是 在传递给kafka之前要有一个数据的标准形式，这里的Replace可以看成是 格式的 replace</p><p><img src="/2023/08/31/kafka%E5%92%8Cnifi%E7%9A%84%E4%BD%BF%E7%94%A8/%E9%85%8D%E7%BD%AE2.png" alt="配置2"></p><p>5）新建一个kafka的processor（.10.1版本），先配置，因为是最后一个processor，因此后面相关的都terminal </p><p><img src="/2023/08/31/kafka%E5%92%8Cnifi%E7%9A%84%E4%BD%BF%E7%94%A8/%E9%85%8D%E7%BD%AE3.png" alt="配置3"></p><p><img src="/2023/08/31/kafka%E5%92%8Cnifi%E7%9A%84%E4%BD%BF%E7%94%A8/%E9%85%8D%E7%BD%AE4.png" alt="配置4"></p><p>再将箭头 从replace拉到 kafka处，配置connection的relationship为success，表示 只有成功匹配并处理才会抛给kafka</p><p>再配置replace</p><p>然后可以测试了，测试内容在01视频最后</p><p><img src="/2023/08/31/kafka%E5%92%8Cnifi%E7%9A%84%E4%BD%BF%E7%94%A8/%E9%85%8D%E7%BD%AE5.png" alt="配置5"></p><p>6）新建一个工作区<img src="/2023/08/31/kafka%E5%92%8Cnifi%E7%9A%84%E4%BD%BF%E7%94%A8/%E9%85%8D%E7%BD%AE6.png" alt="配置6"></p><p>7）新建一个consumerkafka，配置如下：</p><p><img src="/2023/08/31/kafka%E5%92%8Cnifi%E7%9A%84%E4%BD%BF%E7%94%A8/%E9%85%8D%E7%BD%AE7.png" alt="配置7"></p><p>8）添加一个MQTTPublish，将连接 从Kkafka连向这个，然后connect配置还是success。它的配置如下：</p><p><img src="/2023/08/31/kafka%E5%92%8Cnifi%E7%9A%84%E4%BD%BF%E7%94%A8/%E9%85%8D%E7%BD%AE8.png" alt="配置8"></p><p><img src="/2023/08/31/kafka%E5%92%8Cnifi%E7%9A%84%E4%BD%BF%E7%94%A8/%E9%85%8D%E7%BD%AE9.png" alt="配置9"></p><p>然后在最后这订阅进行测试</p>]]></content>
    
    
    <categories>
      
      <category>后端技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>kafka、nifi</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>k8s、harbor、docker、rancher的关系？</title>
    <link href="/2023/08/31/k8s%E3%80%81docker%E3%80%81rancher%E7%9A%84%E5%85%B3%E7%B3%BB/"/>
    <url>/2023/08/31/k8s%E3%80%81docker%E3%80%81rancher%E7%9A%84%E5%85%B3%E7%B3%BB/</url>
    
    <content type="html"><![CDATA[<p>docker从harbor那去取镜像来运行，而运行项目需要 K8S 来统一编排docker容器，而rancher是提供了良好的管理工具和界面更方便地使用k8s集群。下面是关系图：</p><p><img src="/2023/08/31/k8s%E3%80%81docker%E3%80%81rancher%E7%9A%84%E5%85%B3%E7%B3%BB/k8s%E3%80%81docker%E3%80%81rancher%E7%9A%84%E5%85%B3%E7%B3%BB.png" alt="k8s、docker、rancher的关系"></p>]]></content>
    
    
    <categories>
      
      <category>构建与部署</category>
      
    </categories>
    
    
    <tags>
      
      <tag>部署工具与平台</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>利用CICD从gitlab到部署的流程</title>
    <link href="/2023/08/31/%E5%88%A9%E7%94%A8CICD%E4%BB%8Egitlab%E5%88%B0%E9%83%A8%E7%BD%B2%E7%9A%84%E6%B5%81%E7%A8%8B/"/>
    <url>/2023/08/31/%E5%88%A9%E7%94%A8CICD%E4%BB%8Egitlab%E5%88%B0%E9%83%A8%E7%BD%B2%E7%9A%84%E6%B5%81%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>1.在 gitlab 上下载cicd文件以及 加载模板，更新runner</p><p>​                        配置cicd的variables，更新harbor名、gitlab-key、gitab-url</p><p>​                                                                      harbor-user、 harbor-password，等待执行cicd的pipelines</p><p>2.在harbor上查看刚刚推上来的项目，点进去，复制 pull 命令</p><p>3.在rancher上在workloads上点击deploy，输入地址，把pull给去掉，保留后面的</p><p>​                         在service discovery，添加record，设置项目端口</p><p>​                         在load balancing上，添加ingress，用于将前两个连接起来，并生成一个域名   </p>]]></content>
    
    
    <categories>
      
      <category>构建与部署</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CICD</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CICD</title>
    <link href="/2023/08/31/CICD/"/>
    <url>/2023/08/31/CICD/</url>
    
    <content type="html"><![CDATA[<h3 id="什么是CICD？"><a href="#什么是CICD？" class="headerlink" title="什么是CICD？"></a>什么是CICD？</h3><p>指持续集成和持续部署的软件开发实践方法，可以提前在yaml档进行配置，之后可以自动化执行这个脚本，其中包括对代码的 构建、代码检查、release、dockerize等</p><h3 id="怎么使用GitLab-CI？"><a href="#怎么使用GitLab-CI？" class="headerlink" title="怎么使用GitLab CI？"></a>怎么使用GitLab CI？</h3><p> 在项目下面创建一个.gitlab-ci.yml文件，里面包含了  集成、测试 的一些配置，到时候一旦 本地仓库push到gitlab上面之后，会通过 GitLab-Runner 自动执行配置好的一些行为</p><h3 id="什么是GitLab-Running"><a href="#什么是GitLab-Running" class="headerlink" title="什么是GitLab-Running?"></a>什么是GitLab-Running?</h3><p>GitLab-Running可能不止一个，因此GitLab CI需要找到提前注册好的GitLab-Running来帮他执行脚本</p><p>每种GitLab-Running能做的行为都不同</p><ul><li><h4 id="怎么注册并安装、启动一个GitLab-Running？"><a href="#怎么注册并安装、启动一个GitLab-Running？" class="headerlink" title="怎么注册并安装、启动一个GitLab-Running？"></a>怎么注册并安装、启动一个GitLab-Running？</h4><p>1）<a href="http://10.37.37.139/packages/">Index of /packages/</a> ——– 下载 gitlab-runner程序，用来当作命令行命令使用</p><p>2）下载 wistron-root.crt ——– 证书，用于给gitlab注册runner使用</p><p><img src="/2023/08/31/CICD/%E4%B8%8B%E8%BD%BD%E8%AF%81%E4%B9%A6%E9%A1%B5.png" alt="下载证书页"></p><p>2）进入刚刚下载的git-runner程序的文件夹，将此程序 命名为gitlab-runner.exe，因为命令的名字就是 gitlab-runner，打开cmd，输入指令注册runner：</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs delphi">gitlab-runner <span class="hljs-keyword">register</span> --tls-ca-<span class="hljs-keyword">file</span> wistron-root.crt的路径<br></code></pre></td></tr></table></figure></li></ul><p>​        3）打开gitlab进入自己的主页，新建一个项目，进入如图页面</p><p><img src="/2023/08/31/CICD/gitlab%E8%AE%BE%E7%BD%AE.png" alt="gitlab设置"></p><p>​          4）根据提示输入url和token</p><p><img src="/2023/08/31/CICD/%E6%A0%B9%E6%8D%AE%E6%8F%90%E7%A4%BA%E8%BE%93%E5%85%A5url%E5%92%8Ctoken.png" alt="根据提示输入url和token"></p><p>​          5）输入runner的描述和tags</p><p>​          6）选择docker为执行者，再输入如下作为docker image（镜像）：</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">alpine:</span>latest<br></code></pre></td></tr></table></figure><p><img src="/2023/08/31/CICD/%E9%80%89%E6%8B%A9docker.png" alt="选择docker"></p><p>​          7）安装到自己的项目下（刚刚只完成了注册操作，注册就相当于下载，还需要安装才能使用），执行：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">gitlab-runner <span class="hljs-keyword">install</span> --working-<span class="hljs-keyword">file</span>=gitlab-runner<br></code></pre></td></tr></table></figure><p><strong>如果出现</strong>： </p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">FATAL：Failed to <span class="hljs-keyword">install</span> gitlab-runner：service gitlab-runner already <span class="hljs-keyword">exists</span><br></code></pre></td></tr></table></figure><p>则先卸载再安装和启动，这时不需要指定指定的–working-file</p><p><img src="/2023/08/31/CICD/%E5%8D%B8%E8%BD%BD.png" alt="卸载"></p><p><strong>——这是在之前的cicd的runner页面就可以看到自己刚刚创建的running已经启动了（绿色）</strong></p><hr><p>以上可以不用看，直接 选用公司的runner就行，其中tags为：</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs subunit"><span class="hljs-keyword">tags:</span><br>   - k8s-runners<br></code></pre></td></tr></table></figure><h3 id="什么是Git-Running-excutor？"><a href="#什么是Git-Running-excutor？" class="headerlink" title="什么是Git-Running excutor？"></a>什么是Git-Running excutor？</h3><p>它是帮助GitLab-Running执行的，也就是GitLab-Running的工具</p><h3 id="GitLab-CI语法"><a href="#GitLab-CI语法" class="headerlink" title="GitLab-CI语法"></a>GitLab-CI语法</h3><p><strong>格式：</strong>yml</p><p><strong>例子：</strong>job就相当于一个个 脚本，stages包含各阶段的名称，一个job执行一个stage，script为job的脚本名称</p><p><img src="/2023/08/31/CICD/script1.png" alt="script1"></p><p><strong>注意：保留字不能作为job name，相当于编程中的保留字不能做变量名</strong></p><p><strong>基础指令：</strong></p><p> 1）image &amp; services ——– 指定镜像以及附加服务</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">image:</span><br><span class="hljs-symbol">  docker:</span>stable<br><span class="hljs-symbol"></span><br><span class="hljs-symbol">services:</span><br>  - name:docker:dind<br>    entrypointL[]<br><span class="hljs-symbol">    command:</span>[<span class="hljs-string">&quot;--security-register=harbor-k8s.wistron.com&quot;</span>]<br></code></pre></td></tr></table></figure><p>2）stages &amp; job</p><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">stages</span><span class="hljs-punctuation">:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">build</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">test</span><br><span class="hljs-attribute">job</span><span class="hljs-punctuation">:</span><br>  stage:build<br></code></pre></td></tr></table></figure><p>3）before_script &amp; after_script：用来定义 job 开始前 和 开始后 的脚本，既可以放在job之前，也可以放在job内部<img src="/2023/08/31/CICD/script2.png" alt="script2"></p><p>4）only &amp; except：限制执行的branch，不会执行develop这个分支</p><p>​      tags：设定执行的runner</p><p><img src="/2023/08/31/CICD/script3.png" alt="script3"></p><p>5）artifacts：添加特定档案或者目录在job上</p><p>​      artfacts:paths：将指定路径的档案或目录放到job</p><p>​      artfacts:when：什么时候存放，on_success、on_failure、always</p><p>​      artfacts:expire_in：档案或目录存放的时间，通常不要设置太大，否则存放的文档太多</p><p><img src="/2023/08/31/CICD/script4.png" alt="script4"></p><p><strong>需要注意格式问题：关键字冒号后面的内容一定要加空格</strong></p><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">image</span><span class="hljs-punctuation">:</span> <span class="hljs-string">docker:stable            -------image冒号后面要加空格，docker不是关键字，只是和stable一起                                        成为image的内容</span><br><span class="hljs-attribute">stages</span><span class="hljs-punctuation">:</span><br> <span class="hljs-bullet">-</span> <span class="hljs-string">Build image</span><br><span class="hljs-attribute">build</span><span class="hljs-punctuation">:</span><br> <span class="hljs-attribute">stage</span><span class="hljs-punctuation">:</span> <span class="hljs-string">Build image             -------stage冒号后面要加空格</span><br> <span class="hljs-attribute">tags</span><span class="hljs-punctuation">:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">runner01</span><br> <span class="hljs-attribute">script</span><span class="hljs-punctuation">:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">docker info</span><br></code></pre></td></tr></table></figure><hr><h3 id="docker和harbor的区别？"><a href="#docker和harbor的区别？" class="headerlink" title="docker和harbor的区别？"></a>docker和harbor的区别？</h3><p>harbor是存放镜像源的，而docker是运行镜像源的</p><hr><h3 id="如何使用gitlab-tool下载cicd的一些必须文件并使用？"><a href="#如何使用gitlab-tool下载cicd的一些必须文件并使用？" class="headerlink" title="如何使用gitlab tool下载cicd的一些必须文件并使用？"></a>如何使用gitlab tool下载cicd的一些必须文件并使用？</h3><p>1.网址：<a href="http://gittemplate-ui-dev.k8s-dev.k8s.wistron.com/ciscript">UI (wistron.com)</a></p><p>​           把angular的所有文件都下下来，除了old版本的文件</p><p>2.只要改一个文件.gitlab-ci.yml，而且改的内容也不多，只要改革 runner的tags</p><p>用公司的k8s-runners就行</p><p>3.打开 <a href="http://gittemplate-ui-dev.k8s-dev.k8s.wistron.com/pjtmp">UI (wistron.com)</a> ——– 输入项目相关信息，生成cicd的一些参数模板</p><p>4.在setting中的cicd的配置中的variable参数中，找到GITLAB-KEY，输入 setting 中的access tokens</p><p>​                                                                                           HARBOR-USER、HARBOR-PASSWORD，分别输入</p><p>k8si40和W#g5xT#y2d</p><p>​                                                                                           VERSION-FILE，在本地项目加一个文件version.txt</p>]]></content>
    
    
    <categories>
      
      <category>构建与部署</category>
      
    </categories>
    
    
    <tags>
      
      <tag>自动化流程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>gitlab的sshkey过期问题</title>
    <link href="/2023/08/31/gitlab%E7%9A%84sshkey%E8%BF%87%E6%9C%9F%E9%97%AE%E9%A2%98/"/>
    <url>/2023/08/31/gitlab%E7%9A%84sshkey%E8%BF%87%E6%9C%9F%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>1.输入ssh-keygen -t rsa -C<br>your email 替换成申请好的邮箱即可<br>ssh-keygen -t rsa -C “your email”<br>2.接着如下提示说让输入生成id_rsa文件的路径<br>复制你自己那括号里的路径就行<br>Enter file in which to save the key (~/.ssh/id_rsa):<br>3.接着提示设置密码，然后等待生成<br>Enter passphrase (empty for no passphrase):<br>Enter same passphrase again:<br>4.输入如下命令打开生成好的id_rsa.pub文件，复制里面的公钥用<br>cat ~/.ssh/id_rsa.pub<br>pbcopy &lt; ~/.ssh/id_rsa.pub<br>3.登录对应工作环境gitlab<br>打开gitlab网站，登录后，找到setting栏，再找到SSH key栏，选择ADD SSH KEY，把上面复制的公钥粘贴进去，OK</p>]]></content>
    
    
    <categories>
      
      <category>Gitlab</category>
      
    </categories>
    
    
    <tags>
      
      <tag>sshkey过期</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git常用命令</title>
    <link href="/2023/08/31/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <url>/2023/08/31/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<p>git clone @———–</p><p>git init 新建一个空的仓库<br>git status 查看状态<br>git add . 添加文件<br>git commit -m ‘注释’ 提交添加的文件并备注说明<br>git remote add origin <a href="mailto:&#x67;&#105;&#116;&#64;&#x67;&#105;&#116;&#x68;&#117;&#98;&#46;&#x63;&#x6f;&#109;">&#x67;&#105;&#116;&#64;&#x67;&#105;&#116;&#x68;&#117;&#98;&#46;&#x63;&#x6f;&#109;</a>:jinzhaogit/git.git 连接远程仓库<br>git push -u origin master 将本地仓库文件推送到远程仓库<br>git log 查看变更日志<br>git reset –hard 版本号前六位 回归到指定版本<br>git branch 查看分支<br>git branch newname 创建一个叫newname的分支<br>git checkout newname 切换到叫newname的分支上<br>git merge newname 把newname分支合并到当前分支上<br>git pull origin master 将master分支上的内容拉到本地上</p>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>常用命令</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ts语法</title>
    <link href="/2023/08/30/Typescript%E8%AF%AD%E6%B3%95/"/>
    <url>/2023/08/30/Typescript%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h3 id="什么是TypeScript？"><a href="#什么是TypeScript？" class="headerlink" title="什么是TypeScript？"></a>什么是TypeScript？</h3><p>1.是js的超集（js有的ts也有，而且ts还有js没有的东西）</p><p>2.没有的部分主要添加了类型检查，所以说名字有Type</p><h3 id="TypeScript为什么要添加类型支持？"><a href="#TypeScript为什么要添加类型支持？" class="headerlink" title="TypeScript为什么要添加类型支持？"></a>TypeScript为什么要添加类型支持？</h3><p>因为js经常会出现类型错误，ts就是来弥补这一缺陷的</p><ul><li><p><strong>为什么js经常会出现类型错误，ts又是如何解决的呢？</strong></p><p>编译语言分为静态语言（ts）和动态语言（js），静态语言是在编译时进行类型检查的，而动态语言是在运行时检查类型的，由于js每次在运行时才检查类型发现错误时就已经晚了，所以会经常出现类型错误，而ts在编译时配合VSCode编译器可以在编写代码时就及时提示错误的类型并加以改正，因此运行后bug就减少了许多。</p></li></ul><h3 id="TypeScript相比JavaScript的优势？"><a href="#TypeScript相比JavaScript的优势？" class="headerlink" title="TypeScript相比JavaScript的优势？"></a>TypeScript相比JavaScript的优势？</h3><p>1.任何地方都有代码提示，随时随地的安全感，提升代码体验</p><p>2.类似地，错误也会更早地发现，减少维护成本</p><p>3.支持js的最新语法，让你走在技术的最前端</p><p>4.支持类型推断：并不用任何地方都要写类型，即享受着ts的优势，又能减少开发成本</p><h3 id="为什么要安装TypeScript工具包？"><a href="#为什么要安装TypeScript工具包？" class="headerlink" title="为什么要安装TypeScript工具包？"></a>为什么要安装TypeScript工具包？</h3><p>因为node.js/浏览器只认识js，不认识ts，需要TypeScript工具包将ts转化为js</p><p><strong>简化编译运行的包的下载：npm i -g ts-node</strong></p><ul><li>直接ts-node 文件名，不用先tsc 在node </li><li>在使用之前需要先 node -init</li><li>它是在内部转化为js然后运行js文件的，因此不会显式地生成一个js文件</li></ul><h3 id="TypeScript中的类型"><a href="#TypeScript中的类型" class="headerlink" title="TypeScript中的类型"></a>TypeScript中的类型</h3><p><strong>分为js中已有的类型和ts新增的类型</strong></p><ul><li>js中已有的类型<ul><li>基础类型：number、string、boolean、undefined、null、symbol（es6新增）</li><li>引用类型：数组、函数、对象等</li></ul></li><li>ts新增的类型<ul><li>联合类型、自定义类型（类型别名）、接口、元组、字面量类型、枚举、void、any等</li></ul></li></ul><h3 id="基础类型"><a href="#基础类型" class="headerlink" title="基础类型"></a>基础类型</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs typescript">  <span class="hljs-comment">//练习void声明，声明在ts中叫做类型注解</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">unusable1</span>:<span class="hljs-built_in">void</span>=<span class="hljs-literal">undefined</span>;<br>   <span class="hljs-keyword">let</span> <span class="hljs-attr">unusable2</span>:<span class="hljs-built_in">void</span>=<span class="hljs-literal">null</span>;<br>   <span class="hljs-keyword">function</span> <span class="hljs-title function_">warnUser</span>(<span class="hljs-params"></span>):<span class="hljs-built_in">void</span>&#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;This is a warning message!&quot;</span>)<br>   &#125;<br><span class="hljs-comment">//undefined、null</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">u</span>:<span class="hljs-literal">undefined</span>=<span class="hljs-literal">undefined</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">n</span>:<span class="hljs-literal">null</span>=<span class="hljs-literal">null</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">num</span>:<span class="hljs-built_in">number</span>=<span class="hljs-literal">null</span>;<span class="hljs-comment">//null和undfined是所有类型的子类，可看作初始化吧</span><br><br><span class="hljs-comment">//never表示不存在的值的类型，比如函数中死循环或者抛出异常的返回值类型</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">infiniteLoop</span>(<span class="hljs-params"></span>)&#123;<br> <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br> <br> &#125;<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">error</span>(<span class="hljs-params">message:<span class="hljs-built_in">String</span></span>)&#123;<br> <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(message);<br>&#125;<br><br><span class="hljs-comment">//object类型是除了number、string、boolean、undefined或null之外的类型</span><br><br><span class="hljs-comment">//类型断言：在编译时告诉编译器&quot;我来手动指定类型，并且请你放心&quot;</span><br><span class="hljs-comment">//方式一</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">someValue</span>:<span class="hljs-built_in">any</span>=<span class="hljs-string">&quot;a value&quot;</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">strLength</span>:<span class="hljs-built_in">number</span>=(&lt;<span class="hljs-built_in">string</span>&gt;someValue).<span class="hljs-property">length</span>;<br><span class="hljs-comment">//方式二</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">strLength</span>:<span class="hljs-built_in">number</span>=(someValue <span class="hljs-keyword">as</span> <span class="hljs-built_in">string</span>).<span class="hljs-property">length</span>;<br></code></pre></td></tr></table></figure><h3 id="变量的声明"><a href="#变量的声明" class="headerlink" title="变量的声明"></a>变量的声明</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">//var</span><br><span class="hljs-comment">/*作用域</span><br><span class="hljs-comment">1.在函数内任何地方声明作用域都为整个函数内</span><br><span class="hljs-comment">2.在函数内直接声明，不加var则表示全局变量，否则是局部变量</span><br><span class="hljs-comment">3.在函数外不管加不加var则都是全局变量</span><br><span class="hljs-comment">*/</span><br>   <span class="hljs-comment">/*setTimeout异步处理机制：</span><br><span class="hljs-comment">  主线程里面的执行栈存放同步任务，还有个任务队列，只要有异步任务就会增加一个事件存放在任务队列</span><br><span class="hljs-comment">  系统先按顺序执行完所有执行栈中的同步任务，然后就会读取任务队列执行其中的事件解除对应异步任务的等待状态并将异步任务放到执行栈中执行</span><br><span class="hljs-comment">  直到任务队列中所有任务被执行完</span><br><span class="hljs-comment">*/</span><br>   <span class="hljs-comment">//let</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">作用域：局部作用域</span><br><span class="hljs-comment">其中捕获的异常也是局部的，例如这里的e在括号外是无法取到的</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">try</span>&#123;<br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Oh No!&quot;</span>)<br>&#125;<span class="hljs-keyword">catch</span>(e)&#123;<br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Oh Well!&quot;</span>)<br>&#125;<br>   <span class="hljs-comment">/*</span><br><span class="hljs-comment">正常来说 块级作用域变量在声明之前是无法使用的，但有个特例：函数的声明，但是调用却不行</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>     <span class="hljs-comment">//okay to capture &#x27;a&#x27;</span><br>     <span class="hljs-keyword">return</span> a;<br>   &#125;<br><span class="hljs-title function_">foo</span>();<span class="hljs-comment">//报错</span><br>   <span class="hljs-keyword">let</span> a=<span class="hljs-number">1</span>;<br>   <span class="hljs-comment">/*能用const就用const，是为了安全*/</span><br>   <span class="hljs-comment">//解构：解析一个数据的结构，是通过给这个数据每个值(不一定每一个，一一对应就行)定义一个变量来实现的，由于这个数据的结构由自定义的变量组成，因为它的结构整体上来看更清晰，更方便使用</span><br>   <span class="hljs-comment">//解构其实就是c++中的别名，既能访问，又能修改值（两边都变）</span><br>  <span class="hljs-comment">//1.解构数组</span><br>  <span class="hljs-keyword">let</span> input=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>];<br>  <span class="hljs-keyword">let</span> [first,second]=input;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(first)<span class="hljs-comment">//1</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(second)<span class="hljs-comment">//2</span><br>  <span class="hljs-comment">//交换变量很方便</span><br>  [first,second]=[second,first]<br>  <span class="hljs-comment">//作为函数参数</span><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">[first,second]:[<span class="hljs-built_in">number</span>,<span class="hljs-built_in">number</span>]</span>)&#123;<br>       <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(first)<br>       <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(second)<br>  &#125;<br>  <span class="hljs-title function_">f</span>(input);<br>  <span class="hljs-comment">//可使…创建剩余变量</span><br>  <span class="hljs-keyword">let</span> [first,…rest]=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(first)<span class="hljs-comment">//1</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(rest)<span class="hljs-comment">//2,3,4</span><br>  <span class="hljs-comment">//只定义一个变量时默认是第一个，没有定义全时，一一对应即可</span><br>  <span class="hljs-keyword">let</span> [first]=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(first)<span class="hljs-comment">//1</span><br>  <span class="hljs-keyword">let</span> [first,,third]=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(third)<span class="hljs-comment">//3</span><br>  <span class="hljs-comment">//2.解构对象</span><br>  <span class="hljs-keyword">let</span> o=&#123;<br>      <span class="hljs-attr">a</span>:<span class="hljs-string">&quot;a&quot;</span>,<br>      <span class="hljs-attr">b</span>:<span class="hljs-number">123</span>,<br>      <span class="hljs-attr">c</span>:<span class="hljs-string">&quot;cc&quot;</span><br>  &#125;<br>  <span class="hljs-keyword">let</span> &#123;a,b&#125;=o;<span class="hljs-comment">//一一对应</span><br>  <span class="hljs-comment">//用…声明剩余变量</span><br>  <span class="hljs-keyword">let</span> &#123;a,…passthrough&#125;=o;<br>  <span class="hljs-keyword">let</span> total=passthrough.<span class="hljs-property">b</span>+passthrough.<span class="hljs-property">c</span>.<span class="hljs-property">length</span><br>  <span class="hljs-comment">//属性重命名：在解构时可以对自定义的变量重新命名</span><br>  <span class="hljs-keyword">let</span> &#123;<span class="hljs-attr">a</span>:newName1,<span class="hljs-attr">b</span>:newName2&#125;=o;<span class="hljs-comment">//这里的冒号并不是指声明数据类型</span><br>  <span class="hljs-comment">//给解构变量声明数据类型:需要在整体后面加冒号，并且重新用括号一一制定</span><br>  <span class="hljs-keyword">let</span> &#123;a,b&#125;:&#123;<span class="hljs-attr">a</span>:<span class="hljs-built_in">string</span>,<span class="hljs-attr">b</span>:<span class="hljs-built_in">number</span>&#125;=o;<br>  <span class="hljs-comment">//4.默认值，目的是针对undfined的值有个缺省值</span><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">fun</span>(<span class="hljs-params"><span class="hljs-built_in">object</span>:&#123;a:<span class="hljs-built_in">string</span>,b?:<span class="hljs-built_in">number</span>&#125;</span>)&#123;<br>      <span class="hljs-keyword">let</span> &#123;a,b=<span class="hljs-number">100</span>&#125;=<span class="hljs-built_in">object</span>;<br>  &#125;<span class="hljs-comment">//b原来有个?表示undfined，现在object的b就有默认值不再是undfined了</span><br>  <span class="hljs-comment">//函数声明</span><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">&#123;a,b=<span class="hljs-number">0</span>&#125;=&#123;a=<span class="hljs-string">&quot;&quot;</span>&#125;</span>):<span class="hljs-built_in">void</span>&#123;<br>      ...<br>  &#125;<br>  <span class="hljs-comment">//从这里可以看出解构不仅仅是“别名”，若原来没有的还可以添加上去，比如这里的b而且还有缺省值</span><br>  <span class="hljs-title function_">f</span>(&#123;<span class="hljs-attr">a</span>:<span class="hljs-string">&quot;123&quot;</span>&#125;)--a=<span class="hljs-string">&quot;123&quot;</span>,b=<span class="hljs-number">0</span><br>  <span class="hljs-title function_">f</span>()----a=<span class="hljs-string">&quot;&quot;</span>,b=<span class="hljs-number">0</span><br>  <span class="hljs-title function_">f</span>(&#123;&#125;)----error, <span class="hljs-string">&#x27;a&#x27;</span> is required <span class="hljs-keyword">if</span> you supply an argument<br>  <span class="hljs-comment">//以上例子意思就是说不提供参数可以，因为都有缺省值可是已经确定提供参数了，那就说明不要缺省值，而你有没有替代缺省值的值，那肯定报错啊</span><br>  <span class="hljs-comment">//3.展开表达式：和解构相反，解构是将数据拆开来使用，而展开是将各个合并起来使用，展开指的是合并后的状态</span><br>  <span class="hljs-comment">//3.1 数组展开</span><br>  <span class="hljs-keyword">let</span> first = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>];<br>  <span class="hljs-keyword">let</span> second = [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br>  <span class="hljs-keyword">let</span> bothPlus = [<span class="hljs-number">0</span>,first,second,<span class="hljs-number">5</span>];<span class="hljs-comment">//0,1,2,3,4,5,浅拷贝，原来first second不会改变</span><br>  <span class="hljs-comment">//3.2 对象展开</span><br>  <span class="hljs-keyword">let</span> defaults = &#123; <span class="hljs-attr">food</span>: <span class="hljs-string">&quot;spicy&quot;</span>, <span class="hljs-attr">price</span>: <span class="hljs-string">&quot;$$&quot;</span>, <span class="hljs-attr">ambiance</span>: <span class="hljs-string">&quot;noisy&quot;</span> &#125;;<br>  <span class="hljs-keyword">let</span> search = &#123; ...defaults, <span class="hljs-attr">food</span>: <span class="hljs-string">&quot;rich&quot;</span> &#125;;<br>  <span class="hljs-comment">/*结果为food: &quot;spicy&quot;, price: &quot;$$&quot;, ambiance: &quot;noisy&quot;，food: &quot;rich&quot;</span><br><span class="hljs-comment">    但是 如果声明为 let search = &#123; food: &quot;rich&quot;, ...defaults &#125;;</span><br><span class="hljs-comment">    添加进来的若有重名的会替换，即只有一个后面的food</span><br><span class="hljs-comment">  */</span><br>  <span class="hljs-comment">//对象展开还有个限制：展开对象实例时只能访问属性无法访问方法</span><br>  <span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> &#123;<br>    p = <span class="hljs-number">12</span>;<br>    <span class="hljs-title function_">m</span>(<span class="hljs-params"></span>) &#123;<br>   &#125;<br>  &#125;<br> <span class="hljs-keyword">let</span> c = <span class="hljs-keyword">new</span> <span class="hljs-title function_">C</span>();<br> <span class="hljs-keyword">let</span> clone = &#123; ...c &#125;;<br> clone.<span class="hljs-property">p</span>; <span class="hljs-comment">// ok</span><br> clone.<span class="hljs-title function_">m</span>(); <span class="hljs-comment">// error!</span><br></code></pre></td></tr></table></figure><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">//1.接口初探：接口只是代表着一种对象的规范</span><br><span class="hljs-comment">//一般用于类型检查，即传过来的对象是是否符合规范，检查规则是是否包含接口中的属性，顺序可以不一样</span><br><span class="hljs-keyword">interface</span> labeledValue&#123;<br>    <span class="hljs-attr">label</span>:<span class="hljs-built_in">string</span>;<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">printLabel</span>(<span class="hljs-params">labeledObj:labeledValue</span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(labeledObj.<span class="hljs-property">label</span>)<br>&#125;<br><span class="hljs-keyword">let</span> myObj=&#123;<span class="hljs-attr">size</span>:<span class="hljs-number">10</span>,<span class="hljs-attr">label</span>:<span class="hljs-string">&quot;Size 10 Object&quot;</span>&#125;<br><span class="hljs-title function_">printLabel</span>(myObj)<br>------------------------------------------------------------------------------------<br><span class="hljs-comment">//2.可选属性：接口中属性的?表示可选，和没有可选属性的接口的区别是：有可选属性的接口的属性个数通常大于等于传入对象属性的个数，而没有可选属性的接口的属性个数通常小于等于传入对象属性的个数</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">SquareConfig</span> &#123;<br>  color?: <span class="hljs-built_in">string</span>;<br>  width?: <span class="hljs-built_in">number</span>;<br>&#125;<br><span class="hljs-comment">//注意：对象在声明时属性之间是分号，实例化之后是逗号</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">createSquare</span>(<span class="hljs-params">config: SquareConfig</span>): &#123;<span class="hljs-attr">color</span>: <span class="hljs-built_in">string</span>; <span class="hljs-attr">area</span>:<span class="hljs-built_in">number</span>&#125; &#123;<br>  <span class="hljs-keyword">let</span> newSquare = &#123;<span class="hljs-attr">color</span>: <span class="hljs-string">&quot;white&quot;</span>, <span class="hljs-attr">area</span>: <span class="hljs-number">100</span>&#125;;<br>  <span class="hljs-keyword">if</span> (config.<span class="hljs-property">color</span>) &#123;<br>    newSquare.<span class="hljs-property">color</span> = config.<span class="hljs-property">color</span>;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (config.<span class="hljs-property">width</span>) &#123;<br>    newSquare.<span class="hljs-property">area</span> = config.<span class="hljs-property">width</span> * config.<span class="hljs-property">width</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> newSquare;<br>&#125;<br><span class="hljs-keyword">let</span> mySquare = <span class="hljs-title function_">createSquare</span>(&#123;<span class="hljs-attr">color</span>: <span class="hljs-string">&quot;black&quot;</span>&#125;);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(mySquare)<br>------------------------------------------------------------------------------------<br><span class="hljs-comment">//3.只读属性：</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Point</span> &#123;<br>    <span class="hljs-keyword">readonly</span> <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>;<br>    <span class="hljs-keyword">readonly</span> <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span>;<br>&#125;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">p1</span>: <span class="hljs-title class_">Point</span> = &#123; <span class="hljs-attr">x</span>: <span class="hljs-number">10</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">20</span> &#125;;<br>p1.<span class="hljs-property">x</span> = <span class="hljs-number">5</span>; <span class="hljs-comment">// error!</span><br><span class="hljs-comment">//readOnly是针对属性的，而const是针对变量的</span><br><span class="hljs-comment">//4.额外的属性检查</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">SquareConfig</span> &#123;<br>    color?: <span class="hljs-built_in">string</span>;<br>    width?: <span class="hljs-built_in">number</span>;<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">createSquare</span>(<span class="hljs-params">config: SquareConfig</span>): &#123; <span class="hljs-attr">color</span>: <span class="hljs-built_in">string</span>; <span class="hljs-attr">area</span>: <span class="hljs-built_in">number</span> &#125; &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><span class="hljs-keyword">let</span> mySquare = <span class="hljs-title function_">createSquare</span>(&#123; <span class="hljs-attr">colour</span>: <span class="hljs-string">&quot;red&quot;</span>, <span class="hljs-attr">width</span>: <span class="hljs-number">100</span> &#125;);<span class="hljs-comment">//故意把color拼错</span><br><span class="hljs-comment">//此时ts会进行额外的属性检查：既然传入了一个两个属性的对象，那么ts就会注意检查是否和定义的两个属性的数据类型一样，如果只有width属性是可以的，因为color是可选的。简而言之，就是可选属性是指少一些属性可以，但是如果不少那么类型必须一样否则报错</span><br><span class="hljs-comment">//4.1 也可以绕开属性检查，方法一-----类型断言（强制类型转换）</span><br><span class="hljs-keyword">let</span> mySquare = <span class="hljs-title function_">createSquare</span>(&#123; <span class="hljs-attr">opacity</span>: <span class="hljs-number">0.5</span>, <span class="hljs-attr">width</span>: <span class="hljs-number">100</span> &#125; <span class="hljs-keyword">as</span> <span class="hljs-title class_">SquareConfig</span>);<br><span class="hljs-comment">//转换了之后参数就变为只有width的SquareConfig，可选属性就用上了</span><br><span class="hljs-comment">//4.3 方法二-----加一个索引签名：就是就是键值对（对象的属性本来就是键值对的形式定义的）</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">SquareConfig</span>&#123;<br>    color?: <span class="hljs-built_in">string</span>;<br>    width?: <span class="hljs-built_in">number</span>;<br>    [<span class="hljs-attr">propName</span>:<span class="hljs-built_in">string</span>]:<span class="hljs-built_in">any</span>;<span class="hljs-comment">//键为字符串，值为任意类型</span><br>&#125;<br><span class="hljs-comment">//4.4 方法三----对象赋值给另外一个变量（就好比原来是匿名对象后来有名字了）</span><br><span class="hljs-keyword">let</span> squareOptions=&#123; <span class="hljs-attr">colour</span>: <span class="hljs-string">&quot;red&quot;</span>, <span class="hljs-attr">width</span>: <span class="hljs-number">100</span> &#125;;<br><span class="hljs-keyword">let</span> mySquare = <span class="hljs-title function_">createSquare</span>(squareOptions);<br>------------------------------------------------------------------------------------<br><span class="hljs-comment">//5.使用接口也可以定义函数</span><br><span class="hljs-keyword">interface</span> searchFunc&#123;<br>    (<span class="hljs-attr">source</span>:<span class="hljs-built_in">string</span>,<span class="hljs-attr">subString</span>:<span class="hljs-built_in">string</span>):<span class="hljs-built_in">boolean</span>;<br>&#125; <br><span class="hljs-keyword">let</span> <span class="hljs-attr">mySearch</span>:searchFunc;<br>mySearch=<span class="hljs-keyword">function</span>(<span class="hljs-params">src:<span class="hljs-built_in">string</span>,sub:<span class="hljs-built_in">string</span></span>):<span class="hljs-built_in">boolean</span>&#123;<span class="hljs-comment">//名字可以不一样，重要的是检查类型</span><br>    <span class="hljs-keyword">let</span> result=src.<span class="hljs-title function_">search</span>(subString);<br>    retrurn result&gt;-<span class="hljs-number">1</span>;<br>&#125;<span class="hljs-comment">//mySearch(参数一，参数二)调用</span><br><span class="hljs-comment">//5.1 如果如果参数类型或返回值类型没写，ts还可以推断，在调用时根据传入的参数来判断然后再检查</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">mySearch</span>: <span class="hljs-title class_">SearchFunc</span>;<br>mySearch = <span class="hljs-keyword">function</span>(<span class="hljs-params">src, sub</span>) &#123;<br>    <span class="hljs-keyword">let</span> result = src.<span class="hljs-title function_">search</span>(sub);<br>    <span class="hljs-keyword">return</span> result &gt; -<span class="hljs-number">1</span>;<br>&#125;<br>------------------------------------------------------------------------------------<br><span class="hljs-comment">//6. 接口还可以定义可索引的类型（索引签名）</span><br><span class="hljs-keyword">interface</span> stringArray&#123;<br>    [<span class="hljs-attr">index</span>:<span class="hljs-built_in">number</span>]:<span class="hljs-built_in">string</span>;<br>&#125;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">myArray</span>:stringArray;<br>myArray=[<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>];<br><span class="hljs-keyword">let</span> myStr=myArray[<span class="hljs-number">0</span>];<br><span class="hljs-comment">//6.1 索引签名分为数值型和字符串型，接口可以同时定义这两个，（好像）但是名字要一样，于是最后只会用一个</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span>&#123;<br>    <span class="hljs-attr">name</span>:<span class="hljs-built_in">string</span>;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Animal</span>&#123;<br>    <span class="hljs-attr">breed</span>:<span class="hljs-built_in">string</span>;<br>&#125;<br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">NotOk</span>&#123;<br>    <span class="hljs-comment">//错误，数值型索引签名的返回值必须为字符串型索引签名的返回值的子类型，因为使用number来索引时，js会默认将数值型转换为字符串型然后再去索引对象，也就是说1最后会被当做&quot;1&quot;</span><br>    [<span class="hljs-attr">x</span>:<span class="hljs-built_in">number</span>]:<span class="hljs-title class_">Animal</span>;        [<span class="hljs-attr">x</span>:<span class="hljs-built_in">number</span>]:<span class="hljs-title class_">Dog</span>;---ok<br>    [<span class="hljs-attr">x</span>:<span class="hljs-built_in">string</span>]:<span class="hljs-title class_">Dog</span>;           [<span class="hljs-attr">x</span>:<span class="hljs-built_in">string</span>]:<span class="hljs-title class_">Animal</span>;----ok<br>    <span class="hljs-comment">//其实就是如下所示：上面的number变为string以后，如果传入的是100，那么就会变成&quot;100&quot;，第一个满足，则使用第一个类型，如果本来传入的就是&quot;100&quot;,那么就用第二个（此时第一个还是number，只有传入是数字型第一个才为字符型），后面的子类是为了 当都是string型时优先用子类的（多态）</span><br>    [<span class="hljs-attr">x</span>:<span class="hljs-built_in">string</span>]:<span class="hljs-title class_">Dog</span>; <br>    [<span class="hljs-attr">x</span>:<span class="hljs-built_in">string</span>]:<span class="hljs-title class_">Animal</span>;   <br>&#125;<br><span class="hljs-comment">//6.2 其中字符串索引声明还指明了接口属性的返回值，如果有属性返回值与字符串索引返回值不一致则会报错，可以把接口中的字符串索引当作是其他属性的规范,因为属性名默认都是string类型的</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">NumberDictionary</span>&#123;<br>    <span class="hljs-keyword">readonly</span> [<span class="hljs-attr">index</span>:<span class="hljs-built_in">string</span>]:<span class="hljs-built_in">number</span>;<span class="hljs-comment">//readonly加上可以不能被修改</span><br>    <span class="hljs-attr">length</span>:<span class="hljs-built_in">number</span>;<br>    <span class="hljs-attr">name</span>:<span class="hljs-built_in">string</span>;<span class="hljs-comment">//错误，应该为number</span><br>&#125;<br>------------------------------------------------------------------------------------<br><span class="hljs-comment">//7.和java一样可以用类实现接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">ClockInterface</span> &#123;<br>    <span class="hljs-attr">currentTime</span>: <span class="hljs-title class_">Date</span>;<br>    <span class="hljs-title function_">setTime</span>(<span class="hljs-attr">d</span>: <span class="hljs-title class_">Date</span>);<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Clock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ClockInterface</span> &#123;<br>    <span class="hljs-attr">currentTime</span>: <span class="hljs-title class_">Date</span>;<br>    <span class="hljs-title function_">setTime</span>(<span class="hljs-params">d: <span class="hljs-built_in">Date</span></span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">currentTime</span> = d;<br>    &#125;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">h: <span class="hljs-built_in">number</span>, m: <span class="hljs-built_in">number</span></span>) &#123; &#125;<br>&#125;<br>------------------------------------------------------------------------------------<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Ts</category>
      
    </categories>
    
    
    <tags>
      
      <tag>语法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Angular更新版本的注意点</title>
    <link href="/2023/08/30/Angular%E6%9B%B4%E6%96%B0%E7%89%88%E6%9C%AC%E7%9A%84%E6%B3%A8%E6%84%8F%E7%82%B9/"/>
    <url>/2023/08/30/Angular%E6%9B%B4%E6%96%B0%E7%89%88%E6%9C%AC%E7%9A%84%E6%B3%A8%E6%84%8F%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<p>1.自Angular V5起，不赞成使用@angular/http中的HttpModule和Http，而应改用@angular/common/http中的HttpClientModule和HttpClient</p><p>2.”@angular/platform-browser”: “^14.1.0”,</p><p>  “@angular/platform-browser-dynamic”: “^14.1.0”,</p><p>​    这两个都是和在浏览器上启动相关</p><p>3.file-saver是用于文件导出的，任何到处都要用到</p><p>4.angularjs的i18n是国际化，可以将英文翻译成中文</p><p>5.keycloak-js可以使得采用授权码方式登录账号</p><p>6.matomo-js用于统计网络数据</p><p>7.想安装开发依赖，要用–save-dev（就一个杠），想安装运行必须要的，则–save</p><p>8.最大的收获：修改bug要一个一个来，这样也容易寻找错误原因，切勿急躁</p><p>9.函数内var定义的变量是没有局部变量之说，在函数内都是可用的</p><p>10.<code>Observable.if</code>和 <code>Observable.throw</code> 这些方法已由 static 代替 <code>iif()</code>和 <code>throwError()</code>function</p><p>11.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-title class_">Observable</span>.<span class="hljs-keyword">throw</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>());<br><span class="hljs-comment">// becomes</span><br><span class="hljs-title function_">throwError</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>());<br></code></pre></td></tr></table></figure><p>12.namespace区域内的 声明 是为了 想要使用同名但不同功能的 属性或函数</p><p>13.在追踪bug时，一定要去找源头，比如数据没显示很可能是 本来就没有，而不是一直看显示方式问题</p>]]></content>
    
    
    <categories>
      
      <category>前端框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Angular</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Angular知识点</title>
    <link href="/2023/08/30/Angular/"/>
    <url>/2023/08/30/Angular/</url>
    
    <content type="html"><![CDATA[<p><strong>以下是我学习Angular的记录，虽然有些杂，但是是针对的遗漏的知识点进行的查漏补缺</strong></p><p>1.管道对于一些数据的格式化显示很方便<br>2.类或接口可以直接写在ts中，用export导出即可<br>3.在声明属性时，如果不初始化，可以在变量名后面加一个可选符号?，这样便可以去除异常了<br>4.如果数据的显示刚开始为空，后面不为空，则可以使用*ngIf来控制显示<br>5.要是动态属性都是加[]，[class.selected]=”hero === selectedHero”这指的是类选择器里面的.selected样式类<br>6.关于服务<br>  1）让服务去请求数据，这样的话所有组件都可以从服务中获取请求的数据<br>  2）通过依赖注入的方式，而不是new的方式，声明更方便，耦合度更低</p><p>7.关于Rxjs</p><p>  1）of(data)可以将data转换成Obserable对象</p><ol start="2"><li> 在订阅时subscribe里面的回调函数连函数的()都可以不用写</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">this</span>.<span class="hljs-property">heroService</span>.<span class="hljs-title function_">getHeroes</span>().<span class="hljs-title function_">subscribe</span>(<br>        <span class="hljs-function"><span class="hljs-params">heroes</span> =&gt;</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">heroes</span> = heroes<br>     )<br></code></pre></td></tr></table></figure><p>8.原来可以服务中再注入其他服务</p><p>9.依赖注入时 前面写private和pubic的区别：</p><p>   private只能在当前类中使用，而public在类外也可以使用，比如组建的HTML文件中</p><p>10.在字符串中传递参数时，有两个注意点:</p><p>​    1.需要用反单引号，这样才能识别参数</p><p>​    2.用${}来传递，和mybatis类似，只不过用$，可能是为了区分</p><p>11.关于app-routing.module.ts中的RouterModule.forRoot(routes)</p><p>forRoot 这么命名是因为我实在顶层(根部)配置路由的，这个方法可以提供给路由服务提供着和指令</p><ol start="12"><li><p>slice 原来还可以对数组操作，左闭右开，(1,5)表示第1-4个元素(英雄)</p></li><li><p>pathMatch:’full’指的是必须与路径完全匹配才会跳转</p><p>  另一个参数’prefix’是指路由中有path就可以</p><p>  举个例子： { path:’a’,redirectTo:’/dialog’,pathMatch:’prefix’},</p><p>  1.<a href="http://localhost:9800/a">http://localhost:9800/a</a></p><p>  2.<a href="http://localhost:9800/a/sadf/adfs/">http://localhost:9800/a/sadf/adfs/</a></p><p>  都会被重定向，但是</p><p>  <a href="http://localhost:9800/asdfsdf">http://localhost:9800/asdfsdf</a> —不可以，必须得是/a/</p><ol><li>full和prefix的区别：前者通常要整个路径匹配，而prefix既然是前缀，因此这个地址很可能在中间</li></ol></li><li><p>英雄案例使用动态路由的原因</p><p>点击需要跳转英雄详情页面，因此需要路由，又因为诶个英雄都有id，因此是动态路由</p></li><li><p>ngFor循环中的id原来在它本层也可以直接用(相当于是前c++中for循环的i++)，之前还以为只能在内层中使用</p></li><li><p>HEROES.find(h =&gt; h.id === id)关于函数表达式的解释</p><p>js中数组的find方法的第一个参数就是一个函数，这个函数需要有判断的性质来告诉find方法怎么查找</p></li><li><p>关于ts</p><p>在一个变量后面加上!表示当前变量排除null或undefined的取值</p></li><li><p>当代码中有一个错误怎么也找不到原因，那就很可能不是逻辑错误，这时候就不要把重心放在一些关键代码上而是一些 无关紧要细节，比如导包导错或未导包，如下就是未导location的包，导致路由跳转异常，连默认路由都跳转不过去</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//这个Location是angular中的依赖，有一个同名的接口，直接写不导入包的话那么用的就是那个接口！！！</span><br>private <span class="hljs-attr">location</span>: <span class="hljs-title class_">Location</span><br></code></pre></td></tr></table></figure></li><li><p>Number(this.route.snapshot.paramMap.get(‘id’))的代码解释：</p><p>1.snapshot指快照，对路由路径的保存</p><p>2.保存好了之后，paramMap用来获取路径中的参数，可以看出是个哈希结构因此用get按照键来取</p><p>3.路径中取到的默认是字符串，要用Number转化成数字类型</p></li><li><p>… 可以将数组的[]去掉，变成一个个零散的元素 value1,value2,value3，因为max只支持这样的参数</p><p>… 还可以用在 对象中，将…obj放入新的对象中，那么可以将多个属性组合成一个新的对象，这对于利用现有的对象组成新对象很方便</p></li><li><p>函数表达式如果箭头后面仅仅只有一个值，那么这个就是要返回的值</p></li><li><p>数组有一个map方法，可以在不修改原数组的情况下返回一个新数组，规则来自第一个参数（回调函数）</p></li><li><p>angular中get请求数据：this.http.get&lt;Hero[]&gt;(this.heroesUrl)   </p><p>​                                          private heroesUrl = ‘api/heroes’;  // URL to web api</p><p>1.由于get返回的也是一个obserable对象，但是不够明确（默认是一个无类型的Json数据），加个&lt;Hero[]&gt;，表示返回的是 obserable&lt;Hero[]&gt;对象</p><p>2.那么后面那个括号就是请求的地址</p><p>3.heroesUrl的前面api是模拟服务器默认地址，后面的heroes是里面数据库返回的数据名</p></li><li><p>关于模拟服务器数据（在内存中划分一块区域来存储）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//内存网络API模块，用来模拟服务请求与响应，包含内存数据服务，后面那个是数据封装，暂时不要</span><br><span class="hljs-title class_">HttpClientInMemoryWebApiModule</span>.<span class="hljs-title function_">forRoot</span>(<br>   <span class="hljs-title class_">InMemoryDataService</span>, &#123; <span class="hljs-attr">dataEncapsulation</span>: <span class="hljs-literal">false</span> &#125;<br>  )<br></code></pre></td></tr></table></figure></li><li><p>HttpClient的方法只返回单个值</p></li></ol><p>​      通常Observable在可以在一段时间内返回多个值，但是HttpClient比如http.get()就只能返回一个值，因此服务器那边要下次把要相应的数据准备好</p><p> 27.函数箭头表达式：本质上是用lambda表达式来表示一个匿名函数</p><p>​     () =&gt; {}、x =&gt; {} （只有一个参数可以去掉括号）、(x,y) =&gt; {}</p><p>​     当函数体中只有一条语句，则可以省略不写；只有一个参数但是要写类型的话必须加()</p><ol start="28"><li><p>tap(_ =&gt; this.log(‘fetched heroes’))—tap(窥视)能窥探Obervable数据流，并用log打印</p></li><li><p>由于大多Web API都支持 :BaseUrl/:id 的形式根据id获取对象，其实是因为我的英雄对象中包含id这个属性，因此我可以通过get请求来直接获取特定的英雄：</p><p>  const url =  <code>$&#123;this.heroesUrl&#125;/$&#123;id&#125;</code></p><p>  return this.http.get<Hero>(url)</p></li><li><p>在更新服务器数据时，需要一个请求头，不让浏览器认为是爬虫，可以认为是一个反爬虫机制</p><p>return this.http.put(this.heroesUrl, hero, this.httpOptions)</p></li><li><p>```js<br>httpOptions = {<br>  headers: new HttpHeaders({ ‘Content-Type’: ‘application/json’ })<br>};</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br>    千万要注意这个请求头new的是HttpHeaders而不是Headers，不报错很容出错<br><br>32. ```js<br>       &lt;input <span class="hljs-built_in">id</span>=<span class="hljs-string">&quot;new-hero&quot;</span> <span class="hljs-comment">#heroName&gt;</span><br>       &lt;button <span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;button&quot;</span> class=<span class="hljs-string">&quot;add-button&quot;</span> (click)=<span class="hljs-string">&quot;add(heroName.value);heroName.value = &#x27;&#x27;&quot;</span>&gt;&lt;/button&gt;<br></code></pre></td></tr></table></figure><p>1.原来HTML中的元素可以在当前页面通过#相互引用</p><p>2.原来(click)点击事件里面不止可以写函数，也可以直接写执行的操作，还可以用分号隔开放一起写</p></li><li><p>在添加 用户输入的数据时，要先trim()一下看是否为空，若为空则本来就没有输入，这样就可以直接结束函数了</p></li><li><p>想要将基础类型转化为对象类型，必须先得在这个基础类型外面加一个{}先把格式统一然后转化就很方便</p></li><li><p>正常进行post请求之后是会返回来提交的对象给回调函数的，方便再使用</p></li><li><p>http的put、delete、post都需要请求头，因为需要修改值，但是get不需要</p></li><li><p>http的这些请求有没有返回值就看有没有指出泛型类型，比如put就没有，而get&lt;Hero[]&gt;、post<Hero>、delete<Hero>都有</p></li><li><p>直接通过get的?name=xxx便可查询所有name为xxx的英雄</p><p>return this.http.get&lt;Hero[]&gt;(<code>$&#123;this.heroesUrl&#125;/?name = $&#123;term&#125;</code>)</p></li><li><p>由于ngFor里面不支持obserable对象，而这里想直接显示从服务器返回的结果，因此需要管道|转换为async，它会自动订阅，不用再组件中subscribe了 </p><li *ngFor="let hero of heroes$ | async"></li><li><p>Subject本身是Obsevrable对象，但是用法和promise类似（用next发出消息）</p></li><li><p>一般要把项目传输给别人时，node_modules文件夹是不传的，因为这个包大而，而且子文件分得太细了，系统要根据路径去找还得花时间，因此传输效率低</p></li><li><p>关于搜索请求，return this.http.get&lt;Hero[]&gt;(<code>$&#123;this.heroesUrl&#125;/?name=$&#123;term&#125;</code>)</p></li></ol><p>​       这里name=${term}多一个空格都不行，就像是sql语句一样，而且这个竟然是模糊查询</p><p> 43.为了避免请求次数过多，而作的请求限制</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// searchTerms 发送请求，再通过pipe处理一下数据，真正通过switchMap请求</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">heroes$</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">searchTerms</span>.<span class="hljs-title function_">pipe</span>(<br><br>    <span class="hljs-comment">// 每次请求要间隔300ms</span><br>    <span class="hljs-title function_">debounceTime</span>(<span class="hljs-number">300</span>),<br><br>    <span class="hljs-comment">// 只有在值变化才会请求</span><br>    <span class="hljs-title function_">distinctUntilChanged</span>(),<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 每一次请求都会换(switch)一个新的Observable对象请求</span><br><span class="hljs-comment">     * 虽然每隔至少300ms再请求，但是仍有一些请求没有得到相应(服务器忙不过来了)，此时就取最近的一次返回结果</span><br><span class="hljs-comment">     *  */</span><br>    <span class="hljs-title function_">switchMap</span>( <span class="hljs-function">(<span class="hljs-params">term:string</span>) =&gt;</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">heroService</span>.<span class="hljs-title function_">searchHeroes</span>(term))<br></code></pre></td></tr></table></figure><p>  44.引入样式时，最上面的会覆盖下面引入的样式表</p><p>  45.每引入一个组件样式，都需要在app.module.ts中引入</p><p>  46.什么是git？git bash？git shell？</p><p>​       git：分布式的版本控制工具</p><p>​       shell：linux、unix系统的外壳，用于执行一些命令</p><p>​       bash：最常见的shell</p><p>​       git bash：方便在windows环境下运行get命令</p><p>  47.切换路由时不变的部分放在父组件中即可，比如nav元素包含的部分</p><p>  48.设置路由时，path:’’和path:’**’的区别：</p><p>​       前者是默认路由，即localhost:4200，后者是前面都没有匹配才跳转的路由，通常放最后</p><p>  49.一个组件只能引入到一个Module中，若引入多个模块会报错</p><p>  50.可以专门为某一块部分专门设置 它的 路由和module，这样各个组成部分更独立</p><ol start="51"><li><p>imports: [RouterModule.forChild(routes)]</p><p>在特定路由中，这些路由就不是给根组件用的，而是某个孩子组件，因此是forChild</p></li><li><p>在获取动态路由中的id时，有两种方法：</p><p>使用ParamMap，可以复用子组件的实例（HeroDetailComponent）</p><p>使用snapshop，每次都是新的实例（每次复制一份）</p></li><li><p>当碰到 非常奇怪的bug（按正常逻辑无法排除出来）时，很有可能是模块引入的错误！</p></li><li><p>引入模块有两个原则：</p><p>1）一定是大的包含小的（比如 跟模块引入特殊模块）</p><p>2）要清楚是哪个模块需要哪个模块</p></li><li><p>想要 通过路由跳转到另一个页面（也可携带参数）用的是 Router服务，而想获取被选中数据的某些信息用的是ActivatedRouter服务</p></li><li><p>如何给路由添加动画？</p><p>1）在app.module.ts中添加BrowserAnimationsModule</p><p>2）在路由设置中每个路由后面加个data对象，利用里面的animiation名字来确定转场的对象</p><p>3）新建一个animinations.ts文件确定 动画触发器等具体动画内容</p><p>4）在需要转场的html中用一个div将routerOutlet包起来，加上@routeAnimation属性，用一个函数赋值来寻找转场对象值进行转场</p></li><li><p>设置子路由的目的就是 想要让子组件进行路由切换，而父路由保持不变</p></li><li><p>在路由设置中父子路由，那么父路由的path就是整个路由的前缀</p><p>比如：</p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;crisis-center&#x27;</span>,<br><span class="hljs-attr">component</span>: <span class="hljs-title class_">CrisisCenterComponent</span>,<br><span class="hljs-attr">children</span>: [<br>      &#123;<br>        <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br>            ……<br></code></pre></td></tr></table></figure><p>子路由为’ ‘，则整个路由地址就为 crisis-center/，也就是说子路由不用写斜杠，即子路由是在父路由路径的基础上做出的扩展</p><p>  60.当项目模块很多设置路由时，可以在顶层路由只设置 默认路由和通配符路由，其他模块的放在各模块的路由配置文件中，最后再将各个模块包含起来即可</p><p>  61.如果路径中 特定父路由突然发生了变化，那么就要在路由设置中进行修改，于是就有了 相对路由的写法，在跳转路由时不用写绝对路径</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">this</span>.<span class="hljs-property">router</span>.<span class="hljs-title function_">navigate</span>([<span class="hljs-string">&#x27;../&#x27;</span>,&#123;<span class="hljs-attr">id</span>: crisisId, <span class="hljs-attr">foo</span>: <span class="hljs-string">&#x27;foo&#x27;</span>&#125;], &#123;<span class="hljs-attr">relativeTo</span>:<span class="hljs-variable language_">this</span>.<span class="hljs-property">activedRoute</span>&#125;)<br></code></pre></td></tr></table></figure><p>  这里需要提供activedRoute来告诉编译器当前在什么位置，然后通过../再往上一层，最后再加上id</p><p>  62.在同一页面 只可以出现一个无名路由（没有name属性的值），但是可以有多个有名路由（这样就可以区分了）</p><p>  63.原来看两个组件是否是父子组件关系，直接看文件夹的包含关系</p><p>  64.怎么知道 哪个路由设置中的路由会在哪个outlet中进行切换？</p><p>  在父组件对应的路由配置中 设置子组件的路由，然后在父组件的html中加上outlet，表示这些都是子组件的路由出口</p><ol start="65"><li> 主路由(出口)：一个HTML中从上往下第一个outlet出口</li></ol><p>​        第二路由(出口）：一个HTML中从上往下第二个outlet出口</p><p>​        修改主路由并不会改变第二路由，因为那仅仅是切换了主路由而已</p><p> 66.this.route.navigate([{ outlets: { popup: null}}])</p><p>​      这里是通过将该路由的出口设置成null来阻断跳转，即不显示该路由跳转的页面</p><p> 67.路由守卫：在路由跳转之前处理一些数据或认证，或者决定是否跳转</p><p> 68.如果本身文件夹不是包含关系，是平级的，router-oulet在任意一个子组件也想要设置一个父子路由关系，那么这时就需要在父组件的（配置总是在父组件中）路由配置文件中用children手动设置关系</p><p> 69.devDependence和dependence的区别：</p><p>​       前者是开发时的用到的依赖，而后者是项目运行时用到的依赖，比如脚手架它就是只在开发时采用的到，所以只存在于devDependence中</p><p>70.目录结构不用 和 嵌套路由的结构保持一致</p><p>71.特征路由是和特征模块放一块的，里面指明了这个模块所有组件的路由</p><p>72.嵌套路由 和 和router-outlet的位置有关：</p><p>​     每个父路由组件的HTML中都要提供一个router-outlet来给它的子路由进行切换</p><p>73.创建特定模块顺便创建对应的路由：ng g module xxx –routing</p><p>74.才理解 路由配置中path:’ ‘ 为什么一定要加match:’full’ 了</p><p>​     full的意思是一直匹配到最后，与之对立的prefix则只要这个path在整个路径中存在就行了</p><p>​     因为如果不加full，则‘ ’可以作为中间路径（由于是空的等于没加，直接可跳转任何地址），然后后面可以加任何地址，因此空地址通常都要加full</p><p>75.[routerLinkActiveOptions]=”{exact: true}”就等于上面说的pathMatch:’full’通常是对空地址的限制</p><p>76.无组件路由：用于分组，层次更清晰，还可保护子路由（为什么暂时不清楚）</p><p>77.要记住加了[]的都是动态属性，是需要在ts中自己自定义变量的</p><p>78.pipe里面的tap函数不只是用来打印数据，也可以用来处理其他的逻辑（处理变量值）</p><p>79.RouterStateSnapshot指的是路由在某个点的瞬时路由状态信息，包含url和toString</p><p>​      而ActivatedRouteSnapshot，也包含当前的路由地址，但还包括组件的其他服务更多一些</p><p>80.字符串连接如果要和三元字符一起使用的话，后面的括号 要全包起来，因为是整体最终的结果才构成一个字符串，然后再拼接</p><p>81.总结一下 如何使用 canActivated 对登录 进行身份验证（守卫）：</p><p>​    1.添加守卫的module和routing——守卫也是个模块，也就有路由（用来设置重定向的路由地址）</p><p>​    2.添加 一个 canActivatied 的 guard</p><p>​    3.在路由配置中把想要进行守卫的路由后面加一个canActivatied :[添加的守卫名称]</p><p>​     4.在 guard文件里面加入 具体验证的逻辑（另在函数中写的），它只提供当前URL等信息，其中也是要调用 守卫的服务的（另外创建，包含登陆变量、打印、登入登出函数），若未登录则重定向到登陆页面</p><p>​    5.添加登陆页面以及组件（登陆成功则跳转首页）</p><p>82.守护一个路由但是它的子路由却保护不到，如何更方便地保护子路由？</p><p>1）在要保护的子路由的父路由添canActivatedChild:[添加的守卫名称]</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs typescript">&#123;<br>      <span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;admin&#x27;</span>,<br>      <span class="hljs-attr">component</span>:<span class="hljs-title class_">AdminComponent</span>,<br>      <span class="hljs-comment">// 在跳转之前加个身份验证</span><br>      <span class="hljs-attr">canActivate</span>:[<span class="hljs-title class_">AuthGuard</span>],<br>      <span class="hljs-attr">children</span>:[<br>         &#123;<br>          <span class="hljs-comment">// 无组件路由，用于分组，层次更清晰，也可保护子路由</span><br>            <span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;&#x27;</span>,<br>            <span class="hljs-comment">// 表示对下面所有的孩子进行守卫</span><br>            <span class="hljs-attr">canActivateChild</span>:[<span class="hljs-title class_">AuthGuard</span>],<br>            <span class="hljs-attr">children</span>:[<br>               &#123; <span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-attr">component</span>:<span class="hljs-title class_">AdminDashboardComponent</span> &#125;,<br><br>               &#123; <span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;crises&#x27;</span>, <span class="hljs-attr">component</span>:<span class="hljs-title class_">ManageCrisesComponent</span> &#125;,<br><br>               &#123; <span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;heroes&#x27;</span>, <span class="hljs-attr">component</span>:<span class="hljs-title class_">ManageHeroesComponent</span> &#125;,<br>            ]<br>         &#125;<br>      ]<br>    &#125;<br></code></pre></td></tr></table></figure><p>2）在guard文件中，添加实现canActivatedChild（这样就可以用一个guard来实现多个守卫了），添加守护子路由接口canActivatedChild，因为此时 子路由有子路由的 函数参数，因此直接调用前面守护路由的 函数就行了</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AuthGuard</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">CanActivate</span>,<span class="hljs-title class_">CanActivateChild</span> &#123;<br>...<br><span class="hljs-title function_">canActivateChild</span>(<br>    <span class="hljs-attr">route</span>: <span class="hljs-title class_">ActivatedRouteSnapshot</span>,<br>    <span class="hljs-attr">state</span>: <span class="hljs-title class_">RouterStateSnapshot</span>): <span class="hljs-title class_">Observable</span>&lt;<span class="hljs-built_in">boolean</span> | <span class="hljs-title class_">UrlTree</span>&gt; | <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">boolean</span> | <span class="hljs-title class_">UrlTree</span>&gt; | <span class="hljs-built_in">boolean</span> | <span class="hljs-title class_">UrlTree</span> &#123;<br>    <span class="hljs-comment">// console.log(&#x27;AuthGuard canActivated called&#x27;)</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">canActivate</span>(route,state);<br>  &#125;<br><br></code></pre></td></tr></table></figure><p>83.任何的具体的逻辑实现都是写在服务中的</p><p>84.canDeactivate是用来 是否允许离开的，通常是需要加个确认框的判断，如果符合条件就可以离开当前路由，否则还是停留在当前路由</p><h4 id="Angular官网英雄之旅练习案例：https-gitee-com-zhoujielovesinging-angulars-heroic-journey"><a href="#Angular官网英雄之旅练习案例：https-gitee-com-zhoujielovesinging-angulars-heroic-journey" class="headerlink" title="Angular官网英雄之旅练习案例：https://gitee.com/zhoujielovesinging/angulars-heroic-journey"></a>Angular官网英雄之旅练习案例：<a href="https://gitee.com/zhoujielovesinging/angulars-heroic-journey">https://gitee.com/zhoujielovesinging/angulars-heroic-journey</a></h4>]]></content>
    
    
    <categories>
      
      <category>前端框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Angular</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端面试题(持续更新)</title>
    <link href="/2023/08/30/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/"/>
    <url>/2023/08/30/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="1px物理像素的实现"><a href="#1px物理像素的实现" class="headerlink" title="1px物理像素的实现"></a>1px物理像素的实现</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;title&gt;1px物理像素的实现&lt;/title&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="language-css"><span class="language-xml">      *&#123;Lcrouny Si/WKS/Wistron</span></span><br><span class="language-css"><span class="language-xml">        <span class="hljs-attribute">margin</span>:<span class="hljs-number">0</span>;</span></span><br><span class="language-css"><span class="language-xml">        <span class="hljs-attribute">padding</span>:<span class="hljs-number">0</span>;</span></span><br><span class="language-css"><span class="language-xml">      &#125;</span></span><br><span class="language-css"><span class="language-xml">      <span class="hljs-selector-id">#box</span>&#123;</span></span><br><span class="language-css"><span class="language-xml">        <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;</span></span><br><span class="language-css"><span class="language-xml">        <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;</span></span><br><span class="language-css"><span class="language-xml">        <span class="hljs-attribute">position</span>: relative;</span></span><br><span class="language-css"><span class="language-xml">        <span class="hljs-comment">/* 方案一 ：用border厚度1px来区分1px物理像素 */</span></span></span><br><span class="language-css"><span class="language-xml">        <span class="hljs-comment">/* border-bottom: 1px solid #000; */</span></span></span><br><span class="language-css"><span class="language-xml">      &#125;</span></span><br><span class="language-css"><span class="language-xml">      <span class="hljs-comment">/* 方案二： @media screen 只针对#box:before进行反向变回来*/</span></span></span><br><span class="language-css"><span class="language-xml">      <span class="hljs-selector-id">#box</span><span class="hljs-selector-pseudo">:before</span>&#123;</span></span><br><span class="language-css"><span class="language-xml">        <span class="hljs-attribute">content</span>: <span class="hljs-string">&#x27;&#x27;</span>;</span></span><br><span class="language-css"><span class="language-xml">        <span class="hljs-attribute">position</span>: absolute;</span></span><br><span class="language-css"><span class="language-xml">        <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;</span></span><br><span class="language-css"><span class="language-xml">        <span class="hljs-attribute">bottom</span>: <span class="hljs-number">0</span>;</span></span><br><span class="language-css"><span class="language-xml">        <span class="hljs-comment">/* 用box前面放一个高为1的元素来验证 */</span></span></span><br><span class="language-css"><span class="language-xml">        <span class="hljs-attribute">height</span>: <span class="hljs-number">1px</span>;</span></span><br><span class="language-css"><span class="language-xml">        <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;</span></span><br><span class="language-css"><span class="language-xml">        <span class="hljs-attribute">background-color</span>: black;</span></span><br><span class="language-css"><span class="language-xml">      &#125;</span></span><br><span class="language-css"><span class="language-xml">      <span class="hljs-keyword">@media</span> screen <span class="hljs-keyword">and</span> (<span class="hljs-attribute">-webkit-min-device-pixel-ratio</span>:<span class="hljs-number">1.5</span>)&#123;</span></span><br><span class="language-css"><span class="language-xml">        <span class="hljs-selector-id">#box</span><span class="hljs-selector-pseudo">:before</span>&#123;</span></span><br><span class="language-css"><span class="language-xml">          <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">scaleY</span>(<span class="hljs-number">0.67</span>);</span></span><br><span class="language-css"><span class="language-xml">        &#125;</span></span><br><span class="language-css"><span class="language-xml">      &#125;</span></span><br><span class="language-css"><span class="language-xml">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></span><br>&lt;/head&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;</span></span><br><span class="language-xml">        312</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&#x27;text/javascript&#x27;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">   <span class="hljs-variable language_">window</span>.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">params</span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">       </span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-comment">// 以下是方案一</span></span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-comment">// 1. 物理像素/CSS像素 = 像素比 </span></span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-keyword">var</span> dpr = <span class="hljs-variable language_">window</span>.<span class="hljs-property">devicePixelRatio</span>;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(dpr);<span class="hljs-comment">//1.5</span></span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-comment">// 2.initial-scale在meta标签中指的是CSS像素的缩放比</span></span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-keyword">var</span> scale = <span class="hljs-number">1</span>/dpr;</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-comment">// 屏幕区的宽</span></span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-keyword">var</span> width = <span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>.<span class="hljs-property">width</span></span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-comment">// 3.由物理像素1px反推initial-scale的缩放比并重新设置</span></span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-keyword">var</span> metaNode = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;meta[name=&quot;viewport&quot;]&#x27;</span>)</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(metaNode);</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">      metaNode.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">&#x27;content&#x27;</span>,<span class="hljs-string">&quot;width=device-width, initial-scale=&quot;</span>+scale)</span></span><br><span class="language-javascript"><span class="language-xml">       </span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-keyword">var</span> htmlNode = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;html&#x27;</span>)</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-comment">// 4.但是整体initial-scale变了，盒子长宽也变了需要再反向乘回来</span></span></span><br><span class="language-javascript"><span class="language-xml">      htmlNode.<span class="hljs-property">style</span>.<span class="hljs-property">fontSize</span> = width * scale + <span class="hljs-string">&#x27;px&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">   &#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="纯CSS创建一个三角形"><a href="#纯CSS创建一个三角形" class="headerlink" title="纯CSS创建一个三角形"></a>纯CSS创建一个三角形</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;style&gt;<br>     #box&#123;<br>       <span class="hljs-attr">width</span>: 0px;<br>       <span class="hljs-attr">height</span>: 0px;<br>      <span class="hljs-comment">/* 原理：四个角border足够大，互不相让，就形成了三角形</span><br><span class="hljs-comment">               但是似乎border无法做到足够大，那么就把盒子宽高设置为0(相当于宽高是种达到三角形的束缚)</span><br><span class="hljs-comment">               其他不要的三角形就设置透明色</span><br><span class="hljs-comment">      */</span><br>       <span class="hljs-attr">border</span>: 100px solid;<br><br>       border-top-<span class="hljs-attr">color</span>: blue;<br>       border-bottom-<span class="hljs-attr">color</span>: transparent;<br>       border-left-<span class="hljs-attr">color</span>: transparent;<br>       border-right-<span class="hljs-attr">color</span>: transparent;<br>     &#125;<br>  &lt;/style&gt;<br>&lt;/head&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="求背景图片左边到-box盒子左边框外侧的距离"><a href="#求背景图片左边到-box盒子左边框外侧的距离" class="headerlink" title="求背景图片左边到#box盒子左边框外侧的距离"></a>求背景图片左边到#box盒子左边框外侧的距离</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;style&gt;<br>     *&#123;<br>        <span class="hljs-attr">margin</span>:<span class="hljs-number">0</span>;<br>        <span class="hljs-attr">padding</span>:<span class="hljs-number">0</span>;<br>     &#125;<br>     <span class="hljs-comment">/* 题目的意思就是按照给出的box位置，计算一下 背景图片左边到box左边框的距离</span><br><span class="hljs-comment">        其实就是考的 border-box、padding-box、content-box的关系</span><br><span class="hljs-comment">     */</span><br>     #box&#123;<br>        <span class="hljs-attr">width</span>: 100px;<br>        <span class="hljs-attr">height</span>: 200px;<br>        background-<span class="hljs-attr">color</span>: pink;<br>        <span class="hljs-attr">padding</span>: 100px;<br>        <span class="hljs-attr">border</span>: 80px solid blue;<br>        background-<span class="hljs-attr">image</span>: <span class="hljs-title function_">url</span>(<span class="hljs-string">&quot;./images/作用域和引用类型的传递.png&quot;</span>); <br>        background-<span class="hljs-attr">size</span>: contain;<br>        <span class="hljs-comment">/* 背景图片起始源的位置 */</span><br>        background-<span class="hljs-attr">origin</span>: content-box;<br>        background-<span class="hljs-attr">repeat</span>: no-repeat;<br>        <span class="hljs-comment">/* 在content-box的-50px ,于是答案为 (100+80)-50=130px*/</span><br>        background-<span class="hljs-attr">position</span>: -50px <span class="hljs-number">0</span>;<br>     &#125;<br>  &lt;/style&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><br><span class="language-xml">   <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;</span></span><br><span class="language-xml">   <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="如何实现移动端rem适配"><a href="#如何实现移动端rem适配" class="headerlink" title="如何实现移动端rem适配"></a>如何实现移动端rem适配</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;!-- em是针对父元素的适配单位，而rem是只针对<span class="hljs-title function_">html</span>(root即根部)的适配单位<br>       比如html的fontSize为50px，然后body的字体设置为<span class="hljs-number">50</span>%，那么这个1em/1rem就为25px<br>  --&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="language-css"><span class="language-xml">     <span class="hljs-selector-id">#box</span>&#123;</span></span><br><span class="language-css"><span class="language-xml">        <span class="hljs-attribute">width</span>: <span class="hljs-number">0.5rem</span>;</span></span><br><span class="language-css"><span class="language-xml">        <span class="hljs-attribute">height</span>: <span class="hljs-number">0.5rem</span>;</span></span><br><span class="language-css"><span class="language-xml">        <span class="hljs-attribute">background-color</span>: red;</span></span><br><span class="language-css"><span class="language-xml">     &#125;</span></span><br><span class="language-css"><span class="language-xml">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></span><br>&lt;/head&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-comment">&lt;!-- 方法就是 html根元素的字体大小 = 屏幕区的宽</span></span><br><span class="hljs-comment"><span class="language-xml">       目的是想把 1rem设置成整个屏幕的宽，那下次某个盒子想要设置成占整个屏幕多大比例，那直接 1rem/x</span></span><br><span class="hljs-comment"><span class="language-xml">       比如 某个盒子想要占屏幕的一半，那设置完之后就可以设置宽高为0.5rem-&gt;特指整个屏幕的一半，这样不管是什么分辨率都可以设置 </span></span><br><span class="hljs-comment"><span class="language-xml">       Ps：这里的字体大小默认是 指的是rem或em的单位</span></span><br><span class="hljs-comment"><span class="language-xml">      --&gt;</span></span><br><span class="language-xml">   <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;</span></span><br><span class="language-xml">       </span><br><span class="language-xml">   <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&#x27;text/javascript&#x27;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-variable language_">window</span>.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-comment">// 整个屏幕的宽</span></span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-keyword">var</span> width = <span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>.<span class="hljs-property">clientWidth</span></span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-keyword">var</span> htmlNode = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;html&#x27;</span>)</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">        htmlNode.<span class="hljs-property">style</span>.<span class="hljs-property">fontSize</span> = width + <span class="hljs-string">&#x27;px&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-comment">// 以上三个步骤是为了当前屏幕单位 都为1rem</span></span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="使用flex实现水平居中"><a href="#使用flex实现水平居中" class="headerlink" title="使用flex实现水平居中"></a>使用flex实现水平居中</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;!-- 顺便先复习下之前的两种水平居中方式：绝对定位 --&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="language-css"><span class="language-xml">     <span class="hljs-selector-id">#wrap</span>&#123;</span></span><br><span class="language-css"><span class="language-xml">       <span class="hljs-attribute">width</span>: <span class="hljs-number">500px</span>;</span></span><br><span class="language-css"><span class="language-xml">       <span class="hljs-attribute">height</span>: <span class="hljs-number">500px</span>;</span></span><br><span class="language-css"><span class="language-xml">       <span class="hljs-comment">/* position: relative; */</span></span></span><br><span class="language-css"><span class="language-xml">       <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid black;</span></span><br><span class="language-css"><span class="language-xml">       <span class="hljs-comment">/* 方案三: 靠flex,直接在父元素对子元素自动调整----------应该是最方便的了★ */</span></span></span><br><span class="language-css"><span class="language-xml">       <span class="hljs-attribute">display</span>: flex;</span></span><br><span class="language-css"><span class="language-xml">       <span class="hljs-comment">/* 主轴(水平)设置在居中位置 */</span></span></span><br><span class="language-css"><span class="language-xml">       <span class="hljs-attribute">justify-content</span>: center;</span></span><br><span class="language-css"><span class="language-xml">       <span class="hljs-comment">/* 侧轴(垂直)设置在居中位置 */</span></span></span><br><span class="language-css"><span class="language-xml">       <span class="hljs-attribute">align-items</span>: center;</span></span><br><span class="language-css"><span class="language-xml"></span></span><br><span class="language-css"><span class="language-xml">       <span class="hljs-comment">/* flex对应的老版本 */</span></span></span><br><span class="language-css"><span class="language-xml">       <span class="hljs-comment">/* display: -webkit-box;</span></span></span><br><span class="hljs-comment"><span class="language-css"><span class="language-xml">       -webkit-box-pack: center;</span></span></span><br><span class="hljs-comment"><span class="language-css"><span class="language-xml">       -webkit-box-align: center; */</span></span></span><br><span class="language-css"><span class="language-xml">      &#125;</span></span><br><span class="language-css"><span class="language-xml">     <span class="hljs-selector-id">#wrap</span> <span class="hljs-selector-class">.box</span>&#123;</span></span><br><span class="language-css"><span class="language-xml">       <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;</span></span><br><span class="language-css"><span class="language-xml">       <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;</span></span><br><span class="language-css"><span class="language-xml">       <span class="hljs-attribute">position</span>: absolute;</span></span><br><span class="language-css"><span class="language-xml">       <span class="hljs-comment">/* 方案一：靠margin  都为0目的是去除对margin控制盒子的影响 */</span></span></span><br><span class="language-css"><span class="language-xml">       <span class="hljs-comment">/* top: 0;</span></span></span><br><span class="hljs-comment"><span class="language-css"><span class="language-xml">       bottom: 0;</span></span></span><br><span class="hljs-comment"><span class="language-css"><span class="language-xml">       left: 0;</span></span></span><br><span class="hljs-comment"><span class="language-css"><span class="language-xml">       right: 0;</span></span></span><br><span class="hljs-comment"><span class="language-css"><span class="language-xml">       margin: auto; */</span></span></span><br><span class="language-css"><span class="language-xml">       <span class="hljs-comment">/* 方案二: 只靠定位 */</span></span></span><br><span class="language-css"><span class="language-xml">       <span class="hljs-comment">/* left: 50%;</span></span></span><br><span class="hljs-comment"><span class="language-css"><span class="language-xml">       top: 50%;</span></span></span><br><span class="hljs-comment"><span class="language-css"><span class="language-xml">       transform: translate(-50%,-50%); */</span></span></span><br><span class="language-css"><span class="language-xml"></span></span><br><span class="language-css"><span class="language-xml">       <span class="hljs-attribute">background-color</span>: pink;</span></span><br><span class="language-css"><span class="language-xml">     &#125;</span></span><br><span class="language-css"><span class="language-xml">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></span><br>&lt;/head&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><br><span class="language-xml">   <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;wrap&quot;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">   <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="字符串驼峰的转换"><a href="#字符串驼峰的转换" class="headerlink" title="字符串驼峰的转换"></a>字符串驼峰的转换</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">toString</span>(<span class="hljs-params">foo</span>) &#123;<br>  <span class="hljs-keyword">var</span> arr = foo.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;-&quot;</span>);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> index = <span class="hljs-number">1</span>; index &lt; arr.<span class="hljs-property">length</span>; index++) &#123;<br>    arr[index] =<br>      arr[index].<span class="hljs-title function_">charAt</span>(<span class="hljs-number">0</span>).<span class="hljs-title function_">toUpperCase</span>() +<br>      arr[index].<span class="hljs-title function_">substring</span>(<span class="hljs-number">1</span>, arr[index].<span class="hljs-property">length</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> arr.<span class="hljs-title function_">join</span>(<span class="hljs-string">&quot;&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="作用域和值类型和引用类型的传递"><a href="#作用域和值类型和引用类型的传递" class="headerlink" title="作用域和值类型和引用类型的传递"></a><strong>作用域和值类型和引用类型的传递</strong></h3><blockquote><p>1.作用域在JS高级里面叫 “执行上下文”，”上下文”很容易理解，对应”域”，那”执行”就对应”作用”了</p><p>2.分为全局执行上下文和函数执行上下文，这两个上下文都会提前将变量以及函数放入上下文</p><p>3.注意下 xxx is not defined、undefined、null的区别</p><p>xxx is not defined：没有定义</p><p>undefined：定义了为赋值</p><p>null：定义了，值为null</p><p>层层递进，情况越来越好</p></blockquote><hr><p><img src="/2023/08/30/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%BC%A0%E9%80%92.png" alt="作用域和引用类型的传递"></p><blockquote><p>这题我错在哪里？</p><p>错在了 我忘了函数 参数的传递是一个赋值过程，我忽略了这个过程，看来在 引用类型这种特殊的类型尤其要注意细节赋值</p><p>重新解题：第一个空忽略，第二个空：在栈处重新加一个变量person并赋值p的地址，一开始指向p的地址，后来指向new的地址，但是它问的是传进去p的name</p></blockquote><p><strong>错误总结：</strong>看到引用类型传值，就考的是引用类型地址指向的问题，这种就需要注意它输出的是 哪个引用类型变量的属性</p><h3 id="封装函数进行字符串驼峰命名转换（主要复习string的方法）"><a href="#封装函数进行字符串驼峰命名转换（主要复习string的方法）" class="headerlink" title="封装函数进行字符串驼峰命名转换（主要复习string的方法）"></a><strong>封装函数进行字符串驼峰命名转换（主要复习string的方法）</strong></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">toString</span>(<span class="hljs-params">foo</span>) &#123;<br>  <span class="hljs-comment">// 根据符号-分开并组成数组</span><br>  <span class="hljs-keyword">var</span> arr = foo.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;-&#x27;</span>)<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> index = <span class="hljs-number">1</span>; index &lt; arr.<span class="hljs-property">length</span>; index++) &#123;<br>      <span class="hljs-comment">//注意substring是左闭右开</span><br>      arr[index] = arr[index].<span class="hljs-title function_">charAt</span>(<span class="hljs-number">0</span>).<span class="hljs-title function_">toUpperCase</span>()+arr[index].<span class="hljs-title function_">substring</span>(<span class="hljs-number">1</span>,arr[index].<span class="hljs-property">length</span>)<br>  &#125;<br>  <span class="hljs-comment">// 根据符号再将数组个元素连成字符串</span><br>  <span class="hljs-keyword">return</span> arr.<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;&#x27;</span>)<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">toString</span>(<span class="hljs-string">&#x27;get-element-by-id&#x27;</span>));<br></code></pre></td></tr></table></figure><p>Ps：split这个方法就是专门针对某个字符进行分割，以后看到字符串里多次出现某个字符，就很可能要用这个</p><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a><strong>冒泡排序</strong></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> array = [<span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">8</span>];<br><span class="hljs-comment">// 轮数</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; array.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>; i++) &#123;<br>  <span class="hljs-comment">// 交换次数，插入排序才是j=i，轮数越往后交换次数越少因此肯定和i有关</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; array.<span class="hljs-property">length</span> - i - <span class="hljs-number">1</span>; j++) &#123;<br>    <span class="hljs-keyword">if</span> (array[j] &gt; array[j + <span class="hljs-number">1</span>]) &#123;<br>      <span class="hljs-keyword">let</span> temp = array[j];<br>      array[j] = array[j + <span class="hljs-number">1</span>];<br>      array[j + <span class="hljs-number">1</span>] = temp;<br>    &#125;<br>  &#125;<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(array);<br></code></pre></td></tr></table></figure><h3 id="Js综合"><a href="#Js综合" class="headerlink" title="Js综合"></a><strong>Js综合</strong></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Foo</span>(<span class="hljs-params"></span>) &#123;<br>    getName = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-title function_">alert</span>(<span class="hljs-number">1</span>)<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span><br><br><span class="hljs-title class_">Foo</span>.<span class="hljs-property">getName</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">alert</span>(<span class="hljs-number">2</span>)<br>&#125;<br><br><span class="hljs-title class_">Foo</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getName</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">alert</span>(<span class="hljs-number">3</span>)<br>&#125;<br><br><span class="hljs-keyword">var</span> getName = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">alert</span>(<span class="hljs-number">4</span>)<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getName</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">alert</span>(<span class="hljs-number">5</span>)<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * (1)注意 function Foo 内的getName不是这个函数的，因为没有用var定义，因此会默认往全局作用于去找-------变量的寻找，靠作用域</span><br><span class="hljs-comment"> * */</span> <br><span class="hljs-title class_">Foo</span>.<span class="hljs-title function_">getName</span>()<span class="hljs-comment">//2</span><br><br><span class="hljs-comment">/*------------------------变量和函数提升之后---------------*/</span><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">Foo</span>(<span class="hljs-params"></span>) &#123;<br>        getName = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>            <span class="hljs-title function_">alert</span>(<span class="hljs-number">1</span>)<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span><br>    &#125;<br>    <span class="hljs-comment">// var getName;</span><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">getName</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-title function_">alert</span>(<span class="hljs-number">5</span>) &#125;;<br>    <br>    <span class="hljs-title class_">Foo</span>.<span class="hljs-property">getName</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-title function_">alert</span>(<span class="hljs-number">2</span>)<br>    &#125;<br>    <span class="hljs-title class_">Foo</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getName</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-title function_">alert</span>(<span class="hljs-number">3</span>)<br>    &#125;<br>    getName = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-title function_">alert</span>(<span class="hljs-number">4</span>)<br>    &#125;<br><br><span class="hljs-comment">/*-------------------------------------------------------*/</span><br><br><span class="hljs-title function_">getName</span>()<span class="hljs-comment">//4      变量提升，详细见下一题</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 先把 Foo() 化简了，算出来再去调用</span><br><span class="hljs-comment"> * (2)Foo返回的是this，但是这个this指的是window，因为看的是调用者，(window).Foo()-------this的指向</span><br><span class="hljs-comment"> * 全局作用域上有两个一个是var getName一个是函数，在加载数据时，会变量和函数提升：见上面</span><br><span class="hljs-comment"> * 又因为变量和函数同名时会忽略变量，优先看函数的(Jsz中函数相当于类很重要)，alert此时为5 -------变量和函数提升</span><br><span class="hljs-comment"> * 到最后时getName被赋值为alert(4)</span><br><span class="hljs-comment"> * 但是在Foo调用之后getName又被重新赋值为alert(1)，因此过程为5-&gt;4-&gt;1</span><br><span class="hljs-comment"> * */</span> <br><span class="hljs-title class_">Foo</span>().<span class="hljs-title function_">getName</span>()<span class="hljs-comment">//1</span><br><br><span class="hljs-title function_">getName</span>() <span class="hljs-comment">//1  具体见上一题：最后被赋值为alert(1)</span><br><br><span class="hljs-comment">/*下面两题用到了优先级的大小，具体如下图</span><br><span class="hljs-comment">  new 不带参和new ( fun())带参</span><br><span class="hljs-comment">  可以这么理解：前者后面没有参数也就是把后面当作一个整体，算好了再new</span><br><span class="hljs-comment">               后者直接算算不出来，需要先配合new一起算，然后再.调用</span><br><span class="hljs-comment">  这就是对于new来说，new带参比new不带参优先级高的原因</span><br><span class="hljs-comment">*/</span> <br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * .的优先级比new高，因此先看Foo.getName，又刚好可以替换成 function () &#123;alert(2)&#125;</span><br><span class="hljs-comment"> * 因此直接变成 new (function () &#123;alert(2)&#125;)()-&gt;当前函数的实例()--&gt;2</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Foo</span>.<span class="hljs-title function_">getName</span>()<span class="hljs-comment">//2</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * (new Foo()).getName()-&gt;(new this).getName()-&gt;foo.getName()从原型链上找-&gt;alert(3)----原型链</span><br><span class="hljs-comment"> * */</span> <br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Foo</span>().<span class="hljs-title function_">getName</span>()<span class="hljs-comment">//3</span><br><br><span class="hljs-comment">// 根据上面两题分析：new (new Foo()).getName()-&gt;new foo.getName()-&gt;alert(3)再实例（实例不对结果有影响）</span><br><span class="hljs-keyword">new</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Foo</span>().<span class="hljs-title function_">getName</span>()<span class="hljs-comment">//3</span><br></code></pre></td></tr></table></figure><p><img src="/2023/08/30/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/new%E5%92%8C.%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7.png" alt="new和.运算符的优先级"></p><blockquote><p>这个题很牛：考到了知识点有 找变量按照作用域链、变量和函数声明的提升、运算符优先级、原型链</p></blockquote><h3 id="防抖与节流"><a href="#防抖与节流" class="headerlink" title="防抖与节流"></a><strong>防抖与节流</strong></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// -------------------------------防抖与节流-------------------------------------------</span><br><span class="hljs-comment">//  节流：为了节省资源，减少事件触发的频率</span><br><span class="hljs-comment">//  就可以通过 一个周期减少函数执行的次数来实现，即设置多长时间执行一次（也可以用定时器），提高了性能</span><br><span class="hljs-comment">//  (第一次生效，后面不生效)</span><br><span class="hljs-comment">//  参数：delay时间执行一次fn</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">throttle</span>(<span class="hljs-params">fn, delay</span>) &#123;<br>    <span class="hljs-comment">// 利用闭包，每次的lastTime不会变，相当于小的全局变量</span><br>    <span class="hljs-keyword">var</span> lastTime = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">var</span> nowTime = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>()<br>        <br>        <span class="hljs-comment">// 到达一定时间再执行</span><br>        <span class="hljs-keyword">if</span> (nowTime - lastTime &gt; delay) &#123;<br>            <span class="hljs-comment">// 使用call是为了让this指向和里层function一致(因为闭包使用的是外部函数的变量和参数因此this也是外部函数的this)</span><br>            <span class="hljs-title function_">fn</span>()<br><br>            <span class="hljs-comment">// 更新时间</span><br>            lastTime = nowTime<br>        &#125;<br>    &#125;<br>&#125;<br><br>documnt.<span class="hljs-property">onscroll</span> = <span class="hljs-title function_">throttle</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;onscroll事件被触发了&#x27;</span>)&#125;,<span class="hljs-number">1000</span>)<br><br><span class="hljs-comment">// 防抖：防止比必要的操作(抖动)来节省资源，在真正需要的时机(最后一次操作延迟一段时间)再触发</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">debounce</span>(<span class="hljs-params">fn,delay</span>)&#123;<br>    <span class="hljs-keyword">var</span> time = <span class="hljs-literal">null</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">funtion</span>(<span class="hljs-params"></span>)&#123;<br>       <span class="hljs-comment">// 只要在时间之内就给你结束掉(如果到达了时间并且成功执行完毕后也会自行关闭)</span><br>       <span class="hljs-built_in">clearTimeout</span>(time)<br>        time = <span class="hljs-title function_">setTimeOut</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>        <span class="hljs-title function_">fn</span>()<br>        &#125;,delay)<br>    &#125;<br>    <br>&#125;<br><br><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;#btn&#x27;</span>).<span class="hljs-property">onclick</span> = <span class="hljs-title function_">debounce</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;btn事件被触发了&#x27;</span>)&#125;,<span class="hljs-number">1000</span>)<br><br><span class="hljs-comment">// 化繁为简：最大的区别，防抖是要等待操作停止下来达到delay时间后再执行，而节流是不管你什么操作，只按照我的时间周期来执行</span><br></code></pre></td></tr></table></figure><h3 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h3><p><strong>面试题：什么是跨域？跨域的解决办法是什么？</strong></p><p>浏览器安全的一种策略（类似权限的设置），需要保证 协议、域名、端口号一致</p><p>解决办法：</p><p>jsonp（需前后端都配置）、cors（只需后端配置）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// jsonp：利用script标签的不受跨域限制的特点，将需要执行的回调函数作为参数传递过去，那么请求结束回调函数自动会执行</span><br><br><span class="hljs-keyword">var</span> script = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;script&#x27;</span>)<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getData</span>(<span class="hljs-params">data</span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data)<br>&#125;<br><br>script.<span class="hljs-property">src</span> = <span class="hljs-string">&#x27;http://localhost:3000?callback=&#x27;</span>+getData<br><br><span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(script)<br></code></pre></td></tr></table></figure><h3 id="nodejs事件轮询机制"><a href="#nodejs事件轮询机制" class="headerlink" title="nodejs事件轮询机制"></a>nodejs事件轮询机制</h3><p><strong>面试题：下面三个函数执行顺序是什么？</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;setTimeout&#x27;</span>)<br>&#125;)<br><br><span class="hljs-title function_">setImmediately</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;setImmediately&#x27;</span>)<br>&#125;)<br><br>process.<span class="hljs-title function_">nextTick</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;process.nextTick&#x27;</span>)<br>&#125;)<br><br><span class="hljs-comment">// 不论执行的顺序先后如何，最后的打印结果都会如下：</span><br><span class="hljs-comment">// process.nextTick(在任何阶段都可以优先执行)</span><br><span class="hljs-comment">// setTimeout</span><br><span class="hljs-comment">// setImmediately</span><br></code></pre></td></tr></table></figure><p><img src="/2023/08/30/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/nodejs%E8%BD%AE%E8%AF%A2%E6%9C%BA%E5%88%B6(1).png" alt="事件循环机制的六个阶段(1)"></p><p><img src="/2023/08/30/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/nodejs%E8%BD%AE%E8%AF%A2%E6%9C%BA%E5%88%B6(2).png" alt="事件循环机制的六个阶段(2)"></p><p>**化繁为简一句话总结：优先级为 process.nextTick &gt;  定时器 &gt; poll阶段的回调函数 &gt; setImmediately **</p><h3 id="从URL输入网址"><a href="#从URL输入网址" class="headerlink" title="从URL输入网址"></a>从URL输入网址</h3><p><strong>面试题：从url输入网址到最终页面渲染完成，发生了什么？</strong></p><blockquote><p>补充：<a href="http://www.baidu.com/">www.baidu.com</a></p><p>www：万维网</p><p>URL：统一资源定位符</p><p>一共会有6个步骤，如下：</p><ol><li><p>DNS解析：将域名解析成ip地址，会按照以下顺序寻找映射表</p><ul><li>从浏览器缓存</li><li>从当前系统</li><li>从路由表</li><li>从网络运营商</li><li>递归搜索，从顶级域名服务器往下寻找，例如要找的是<a href="http://www.example.com这个地址/">www.example.com这个地址</a><ul><li>从.com域名寻找</li><li>从.example域名寻找</li><li>从www域名寻找</li></ul></li></ul></li><li><p>TCP连接：三次握手</p><ol><li><p>第一次握手，由浏览器发起，通知服务器准备发送数据了</p></li><li><p>第二次握手，由服务器发起，告诉浏览器确认收到通知了</p></li><li><p>第三次握手，由浏览器发起，告诉服务器收到确认消息了，我要开始发了，你准备好了</p><p><strong>面试题：为什么第三次还要再握手一次？</strong></p><p>因为前两次握手只能让客户端知道服务器能正常收到自己发送的数据，但是服务器不能保证客户端能正常收到自己发送的数据（可能半路数据丢失了，于是服务器自己就会超时重传），三次握手就是保证双方发送和接受都是正常的</p></li></ol></li><li><p>发送报文</p></li><li><p>响应报文</p></li><li><p>渲染页面：</p><ul><li>遇见HTML标签，浏览器用HTML解析器生成Token标记并构建成DOM树</li><li>遇见Style/Link标签，浏览器用CSS解析器构建CSSOM树</li><li>遇见script标签，浏览器用javascript解析器处理javascript代码（绑定事件，修改DOM树、CSSDOM树）</li><li>将DOM树、CSSOM树合并成渲染树</li><li>根据渲染树来计算布局，包括元素几何信息、大小等（布局）——— 回流（重排）</li><li>给元素绘制颜色（颜色） ————重绘</li></ul><p>由于各个内容可能经常变动，这些步骤会经常执行，并且顺序不固定</p></li><li><p>关闭TCP连接，四次挥手</p><ol><li>第一次挥手，浏览器告知服务器，即将关闭传输数据的通道，你准备准备</li><li>第二次挥手，服务器确认收到浏览器的关闭通知，表示还需要把剩余的数据传完再说</li><li>第三次挥手，服务器告知浏览器，我数据传递完毕了，我要关闭了</li><li>第四次挥手，浏览器确认服务器的关闭通知，你关闭吧，我过一段时间也关闭</li></ol><p><strong>面试题：为什么第四次挥手要等一段时间才关闭？</strong></p><p>确保服务器能收到自己的确认消息，让服务器放心【在发送路途中考虑到特殊情况（延迟、重传、乱序等问题），确保服务器其能收到自己发的消息】—和第三次握手目的是一样的</p></li></ol></blockquote><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p><strong>什么是闭包？</strong></p><p>它是一个对象（Closure），数据结构为key-value形式</p><p><strong>闭包形成的条件？</strong></p><ol><li>嵌套函数</li><li>内层函数对外层函数变的引用</li><li>**<u>外部函数调用时</u>**（重要），此时产生Closure对象</li></ol><p><strong>闭包优缺点以及注意点？</strong></p><p>优点：延长外层函数变量的生命周期</p><p>缺点：使用不当容易造成内存泄露</p><p>注意点：要及时销毁</p><p><strong>如何销毁？</strong></p><p>没有被使用 或者 被使用了之后成为了垃圾对象（没有指向新的对象或设置为null）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn1</span>(<span class="hljs-params"></span>)&#123;<br>    -------------------------------------此时就已经产生了闭包(变量提升)<br>    <span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">fn2</span>(<span class="hljs-params"></span>)&#123;<br>        a++  <span class="hljs-comment">//引用函数外部变量，产生闭包</span><br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a)<br>    &#125;------------------------------------这里整个fn2就会被释放，因为没有被使用(<span class="hljs-number">1</span>)<br>     <span class="hljs-keyword">function</span> <span class="hljs-title function_">fn3</span>(<span class="hljs-params"></span>)&#123;<br>        a++  <span class="hljs-comment">//引用函数外部变量，产生闭包</span><br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a)<br>    &#125;<br>    <span class="hljs-keyword">return</span> fn3<br>&#125;<br><span class="hljs-comment">//fn1()----------------------------------这里fn1调用结束后，如果没有变量指向fn3(返回值)，那fn3就会成为垃圾对象，准备被销毁，那闭包中的变量也没了(2)</span><br><span class="hljs-keyword">var</span> f = <span class="hljs-title function_">fn1</span>()<br><span class="hljs-title function_">f</span>()<br>f = <span class="hljs-literal">null</span> <span class="hljs-comment">// (2)设置为null也成为了垃圾对象</span><br></code></pre></td></tr></table></figure><p><strong>闭包的使用场景？</strong></p><p>函数的防抖与节流、第三方库的封装（数据私有化）</p><blockquote><p>下面举个第三方库的封装的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> counter = (<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 私有变量</span><br>  <span class="hljs-keyword">var</span> count = <span class="hljs-number">0</span>;<br>  <br>  <span class="hljs-comment">// 私有函数</span><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">increment</span>(<span class="hljs-params"></span>) &#123;<br>    count++;<br>  &#125;<br>  <br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">decrement</span>(<span class="hljs-params"></span>) &#123;<br>    count--;<br>  &#125;<br>  <br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">getCount</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> count;<br>  &#125;<br>  <br>  <span class="hljs-comment">// 返回接口</span><br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">increment</span>: increment,<br>    <span class="hljs-attr">decrement</span>: decrement,<br>    <span class="hljs-attr">getCount</span>: getCount<br>  &#125;;<br>&#125;)();<br><br>可以通过<span class="hljs-string">`counter.increment()`</span>和<span class="hljs-string">`counter.getCount()`</span>等接口来操作和获取计数器的状态，而无需关心内部的实现细节。<br></code></pre></td></tr></table></figure></blockquote><p><strong>闭包面试题</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fun</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a)<br>    &#125;<br>&#125;<br><span class="hljs-keyword">let</span> fun2 = <span class="hljs-title function_">fun</span>()<br><span class="hljs-title function_">fun2</span>()<span class="hljs-comment">//1</span><br><span class="hljs-title function_">fun2</span>()<span class="hljs-comment">//1 ---------- 这两次一直在使用闭包中的变量</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fun</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        a++<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a)<br>    &#125;<br>&#125;<br><span class="hljs-keyword">let</span> fun2 = <span class="hljs-title function_">fun</span>() <br><span class="hljs-title function_">fun2</span>()<span class="hljs-comment">//2</span><br><span class="hljs-title function_">fun2</span>()<span class="hljs-comment">//3 ---------- 同上</span><br><br><span class="hljs-comment">// 下面是闭包终极面试题 ----- 懂了就没啥问题了</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fun</span>(<span class="hljs-params">n,o</span>)&#123;<br>    <span class="hljs-comment">// var n,o</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(o)<br>    <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-attr">fun</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">m</span>)&#123;<br>            <span class="hljs-comment">// var m</span><br>            <span class="hljs-title function_">fun</span>(m,n)<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">var</span> a = <span class="hljs-title function_">fun</span>(<span class="hljs-number">0</span>)<br>a.<span class="hljs-title function_">fun</span>(<span class="hljs-number">1</span>)<br>a.<span class="hljs-title function_">fun</span>(<span class="hljs-number">2</span>)<br>a.<span class="hljs-title function_">fun</span>(<span class="hljs-number">3</span>) <span class="hljs-comment">// undefined,0,0,0</span><br><br><span class="hljs-keyword">var</span> b = <span class="hljs-title function_">fun</span>(<span class="hljs-number">0</span>).<span class="hljs-title function_">fun</span>(<span class="hljs-number">1</span>).<span class="hljs-title function_">fun</span>(<span class="hljs-number">2</span>).<span class="hljs-title function_">fun</span>(<span class="hljs-number">3</span>) <span class="hljs-comment">// undefined,0,1,2</span><br><br><span class="hljs-keyword">var</span> c = <span class="hljs-title function_">fun</span>(<span class="hljs-number">0</span>).<span class="hljs-title function_">fun</span>(<span class="hljs-number">1</span>)<br>c.<span class="hljs-title function_">fun</span>(<span class="hljs-number">2</span>)<br>c.<span class="hljs-title function_">fun</span>(<span class="hljs-number">3</span>) <span class="hljs-comment">// undefined,1,1,1</span><br></code></pre></td></tr></table></figure><p><strong>总结技巧：</strong></p><ul><li>对于链式 ———– 返回上一个对象里面闭包的值</li><li>对于非链式———要清除该对象内闭包值是多少，只要不是新的对象，闭包值不变</li></ul><h3 id="变量提升-amp-执行上下文-amp-作用域链"><a href="#变量提升-amp-执行上下文-amp-作用域链" class="headerlink" title="变量提升&amp;执行上下文&amp;作用域链"></a>变量提升&amp;执行上下文&amp;作用域链</h3><blockquote><ol><li><p>变量提升（预处理）   ————— 提前保存</p><p>1）收集 变量</p><p>2）收集 函数的声明以及函数的参数</p><p>3）将 收集的 东西 放入 <strong>变量对象</strong> 中</p><p>其中，变量对象 分为 全局和局部</p><p>全局 -&gt; window</p><p>局部 -&gt; 抽象的</p></li><li><p>确认this的指向 ——————–方便给程序员统一用this访问数据</p><p>1）全局：this-&gt;window   ———（有上面可知，全局变量对象也-&gt;window，即this = 变量对象 = winodw）</p><p>2）局部：this-&gt;调用它的对象 </p></li><li><p>创建作用域链 —————— 如果找不到数据-&gt;找上找</p><p>它的值 = 父级作用域链 + 当前变量对象</p></li></ol><p><strong>总结：以上所有数据保存在执行上下文对象（execute obj）中</strong></p><p>ECObj = {</p><p>​      变量对象：{变量，函数的声明，函数的参数}，</p><p>​      this：{window || 调用它的对象 }，</p><p>​      作用域链（scopeChain）：父级作用域链 + 当前变量对象</p><p>}</p><p>流程：按照作用域链，先从当前执行上下文的变量对象去找，找不到再往外</p><p>this就是指当前执行上下文，只不过默认就是直接跳过变量对象去访问变量</p></blockquote><h3 id="宏任务与微任务"><a href="#宏任务与微任务" class="headerlink" title="宏任务与微任务"></a>宏任务与微任务</h3><p><strong>宏任务、微任务和nodejs事件循环机制的关系</strong></p><blockquote><p>宏任务、微任务都是nodejs事件循环机制处理的对象</p></blockquote><p><strong>宏任务</strong></p><blockquote><p>分类：定时器（<u>setTimeout、setInterval</u>）、requestAnimationFrame（请求动画的回调）</p><p>特点：耗时</p></blockquote><p><strong>宏任务队列</strong></p><blockquote><p>可以用来存放宏任务的，可以有多个，但是第一个是给 主线程 用的，后面的存放宏任务</p></blockquote><p><strong>微任务</strong></p><blockquote><p>分类：new promise(回调).then()、process.nextTick()</p><p>特点：紧急性高</p></blockquote><p><strong>微任务对队列</strong></p><blockquote><p>用来存放微任务，有且只有一个</p></blockquote><p><strong>宏任务和微任务执行顺序？</strong></p><blockquote><p>-&gt;执行第一个宏任务队列（主线程）</p><p>-&gt; 如果存在微任务队列</p><p>​     -&gt; 执行微任务队列</p><p>​    否则</p><p>​    -&gt;执行宏任务队列</p></blockquote><p><strong>宏任务、微任务以及nodejs事件循环检查阶段的执行顺序？</strong></p><blockquote><p>nodejs事件循环检查阶段———————–见上面：事件循环机制的六个阶段</p><p>nodejs事件循环检查阶段主要是针对宏任务的，只是在每个检查阶段结束后都会检查微队列中是否有微队列要执行，有的话先执行微队列，说明了微任务的紧急性。</p></blockquote><p><strong>面试题</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;---------------------start-------------------------&#x27;</span>)<br><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;setTimeout&#x27;</span>)<br>&#125;, <span class="hljs-number">0</span>)<br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i)<br>  &#125;<br>  <span class="hljs-title function_">resolve</span>()<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Promise实例成功执行&#x27;</span>)<br>&#125;)<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;---------------------end-------------------------&#x27;</span>)<br><br><span class="hljs-comment">//以下是执行结果</span><br>---------------------start-------------------------<br><span class="hljs-number">0</span><br><span class="hljs-number">1</span><br><span class="hljs-number">2</span><br><span class="hljs-number">3</span><br><span class="hljs-number">4</span><br>---------------------end-------------------------<br><span class="hljs-title class_">Promise</span>实例成功执行<br><span class="hljs-built_in">setTimeout</span><br></code></pre></td></tr></table></figure><h3 id="比较React和Vue"><a href="#比较React和Vue" class="headerlink" title="比较React和Vue"></a>比较React和Vue</h3><p><strong>相同点</strong></p><ol><li>都支持props进行父子组件间通信</li><li>都支持数据驱动视图，即 数据改变自动更新视图，不需手动更新</li><li>都支持服务端渲染</li><li>都支持虚拟DOM（React偏向于全部重新渲染）</li><li>都支持组件化开发</li></ol><p><strong>不同点</strong></p><ol><li>Vue是双向数据流，而React是单向的</li><li>Vue在修改仓库的数据可以直接this.xxx修改，而React必须调用封装的setState函数</li><li>Vue使用的是webback+vue-loader将js、html、css打包成的组件文件，而React使用的是JSX文件，将html、css全放入js中</li></ol><blockquote><p>如何记忆？js-&gt;模板视图渲染-&gt;组件</p><p>​                   js-&gt;仓库数据-&gt;组件</p><p>分类-&gt;时间顺序-&gt;规模由小到大</p></blockquote><h3 id="Vuex状态管理的机制"><a href="#Vuex状态管理的机制" class="headerlink" title="Vuex状态管理的机制"></a>Vuex状态管理的机制</h3><p><strong>是什么</strong></p><p>是一个专门用于Vue状态管理的插件</p><p><strong>作用</strong></p><p>可集中式处理多个组件的状态和处理后台数据</p><p><strong>原理</strong></p><p>state用来存储状态，getters是对于state计算后的结果，这两者都可以通过$store.state/getters或mapState、mapGetters给组件使用；actions里面的函数可以通过$store.dispatch或mapActions触发，触发后本质上是通过commit调用mutations里面的函数，mutions会直接修改state的值，当然，刚刚这个是actions获取数据，还可以actions里面也可以去修改后台数据。</p><blockquote><p>不难，但是要能说出来</p><p>思路：管理状态和处理后台数据</p><p>管理状态：state-&gt;actions-&gt;mutations-&gt;state-&gt;actions</p><p>处理后台数据：actions</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>面试题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端综合</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Node.js知识点</title>
    <link href="/2023/08/30/node-js/"/>
    <url>/2023/08/30/node-js/</url>
    
    <content type="html"><![CDATA[<h3 id="1-为什么javascript代码可以在浏览器中被执行？"><a href="#1-为什么javascript代码可以在浏览器中被执行？" class="headerlink" title="1.为什么javascript代码可以在浏览器中被执行？"></a>1.为什么javascript代码可以在浏览器中被执行？</h3><p>因为浏览器有js解析引擎，可以对js代码进行解析。这个js解析引擎每个浏览器都不同，只要知道其中谷歌浏览器的V8引擎是性能最好的，这也是前端程序员喜欢用谷歌浏览器的原因。</p><p><img src="/2023/08/30/node-js/js%E8%A7%A3%E6%9E%90%E5%BC%95%E6%93%8E.png" alt="js解析引擎"></p><h3 id="2-为什么javascript可以操作DOM、BOM"><a href="#2-为什么javascript可以操作DOM、BOM" class="headerlink" title="2.为什么javascript可以操作DOM、BOM"></a>2.为什么javascript可以操作DOM、BOM</h3><p>因为每个浏览器都内置了DOM、BOM这样的内置对象，这样js就可以在浏览器里操作它们。</p><ul><li><p>什么是DOM、BOM</p><p>DOM文本对象模型，包含处理页面的许多API</p><p>BOM浏览器对象模型，包含了与浏览器交互的API</p></li></ul><h3 id="3-javascript的运行环境包括什么？"><a href="#3-javascript的运行环境包括什么？" class="headerlink" title="3.javascript的运行环境包括什么？"></a>3.javascript的运行环境包括什么？</h3><p>即代码所需要的运行环境，包括 js解析引擎 和 内置API，其实就是上面两点所说的</p><p><u>关系：</u>应该是先经过解析引擎解析然后调用内置API就可以操作 BOM、DOM了</p><p><img src="/2023/08/30/node-js/js%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83.png" alt="js运行环境"></p><h3 id="4-javascript是如何做后端开发的？"><a href="#4-javascript是如何做后端开发的？" class="headerlink" title="4.javascript是如何做后端开发的？"></a>4.javascript是如何做后端开发的？</h3><p>javascript放在浏览器的环境里就是做前端的，放在node.js环境里就是做后端的。</p><ul><li>注意：在node.js环境中不能调用DOM、BOM、ajax对象，因为它里面只提供后端的API，这些浏览器的内置API它无关。</li></ul><h4 id="5-什么是node-js？"><a href="#5-什么是node-js？" class="headerlink" title="5.什么是node.js？"></a>5.什么是node.js？</h4><p>node.js是基于V8引擎的javascript运行环境。注意是这里也是V8引擎，是因为谷歌V8引擎性能好。</p><h3 id="6-node-js可以干什么以及学习路径？"><a href="#6-node-js可以干什么以及学习路径？" class="headerlink" title="6.node.js可以干什么以及学习路径？"></a>6.node.js可以干什么以及学习路径？</h3><p>可以做所有后端可以做的事情</p><p>学习路径：js基础语法-&gt;内置API（fs、path、http）-&gt;第三方API模块（express、mysql）</p><h3 id="7-powershell是什么？如何打开？"><a href="#7-powershell是什么？如何打开？" class="headerlink" title="7.powershell是什么？如何打开？"></a>7.powershell是什么？如何打开？</h3><p>它是cmd的升级版，以后尽量使用powershell，在当前文件夹按住shift右键便可打开</p><h3 id="8-终端中的快捷键"><a href="#8-终端中的快捷键" class="headerlink" title="8.终端中的快捷键"></a>8.终端中的快捷键</h3><p>方向↑键：获取上一条命令</p><p>esc：清空当前命令</p><p>tab：在当前文件夹中，输入某个文件的前几个字符，按tab可以直接补全，这个一般用于 文件名太长的场景下。</p><p>cls：清空所有命令</p><h2 id="fs文件系统模块"><a href="#fs文件系统模块" class="headerlink" title="fs文件系统模块"></a>fs文件系统模块</h2><h3 id="1-How-to-import"><a href="#1-How-to-import" class="headerlink" title="1.How to import?"></a>1.How to import?</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="2-什么是utf-8？"><a href="#2-什么是utf-8？" class="headerlink" title="2.什么是utf-8？"></a>2.什么是utf-8？</h3><p>它是一种基于unicode的一种编码方式，可以表示unicode的任意一种字符</p><h2 id="path模块"><a href="#path模块" class="headerlink" title="path模块"></a>path模块</h2><h3 id="1-什么是path模块？"><a href="#1-什么是path模块？" class="headerlink" title="1.什么是path模块？"></a>1.什么是path模块？</h3><p>可以对路径进行各种处理，包括join()可将多个路径片段拼接成一个字符串、basename()获取路径中的文件名</p><h2 id="HTTP模块"><a href="#HTTP模块" class="headerlink" title="HTTP模块"></a>HTTP模块</h2><h3 id="1-127-0-0-1就是localhost"><a href="#1-127-0-0-1就是localhost" class="headerlink" title="1.127.0.0.1就是localhost"></a>1.127.0.0.1就是localhost</h3><h3 id="2-80端口的服务80端口是可以省略的"><a href="#2-80端口的服务80端口是可以省略的" class="headerlink" title="2.80端口的服务80端口是可以省略的"></a>2.80端口的服务80端口是可以省略的</h3><p>npm与包</p><h3 id="1-安装package-json的命令：npm-init-y"><a href="#1-安装package-json的命令：npm-init-y" class="headerlink" title="1.安装package.json的命令：npm init -y"></a>1.安装package.json的命令：npm init -y</h3><p>这里的-y是指当选择确认或者取消的时候自动选择y(yes)，好像可以不写-y</p><p>注意：</p><ul><li>使用这个命令的时候，路径不能为中文且名字不能有空格</li><li>一定要初始化之后，安装第三方包才会生效，才会安装到此项目中，否则都不知道安装到哪去了</li></ul><h3 id="2-dependences"><a href="#2-dependences" class="headerlink" title="2.dependences"></a>2.dependences</h3><p>在package.json里面，专门记录安装了哪些包，因此有时候也说依赖包，在依赖下的包</p><p>在安装多个包的时候，可以用空格来分隔 npm i jquery art-template</p><h3 id="3-devDependence"><a href="#3-devDependence" class="headerlink" title="3.devDependence"></a>3.devDependence</h3><p>只在开发阶段使用的包放在这里，怎么看是否要安装到dev环境？</p><p>到官网npmjs.com去查找使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">npm i 包名 -D<br></code></pre></td></tr></table></figure><p>这里的-D就是–save -dev的简写，不写-D默认安装在dependences里面</p><h3 id="4-包下载慢的问题"><a href="#4-包下载慢的问题" class="headerlink" title="4.包下载慢的问题"></a>4.包下载慢的问题</h3><p><strong>原因：</strong></p><p>使用npm通常是直接从国外服务器下载过来的，其中需要经过海底光缆，需要一定时间</p><p>而 国内淘宝镜像服务器 它可以每隔一段时间把国外服务器上的数据同步过来，然后提供给国内用户下载，这样国内用户就可以在镜像上下载，而且还很快</p><p><strong>称为镜像的原因：</strong></p><p>就像镜子中的人像一样，就相当于你的副本</p><p><strong>如何切换为国内淘宝镜像源：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-number">1</span>、先查看当前镜像源地址<br>npm config get registry<br><span class="hljs-number">2</span>、配置<br>npm config set registry=<span class="hljs-attr">https</span>:<span class="hljs-comment">//registry.npm.taobao.org/</span><br></code></pre></td></tr></table></figure><p><strong>如何更方便的切换：使用nrm（node registry management）</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-number">1</span>、安装<br>npm i nrm -g<br><span class="hljs-number">2</span>、查看所有镜像源地址<br>nrm ls<br><span class="hljs-number">3</span>、使用淘宝镜像<br>nrm use taobao <br></code></pre></td></tr></table></figure><h3 id="4-包的分类"><a href="#4-包的分类" class="headerlink" title="4.包的分类"></a>4.包的分类</h3><ul><li><p>项目包（从项目开发的角度）</p><p>又开发依赖包（devDependence）和核心包（dependence）</p></li><li><p>全局包</p><p>默认安装位置：C:\Users\K22070055\AppData\Roaming\npm\node_modules</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">npm i 包名 -g<br>npm uninstall 包名 -g<br></code></pre></td></tr></table></figure><p>什么时候需要加-g？</p><p>1.加-g的最好是工具包，就是可以提供一些命令使用的，这样就可以任意地方使用</p><p>2.是在不清楚可以去npmjs.com官网查看是否需要加，人家都有写在上面</p><p><u>PS：好用的全局包</u>：</p><p>npm i -g i5ting_toc ————– 可以将md文件转换为html文件</p><p>使用方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">i5ting_toc -f md文件地址 -o<br></code></pre></td></tr></table></figure><p>表示把文件（file）地址为…的文件从md转换为html并打开（open）</p><p>注意文件地址，如果是相对路径一定要和当前目录拼接对应上</p></li></ul><h3 id="5-规范的包结构"><a href="#5-规范的包结构" class="headerlink" title="5.规范的包结构"></a>5.规范的包结构</h3><ul><li>包必须以单独的目录存在（node_modules）</li><li>每个包的顶级目录（当前包刚点进去）必有一个package.json文件</li><li>每个package.json文件必须包含name（包名）、version（版本号）、main（包的入口），这个入口就是提供被别人使用require来引入的</li></ul><h3 id="6-开发属于自己的包"><a href="#6-开发属于自己的包" class="headerlink" title="6.开发属于自己的包"></a>6.开发属于自己的包</h3><p>1.新建一个文件夹itheima-tools，作为包的根目录</p><p>2.在itheima-tools文件夹中新建如下三个文件：</p><ul><li>package.json（包管理配置文件）</li><li>index.js（包的入口文件）</li><li>README.md（包的说明文档）</li><li>在当前包根目录下 npm publish即可发布，名字不能是大写而且改完后还要改package.json文件里的name</li></ul><p>注意：尽量不要在npm上面发布无意义的包，此时就需要删除自己发布的包，用命令 npm unpublish 包名 –force</p><h3 id="7-模块的加载机制"><a href="#7-模块的加载机制" class="headerlink" title="7.模块的加载机制"></a>7.模块的加载机制</h3><p><u>优先从缓存中加载</u>，即如果一个包已经加载过一次，那么就会在本地缓存一份，那么下次再加载就会优先从缓存中加载，不会再从头到尾重新执行一遍代码，提高了加载效率</p><ul><li><p>内置模块的加载机制，如果出现同名模块，则优先加载内置模块的那个</p></li><li><p>自定义模块的加载机制，在加载时一定要以./、../开头，因为不加这些node会默认把它当作是内置模块或者是第三方模块，加了就是为了告诉node我写的模块在哪</p><p>同时，如果自定义模块在加载时 拓展名 忘记写了，则Node会默认按照一下顺序进行不全，补全.js进行加载-&gt;补全.json进行加载-&gt;补全.node进行加载-&gt;加载失败，终端报错</p></li><li><p>将某目录作为模块，则会 </p><p>找当前目录的package.json文件，然后找到main属性所指向的地址-&gt;如果没有package.json文件或者main不存在或者地址无法解析，则会加载当前目录的index.js-&gt;如果前两部都失败了，则会报错：Error:Can’t find the module xxx</p></li></ul><h2 id="Express"><a href="#Express" class="headerlink" title="Express"></a>Express</h2><h3 id="1-简单介绍"><a href="#1-简单介绍" class="headerlink" title="1.简单介绍"></a>1.简单介绍</h3><ul><li><p>它是基于node.js的极简的web框架的第三方模块</p></li><li><p>没有express可以创建web服务器吗？</p><p>可以，使用Http模块就可以</p></li><li><p>既然有了Http模块，为什么还要express？</p><p>因为Http模块太过繁琐，开发效率低，而express是从Http模块进一步封装来的，开发效率高</p></li></ul><h3 id="2-Express能做什么？"><a href="#2-Express能做什么？" class="headerlink" title="2.Express能做什么？"></a>2.Express能做什么？</h3><p>对于前端程序员有两种服务器：</p><ul><li><p>网站服务器</p><p>专门对外提供网站资源的服务器</p></li><li><p>API接口服务器</p><p>专门对外提供API接口的服务器</p></li></ul><p>Express能够很方便的<u>创建网站服务器</u>或<u>API接口服务器</u></p><h3 id="3-Express中间件"><a href="#3-Express中间件" class="headerlink" title="3.Express中间件"></a>3.Express中间件</h3><p><strong>1.概念</strong></p><p>类似于处理污水的中间处理环节</p><p><strong>2.中间件的处理流程</strong></p><p>当一个请求到达express服务器的时候，会连续调用多个中间件，进而对请求进行预处理，也就是说中间件的作用就是对请求进行预处理</p><p><img src="/2023/08/30/node-js/%E4%B8%AD%E9%97%B4%E4%BB%B6%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B.png" alt="中间件调用流程"></p><p><strong>3.中间件的格式</strong></p><p>中间件本质上是个处理函数，在参数上比路由多一个next参数，且这个next参数是个函数</p><p><img src="/2023/08/30/node-js/%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%A0%BC%E5%BC%8F.png" alt="中间件格式"></p><p><strong>4.next函数的作用</strong></p><p>它是中间件连续调用的关键，调用了next函数后就可以转接给下一个中间件或路由</p><p><strong>5.中间件的作用</strong></p><p>由于中间件之间可以共享req res，因此上层中间件可以定义一些自定义属性和方法给下层使用</p><p><strong>6.中间件的分类</strong></p><ul><li><p>应用级别</p><p>像app.get、app.post这种挂载在app上的中间件</p></li><li><p>路由级别</p><p>像router.get、router.post这种由express.Router()挂载的中间件</p></li><li><p>错误级别</p><p>函数参数前面还需要err的中间件</p></li><li><p>内置</p><p>express.static、express.json（负责解析json格式数据）、express.urlencoded（负责解析URL-encoded格式数据），后两个必须要在4.16.0以后才能使用</p></li><li><p>第三方</p></li></ul><h2 id="跨域问题"><a href="#跨域问题" class="headerlink" title="跨域问题"></a><strong>跨域问题</strong></h2><p><strong>1.前言</strong></p><p>在不同域数据时请求时，由于浏览器的同源策略，会阻止服务器返回来的资源进入浏览器</p><p><strong>2.用cors解决跨域</strong></p><p>它会有一些响应头相当于vip让浏览器可以允许通过 </p><p><strong>3.cors的三个请求头</strong></p><p>Access-Control-Allow-Origin：可具体设置允许哪个 url，或者*所有url 通过</p><p>Access-Control-Allow-Header：内置一些允许的头部，如果请求的头部不在里面，则需另外加</p><p>Access-Control-Allow-Methods：针对一些方法来设置是否允许请求，比如DELETE、PUT</p><p><strong>4.cors请求的分类</strong></p><ul><li><p>简单请求</p><p>①请求方式：GET、POST、HEAD三者之一</p><p>②头部信息不超过内置的所有种类</p></li><li><p>预检请求</p><p>在浏览器与服务器正式通信之前，浏览器会先发送OPTION请求进行<u>预检</u>，来确认服务器是否允许这次请求</p><p>①请求方式为除了GET、POST、HEAD之外的Method类型</p><p>②请求头中包含自定义字段</p><p>③向服务器发送了application/json格式的数据</p></li></ul><p><strong>5.jsonp来解决跨域</strong></p><p><u>概念</u>：浏览器通过<script>标签的src属性向服务器请求数据，服务器返回一个函数的调用，这种方式就叫做JSONP</p><p><u>特点</u>：</p><p>①JSONP不属于Ajax请求，因为它没有使用XMLHttpRequest这个对象</p><p>②JSONP仅支持GET请求，不支持PUT、DELETE、POST等请求</p><h3 id="JWT（Json-Web-Token）身份认证"><a href="#JWT（Json-Web-Token）身份认证" class="headerlink" title="JWT（Json Web Token）身份认证"></a>JWT（Json Web Token）身份认证</h3><p><strong>1.组成部分</strong></p><p>Payload：这才是真正的用户信息，它是由用户信息经过加密后字符串</p><p>Header、Signature：只是为了保证Token的安全 </p>]]></content>
    
    
    <categories>
      
      <category>Node.js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>知识点</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue3相对于Vue2的不同用法</title>
    <link href="/2023/08/30/Vue3%E7%9B%B8%E5%AF%B9%E4%BA%8EVue2%E7%9A%84%E4%B8%8D%E5%90%8C%E7%94%A8%E6%B3%95/"/>
    <url>/2023/08/30/Vue3%E7%9B%B8%E5%AF%B9%E4%BA%8EVue2%E7%9A%84%E4%B8%8D%E5%90%8C%E7%94%A8%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h3 id="1-项目结构"><a href="#1-项目结构" class="headerlink" title="1.项目结构"></a>1.项目结构</h3><p><strong>main.js文件</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; createApp &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./App.vue&#x27;</span><br><br><span class="hljs-comment">//Vue3写法 </span><br><span class="hljs-title function_">createApp</span>(<span class="hljs-title class_">App</span>).<span class="hljs-title function_">mount</span>(<span class="hljs-string">&#x27;#app&#x27;</span>)<br><br><span class="hljs-comment">// Vue2写法</span><br><span class="hljs-comment">// new Vue(&#123;</span><br><span class="hljs-comment">//     render: h =&gt; h(App)</span><br><span class="hljs-comment">// &#125;)</span><br><br><span class="hljs-comment">// ========&gt; (1)新建实例并渲染App 直接简化为 创建App,简化后更加利于理解</span><br></code></pre></td></tr></table></figure><h3 id="2-setup"><a href="#2-setup" class="headerlink" title="2.setup"></a>2.setup</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;template&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;&#123; a &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;sayHello&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>&lt;/template&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> &#123;h&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-attr">name</span>: <span class="hljs-string">&quot;HelloWorld&quot;</span>,</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-comment">//    vue2的写法是可以兼容的  data...</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-comment">//    访问顺序，vue2的配置(data、computed、watch...)=&gt;vue3的stepup，但vue3的stepup无法访问vue2的配置</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-comment">// (3)目的是：Vue3统一访问数据规范，不乱套(如果有重名优先setup)</span></span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-comment">// (1)数据、方法全放在sepup里，用于替代created、beforecreated，</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-comment">//    是组合式API，也Vue3的原生写法，代码更清晰</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-comment">// (4)不可在setup前加async，因为它默认只有返回对象或渲染函数才能被模板使用，而不是包裹着promise的对象（后期也可以返回promise对象，只是需要suspense和异步引入组件）</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml"> <span class="hljs-keyword">let</span> a = <span class="hljs-number">1</span>;</span></span><br><span class="language-javascript"><span class="language-xml"> <span class="hljs-keyword">function</span> <span class="hljs-title function_">sayHello</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">   <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;hello&quot;</span>);</span></span><br><span class="language-javascript"><span class="language-xml"> &#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"> <span class="hljs-comment">// 返回对象 ----- 组合式API体现出来了</span></span></span><br><span class="language-javascript"><span class="language-xml"> <span class="hljs-keyword">return</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">   a,</span></span><br><span class="language-javascript"><span class="language-xml">   sayHello</span></span><br><span class="language-javascript"><span class="language-xml"> &#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"> <span class="hljs-comment">// (2)返回渲染函数----针对具体某个标签单独渲染</span></span></span><br><span class="language-javascript"><span class="language-xml"> <span class="hljs-comment">// return ()=&gt;h(&#x27;h1&#x27;,a)</span></span></span><br><span class="language-javascript"><span class="language-xml">&#125;,</span></span><br><span class="language-javascript"><span class="language-xml">&#125;;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="3-ref"><a href="#3-ref" class="headerlink" title="3.ref"></a>3.ref</h3><p><strong>基本类型</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;template&gt;<br>&lt;!-- (<span class="hljs-number">4</span>)在模板中不需要 .<span class="hljs-property">value</span>，因为<span class="hljs-title class_">Vue3</span>默认给你添上了 --&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;&#123; name &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;&#123; age &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;changeInfo&quot;</span>&gt;</span>更改信息<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>&lt;/template&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> &#123;ref&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-attr">name</span>: <span class="hljs-string">&quot;HelloWorld&quot;</span>,</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-attr">props</span>: &#123;</span></span><br><span class="language-javascript"><span class="language-xml"> <span class="hljs-attr">msg</span>: <span class="hljs-title class_">String</span>,</span></span><br><span class="language-javascript"><span class="language-xml">&#125;,</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml"> <span class="hljs-keyword">let</span> name = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&#x27;张三&#x27;</span>); <span class="hljs-comment">// (2)&#x27;张三&#x27;变成了引用对象RefImpl:&#123;...,value,...&#125;</span></span></span><br><span class="language-javascript"><span class="language-xml"> <span class="hljs-keyword">let</span> age = <span class="hljs-title function_">ref</span>(<span class="hljs-number">18</span>);</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"> <span class="hljs-comment">// (1)不用ref并对value修改的话，数据不是响应式的：数据修改了但是没有渲染到模板上(因为是原生写法)</span></span></span><br><span class="language-javascript"><span class="language-xml"> <span class="hljs-comment">// (5)而ref是响应式的，看名字也可理解：引用实现，相当于C++的引用，模板拿的是地址，而这里是地址对应的值</span></span></span><br><span class="language-javascript"><span class="language-xml"> <span class="hljs-keyword">function</span> <span class="hljs-title function_">changeInfo</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">   name.<span class="hljs-property">value</span> = <span class="hljs-string">&#x27;李四&#x27;</span>; <span class="hljs-comment">// (3)在原型对象上有getter和setter可对value进行读写</span></span></span><br><span class="language-javascript"><span class="language-xml">   age.<span class="hljs-property">value</span> = <span class="hljs-number">48</span>;</span></span><br><span class="language-javascript"><span class="language-xml">   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name,age);</span></span><br><span class="language-javascript"><span class="language-xml"> &#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"> <span class="hljs-keyword">return</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">   name,</span></span><br><span class="language-javascript"><span class="language-xml">   age,</span></span><br><span class="language-javascript"><span class="language-xml">   changeInfo</span></span><br><span class="language-javascript"><span class="language-xml"> &#125;</span></span><br><span class="language-javascript"><span class="language-xml">&#125;,</span></span><br><span class="language-javascript"><span class="language-xml">&#125;;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p><strong>引用类型</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;template&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;&#123; job.type &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;&#123; job.salary &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;changeInfo&quot;</span>&gt;</span>更改信息<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>&lt;/template&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> &#123;ref&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-attr">name</span>: <span class="hljs-string">&quot;HelloWorld&quot;</span>,</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml"> <span class="hljs-keyword">let</span> job = <span class="hljs-title function_">ref</span>(&#123;</span></span><br><span class="language-javascript"><span class="language-xml">   <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;前端&#x27;</span>,</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-attr">salary</span>:<span class="hljs-string">&#x27;10K&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml"> &#125;)</span></span><br><span class="language-javascript"><span class="language-xml"> <span class="hljs-keyword">function</span> <span class="hljs-title function_">changeInfo</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">   <span class="hljs-comment">// (1) ref对于对象类型来说，直接转换为proxy对象:proxy&#123;type: &#x27;前端&#x27;,salary:&#x27;10K&#x27;&#125;，因此不需要type再.value了</span></span></span><br><span class="language-javascript"><span class="language-xml">   <span class="hljs-comment">//     而proxy的实现其实reactive来封装的，因此可以说ref对于对象类型其实求助于了reactive     即 value:proxy&#123;&#125; </span></span></span><br><span class="language-javascript"><span class="language-xml">   job.<span class="hljs-property">value</span>.<span class="hljs-property">type</span> = <span class="hljs-string">&#x27;UI设计师&#x27;</span>;</span></span><br><span class="language-javascript"><span class="language-xml">   job.<span class="hljs-property">value</span>.<span class="hljs-property">salary</span> = <span class="hljs-string">&#x27;20K&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml"> &#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"> <span class="hljs-keyword">return</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">   changeInfo,</span></span><br><span class="language-javascript"><span class="language-xml">   job</span></span><br><span class="language-javascript"><span class="language-xml"> &#125;</span></span><br><span class="language-javascript"><span class="language-xml">&#125;,</span></span><br><span class="language-javascript"><span class="language-xml">&#125;;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="4-reactive"><a href="#4-reactive" class="headerlink" title="4.reactive"></a>4.reactive</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js">...<br><span class="hljs-keyword">let</span> job = <span class="hljs-title function_">reactive</span>(&#123;<br>   <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;前端&#x27;</span>,<br>    <span class="hljs-attr">salary</span>:<span class="hljs-string">&#x27;10K&#x27;</span><br> &#125;)<br> <br> <span class="hljs-keyword">function</span> <span class="hljs-title function_">changeInfo</span>(<span class="hljs-params"></span>) &#123;<br>   name.<span class="hljs-property">value</span> = <span class="hljs-string">&#x27;李四&#x27;</span>; <br>   age.<span class="hljs-property">value</span> = <span class="hljs-number">48</span>;<br><br>   <span class="hljs-comment">// (1)reactive直接转化成 proxy&#123;type: &#x27;前端&#x27;,salary:&#x27;10K&#x27;&#125;,这样就可以像正常访问数据并修改后直接相应到模板上</span><br>   job.<span class="hljs-property">type</span> = <span class="hljs-string">&#x27;UI设计师&#x27;</span>;<br>   job.<span class="hljs-property">salary</span> = <span class="hljs-string">&#x27;20K&#x27;</span><br> &#125;<br>...<br></code></pre></td></tr></table></figure><blockquote><p>建议：基本类型使用ref，引用类型用reactive（不用写value）</p></blockquote><h3 id="5-reflect"><a href="#5-reflect" class="headerlink" title="5.reflect"></a>5.reflect</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> person = &#123;<br>    <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;周杰&#x27;</span><br>&#125;<br><span class="hljs-comment">// (1)Reflect也自带definepropt(注意和Object.defineproperty不是一个东西)，但是它可以自动捕获异常(比如对同一属性重复设置值)，而原来的Object.defineproperty需要手写try-catch</span><br><span class="hljs-comment">// (2)通常配合proxy实现数据响应，使Vue3中数据相应使用更方便</span><br><span class="hljs-keyword">let</span> r = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">defineproperty</span>(person,<span class="hljs-string">&#x27;age&#x27;</span>,&#123;<br>      <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>)&#123;<br>          <span class="hljs-keyword">return</span> number <br>      &#125;,<br>      <span class="hljs-title function_">set</span>(<span class="hljs-params">value</span>)&#123;<br>          <span class="hljs-variable language_">this</span>.<span class="hljs-property">number</span> = value <br>      &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="6-setup补充"><a href="#6-setup补充" class="headerlink" title="6.setup补充"></a>6.setup补充</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 父组件</span><br>&lt;template&gt;<br>  &lt;!-- 绑定一个自定义事件hello给子组件，表示需要子组件传值 --&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Demo</span> <span class="hljs-attr">msg</span>=<span class="hljs-string">&quot;你好啊&quot;</span> <span class="hljs-attr">school</span>=<span class="hljs-string">&quot;尚硅谷&quot;</span> @<span class="hljs-attr">hello</span>=<span class="hljs-string">&quot;hello&quot;</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-comment">&lt;!-- 插槽内容得写在子组件内部，这样就表示子组件是需要使用的 --&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:asd</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>插槽内容<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">Demo</span>&gt;</span></span><br>&lt;/template&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Demo</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./components/Demo.vue&quot;</span>;</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;App&quot;</span>,</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">components</span>: &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-title class_">Demo</span>,</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">function</span> <span class="hljs-title function_">hello</span>(<span class="hljs-params">value</span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;-----接收到了子组件的值：&quot;</span>, value);</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">return</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      hello,</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;;</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">&#125;;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><br><span class="hljs-comment">//子组件</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;&#123; person.name &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;&#123; person.age &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;test&quot;</span>&gt;</span>测试一下触发自定义事件<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> &#123; reactive &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;myDemo&quot;</span>,</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">props</span>: [<span class="hljs-string">&quot;msg&quot;</span>, <span class="hljs-string">&quot;school&quot;</span>],</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-comment">// Vue3中不写会有警告</span></span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">emits</span>: [<span class="hljs-string">&quot;hello&quot;</span>],</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-comment">// slots:[&#x27;asd&#x27;],</span></span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-title function_">beforeCreate</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;---beforeCreate---&quot;</span>);</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-comment">// (1) setup执行的比beforeCreate还早(提前准备好响应式数据)</span></span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-comment">//   且setup的this为undefined(因为setup规范好了不使用this，避免像Vue2中this的指向问题)</span></span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-title function_">setup</span>(<span class="hljs-params">props, context</span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// (2) props参数指 父组件传递过来数据并且子组件中用props:[]接受好了，那么此时使用setup内的props就不会有警告(得准备好了)</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">//     为什么需要setup里面的props?因为它已经把props[]接收到的数据转化成立proxy对象，使用可立即响应</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// (3) context上下文相当于以前的vm，可以获取以前vm很多内置属性attr、emit(没有$)</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">//     在vue3有专门的emits属性，和props一样，这样写非常清晰，表示接受了什么自定义事件</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;---setup---&quot;</span>, props, context);</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;---setup---&quot;</span>, props, context.<span class="hljs-property">attrs</span>);</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;---setup---&quot;</span>, props, context.<span class="hljs-property">emit</span>);</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;---setup---&quot;</span>, props, context.<span class="hljs-property">slots</span>);</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">let</span> person = <span class="hljs-title function_">reactive</span>(&#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;张三&quot;</span>,</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;);</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      context.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;我是传递的值&quot;</span>);</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">return</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      person,</span></span><br><span class="language-javascript"><span class="language-xml">      test</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;;</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">&#125;;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p><strong>化繁为简：</strong>主要讲了setup函数的执行时间以及setup两个参数props和context（数据都是从父组件传过来的）</p><h3 id="7-computed"><a href="#7-computed" class="headerlink" title="7.computed"></a>7.computed</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;template&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>一个人的信息<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br>  姓：&lt;input type=<span class="hljs-string">&quot;text&quot;</span> v-model=<span class="hljs-string">&quot;person.firstName&quot;</span> /&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span></span><br>  名：&lt;input type=<span class="hljs-string">&quot;text&quot;</span> v-model=<span class="hljs-string">&quot;person.lastName&quot;</span> /&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span></span><br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>全名：&#123;&#123; person.fullName &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span></span><br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;person.fullName&quot;</span> /&gt;</span></span><br>&lt;/template&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-comment">// 体现出了组合式API的使用</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> &#123; reactive, computed &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;myDemo&quot;</span>,</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">let</span> person = <span class="hljs-title function_">reactive</span>(&#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">firstName</span>: <span class="hljs-string">&quot;张&quot;</span>,</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">lastName</span>: <span class="hljs-string">&quot;三&quot;</span>,</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;);</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// 简写形式，默认调用get-----只读</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// person.fullName = computed(() =&gt; &#123;</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">//   return person.firstName+&#x27;-&#x27;+person.lastName</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// &#125;)</span></span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// 完整形式，可读可写</span></span></span><br><span class="language-javascript"><span class="language-xml">    person.<span class="hljs-property">fullName</span> = <span class="hljs-title function_">computed</span>(&#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-keyword">return</span> person.<span class="hljs-property">firstName</span> + <span class="hljs-string">&quot;-&quot;</span> + person.<span class="hljs-property">lastName</span>;</span></span><br><span class="language-javascript"><span class="language-xml">      &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-title function_">set</span>(<span class="hljs-params">value</span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-keyword">let</span> arr = value.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;-&quot;</span>);</span></span><br><span class="language-javascript"><span class="language-xml">        person.<span class="hljs-property">firstName</span> = arr[<span class="hljs-number">0</span>];</span></span><br><span class="language-javascript"><span class="language-xml">        person.<span class="hljs-property">lastName</span> = arr[<span class="hljs-number">1</span>];</span></span><br><span class="language-javascript"><span class="language-xml">      &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;);</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">return</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      person,</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;;</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">&#125;;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="8-watch"><a href="#8-watch" class="headerlink" title="8.watch"></a>8.watch</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;template&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>当前求和：&#123;&#123; sum &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;add&quot;</span>&gt;</span>点击+1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>当前信息：&#123;&#123; msg &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;msg += &#x27;!&#x27;&quot;</span>&gt;</span>点击增加感叹号<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span></span><br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>姓名：&#123;&#123; person.name &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>年龄：&#123;&#123; person.age &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;person.name += &#x27;~&#x27;&quot;</span>&gt;</span>修改姓名<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span></span><br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;person.age++&quot;</span>&gt;</span>增长年龄<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span></span><br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>薪资：&#123;&#123; person.job.j1.salary &#125;&#125;K<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span></span><br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;person.job.j1.salary++&quot;</span>&gt;</span>涨薪<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>&lt;/template&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-comment">// 体现出了组合式API的使用</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> &#123; ref, watch, reactive &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;myDemo&quot;</span>,</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">let</span> sum = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>);</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">let</span> msg = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&quot;你好啊&quot;</span>);</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">let</span> person = <span class="hljs-title function_">reactive</span>(&#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;张三&quot;</span>,</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">job</span>: &#123;</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-attr">j1</span>: &#123;</span></span><br><span class="language-javascript"><span class="language-xml">          <span class="hljs-attr">salary</span>: <span class="hljs-number">10</span>,</span></span><br><span class="language-javascript"><span class="language-xml">        &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">      &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;);</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      sum.<span class="hljs-property">value</span>++;</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// 情况一：监视ref定义的一个响应式数据</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// watch(sum, (newValue, oldValue) =&gt; &#123;</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">//   console.log(&quot;sum数据变化了：&quot;, newValue, oldValue);</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// &#125;);</span></span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// 情况二：监视ref多个属性，参数位置：监视对象,数据回调函数,配置项</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// watch(</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">//   [sum, msg],</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">//   (newValue, oldValue) =&gt; &#123;</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">//     console.log(&quot;sum数据变化了：&quot;, newValue[0], oldValue[0]);</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">//     console.log(&quot;msg数据变化了：&quot;, newValue[1], oldValue[1]);</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// );</span></span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">/**</span></span></span><br><span class="hljs-comment"><span class="language-javascript"><span class="language-xml">     * 情况三：监视reactive定义的对象全部属性(两个bug)</span></span></span><br><span class="hljs-comment"><span class="language-javascript"><span class="language-xml">     * 1.注意：变化后新旧值一样，只能把所有属性分别用ref定义来解决</span></span></span><br><span class="hljs-comment"><span class="language-javascript"><span class="language-xml">     * 2.注意：强制开启了深度监听(deep:false无效)</span></span></span><br><span class="hljs-comment"><span class="language-javascript"><span class="language-xml">     * */</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// watch(person, (newValue, oldValue) =&gt; &#123;</span></span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">//   console.log(&quot;person数据变化了：&quot;, newValue, oldValue);</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// &#125;, &#123; deep: false &#125;);</span></span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// 情况四：监视reactive定义的一个响应式数据的某个属性</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">//        属性必须得写成箭头函数，否则无法监视到</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// watch(</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">//   ()=&gt;person.age,</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">//   (newValue, oldValue) =&gt; &#123;</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">//     console.log(&quot;person数据变化了：&quot;, newValue, oldValue);</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">//   &#125;,</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// );</span></span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// 情况五：监视reactive定义的一个响应式数据的某些属性</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">//   watch(</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">//   [()=&gt;person.name, ()=&gt;person.age],</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">//   (newValue, oldValue) =&gt; &#123;</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">//     console.log(&quot;sum数据变化了：&quot;, newValue[0], oldValue[0]);</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">//     console.log(&quot;msg数据变化了：&quot;, newValue[1], oldValue[1]);</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">//   &#125;,</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// );</span></span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// 特殊情况</span></span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-title function_">watch</span>(</span></span><br><span class="language-javascript"><span class="language-xml">       <span class="hljs-function">()=&gt;</span>person.<span class="hljs-property">job</span>,</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-function">(<span class="hljs-params">newValue, oldValue</span>) =&gt;</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;person数据变化了：&quot;</span>, newValue, oldValue);</span></span><br><span class="language-javascript"><span class="language-xml">          &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">      &#123;<span class="hljs-attr">deep</span>:<span class="hljs-literal">true</span>&#125;<span class="hljs-comment">//此处由于监视的是reactive中的某个对象属性(因为这时已经是至少2层了)，deep配置有效-------和情况三区分开来</span></span></span><br><span class="language-javascript"><span class="language-xml">    );</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">return</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      sum,</span></span><br><span class="language-javascript"><span class="language-xml">      add,</span></span><br><span class="language-javascript"><span class="language-xml">      msg,</span></span><br><span class="language-javascript"><span class="language-xml">      person,</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;;</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">&#125;;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p><strong>化繁为简：</strong>重点关注对reactive监听 的坑（情况三、四、五、特殊），正常开发其实一般只关注newValue，实在需要使用可以单独用ref拎出去</p><h3 id="9-watch补充"><a href="#9-watch补充" class="headerlink" title="9.watch补充"></a>9.watch补充</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script&gt;<br><span class="hljs-comment">// 体现出了组合式API的使用</span><br><span class="hljs-keyword">import</span> &#123; ref, watch &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;myDemo&quot;</span>,<br>  <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">let</span> sum = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">let</span> msg = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&quot;你好啊&quot;</span>);<br>    <span class="hljs-keyword">let</span> person = <span class="hljs-title function_">ref</span>(&#123;<br>      <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;张三&quot;</span>,<br>      <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,<br>      <span class="hljs-attr">job</span>: &#123;<br>        <span class="hljs-attr">j1</span>: &#123;<br>          <span class="hljs-attr">salary</span>: <span class="hljs-number">10</span>,<br>        &#125;,<br>      &#125;,<br>    &#125;);<br><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params"></span>) &#123;<br>      sum.<span class="hljs-property">value</span>++;<br>    &#125;<br><br>    <span class="hljs-comment">// (1)由于ref的.value值是定的，没有必要监视，因此会出现警报无法监视</span><br>    <span class="hljs-comment">//    而直接监视ref对象(其value可能会变)便可以监视了（有点类似字面量和变量的区别）</span><br>    <span class="hljs-comment">// watch(sum.value, (newValue, oldValue) =&gt; &#123;</span><br>    <span class="hljs-comment">//    console.log(&#x27;sum被监视了：&#x27;,newValue,oldValue);</span><br>    <span class="hljs-comment">// &#125;)</span><br><br>    <span class="hljs-comment">// (2)无法监视到，ref的person是个proxy对象，而只要对象地址不变，就认为没有变化</span><br>    <span class="hljs-comment">// 解决方法：1.加deep:true(不仅监视对象地址，还监视里面的属性)</span><br>    <span class="hljs-comment">//          2.加.value，这时监视的是reactive的proxy对象，强制deep:true</span><br>    <span class="hljs-title function_">watch</span>(person.<span class="hljs-property">value</span>,<span class="hljs-function">(<span class="hljs-params">newValue, oldValue</span>) =&gt;</span> &#123;<br>       <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;person被监视了：&#x27;</span>,newValue,oldValue);<br>    &#125;)<br><br>    <span class="hljs-keyword">return</span> &#123;<br>      sum,<br>      add,<br>      msg,<br>      person,<br>    &#125;;<br>  &#125;,<br>&#125;;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p><strong>化繁为简</strong>：主要针对ref的基本数据类型和对象类型的.value的情况进行了补充</p><h3 id="10-watchEffect"><a href="#10-watchEffect" class="headerlink" title="10.watchEffect"></a>10.watchEffect</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs js">    <span class="hljs-comment">// 不指明监视对象，在回调里用到什么数据就监视什么数据</span><br>    <span class="hljs-comment">// ==&gt;(1)好处是：不用针对不同的监视对象专门写个watch了</span><br>    <span class="hljs-comment">//       坏处是：如果监视的对象和处理的逻辑没有任何关系，则不会触发监听</span><br>    <span class="hljs-comment">// ==&gt;(2)为什么叫Effect?可能就是指 在回调里面哪个受影响了(使用到了)就监视</span><br>    <span class="hljs-comment">// (3)横向对比：有点类似computed，都会以来某些数据来做出相应的反应</span><br>    <span class="hljs-comment">//          只是computed重视的是结果，watchEffect重视过程 </span><br><span class="hljs-keyword">import</span> &#123; reactive, watchEffect &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">setup</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> state = <span class="hljs-title function_">reactive</span>(&#123;<br>    <span class="hljs-attr">count</span>: <span class="hljs-number">0</span>,<br>  &#125;);<br><br>  <span class="hljs-comment">// 在 watchEffect 中依赖到了 state.count</span><br>  <span class="hljs-title function_">watchEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;count 发生变化：&#x27;</span>, state.<span class="hljs-property">count</span>);<br>  &#125;);<br><br>  <span class="hljs-comment">// 在 setup 函数内部修改 state.count 的值</span><br>  state.<span class="hljs-property">count</span> = <span class="hljs-number">1</span>; <span class="hljs-comment">// 触发 watchEffect 回调函数</span><br><br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">increment</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    state.<span class="hljs-property">count</span>++; <span class="hljs-comment">// 不会触发 watchEffect 回调函数</span><br>  &#125;;<br><br>  <span class="hljs-keyword">return</span> &#123;<br>    state,<br>    increment,<br>  &#125;;<br>&#125;;<br></code></pre></td></tr></table></figure><p>在上面的例子中，我们在 <code>watchEffect</code> 的回调函数中依赖了 <code>state.count</code>，因此当 <code>state.count</code> 发生变化时，会触发 <code>watchEffect</code> 的回调函数。</p><p>然而，在 <code>increment</code> 函数中虽然修改了 <code>state.count</code> 的值，但由于 <code>watchEffect</code> 并没有依赖到 <code>increment</code> 函数，所以不会触发 <code>watchEffect</code> 的回调函数。</p><p>因此，只有在 <code>watchEffect</code> 函数内部依赖的响应式数据发生变化时，才会触发 <code>watchEffect</code> 的回调函数。其他的响应式数据变化不会对 <code>watchEffect</code> 产生影响。</p><h3 id="11-生命周期函数"><a href="#11-生命周期函数" class="headerlink" title="11.生命周期函数"></a>11.生命周期函数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// (1)setup相当于beforeCreated、created</span><br><span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">let</span> sum = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>);<br><br>  <span class="hljs-comment">// (2)在组合式API中得生命周期函数都加了 On</span><br>  <span class="hljs-title function_">onBeforeMount</span>(<span class="hljs-function">() =&gt;</span> &#123; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;---onBeforeMount---&#x27;</span>);&#125;);<br><br>  <span class="hljs-title function_">onMounted</span>(<span class="hljs-function">() =&gt;</span> &#123; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;---onMounted---&#x27;</span>);&#125;);<br><br>  <span class="hljs-title function_">onBeforeUpdate</span>(<span class="hljs-function">() =&gt;</span> &#123; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;---onBeforeUpdate---&#x27;</span>);&#125;);<br><br>  <span class="hljs-title function_">onUpdated</span>(<span class="hljs-function">() =&gt;</span> &#123; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;---onUpdated---&#x27;</span>);&#125;);<br>  <br>  <span class="hljs-comment">// (3)destoryed改为了 unmount，有种对应的感觉</span><br>  <span class="hljs-title function_">onBeforeUnmount</span>(<span class="hljs-function">() =&gt;</span> &#123; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;---onBeforeUnmount---&#x27;</span>);&#125;);<br><br>  <span class="hljs-title function_">onUnmounted</span>(<span class="hljs-function">() =&gt;</span> &#123; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;---onUnmounted---&#x27;</span>);&#125;);<br><br>  <span class="hljs-keyword">return</span> &#123;<br>    sum,<br>  &#125;;<br></code></pre></td></tr></table></figure><h3 id="12-自定义hooks"><a href="#12-自定义hooks" class="headerlink" title="12.自定义hooks"></a>12.自定义hooks</h3><ul><li>定义：是对组合式API的封装，写在setup中代码更加清晰</li><li>类比：相当于Vue2中的mixin</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// hooks/usePoint.js</span><br><span class="hljs-keyword">import</span> &#123; onBeforeUnmount, onMounted,reactive &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">let</span> point = <span class="hljs-title function_">reactive</span>(&#123;<br>    <span class="hljs-attr">x</span>: <span class="hljs-number">0</span>,<br>    <span class="hljs-attr">y</span>:<span class="hljs-number">0</span><br>  &#125;)<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">savePoint</span>(<span class="hljs-params">event</span>) &#123;<br>    point.<span class="hljs-property">x</span> = event.<span class="hljs-property">pageX</span>;<br>    point.<span class="hljs-property">y</span> = event.<span class="hljs-property">pageY</span>;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(point.<span class="hljs-property">x</span>,point.<span class="hljs-property">x</span>);<br>  &#125;<br>  <span class="hljs-title function_">onMounted</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, savePoint)<br>  &#125;);<br>  <span class="hljs-title function_">onBeforeUnmount</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-comment">// 一个点击事件可能有多个回调，因此要指明移除哪个回调</span><br>    <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, savePoint)<br>  &#125;);<br>  <span class="hljs-keyword">return</span> point;<br>&#125;<br><br><span class="hljs-comment">// 使用该逻辑的组件</span><br>&lt;template&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>鼠标坐标X:&#123;&#123; point.x &#125;&#125;,&#123;&#123; point.y &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br>&lt;/template&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> usePoint <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../hooks/usePoint&quot;</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;myDemo&quot;</span>,</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">let</span> point = <span class="hljs-title function_">usePoint</span>()</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">return</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      point</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;;</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">&#125;;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="13-toRef-toRefs"><a href="#13-toRef-toRefs" class="headerlink" title="13.toRef/toRefs"></a>13.toRef/toRefs</h3><ul><li>使用场景：想单独对某个对象的某些属性进行响应式更新，但是不想写多个对象.属性</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;template&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;&#123; person &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>姓名：&#123;&#123; name &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>年龄：&#123;&#123; age &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>薪资：&#123;&#123; salary &#125;&#125;K<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;name += &#x27;~&#x27;&quot;</span>&gt;</span>修改姓名<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span></span><br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;age++&quot;</span>&gt;</span>增长年龄<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span></span><br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;salary++&quot;</span>&gt;</span>涨薪<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>&lt;/template&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-comment">// 体现出了组合式API的使用</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> &#123; reactive, toRef,toRefs &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;myDemo&quot;</span>,</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">let</span> person = <span class="hljs-title function_">reactive</span>(&#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;张三&quot;</span>,</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">job</span>: &#123;</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-attr">j1</span>: &#123;</span></span><br><span class="language-javascript"><span class="language-xml">          <span class="hljs-attr">salary</span>: <span class="hljs-number">10</span>,</span></span><br><span class="language-javascript"><span class="language-xml">        &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">      &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;);</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// (3)toRef可以拿到某个对象的引用来响应式更新对应属性</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">return</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      person,</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-comment">// 错误使用(1)这种方式修改了，不会响应式更新，因为拿到的只是个 数值</span></span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-comment">// name: person.name,</span></span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-comment">// 错误使用(2)这种方式，仅仅是将person.name初始值复制了一份并进行响应式更新，源person内的name没有改变</span></span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-comment">// name: ref(person.name),</span></span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-comment">// name: toRef(person, &quot;name&quot;),</span></span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-comment">// age: toRef(person, &quot;age&quot;),</span></span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-comment">// salary: toRef(person.job.j1, &quot;salary&quot;),</span></span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-comment">// (4) 可以让某对象所有属性都拿到引用来响应式更新对应属性，通常和...一起使用(只能展开一层)----------要用的属性多且只有一层建议使用toRefs，否则toRef</span></span></span><br><span class="language-javascript"><span class="language-xml">      ...<span class="hljs-title function_">toRefs</span>(person)</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;;</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">&#125;;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="14-shallowReactive和shallowRef"><a href="#14-shallowReactive和shallowRef" class="headerlink" title="14.shallowReactive和shallowRef"></a>14.shallowReactive和shallowRef</h3><p>shallowReactive：只针对对象数据第一层进行响应式</p><p>shallowRef：可以对基本数据类型进行相应，但是对于对象数据不响应（没有求助reactive用proxy实现）</p><p>使用场景：<strong>针对对象数据类型，可以提高性能</strong></p><ul><li>如果某个对象层次很深，但是明确知道只有第一层会用到响应式——–shallowReactive</li><li>如果某个对象只可能在将来被整体替换，并且它里面的属性不会被修改——–shallowRef</li></ul><p>​     （shallowReactive只是只针对第一层，而shallowRef都没有进到对象里面，只考虑重新赋值后的属性初始值）</p><h3 id="15-readOnly和shallowReadonly"><a href="#15-readOnly和shallowReadonly" class="headerlink" title="15.readOnly和shallowReadonly"></a>15.readOnly和shallowReadonly</h3><p>把数据变成只读的（ref、reactive），shallowReadonly可以针对对象类型只在第一层限制只读</p><p>（readOnly对于普通对象还可以转化为proxy对象，谁叫这是vue3的api）</p><p>使用场景：某数据在组件A，传递给组件B时，要求组件B只能使用不能修改</p><h3 id="16-toRaw和markRaw"><a href="#16-toRaw和markRaw" class="headerlink" title="16.toRaw和markRaw"></a>16.toRaw和markRaw</h3><p>toRaw：可以将reactive对象———&gt;原对象</p><p>场景：临时不需要响应式——— 用的非常少</p><p>markRaw：永久标记成非响应式的</p><p>场景：第三方库不需要响应式 或者 某个某个对象层数太多，非响应式可以提高性能</p><h3 id="17-customRef"><a href="#17-customRef" class="headerlink" title="17.customRef"></a>17.customRef</h3><ul><li>作用：自定义逻辑的ref</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 通过自定义ref实现 在input框输入值，通过指定delay时间之后再显示到h1</span><br>&lt;template&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;keyword&quot;</span> /&gt;</span></span><br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;&#123; keyword &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br>&lt;/template&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> &#123; customRef &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;App&quot;</span>,</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">function</span> <span class="hljs-title function_">myRef</span>(<span class="hljs-params">value, delay</span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-keyword">return</span> <span class="hljs-title function_">customRef</span>(<span class="hljs-function">(<span class="hljs-params">track, trigger</span>) =&gt;</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-keyword">let</span> timer;</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-keyword">return</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">          <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-title function_">track</span>();</span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-keyword">return</span> value;</span></span><br><span class="language-javascript"><span class="language-xml">          &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">          <span class="hljs-title function_">set</span>(<span class="hljs-params">newValue</span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-comment">// 防止设置太多定时器，因此要每次清理定时器，然后只取最后一次以防抖</span></span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-built_in">clearTimeout</span>(timer);</span></span><br><span class="language-javascript"><span class="language-xml">            timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">              value = newValue;</span></span><br><span class="language-javascript"><span class="language-xml">              <span class="hljs-title function_">trigger</span>();</span></span><br><span class="language-javascript"><span class="language-xml">            &#125;, delay);</span></span><br><span class="language-javascript"><span class="language-xml">          &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">        &#125;;</span></span><br><span class="language-javascript"><span class="language-xml">      &#125;);</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">let</span> keyword = <span class="hljs-title function_">myRef</span>(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-number">500</span>);</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">return</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      keyword,</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;;</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">&#125;;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="18-provide和inject"><a href="#18-provide和inject" class="headerlink" title="18.provide和inject"></a>18.provide和inject</h3><ul><li>作用：用于祖孙之间通信（Vue3废除了全局事件总线）</li></ul><p>​                  (父子组件也能通信，但是父子组件最好还是props)</p><ul><li> 用法：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 爷组件</span><br><span class="hljs-title function_">provide</span>(<span class="hljs-string">&#x27;名字&#x27;</span>，要传递的数据)<br><br><span class="hljs-comment">// 孙组件</span><br><span class="hljs-keyword">let</span> name =  <span class="hljs-title function_">inject</span>(<span class="hljs-string">&#x27;名字&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="19-响应式数据的判断"><a href="#19-响应式数据的判断" class="headerlink" title="19.响应式数据的判断"></a>19.响应式数据的判断</h3><p>isRef、isReactive、isReadOnly、isProxy</p><p>注意：isProxy是判断是否由reactive或者readOnly创建的代理</p><h3 id="20-compositionApi的优势"><a href="#20-compositionApi的优势" class="headerlink" title="20.compositionApi的优势"></a>20.compositionApi的优势</h3><p><img src="/2023/08/30/Vue3%E7%9B%B8%E5%AF%B9%E4%BA%8EVue2%E7%9A%84%E4%B8%8D%E5%90%8C%E7%94%A8%E6%B3%95/vue2.gif" alt="vue2"></p><p><img src="/2023/08/30/Vue3%E7%9B%B8%E5%AF%B9%E4%BA%8EVue2%E7%9A%84%E4%B8%8D%E5%90%8C%E7%94%A8%E6%B3%95/vue3.gif" alt="vue3"></p><p>总结：vue2中一个功能被分散在各个配置项中，功能一多就不易维护，但是vue3一个功能可集中写在一起的</p><h3 id="21-fragmant组件"><a href="#21-fragmant组件" class="headerlink" title="21.fragmant组件"></a>21.fragmant组件</h3><p>由原来Vue2中必须得在template里面写一个跟标签，到Vue3中不用写根标签，但是默认被包在了一个Fragment元素中，<strong>即用内置的Fragment替换手写根标签</strong></p><h3 id="22-teleport组件"><a href="#22-teleport组件" class="headerlink" title="22.teleport组件"></a>22.teleport组件</h3><ul><li>作用：可将html标签移动到指定位置</li><li>案例：在多层嵌套标签内部点击出现基于全屏居中的弹框</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 祖组件</span><br>&lt;template&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;App&quot;</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>我是祖组件<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">Child</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Child</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&lt;/template&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Child</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./components/Child&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;App&#x27;</span>,</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">components</span>:&#123;</span></span><br><span class="language-javascript"><span class="language-xml">     <span class="hljs-title class_">Child</span></span></span><br><span class="language-javascript"><span class="language-xml">  &#125;</span></span><br><span class="language-javascript"><span class="language-xml">&#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;css&quot;</span> <span class="hljs-attr">scoped</span>&gt;</span><span class="language-css"></span></span><br><span class="language-css"><span class="language-xml">  <span class="hljs-selector-class">.App</span>&#123;</span></span><br><span class="language-css"><span class="language-xml">    <span class="hljs-attribute">background-color</span>: gray;</span></span><br><span class="language-css"><span class="language-xml">    <span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span>;</span></span><br><span class="language-css"><span class="language-xml">  &#125;</span></span><br><span class="language-css"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></span><br><br><span class="hljs-comment">// 父组件</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;Child&quot;</span>&gt;</span></span><br><span class="language-xml">       <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>我是父组件<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>    </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Son</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Son</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br>  <br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-keyword">import</span> <span class="hljs-title class_">Son</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./Son&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;myChild&#x27;</span>,</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-attr">components</span>:&#123;</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-title class_">Son</span></span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;</span></span><br><span class="language-javascript"><span class="language-xml">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br>  <br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;css&quot;</span> <span class="hljs-attr">scoped</span>&gt;</span><span class="language-css"></span></span><br><span class="language-css"><span class="language-xml">    <span class="hljs-selector-class">.Child</span>&#123;</span></span><br><span class="language-css"><span class="language-xml">      <span class="hljs-attribute">background-color</span>: skyblue;</span></span><br><span class="language-css"><span class="language-xml">      <span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span>;</span></span><br><span class="language-css"><span class="language-xml">    &#125;</span></span><br><span class="language-css"><span class="language-xml">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></span><br><br><span class="hljs-comment">// 孙组件</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;Son&quot;</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>我是孙组件<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span> </span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;isShow = true&quot;</span>&gt;</span>点我打开<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">teleport</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&#x27;body&#x27;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;mask&quot;</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;isShow&quot;</span>&gt;</span></span><br><span class="language-xml">         <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;dialog&quot;</span>&gt;</span></span><br><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>我是内容<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>我是内容<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>我是内容<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;isShow = false&quot;</span>&gt;</span>点我关闭<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">         <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">teleport</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br>  <br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> &#123;ref&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;mySon&quot;</span>,</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">let</span> isShow = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">false</span>);</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">return</span>&#123;</span></span><br><span class="language-javascript"><span class="language-xml">        isShow</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;</span></span><br><span class="language-javascript"><span class="language-xml">&#125;;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br>  <br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;css&quot;</span> <span class="hljs-attr">scoped</span>&gt;</span><span class="language-css"></span></span><br><span class="language-css"><span class="language-xml"><span class="hljs-selector-class">.dialog</span>&#123;</span></span><br><span class="language-css"><span class="language-xml">   <span class="hljs-attribute">height</span>: <span class="hljs-number">300px</span>;</span></span><br><span class="language-css"><span class="language-xml">   <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;</span></span><br><span class="language-css"><span class="language-xml">   <span class="hljs-attribute">background-color</span>: green;</span></span><br><span class="language-css"><span class="language-xml">   <span class="hljs-attribute">text-align</span>: center;</span></span><br><span class="language-css"><span class="language-xml">   <span class="hljs-attribute">position</span>: absolute;</span></span><br><span class="language-css"><span class="language-xml">   <span class="hljs-attribute">top</span>: <span class="hljs-number">50%</span>;</span></span><br><span class="language-css"><span class="language-xml">   <span class="hljs-attribute">left</span>: <span class="hljs-number">50%</span>;</span></span><br><span class="language-css"><span class="language-xml">   <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate</span>(-<span class="hljs-number">50%</span>,-<span class="hljs-number">50%</span>);</span></span><br><span class="language-css"><span class="language-xml">&#125;</span></span><br><span class="language-css"><span class="language-xml"><span class="hljs-selector-class">.mask</span>&#123;</span></span><br><span class="language-css"><span class="language-xml">  <span class="hljs-attribute">position</span>: absolute;</span></span><br><span class="language-css"><span class="language-xml">  <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;</span></span><br><span class="language-css"><span class="language-xml">  <span class="hljs-attribute">bottom</span>: <span class="hljs-number">0</span>;</span></span><br><span class="language-css"><span class="language-xml">  <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;</span></span><br><span class="language-css"><span class="language-xml">  <span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;</span></span><br><span class="language-css"><span class="language-xml">  <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0.5</span>);</span></span><br><span class="language-css"><span class="language-xml">&#125;</span></span><br><span class="language-css"><span class="language-xml"><span class="hljs-selector-class">.Son</span> &#123;</span></span><br><span class="language-css"><span class="language-xml">  <span class="hljs-attribute">background-color</span>: orange;</span></span><br><span class="language-css"><span class="language-xml">  <span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span>;</span></span><br><span class="language-css"><span class="language-xml">&#125;</span></span><br><span class="language-css"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>![效果](C:/Users/K22070055/Desktop/新建文件夹 (3)/blog/source/_posts/弹框.png)</p><h3 id="23-Suspense组件"><a href="#23-Suspense组件" class="headerlink" title="23.Suspense组件"></a>23.Suspense组件</h3><ul><li>作用：让异步组件渲染一些额外内容，用户体验会更好。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 父组件</span><br>&lt;template&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;App&quot;</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>我是父组件<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">Suspense</span>&gt;</span></span><br><span class="language-xml">       <span class="hljs-comment">&lt;!-- 正常显示 --&gt;</span></span><br><span class="language-xml">       <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:default</span>&gt;</span></span><br><span class="language-xml">         <span class="hljs-tag">&lt;<span class="hljs-name">Child</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Child</span>&gt;</span></span><br><span class="language-xml">       <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">       <span class="hljs-comment">&lt;!-- 网速慢或者加个定时器了就显示加载中 --&gt;</span></span><br><span class="language-xml">       <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:fallback</span>&gt;</span></span><br><span class="language-xml">         <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>加载中...<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="language-xml">       <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">Suspense</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&lt;/template&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> &#123; defineAsyncComponent &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-comment">// import Child from &#x27;./components/Child&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">const</span> <span class="hljs-title class_">Child</span> = <span class="hljs-title function_">defineAsyncComponent</span>(<span class="hljs-function">()=&gt;</span><span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./components/Child.vue&#x27;</span>))</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;App&#x27;</span>,</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">components</span>:&#123;</span></span><br><span class="language-javascript"><span class="language-xml">     <span class="hljs-title class_">Child</span></span></span><br><span class="language-javascript"><span class="language-xml">  &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">&#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;css&quot;</span> <span class="hljs-attr">scoped</span>&gt;</span><span class="language-css"></span></span><br><span class="language-css"><span class="language-xml">  <span class="hljs-selector-class">.App</span>&#123;</span></span><br><span class="language-css"><span class="language-xml">    <span class="hljs-attribute">background-color</span>: gray;</span></span><br><span class="language-css"><span class="language-xml">    <span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span>;</span></span><br><span class="language-css"><span class="language-xml">  &#125;</span></span><br><span class="language-css"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></span><br><br><span class="hljs-comment">// 子组件</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;Child&quot;</span>&gt;</span></span><br><span class="language-xml">       <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>我是子组件<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>  </span><br><span class="language-xml">       &#123;&#123; sum &#125;&#125;  </span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br>  <br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-keyword">import</span> &#123;ref&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;myChild&#x27;</span>,</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">async</span> <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">     <span class="hljs-keyword">let</span> sum = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>);</span></span><br><span class="language-javascript"><span class="language-xml">     <span class="hljs-keyword">let</span> p =  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>)=&gt;</span>&#123;</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;</span></span><br><span class="language-javascript"><span class="language-xml">          <span class="hljs-title function_">resolve</span>(&#123;sum&#125;)</span></span><br><span class="language-javascript"><span class="language-xml">        &#125;,<span class="hljs-number">3000</span>);<span class="hljs-comment">// 这样 加载中... 就等了3s才出现</span></span></span><br><span class="language-javascript"><span class="language-xml">     &#125;)</span></span><br><span class="language-javascript"><span class="language-xml">     <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> p;</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;</span></span><br><span class="language-javascript"><span class="language-xml">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br>  <br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;css&quot;</span> <span class="hljs-attr">scoped</span>&gt;</span><span class="language-css"></span></span><br><span class="language-css"><span class="language-xml">    <span class="hljs-selector-class">.Child</span>&#123;</span></span><br><span class="language-css"><span class="language-xml">      <span class="hljs-attribute">background-color</span>: skyblue;</span></span><br><span class="language-css"><span class="language-xml">      <span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span>;</span></span><br><span class="language-css"><span class="language-xml">    &#125;</span></span><br><span class="language-css"><span class="language-xml">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="24-其他"><a href="#24-其他" class="headerlink" title="24.其他"></a>24.其他</h3><h4 id="1-全局API的转移"><a href="#1-全局API的转移" class="headerlink" title="1.全局API的转移"></a>1.全局API的转移</h4><ul><li>Vue 2.x 有许多全局 API 和配置。<ul><li>例如：注册全局组件、注册全局指令等。</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript">javascript复制代码<span class="hljs-comment">//注册全局组件</span><br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">component</span>(<span class="hljs-string">&#x27;MyButton&#x27;</span>, &#123;<br>  <span class="hljs-attr">data</span>: <span class="hljs-function">() =&gt;</span> (&#123;<br>    <span class="hljs-attr">count</span>: <span class="hljs-number">0</span><br>  &#125;),<br>  <span class="hljs-attr">template</span>: <span class="hljs-string">&#x27;&lt;button @click=&quot;count++&quot;&gt;Clicked &#123;&#123; count &#125;&#125; times.&lt;/button&gt;&#x27;</span><br>&#125;)<br><br><span class="hljs-comment">//注册全局指令</span><br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">directive</span>(<span class="hljs-string">&#x27;focus&#x27;</span>, &#123;<br>  <span class="hljs-attr">inserted</span>: <span class="hljs-function"><span class="hljs-params">el</span> =&gt;</span> el.<span class="hljs-title function_">focus</span>()<br>&#125;<br></code></pre></td></tr></table></figure><p>Vue3.0中对这些API做出了调整：</p><ul><li><p>将全局的API，即：<code>Vue.xxx</code>调整到应用实例（<code>app</code>）上</p><table><thead><tr><th>2.x 全局 API（<code>Vue</code>）</th><th>3.x 实例 API (<code>app</code>)</th></tr></thead><tbody><tr><td>Vue.config.xxxx</td><td>app.config.xxxx</td></tr><tr><td>Vue.config.productionTip</td><td><strong>移除</strong></td></tr><tr><td>Vue.component</td><td>app.component</td></tr><tr><td>Vue.directive</td><td>app.directive</td></tr><tr><td>Vue.mixin</td><td>app.mixin</td></tr><tr><td>Vue.use</td><td>app.use</td></tr><tr><td>Vue.prototype</td><td>app.config.globalProperties</td></tr></tbody></table></li></ul><h4 id="2-其他改变"><a href="#2-其他改变" class="headerlink" title="2.其他改变"></a>2.其他改变</h4><h5 id="①-data选项应始终被声明为一个函数（避免对象形式的引用关系互相影响）"><a href="#①-data选项应始终被声明为一个函数（避免对象形式的引用关系互相影响）" class="headerlink" title="① data选项应始终被声明为一个函数（避免对象形式的引用关系互相影响）"></a>① <code>data</code>选项应始终被声明为一个函数（避免对象形式的引用关系互相影响）</h5><h5 id="②-过渡类名的更改"><a href="#②-过渡类名的更改" class="headerlink" title="② 过渡类名的更改"></a>② 过渡类名的更改</h5><p>Vue2.x写法</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css">css复制代码<span class="hljs-selector-class">.v-enter</span>,<br><span class="hljs-selector-class">.v-leave-to</span> &#123;<br>  <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-selector-class">.v-leave</span>,<br><span class="hljs-selector-class">.v-enter-to</span> &#123;<br>  <span class="hljs-attribute">opacity</span>: <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>Vue3.x写法</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs css">css复制代码<span class="hljs-selector-class">.v-enter-from</span>,--------------更易理解<br><span class="hljs-selector-class">.v-leave-to</span> &#123;<br>  <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-selector-class">.v-leave-from</span>,<br><span class="hljs-selector-class">.v-enter-to</span> &#123;<br>  <span class="hljs-attribute">opacity</span>: <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="③-移除keyCode作为-v-on-的修饰符，同时也不再支持config-keyCodes（因为兼容性差）"><a href="#③-移除keyCode作为-v-on-的修饰符，同时也不再支持config-keyCodes（因为兼容性差）" class="headerlink" title="③ 移除keyCode作为 v-on 的修饰符，同时也不再支持config.keyCodes（因为兼容性差）"></a>③ 移除<code>keyCode</code>作为 <code>v-on</code> 的修饰符，同时也不再支持<code>config.keyCodes</code>（因为兼容性差）</h5><h5 id="④-移除v-on-native修饰符"><a href="#④-移除v-on-native修饰符" class="headerlink" title="④ 移除v-on.native修饰符"></a>④ 移除<code>v-on.native</code>修饰符</h5><ul><li>父组件中绑定事件</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">javascript复制代码&lt;my-component<br>  v-<span class="hljs-attr">on</span>:close=<span class="hljs-string">&quot;handleComponentEvent&quot;</span><br>  v-<span class="hljs-attr">on</span>:click=<span class="hljs-string">&quot;handleNativeClickEvent&quot;</span><br>/&gt;<br></code></pre></td></tr></table></figure><p>子组件中声明自定义事件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">javascript复制代码&lt;script&gt;<br>  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>    <span class="hljs-attr">emits</span>: [<span class="hljs-string">&#x27;close&#x27;</span>]-------------通过emit来显式声明哪个是自定义事件，如果不写原生有的话就认为是原生的(比如click)<br>  &#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h5 id="⑤-移除过滤器（filter）"><a href="#⑤-移除过滤器（filter）" class="headerlink" title="⑤ 移除过滤器（filter）"></a>⑤ 移除过滤器（filter）</h5><blockquote><p>过滤器虽然这看起来很方便，但它需要一个自定义语法，打破大括号内表达式是 “只是 JavaScript” 的假设，这不仅有学习成本，而且有实现成本！建议用方法调用或计算属性去替换过滤器。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>前端框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>flex布局影响滚动条的显示</title>
    <link href="/2023/08/29/flex%E5%B8%83%E5%B1%80%E5%BD%B1%E5%93%8D%E6%BB%9A%E5%8A%A8%E6%9D%A1%E7%9A%84%E6%98%BE%E7%A4%BA/"/>
    <url>/2023/08/29/flex%E5%B8%83%E5%B1%80%E5%BD%B1%E5%93%8D%E6%BB%9A%E5%8A%A8%E6%9D%A1%E7%9A%84%E6%98%BE%E7%A4%BA/</url>
    
    <content type="html"><![CDATA[<p><strong>前言</strong></p><p>在设置子标签的滚动条时，发现父元素设置了固定高度、overflow:auto了，并且子标签高度已经大于这个高度，但是滚动条就是不显示。</p><p><strong>发现问题</strong></p><p>在调试时发现把flex布局去掉后，滚动条显示了</p><p><strong>原因</strong></p><p>flex布局下的子元素自带弹性伸缩属性，即 即使父元素设置了固定高度，但是子标签始终会按照flex对应的排列方式排列，即使元素非常多，也会缩小自己以排列在父元素内部。这样就不会有溢出的空间并触发滚动条了，比如：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs CSS">just-<span class="hljs-attribute">content</span>:space-between<br></code></pre></td></tr></table></figure><p>这个属性，最两端的元素肯定是贴在父元素边上的，绝不会溢出来一说，中间的元素就全缩在一起。</p><p><img src="/2023/08/29/flex%E5%B8%83%E5%B1%80%E5%BD%B1%E5%93%8D%E6%BB%9A%E5%8A%A8%E6%9D%A1%E7%9A%84%E6%98%BE%E7%A4%BA/%E5%AD%90%E5%85%83%E7%B4%A0%E4%BC%B8%E7%BC%A9.png" alt="子元素缩小"></p><p><strong>解决方法</strong></p><p>在flex布局标签外部套一个div，重新设置 固定高度和overflow:auto，摆脱flex布局即可。</p>]]></content>
    
    
    <categories>
      
      <category>CSS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>滚动条显示问题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>变量样式var()的使用</title>
    <link href="/2023/08/29/%E5%8F%98%E9%87%8F%E6%A0%B7%E5%BC%8Fvar-%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2023/08/29/%E5%8F%98%E9%87%8F%E6%A0%B7%E5%BC%8Fvar-%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p><strong>前言</strong></p><p>在调整UI组件的内置样式时，发现组件内置的样式通常值都不是具体值，而是一个类似 </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">属性名:<span class="hljs-built_in">var</span>(--属性名)<br></code></pre></td></tr></table></figure><p>这样的格式，于是我去查询了用法。</p><p><strong>发现新大陆</strong></p><p><u>定义</u></p><p>原来这是一种变量样式的写法，也就是说 样式值是一个变量，它被定义在引入的样式文件根部中，如下：</p><p><img src="/2023/08/29/%E5%8F%98%E9%87%8F%E6%A0%B7%E5%BC%8Fvar-%E7%9A%84%E4%BD%BF%E7%94%A8/%E6%A0%B7%E5%BC%8F%E6%96%87%E4%BB%B6%E7%9A%84%E6%A0%B9%E9%83%A8.png" alt="引入的样式文件根部"></p><p><u>使用</u></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attr">--background</span>: <span class="hljs-built_in">var</span>(--ion-color-buttonRed);<br></code></pre></td></tr></table></figure><p><u>好处</u></p><p>如果变更需求，只要在样式文件根部修改即可。 </p>]]></content>
    
    
    <categories>
      
      <category>CSS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>变量样式var()</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>像素对齐问题</title>
    <link href="/2023/08/28/%E5%83%8F%E7%B4%A0%E5%AF%B9%E9%BD%90%E9%97%AE%E9%A2%98/"/>
    <url>/2023/08/28/%E5%83%8F%E7%B4%A0%E5%AF%B9%E9%BD%90%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p><strong>前言</strong></p><p>在调整item和label标签距离时，随着距离越来越近，发现下面label的文字竟然模糊了。效果如下：</p><p><img src="/2023/08/28/%E5%83%8F%E7%B4%A0%E5%AF%B9%E9%BD%90%E9%97%AE%E9%A2%98/before.png" alt="before"></p><p><img src="/2023/08/28/%E5%83%8F%E7%B4%A0%E5%AF%B9%E9%BD%90%E9%97%AE%E9%A2%98/after.png" alt="after"></p><p><strong>原因</strong></p><p>当两个标签的位置非常接近时，可能会出现像素对齐问题，导致字体模糊。这是因为浏览器在渲染字体时，会将字体的位置对齐到像素网格上，如果两个标签的位置不是像素网格的整数倍，就会出现模糊。</p><p><strong>解决方法</strong></p><p>调整标签的位置，使其与像素网格对齐，通常距离要调大一点。</p>]]></content>
    
    
    <categories>
      
      <category>CSS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字体显示不正常</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS样式调整经验(持续更新)</title>
    <link href="/2023/08/25/CSS%E6%A0%B7%E5%BC%8F%E8%B0%83%E6%95%B4%E7%BB%8F%E9%AA%8C-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/"/>
    <url>/2023/08/25/CSS%E6%A0%B7%E5%BC%8F%E8%B0%83%E6%95%B4%E7%BB%8F%E9%AA%8C-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/</url>
    
    <content type="html"><![CDATA[<ul><li>父元素高度跟着子元素高度走 原因 是父元素没有设置固定高度导致子元素没有活动空间</li><li>尽量使用flex布局，其中just-content指的是flex-direction的排列方式，而align-items指的是just-content另外一个方向的排列方式，比如flex-direction:row;just-content:center是水平居中，那么align-items:center就是垂直居中，总之：just-content:center、align-items:center都加上就是水平+垂直居中</li><li>若UI组件中同一行的两个元素默认宽度平分，这时可以添加</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">flex-grow</span><br></code></pre></td></tr></table></figure><p>属性来给每个标签设置权重，以达到需求的比例显示效果</p><ul><li>嵌套样式中，相同标签内部样式会覆盖外部样式，比如：</li></ul><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">500px</span>;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#f5f5f5</span>;<br>  <br>  <span class="hljs-selector-tag">p</span> &#123;<br>    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">14px</span>;<br>    <span class="hljs-attribute">color</span>: <span class="hljs-number">#333</span>;<br>  &#125;<br>  <br>  <span class="hljs-selector-class">.content</span> &#123;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">400px</span>;<br>    <span class="hljs-attribute">padding</span>: <span class="hljs-number">20px</span>;<br>    <br>    <span class="hljs-selector-tag">p</span> &#123;<br>      <span class="hljs-attribute">font-size</span>: <span class="hljs-number">16px</span>;<br>      <span class="hljs-attribute">color</span>: <span class="hljs-number">#007bff</span>;<br>    &#125;<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>在上面的例子中，<code>.container</code>元素中的<code>p</code>标签样式设置了字体大小为14px，颜色为#333。但是在<code>.content</code>元素中，又重新设置了<code>p</code>标签的字体大小为16px，颜色为#007bff。这样一来，<code>.content</code>元素中的<code>p</code>标签样式会覆盖<code>.container</code>元素中的<code>p</code>标签样式。</p><ul><li><p>如何给图标设置原地旋转的动画？</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@keyframes</span> rotate-loading &#123;<br>  <span class="hljs-number">0%</span> &#123;<br>    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">rotate</span>(<span class="hljs-number">0deg</span>);<br>    <span class="hljs-comment">/* 初始状态 */</span><br>  &#125;<br>  <br>  <span class="hljs-number">100%</span> &#123;<br>    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">rotate</span>(<span class="hljs-number">360deg</span>);<br>    <span class="hljs-comment">/* 最终状态，旋转360度 */</span><br>  &#125;<br>&#125;<br>  <br>  <br><span class="hljs-selector-class">.icon-upload-loading</span> &#123;<br>  <span class="hljs-attribute">animation</span>: rotate-loading <span class="hljs-number">2s</span> infinite linear;<br>&#125;<br>  <br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>CSS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>经验</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端开发经验(持续更新)</title>
    <link href="/2023/08/25/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E7%BB%8F%E9%AA%8C-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/"/>
    <url>/2023/08/25/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E7%BB%8F%E9%AA%8C-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="查漏补缺："><a href="#查漏补缺：" class="headerlink" title="查漏补缺："></a>查漏补缺：</h1><h3 id="技术部分"><a href="#技术部分" class="headerlink" title="技术部分"></a>技术部分</h3><p><strong>URL和路由的区别</strong></p><p>URL是整个地址，而路由只是端口号后面的部分</p><p><strong>日期的比较</strong></p><p>需要先将字符串转化为日期对象才可以直接用 &gt;&lt;比较</p><p><strong>path参数和query参数的区别</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">data =&gt; <span class="hljs-title function_">get</span>(<span class="hljs-string">`/coupon/detail/<span class="hljs-subst">$&#123;data.couponId&#125;</span>`</span>) <br><br>data =&gt; <span class="hljs-title function_">get</span>(<span class="hljs-string">`/coupon/detail/`</span>,data) <br></code></pre></td></tr></table></figure><p>两者的区别：前者没有传递参数，仅仅是一个URL，后者会传递query参数，比如?couponId=5</p><p><strong>post请求也可以有查询参数</strong></p><p>get请求 =  post请求在URL后面直接拼接参数（post(<code>/sourceadmin/manager/new/updateVipPurviewByVipId.action?vipId=$&#123;data.vipId&#125;</code>,data)），因为get请求默认就是query参数</p><p><strong>打包相关</strong></p><p>NODE_OPTIONS 报不是内部命令时，执行 npm install -g win-node-env 再尝试</p><p><strong>git</strong></p><p>git如果改的东西不多还是建议，先pull再commit，还是想清晰地显示下 commit的内容</p><h1 id="开发经验"><a href="#开发经验" class="headerlink" title="开发经验"></a>开发经验</h1><p>后端 数据的 问题，前端 提醒一下就行了，我该干嘛干嘛，不用等他，我前端逻辑又没错</p><p><strong>h5和vue目录的关系</strong></p><p>纯H5项目的文件就是Vue项目build之后的文件，只保存用到的css、js、html</p><p><strong>前后端不同环境的区别</strong></p><p>前端不同环境（看网址URL）决定了页面不同，而后端不同环境（看接口URL）决定了数据的不同</p><p><strong>Bug修改</strong></p><p>若接口有数据且也能正确获取到，但就是 不显示 ——-&gt; 看看控制台有没有错误，只要有某行代码有问题 阻塞下面 代码的执行</p><p><strong>vue项目目录结构</strong></p><blockquote><p>–src</p><p>assets：静态文件——–图片、图标</p><p>api：api.js，注意要按模块分：common.js、xxx.js…；config.js，为api.js配置api环境、请求拦截、封装请求方法…</p><p>components：公共组件，即封装的 可复用的组件</p><p>plugins：第三方插件，按需Vue.use</p><p>layout：布局组件，主页面的  轮廓组件：SideBar、Navbar</p><p>router：路由文件，注意也要 按模块分，子菜单注意要用children，避免单个路由写的过长</p><p>store：仓库，注意要 按模块分</p><p>utils：自己封装的js工具，登陆加密、数据格式转换</p><p>–root</p><p>main：入口文件，注册插件、组件、原型上添加方法等</p><p>.env.debug/development/production：设置Api调用环境的地址</p><p>vue.config.js：打包的配置、优化等</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>经验</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cordova_not_available</title>
    <link href="/2023/08/14/ionic%EF%BC%9Acordova-not-available/"/>
    <url>/2023/08/14/ionic%EF%BC%9Acordova-not-available/</url>
    
    <content type="html"><![CDATA[<p><strong>问题</strong></p><p><img src="/2023/08/14/ionic%EF%BC%9Acordova-not-available/cordova_not_available.png" alt="cordova_not_available"></p><p><strong>原因</strong></p><p>调用android原生api只能在真机或模拟器上，浏览器不支持，因此也就没有值</p><p><strong>解决办法：</strong></p><p>要么build后安装apk到手机上debug，要么连接模拟器（似乎很麻烦）</p><p>Ps：由于只是个warning，如果能确保调用的api方法没错的情况下，不影响其他部分的开发</p>]]></content>
    
    
    <categories>
      
      <category>Ionic</category>
      
    </categories>
    
    
    <tags>
      
      <tag>issues</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ts中的??与||的区别</title>
    <link href="/2023/08/10/Ts%E4%B8%AD%E7%9A%84-%E4%B8%8E%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2023/08/10/Ts%E4%B8%AD%E7%9A%84-%E4%B8%8E%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<p><strong>前言</strong></p><p>在开发时发现Ts中的??与js中的||似乎有类似的作用，但是又不知道其中的区别    </p><p><strong>异同点</strong></p><p>同：都用于判断前者的值来确定是否赋值于后者</p><p>异：||会当前者值为 null、undefined、’’、0时才会赋值为后者</p><p>​        ?? 仅当前者值为 null、undefined 才会赋值为后者</p><p><strong>总结：</strong></p><p>可以看出??是||的部分情况，这两个情况是专门用于判断 <u>引用类型</u> <u>是否定义</u>或<u>是否有值</u>（用的最多），而||可用于 引用类型、字符串、数值 类型的判断</p>]]></content>
    
    
    <categories>
      
      <category>Ts</category>
      
    </categories>
    
    
    <tags>
      
      <tag>用法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>npm无法下载问题</title>
    <link href="/2023/08/07/npm%E6%97%A0%E6%B3%95%E4%B8%8B%E8%BD%BD%E9%97%AE%E9%A2%98/"/>
    <url>/2023/08/07/npm%E6%97%A0%E6%B3%95%E4%B8%8B%E8%BD%BD%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p><strong>前言</strong></p><p>经常会出现npm下载包无法下载的问题，问题如下：</p><p><img src="/2023/08/07/npm%E6%97%A0%E6%B3%95%E4%B8%8B%E8%BD%BD%E9%97%AE%E9%A2%98/npm%E6%97%A0%E6%B3%95%E4%B8%8B%E8%BD%BD.png" alt="npm无法下载"></p><p><strong>设置代理试过：无效</strong></p><p><strong>可进行以下操作</strong></p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-number">1</span>、查看代理设置执行，不为<span class="hljs-literal">null</span>时设置为空：<br>npm config <span class="hljs-built_in">get</span> proxy<br>npm config <span class="hljs-built_in">get</span> <span class="hljs-keyword">https</span>-proxy<br>如果返回值不为<span class="hljs-literal">null</span>，继续执行：<br>（这一步很重要，一定要保证两个命令的返回值都为<span class="hljs-literal">null</span>）<br>npm config <span class="hljs-built_in">set</span> proxy <span class="hljs-literal">null</span><br>npm config <span class="hljs-built_in">set</span> <span class="hljs-keyword">https</span>-proxy <span class="hljs-literal">null</span><br><span class="hljs-number">2</span>、执行：<br>npm config <span class="hljs-built_in">set</span> registry <span class="hljs-keyword">http</span>://registry.cnpmjs.org/<br><span class="hljs-number">3</span>、执行npm i 成功<br></code></pre></td></tr></table></figure><p><strong>总结</strong>：似乎设置代理和设置镜像源不能同时设置，因此要设置为null</p>]]></content>
    
    
    <categories>
      
      <category>Npm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>npm操作问题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git操作:一些关于回退的操作</title>
    <link href="/2023/06/06/git%E6%93%8D%E4%BD%9C-%E4%B8%80%E4%BA%9B%E5%85%B3%E4%BA%8E%E5%9B%9E%E9%80%80%E7%9A%84%E6%93%8D%E4%BD%9C/"/>
    <url>/2023/06/06/git%E6%93%8D%E4%BD%9C-%E4%B8%80%E4%BA%9B%E5%85%B3%E4%BA%8E%E5%9B%9E%E9%80%80%E7%9A%84%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<p><strong>前言</strong></p><p>我们在git协同操作的时候有时候难免会 合并、提交出错，这时候就需要回退操作，使之回到操作之前的状态</p><p><strong>退回到暂存区之前（git add之前）</strong></p><p>有以下几种方式：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">git <span class="hljs-keyword">reset</span>/git <span class="hljs-keyword">reset</span> HEAD/git <span class="hljs-keyword">reset</span> <span class="hljs-comment">--mixed </span><br></code></pre></td></tr></table></figure><p><strong>退回到暂存区commit之前（git commit之前）</strong></p><blockquote><p>1）退回上一次commit</p></blockquote><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">git <span class="hljs-keyword">reset</span> <span class="hljs-comment">--soft HEAD^</span><br></code></pre></td></tr></table></figure><p>Ps：要在vscode里面写，命令行里要写两个^^，因为它默认^是换行</p><p>或</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">git <span class="hljs-keyword">reset</span> <span class="hljs-comment">--soft HEAD~1</span><br></code></pre></td></tr></table></figure><p>Ps：这种方式适合你知道你要退回到前几次commit，1表示退回到上一次，2就是上两次的状态</p><blockquote><p>2）退回到具体的某提提交（可能某次提交太久远了，记不住次数）</p></blockquote><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">git <span class="hljs-keyword">reset</span> <span class="hljs-comment">--soft commitId</span><br></code></pre></td></tr></table></figure><p><u>如何查看某次commit的ID？</u></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">git <span class="hljs-built_in">log</span><br></code></pre></td></tr></table></figure><p><strong>退回commit时，重新修改注释</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">git <span class="hljs-keyword">commit</span> <span class="hljs-comment">--amend</span><br></code></pre></td></tr></table></figure><p>自动会跳出编辑器，重新更新就行</p><p><strong>退回到上一个版本（不会保留新版本修改的代码，慎重）</strong></p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">git reset <span class="hljs-params">--hard</span> Head^<span class="hljs-string">/commitId</span><br></code></pre></td></tr></table></figure><p>Ps：这种一般是用作退回版本的，也可以用于退回合并之前</p><p><strong>总结：</strong></p><p><img src="/2023/06/06/git%E6%93%8D%E4%BD%9C-%E4%B8%80%E4%BA%9B%E5%85%B3%E4%BA%8E%E5%9B%9E%E9%80%80%E7%9A%84%E6%93%8D%E4%BD%9C/git%E5%9B%9E%E9%80%80.png"></p>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git操作</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git操作:如何删除本地和远程分支</title>
    <link href="/2023/05/25/git%E6%93%8D%E4%BD%9C-%E5%A6%82%E4%BD%95%E5%88%A0%E9%99%A4%E6%9C%AC%E5%9C%B0%E5%92%8C%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF/"/>
    <url>/2023/05/25/git%E6%93%8D%E4%BD%9C-%E5%A6%82%E4%BD%95%E5%88%A0%E9%99%A4%E6%9C%AC%E5%9C%B0%E5%92%8C%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF/</url>
    
    <content type="html"><![CDATA[<p><strong>删除本地分支</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">git branch -d <span class="hljs-tag">&lt;<span class="hljs-name">本地分支名</span>&gt;</span><br></code></pre></td></tr></table></figure><p>此删除会检查是否存在没有分支没有合并的内容，会进行提示</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">git branch -D <span class="hljs-tag">&lt;<span class="hljs-name">本地分支名</span>&gt;</span><br></code></pre></td></tr></table></figure><p>此删除是强行删除</p><p><strong>删除远程分支</strong></p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">git <span class="hljs-built_in">push</span> <span class="hljs-built_in">origin</span> -d &lt;远程分支名&gt;<br></code></pre></td></tr></table></figure><p>注意这里的origin指的是远程分支为 origin/&lt;远程分支名&gt; 的分支，如果不清楚远程分支全称，可以通过以下命令查看</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">git branch -r</span><br></code></pre></td></tr></table></figure><p>为什么会有push，我的理解是将删除远程分支的指令告诉远程代码，而 push 就相当于 通往远程代码的 通道。</p>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git操作</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git之问题-没有当前分支的跟踪信息</title>
    <link href="/2023/04/02/git%E4%B9%8B%E9%97%AE%E9%A2%98-%E6%B2%A1%E6%9C%89%E5%BD%93%E5%89%8D%E5%88%86%E6%94%AF%E7%9A%84%E8%B7%9F%E8%B8%AA%E4%BF%A1%E6%81%AF/"/>
    <url>/2023/04/02/git%E4%B9%8B%E9%97%AE%E9%A2%98-%E6%B2%A1%E6%9C%89%E5%BD%93%E5%89%8D%E5%88%86%E6%94%AF%E7%9A%84%E8%B7%9F%E8%B8%AA%E4%BF%A1%E6%81%AF/</url>
    
    <content type="html"><![CDATA[<p><strong>前言</strong></p><p>在git pull 的时候出现 There is no tracking information for the current branch.</p><p><strong>直接原因</strong></p><p>原因是 本地分支没有与远程分支 关联</p><p><strong>发生场景</strong></p><p>通常新建一个本地分支之后，git不清楚这个新分支要准备推送到哪个分支</p><p><strong>解决方法</strong></p><p>输入以下命令可实现关联：</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs delphi">git branch --<span class="hljs-keyword">set</span>-upstream-<span class="hljs-keyword">to</span>=origin/远程分支的名字  本地分支的名字<br></code></pre></td></tr></table></figure><p>否则只能指定远程分支名字（较麻烦）</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">git pull <span class="hljs-built_in">origin</span> 远程分支<br></code></pre></td></tr></table></figure><p><strong>总结：</strong></p><p>下次记得不能随便删除本地仓库.git文件，克隆下来后别动，方便后续开发</p>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git操作</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>slice函数&amp;splice函数&amp;split函数的区别</title>
    <link href="/2023/04/02/slice%E5%87%BD%E6%95%B0&amp;splice%E5%87%BD%E6%95%B0&amp;split%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2023/04/02/slice%E5%87%BD%E6%95%B0&amp;splice%E5%87%BD%E6%95%B0&amp;split%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<p>这三个函数长得非常相似，将它们区分开来很有必要。</p><h3 id="slice（切割）"><a href="#slice（切割）" class="headerlink" title="slice（切割）"></a><strong>slice（切割）</strong></h3><p><strong>作用</strong>：可将 <u>字符串或数组</u> 切割成 其部分的 新的 <u>字符串或数组</u> （不改变原字符串、数组）</p><p><strong>方法：</strong></p><ul><li>str.slice(start,end) ———— 区间 左闭右开—–切割[start,end)区间的 字符串或数组</li></ul><blockquote><p>说到获取部分字符串，便可想到 substr方法和substring方法（也是不改变原字符串、数组）</p><ul><li>str.substr(start,num) ——————从start开始截取num个字符</li><li>str.substring(start,end) ————— 用法和 slice 一样</li></ul></blockquote><h3 id="splice（拼接）"><a href="#splice（拼接）" class="headerlink" title="splice（拼接）"></a>splice（拼接）</h3><p><strong>作用：</strong>可对数组元素进行插入、删除、替换，号称“最强数据操作的方法”，但是会直接修改原数组的，简单粗暴。</p><p><strong>方法：</strong></p><ul><li>str.splice(位置，删除的个数，插入的新的元素1，插入的新的元素1…)</li></ul><blockquote><p>使用：</p><p>删除：str.splice(2,2)——删除位置为2后的2个元素</p><p>替换：str.splice(2,2,2,2)—–删除位置为2后的2个元素并替换成2、2</p><p>插入：str.splice(2,0,2,2)——删除位置为2后的0个元素，并插入2、2–插入2、2</p></blockquote><h3 id="split（分离）"><a href="#split（分离）" class="headerlink" title="split（分离）"></a>split（分离）</h3><p><strong>作用：</strong>对字符串以分隔符进行分离，被拆分的各个部分组成变成各个数组</p><p><strong>使用：</strong>“1：2：3”.split(“:”) —————–[‘1’，’2’，’3’]</p><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p><strong>操作对象的不同：</strong>splice只可操作数组，split只可操作字符串，而slice两者都可</p>]]></content>
    
    
    <categories>
      
      <category>Js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>函数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git之问题:push之后某文件夹出现@+一串数字</title>
    <link href="/2023/03/12/git%E4%B9%8B%E9%97%AE%E9%A2%98-push%E4%B9%8B%E5%90%8E%E6%9F%90%E6%96%87%E4%BB%B6%E5%A4%B9%E5%87%BA%E7%8E%B0-%E4%B8%80%E4%B8%B2%E6%95%B0%E5%AD%97/"/>
    <url>/2023/03/12/git%E4%B9%8B%E9%97%AE%E9%A2%98-push%E4%B9%8B%E5%90%8E%E6%9F%90%E6%96%87%E4%BB%B6%E5%A4%B9%E5%87%BA%E7%8E%B0-%E4%B8%80%E4%B8%B2%E6%95%B0%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<p><strong>问题：</strong></p><p>今天在拉取之前代码时，发现项目突然运行不起来了，找了半天发现缺少文件，再在gitee代码中发现有个子文件夹前面有个@，后面还有一串数字，点进去一看，该文件夹是空的！</p><p><strong>原因：</strong></p><p>在网上找了answer，说是该文件夹的子文件夹中还有.git文件，似乎git只能按照一个git仓库上传，内部文件夹的git仓库默认不上传（又来一个git仓库不知道怎么处理直接不处理）</p><p><strong>解决方法：</strong></p><p>删除内部文件夹的.git文件，重新commit并push，这样才能全部push上去，那么拉去的代码也就不缺少东西啦</p>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git操作</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>吸引力法则和自我催眠法则的关系</title>
    <link href="/2023/03/11/%E5%90%B8%E5%BC%95%E5%8A%9B%E6%B3%95%E5%88%99%E5%92%8C%E8%87%AA%E6%88%91%E5%82%AC%E7%9C%A0%E6%B3%95%E5%88%99%E7%9A%84%E5%85%B3%E7%B3%BB/"/>
    <url>/2023/03/11/%E5%90%B8%E5%BC%95%E5%8A%9B%E6%B3%95%E5%88%99%E5%92%8C%E8%87%AA%E6%88%91%E5%82%AC%E7%9C%A0%E6%B3%95%E5%88%99%E7%9A%84%E5%85%B3%E7%B3%BB/</url>
    
    <content type="html"><![CDATA[<p>分享两个有关心理学（原本是物理学，后来引申到心理学）的知识，吸引力法则与自我催眠法则的关系（信不信看个人）。</p><p><img src="/2023/03/11/%E5%90%B8%E5%BC%95%E5%8A%9B%E6%B3%95%E5%88%99%E5%92%8C%E8%87%AA%E6%88%91%E5%82%AC%E7%9C%A0%E6%B3%95%E5%88%99%E7%9A%84%E5%85%B3%E7%B3%BB/%E5%90%B8%E5%BC%95%E5%8A%9B%E6%B3%95%E5%88%99.jpg" alt="吸引力法则"></p><p><img src="/2023/03/11/%E5%90%B8%E5%BC%95%E5%8A%9B%E6%B3%95%E5%88%99%E5%92%8C%E8%87%AA%E6%88%91%E5%82%AC%E7%9C%A0%E6%B3%95%E5%88%99%E7%9A%84%E5%85%B3%E7%B3%BB/%E5%82%AC%E7%9C%A0%E8%8A%82%E5%A5%8F%E6%B3%95%E5%88%99.jpg" alt="催眠节奏法则"></p>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>心理学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue项目该有的意识（更新中）</title>
    <link href="/2023/03/11/vue%E9%A1%B9%E7%9B%AE%E8%AF%A5%E6%9C%89%E7%9A%84%E6%84%8F%E8%AF%86%EF%BC%88%E7%BB%8F%E9%AA%8C%EF%BC%89/"/>
    <url>/2023/03/11/vue%E9%A1%B9%E7%9B%AE%E8%AF%A5%E6%9C%89%E7%9A%84%E6%84%8F%E8%AF%86%EF%BC%88%E7%BB%8F%E9%AA%8C%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p><strong>用父组件发请求子组件接数据以减少多次请求api</strong></p><blockquote><p>1）组件如果需要重复多次，那么不建议在组件内部发送api请求，因为那样就请求了多次，性能不高，直接在父组件请求好，这样只用请求一次，这是一方面；然后把数据传给子组件，那么子组件就只要对这一份数据进行动态展示就行，这样相当于增加了内聚性，减少了耦合性</p></blockquote><p><strong>标签决定页面格式</strong></p><blockquote><p>2）循环的格式不对，看看v-for写的标签位置是不是不对，因为标签决定了页面格式（标签上有样式）</p></blockquote><p><strong>已经有vue框架了，不需要用原生DOM</strong></p><blockquote><p>3）尽量不要用原生DOM操作，一方面是vue框架就是为了不是用原生框架而设计的，另一方面使用原生DOM代码会出现错误，比如ducoment.querySelector在循环的时候似乎只会生效一次，要使用ref</p></blockquote><p><strong>复用的重要性</strong></p><blockquote><p>4）在页面中有相同或相似的部分要拆分成一个公共组件</p></blockquote><p><strong>展示的数据需要考虑为空时的情况 ——— 请求api是异步的</strong></p><blockquote><p>5）仓库store中state存储的数据的初始值要考虑全面，比如没有请求成功时应该返回给前端什么数据（因为请求api是异步的，很可能返回来数据时页面已经加载完成这时就取不到数据），这时state中的某个list就改写成  list||[] （如果需要数组来展示）</p><p>注意：有时这种需要考虑的是多层的</p><p>比如一开始报 list[0]取不到数据，已经用   list||[]  解决掉了，但是后面子组件还要取 list[0].imageUrl，这时还要在 子组件computed数据的时候 需要 list[0].imageUrl ||{}，因为只有对象才能y用.来取数据</p></blockquote><p><strong>看到页面结构就要想到数据结构</strong></p><blockquote><p>这是一个成熟前端该有的能力：看到页面结构心理就已经有了大致结构</p></blockquote><p><strong>Vuex的Getters的善用</strong></p><blockquote><p>当api请求回来的数据是多层嵌套，需要利用vuex的getters先计算好了再返回，这样前端直接拿来用就行</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>前端框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue2:$nextClick和watch的妙用</title>
    <link href="/2023/03/09/$nextClick%E4%B8%8Ewatch%E7%9A%84%E5%A6%99%E7%94%A8/"/>
    <url>/2023/03/09/$nextClick%E4%B8%8Ewatch%E7%9A%84%E5%A6%99%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p><strong>场景：</strong></p><p>在组件里经常需要在mounted时需要$store.dispatch-&gt;store中的action向服务器发送请求，然后保存在state中，最后组件通过mapState获取数据并展示，也就是所谓的仓库store的三连环（仓库向api请求数据-&gt;将返回的数据保存在仓库中-&gt;组件从仓库中捞数据并展示）。这时，在展示的时候需要配合某个插件使用，这个插件需要在页面完全渲染完成后加上它的js代码才能完成它的动态效果。</p><p><strong>具体：</strong></p><p>我这里需要用到swiper轮播图这个插件，官网的使用代码是这样的：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;swiper&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;swiper-wrapper&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;swiper-slide&quot;</span>&gt;</span>Slide 1<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;swiper-slide&quot;</span>&gt;</span>Slide 2<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;swiper-slide&quot;</span>&gt;</span>Slide 3<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 如果需要分页器 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;swiper-pagination&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <br>    <span class="hljs-comment">&lt;!-- 如果需要导航按钮 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;swiper-button-prev&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;swiper-button-next&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript">        </span><br><span class="language-javascript">  <span class="hljs-keyword">var</span> mySwiper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Swiper</span> (<span class="hljs-string">&#x27;.swiper&#x27;</span>, &#123;</span><br><span class="language-javascript">    <span class="hljs-attr">loop</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 循环模式选项</span></span><br><span class="language-javascript">    </span><br><span class="language-javascript">    <span class="hljs-comment">// 如果需要分页器</span></span><br><span class="language-javascript">    <span class="hljs-attr">pagination</span>: &#123;</span><br><span class="language-javascript">      <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;.swiper-pagination&#x27;</span>,</span><br><span class="language-javascript">    &#125;,</span><br><span class="language-javascript">    </span><br><span class="language-javascript">    <span class="hljs-comment">// 如果需要前进后退按钮</span></span><br><span class="language-javascript">    <span class="hljs-attr">navigation</span>: &#123;</span><br><span class="language-javascript">      <span class="hljs-attr">nextEl</span>: <span class="hljs-string">&#x27;.swiper-button-next&#x27;</span>,</span><br><span class="language-javascript">      <span class="hljs-attr">prevEl</span>: <span class="hljs-string">&#x27;.swiper-button-prev&#x27;</span>,</span><br><span class="language-javascript">    &#125;,</span><br><span class="language-javascript">  &#125;)        </span><br><span class="language-javascript">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>很明显这个js代码需要页面渲染完成才能通过选择器获取到<u>‘swiper’</u>，换到vue组件中使用时，通常我想组件挂载结束获取到数据并展示，同时还想运用这个插件，可是通常通过this.$store.dispatch请求api获得数据是**<u>异步</u>**的操作，这样一来就会先执行插件的js代码（先执行主程序的同步任务，再把异步任务拿到主程序中执行），然后数据才能获取到并存储到store中，此时页面还没有渲染完成，最终结果就是js代码执行2无效，因为无法获取页面的.swiper。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div class=&quot;list-container&quot;&gt;<br>    &lt;div class=&quot;sortList clearfix&quot;&gt;<br>      &lt;div class=&quot;center&quot;&gt;<br>        &lt;!--banner轮播--&gt;<br>        &lt;div class=&quot;swiper-container&quot; id=&quot;mySwiper&quot;&gt;<br>          &lt;div class=&quot;swiper-wrapper&quot;&gt;<br>            &lt;div<br>              class=&quot;swiper-slide&quot;<br>              v-for=&quot;banner in bannerList&quot;<br>              :key=&quot;banner.id&quot;<br>            &gt;<br>              &lt;img :src=&quot;banner.imgUrl&quot; /&gt;<br>            &lt;/div&gt;<br>          &lt;/div&gt;<br>          &lt;!-- 如果需要分页器 --&gt;<br>          &lt;div class=&quot;swiper-pagination&quot;&gt;&lt;/div&gt;<br><br>          &lt;!-- 如果需要导航按钮 --&gt;<br>          &lt;div class=&quot;swiper-button-prev&quot;&gt;&lt;/div&gt;<br>          &lt;div class=&quot;swiper-button-next&quot;&gt;&lt;/div&gt;<br>        &lt;/div&gt;<br>      &lt;/div&gt;<br>    &lt;/div&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>import &#123; mapState &#125; from &quot;vuex&quot;;<br>import Swiper from &quot;swiper&quot;;<br>export default &#123;<br>  name: &quot;ListContainer&quot;,<br>  mounted() &#123;<br>    this.$store.dispatch(&quot;bannerList&quot;);<br>    /**<br>     * 由于this.$store.dispatch(&quot;bannerList&quot;)请求服务器数据包含异步操作，因此<br>     * (3) 复习：虽然代码写在前面，但是异步任务是在主程序同步任务执行完才会放入同步任务来执行<br>     * 那么没有bannerList数据那么页面结构就没有完成，轮播图的js代码就获取不到结构<br>     * 得想办法把轮播图js代码在this.$store.dispatch(&quot;bannerList&quot;)后面执行<br>     * */<br>    // 方法一：可以用setTimeOut但是必须要等一段时间才执行，不是最完美的方案<br>    // setTimeout(() =&gt; &#123;<br><br>    //   &#125;);<br>    // &#125;, 2000);<br>  &#125;,<br>  computed: &#123;<br>    // 为什么要...展开？复习一下，这里的展开值得是将获得的bannerList展开成computed的函数形式<br>    ...mapState(&#123;<br>      bannerList: (state) =&gt; state.home.bannerList,<br>    &#125;),<br>  &#125;,<br>&#125;;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p><strong>解决方法：watch+$nextClick</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs vue">// 方法二：<br>watch: &#123;<br>  bannerList: &#123;<br>    handler(newVal, oldVal) &#123;<br>      /**<br>       * (1)虽然数据变化了，已经有了，但是页面并没有渲染完成，那就获取不到<br>       *    nextTick可以在页面渲染完成后再执行<br>       * <br>       * 最后一个问题：为什么要放到watch里面？<br>       * 我试了一下，直接放到mounted也行，我觉得放这是因为提高性能<br>       * 类似于懒加载，减少new Swiper的次数<br>       * <br>       * (2) 以后知道了一些插件经常要使用nextClick，因为都要在DOM渲染完成之后才能执行某些代码<br>       * */ <br>      this.$nextTick(() =&gt; &#123;<br>        var mySwiper = new Swiper(&quot;#mySwiper&quot;, &#123;<br>          loop: true, // 循环模式选项<br><br>          // 如果需要分页器<br>          pagination: &#123;<br>            el: &quot;.swiper-pagination&quot;,<br>            clickable: true,<br>          &#125;,<br><br>          // 如果需要前进后退按钮<br>          navigation: &#123;<br>            nextEl: &quot;.swiper-button-next&quot;,<br>            prevEl: &quot;.swiper-button-prev&quot;,<br>          &#125;,<br>        &#125;);<br>      &#125;);<br>    &#125;,<br>  &#125;,<br>&#125;,<br></code></pre></td></tr></table></figure><p><u>$nextClick</u>：都知道可以页面渲染完再执行，已经可以解决问题了，可是把代码放在哪？</p><p><strong>为什么要放在数据的监听watch里面？</strong></p><p><del>因为可以提高性能，我试了一下把$nextClick放到mounted中也可以有同样的效果，但是如果发给到mouned里面那么就会每使用一次这个组件，都会new一次Swiper实例，而放到watch里面，有点类似懒加载的感觉，数据真正返回了（第一道关卡，因为可能请求不成功没有数据返回，没有数据直接不执行）我再用$nextClick执行相关插件（第二道关卡，等页面完全渲染完再执行）</del></p><p>先问第一个问题：异步操作和页面渲染完成哪个在后面？</p><p>这个不确定啊，有可能页面渲染完成之后请求数据的异步操作都没完成，好，那我就等你数据来了（异步操作已经执行并返回了数据）我再在nextClick里面执行DOM操作的代码，这样就一来，页面结构才叫完全ok，我安心地操作DOM。</p><p><strong>总结：</strong></p><p>1）异步操作什么时候结束不太确定，因此需要找一个临界点，比如用watch</p><p>2）$nextClick经常和一些插件一起使用</p>]]></content>
    
    
    <categories>
      
      <category>前端框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ES新特性</title>
    <link href="/2023/03/04/ES%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <url>/2023/03/04/ES%E6%96%B0%E7%89%B9%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h3 id="ES6新特性"><a href="#ES6新特性" class="headerlink" title="ES6新特性"></a>ES6新特性</h3><h4 id="1-ECMA（European-Computer-Manufacture-Assocition）"><a href="#1-ECMA（European-Computer-Manufacture-Assocition）" class="headerlink" title="1.ECMA（European Computer Manufacture Assocition）"></a>1.ECMA（European Computer Manufacture Assocition）</h4><blockquote><p>1）欧洲计算机制造商协会</p><p>2）ECMAScript 是脚本程序设计语言,js便是ECMA的一种实现，ES6即ECMA Script 6</p></blockquote><h4 id="2-let"><a href="#2-let" class="headerlink" title="2.let"></a>2.let</h4><blockquote><p> 1）不能重复声明，防止变量被污染，这样每个变量的用途都是唯一的</p><p> ​       不像以前var可以重复声明（后面的会把前面的覆盖掉），很乱</p><p> 2）拥有块级作用域</p><p> 3）不存在变量提升</p><p> 4）不影响作用域链</p><p> 综上：let完全和c++、java中正常声明变量一模一样了</p></blockquote><h4 id="3-const"><a href="#3-const" class="headerlink" title="3.const"></a>3.const</h4><blockquote><p>1）和c++中一样，表示常量、块级作用域、不能被修改、且一般用大写字母命名</p><p>2）一定要赋初始值（如果没有初始值又不能被修改，那这个变量不就没用了）</p><p>3）对const声明的数组是可以修改里面的元素的，因为数组的地址没有改变。— 只要const声明的 变量值 不变就行</p><p>4）以后声明数组和对象都要用const，比较稳妥（地址不变，指向的数组/对象就不变）</p></blockquote><h4 id="4-变量的解构赋值（结构拆解为各个变量并赋值，可选择其中几个）"><a href="#4-变量的解构赋值（结构拆解为各个变量并赋值，可选择其中几个）" class="headerlink" title="4.变量的解构赋值（结构拆解为各个变量并赋值，可选择其中几个）"></a>4.变量的解构赋值（结构拆解为各个变量并赋值，可选择其中几个）</h4><blockquote><p>1）数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">F4</span> = [<span class="hljs-string">&#x27;小沈阳&#x27;</span>，<span class="hljs-string">&#x27;刘能&#x27;</span>，<span class="hljs-string">&#x27;赵四&#x27;</span>，<span class="hljs-string">&#x27;宋小宝&#x27;</span>]<br><span class="hljs-keyword">let</span> [xiao,liu,zhao,song] = <span class="hljs-variable constant_">F4</span><span class="hljs-comment">//左边按照数组的结构给各个元素声明变量就叫解构，然后右边赋值指明解的是哪个数组，并把元素一一对应赋值</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(xiao)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(liu)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(zhao)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(song)<br></code></pre></td></tr></table></figure><p>2）对象（结构的变量必须和原来对象属性值一致，否则单独取一个不知道取哪个）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> zhao = &#123;<br> <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;赵本山&#x27;</span>，<br> <span class="hljs-attr">age</span>:<span class="hljs-string">&#x27;不详&#x27;</span>，<br> <span class="hljs-attr">talent</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>     <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;演小品&#x27;</span>)<br> &#125;<br>&#125;<br><span class="hljs-keyword">let</span> &#123;name,age,talent&#125; = zhao<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(age)<br><span class="hljs-title function_">talent</span>()       --------------这么写是为了想把属性/方法脱离对象的关系<br></code></pre></td></tr></table></figure></blockquote><h4 id="5-模板字符串"><a href="#5-模板字符串" class="headerlink" title="5.模板字符串"></a>5.模板字符串</h4><blockquote><p>1）将字符串 ’ ‘和” “ 统一为 反引号``</p><p>2）可以直接出现换行符，不需要像以前一样需要用 + 拼接（以前只能识别一行）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> str = <span class="hljs-string">`&lt;ul&gt;</span><br><span class="hljs-string">         &lt;li&gt;沈腾&lt;/li&gt;</span><br><span class="hljs-string">         &lt;li&gt;玛丽&lt;/li&gt;</span><br><span class="hljs-string">        &lt;/ul&gt;</span><br><span class="hljs-string">       `</span><br></code></pre></td></tr></table></figure><p>3）变量拼接，在``里才能使用${}</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> lovest = <span class="hljs-string">&#x27;魏翔&#x27;</span><br><span class="hljs-keyword">let</span> out = <span class="hljs-string">`<span class="hljs-subst">$&#123;lovest&#125;</span> 是我心目中最搞笑的演员！！！`</span><br></code></pre></td></tr></table></figure></blockquote><h4 id="6-对象的简化写法"><a href="#6-对象的简化写法" class="headerlink" title="6.对象的简化写法"></a>6.对象的简化写法</h4><blockquote><p>1）直接拿现有的 变量和函数 充当对象的属性和方法 —— 越来越懒了，而且还更霸道了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> name=<span class="hljs-string">&#x27;zhoujie&#x27;</span><br><span class="hljs-keyword">let</span> change = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;我会变得更强的！&#x27;</span>)<br>&#125;<br><span class="hljs-keyword">const</span> person = &#123;<br> name,<br> change<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person.<span class="hljs-property">name</span>,person.<span class="hljs-property">change</span>)<br></code></pre></td></tr></table></figure><p>2）对象中 方法的简写</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> person = &#123;<br> name,<br> change,<br> <span class="hljs-title function_">improve</span>(<span class="hljs-params"></span>)&#123;<br>     <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;提高技能&#x27;</span>)<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>综上：越来越像C++中类里面成员变量和函数的声明了（变量不赋值，函数可以直接声明）</p></blockquote><h4 id="7-箭头函数"><a href="#7-箭头函数" class="headerlink" title="7.箭头函数"></a>7.箭头函数</h4><blockquote><p>1）声明：直接将function变成后面的箭头</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> fn = <span class="hljs-keyword">function</span>(<span class="hljs-params">a,b</span>)&#123;<br>...<br>&#125;<br>==&gt;<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">fn</span> = (<span class="hljs-params">a,b</span>) =&gt; &#123;<br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>2）特性：</p><ul><li>箭头函数 声明的方法，它的this是静态的，始终指向 函数声明时 <strong>所在作用域</strong>下 this 的值，这时之前的 规则是不生效的</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getName1</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>)<br>&#125;<br><span class="hljs-keyword">let</span> <span class="hljs-title function_">getName2</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>)<br>&#125;<br><span class="hljs-variable language_">window</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;zhoujie&#x27;</span><br><span class="hljs-keyword">const</span> school = &#123;<br>    <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;周杰&#x27;</span><br>&#125;<br>getName1.<span class="hljs-title function_">call</span>(school)<span class="hljs-comment">//周杰</span><br>getName2.<span class="hljs-title function_">call</span>(school)<span class="hljs-comment">//zhoujie，不会因为在对象里this就指向当前对象</span><br><br></code></pre></td></tr></table></figure><ul><li>不能作为构造函数实例化对象，因为箭头函数没有constructor</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> <span class="hljs-title function_">Person</span> = (<span class="hljs-params">name,age</span>) =&gt; &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age<br>&#125;<br><span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;zhoujie&#x27;</span>,<span class="hljs-number">18</span>)<span class="hljs-comment">//Person is not a constructor</span><br></code></pre></td></tr></table></figure><ul><li>不能使用arguments变量</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> <span class="hljs-title function_">fn</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">arguments</span>)<br>&#125;<br><span class="hljs-title function_">fn</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)<span class="hljs-comment">//arguments is not defined</span><br></code></pre></td></tr></table></figure><ul><li><p>箭头函数的简写</p><p>1）当形参只有一个时，可以省略小括号</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> <span class="hljs-title function_">fn</span> = n =&gt; &#123;<br>    <span class="hljs-keyword">return</span> n*n<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">fn</span>(<span class="hljs-number">8</span>))<br></code></pre></td></tr></table></figure><p>2）当函数体只有一条语句的时候，可以省略花括号，return也要省掉</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> <span class="hljs-title function_">fn</span> = n =&gt; n*n<br></code></pre></td></tr></table></figure></li></ul><p><strong>3）实践与应用</strong></p><p>1）考点：箭头函数的this指向的是函数声明时 <strong>所在作用域</strong>下 this的值，这里箭头函数和定时器作为整体 放在外部function的作用域下，而这个作用域的this是属于ad的、</p><p>注意js中只有 全局作用域、函数作用域、块作用域，这里定时器第一个参数都不属于一个作用域</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;div id=<span class="hljs-string">&quot;ad&quot;</span>&gt;&lt;/div&gt;<br><span class="hljs-keyword">let</span> ad = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;ad&#x27;</span>)<br>ad.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;click&quot;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">style</span>.<span class="hljs-property">background</span> = <span class="hljs-string">&#x27;pink&#x27;</span><br>    &#125;,<span class="hljs-number">2000</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><p>2）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>]<br>不用箭头函数：<br><span class="hljs-keyword">const</span> result = arr.<span class="hljs-title function_">fliter</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">item</span>)&#123;<br>     <span class="hljs-keyword">if</span>(item % <span class="hljs-number">2</span> === <span class="hljs-number">0</span>)&#123;<br>         <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>     &#125;<span class="hljs-keyword">else</span>&#123;<br>         <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>     &#125;<br>&#125;)<br>使用箭头函数：<br>分析：省去大括号说明只有一条语句，这是个判断那说明是个<span class="hljs-keyword">if</span>语句判断，真则<span class="hljs-literal">true</span>否则<span class="hljs-literal">false</span><br><span class="hljs-keyword">const</span> result = arr.<span class="hljs-title function_">fliter</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item % <span class="hljs-number">2</span> === <span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p><strong>4）总结：</strong></p><p>使用场景：箭头函数适合与this无关的回调、定时器、数组的方法回调</p><p>​                   不适合与this有关的回调、事件回调、对象的方法</p><p>原因：不想与es5中原本this指向规则冲突，但不适合不代表不能用</p></blockquote><h4 id="8-知识点补充"><a href="#8-知识点补充" class="headerlink" title="8.知识点补充"></a>8.知识点补充</h4><p><strong>this指向的补充</strong></p><blockquote><p><strong>在不使用箭头函数</strong>和call、apply、bind的情况下，这些this的指向，当我们调用函数的时候是确定的。调用函数的不同决定了this指向的不同。</p><p><img src="/2023/03/04/ES%E6%96%B0%E7%89%B9%E6%80%A7/this%E7%9A%84%E6%8C%87%E5%90%91.png" alt="this的指向"><br>总结：也就是除了指明对象和事件的，其他都是window</p></blockquote><h4 id="9-函数参数的默认设置"><a href="#9-函数参数的默认设置" class="headerlink" title="9.函数参数的默认设置"></a>9.函数参数的默认设置</h4><blockquote><p>1）允许给函数参数赋缺省值，形参初始值一般放最后面，和c++一样</p><p>应用场景：和解构赋值结合在一起，目的是不现在函数内 多次写对象名</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">connect</span>(<span class="hljs-params">&#123;host=<span class="hljs-string">&#x27;127.0.0.1&#x27;</span>,username,password,port&#125;</span>)&#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(host)<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(username)<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(password)<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(port)<br>&#125;<br><span class="hljs-title function_">connect</span>(&#123;<br> <span class="hljs-attr">host</span>:<span class="hljs-string">&#x27;zhoujie.com&#x27;</span>,<br> <span class="hljs-attr">username</span>:<span class="hljs-string">&#x27;zhoujie&#x27;</span>,<br> <span class="hljs-attr">password</span>:<span class="hljs-string">&#x27;123&#x27;</span>,<br> <span class="hljs-attr">port</span>:<span class="hljs-string">&#x27;4200&#x27;</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>2）引入rest来获取函数实参，以代替arguments，表示剩余的实参，即三个点…</p><p>语法：必须放最后，且前面要有…，可以任意命名，一般取名为args</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params">a,b,...args</span>)&#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a)<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(b)<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(args)<br>&#125;<br><span class="hljs-title function_">fn</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>)<br></code></pre></td></tr></table></figure></blockquote><h4 id="10-扩展运算符的介绍"><a href="#10-扩展运算符的介绍" class="headerlink" title="10.扩展运算符的介绍"></a>10.扩展运算符的介绍</h4><blockquote><p>定义：[…]扩展运算符 可以将 [数组] 转换为逗号分隔的 [参数序列]</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> tfboys = [<span class="hljs-string">&#x27;易烊千玺&#x27;</span>，<span class="hljs-string">&#x27;王源&#x27;</span>，<span class="hljs-string">&#x27;王俊凯&#x27;</span>]<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">chunwan</span>(<span class="hljs-params"></span>)&#123;<br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">arguments</span>)<br>&#125;<br><span class="hljs-title function_">chunwan</span>(...tfboys)<span class="hljs-comment">//&#x27;易烊千玺&#x27;，&#x27;王源&#x27;，&#x27;王俊凯&#x27;</span><br></code></pre></td></tr></table></figure><p>与rest参数的区别：rest参数是放到形参上，而扩展运算符放在实参上</p><p>应用：</p><ul><li><p>数组的合并</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> kuaizi = [<span class="hljs-string">&#x27;王太利&#x27;</span>，<span class="hljs-string">&#x27;肖央&#x27;</span>]<br><span class="hljs-keyword">const</span> fenghuang = [<span class="hljs-string">&#x27;曾毅&#x27;</span>，<span class="hljs-string">&#x27;玲花&#x27;</span>]<br><span class="hljs-keyword">const</span> zuixuanxiaopingguo = [...kuaizi,...fenghuang]<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(zuixuanxiaopingguo)<span class="hljs-comment">//[&#x27;王太利&#x27;，&#x27;肖央&#x27;,&#x27;曾毅&#x27;，&#x27;玲花&#x27;]</span><br></code></pre></td></tr></table></figure></li><li><p>数组的克隆（浅拷贝）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> sanzhihua = [<span class="hljs-string">&#x27;E&#x27;</span>,<span class="hljs-string">&#x27;G&#x27;</span>,<span class="hljs-string">&#x27;M&#x27;</span>]<br><span class="hljs-keyword">const</span> sanyecao = [...sanzhihua]<br></code></pre></td></tr></table></figure></li><li><p>将伪数组转化为真数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;div&gt;&lt;/div&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="hljs-keyword">const</span> divs = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">&#x27;div&#x27;</span>)<br><span class="hljs-keyword">const</span> divArr = [...divs]<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(divArr)<span class="hljs-comment">//拥有数组的方法</span><br></code></pre></td></tr></table></figure><p><strong>什么是伪数组？</strong></p><p>没有继承Array.prototype，没有数组该有的方法，常见的比如 arguments,querySelectorAll获取的list</p></li></ul></blockquote><h4 id="11-Symbol的基本使用"><a href="#11-Symbol的基本使用" class="headerlink" title="11.Symbol的基本使用"></a>11.Symbol的基本使用</h4><blockquote><p>1）定义：ES6引入的新的基本数据类型，表示独一无二的值，类似于字符串</p><p>2）特点：</p><ul><li>Symbol的值是唯一的，用来解决命名冲突的问题（但是如果用Symbol.for创建对象，内容一样，则地址是一样的，为了节省空间）</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> s = <span class="hljs-title class_">Symbol</span>()<br><span class="hljs-keyword">let</span> s1 = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;zhoujie&#x27;</span>)<br><span class="hljs-keyword">let</span> s2 = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;zhoujie&#x27;</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(s1 === s2)<span class="hljs-comment">//false</span><br><span class="hljs-keyword">let</span> s3 = <span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">for</span>(<span class="hljs-string">&#x27;zhoujie&#x27;</span>)<br><span class="hljs-keyword">let</span> s4 = <span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">for</span>(<span class="hljs-string">&#x27;zhoujie&#x27;</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(s3 === s4)<span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure><ul><li>Symbol的值不能与其他数据类型进行运算</li><li>Symbol定义的对象属性不能使用for…in循环，但是可以使用Reflect.ownKeys来获取所有键名</li></ul><p>3）使用场景：向对象中添加方法（假设不确定被添加的对象中有没有此方法）,调用不是很方便，要通过键值对</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//第一种</span><br><span class="hljs-keyword">let</span> game = &#123;...&#125;<span class="hljs-comment">//假设不确定被添加的对象中有没有此方法</span><br><br><span class="hljs-comment">//声明一个对象</span><br><span class="hljs-keyword">let</span> methods = &#123;<br>     <span class="hljs-attr">up</span>:<span class="hljs-title class_">Symbol</span>(),<br>     <span class="hljs-attr">down</span>:<span class="hljs-title class_">Symbol</span>()<br>&#125;<br>game[method.<span class="hljs-property">up</span>] = <span class="hljs-keyword">function</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;上升&#x27;</span>)<br>&#125;<br>game[method.<span class="hljs-property">down</span>] = <span class="hljs-keyword">function</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;下降&#x27;</span>)<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(game)<span class="hljs-comment">//会在原有基础上添加两个名为Symbol()的函数，把Symbol()当作字符串即可，它会保证不一样，    这样不管原来有没有此方法都可以安全添加</span><br><br><span class="hljs-comment">//第二种</span><br><span class="hljs-keyword">let</span> youxi = &#123;<br>    <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;狼人杀&#x27;</span>，<br>    [<span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;say&#x27;</span>)]:<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<span class="hljs-comment">//Symbol()这是一个表达式，是动态的值不能作为名字，估计真正使用的时候才会定下来，因此外面需要加[]给它固定值</span><br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;我可以发言&#x27;</span>)<br>    &#125;<br>    [<span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;zibao&#x27;</span>)]:<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;我可以自爆&#x27;</span>)<br>    &#125;<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(youxi)<br></code></pre></td></tr></table></figure><p>4）Symbol的内置属性</p><ul><li><p>hasInstance，当别的对象用instanceof判断是否是当前对象（类）的实例时，就会自动调用当前对象 名为 [Symbol.hasInstance]的方法—-用执行当前类方法来表示当前类有实例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br>    <span class="hljs-keyword">static</span> [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">hasInstance</span>](param)&#123;<span class="hljs-comment">//还可以将obj对象传过来</span><br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(param)<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;我被用来检测类型了！&#x27;</span>)<br>    &#125;<br>&#125;<br><span class="hljs-keyword">let</span> obj = &#123;&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Person</span>)<br><span class="hljs-comment">// &#123;&#125;</span><br><span class="hljs-comment">// 我被用来检测类型了！</span><br></code></pre></td></tr></table></figure></li><li><p>isConcatSpreadable，布尔值，表示是否可以被展开，当使用数组的concat方法时才有效</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr1 = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br><span class="hljs-keyword">let</span> arr2 = [<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]<br>arr2[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">isConcatSpreadable</span>] = <span class="hljs-literal">false</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-property">concat</span>)<br></code></pre></td></tr></table></figure></li></ul></blockquote><h4 id="12-迭代器（iterator）"><a href="#12-迭代器（iterator）" class="headerlink" title="12.迭代器（iterator）"></a>12.迭代器（iterator）</h4><blockquote><p>1）for…of和for…in的区别：前者得到的是元素，后者得到的是下标</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js">     <span class="hljs-keyword">const</span> xiyou = [<span class="hljs-string">&#x27;孙悟空&#x27;</span>,<span class="hljs-string">&#x27;猪八戒&#x27;</span>,<span class="hljs-string">&#x27;唐僧&#x27;</span>,<span class="hljs-string">&#x27;沙僧&#x27;</span>]<br><br>     <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> item <span class="hljs-keyword">of</span> xiyou)&#123;<br>         <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(item)<br>     &#125;<br><br>     <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> item <span class="hljs-keyword">in</span> xiyou)&#123;<br>         <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(item)<br>     &#125;<br>结果：<br>孙悟空<br>猪八戒<br>唐僧<br>沙僧<br><span class="hljs-number">0</span><br><span class="hljs-number">1</span><br><span class="hljs-number">2</span><br><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>2）原理</p><p>在数组里有个 Symbol(Symbol.iterator):values() ，是个函数，它返回的对象（是个容器）有next()方法每调用一次都会通过指针往后指一个。next()对象是由两个属性组成的对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> xiyou = [<span class="hljs-string">&#x27;孙悟空&#x27;</span>,<span class="hljs-string">&#x27;猪八戒&#x27;</span>,<span class="hljs-string">&#x27;唐僧&#x27;</span>,<span class="hljs-string">&#x27;沙僧&#x27;</span>]<br><span class="hljs-keyword">let</span> iterator =  xiyou[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>]()<br><span class="hljs-variable language_">console</span>,<span class="hljs-title function_">log</span>(iterator.<span class="hljs-title function_">next</span>())<br><span class="hljs-variable language_">console</span>,<span class="hljs-title function_">log</span>(iterator.<span class="hljs-title function_">next</span>())<br><span class="hljs-variable language_">console</span>,<span class="hljs-title function_">log</span>(iterator.<span class="hljs-title function_">next</span>())<br><span class="hljs-variable language_">console</span>,<span class="hljs-title function_">log</span>(iterator.<span class="hljs-title function_">next</span>())<br><span class="hljs-variable language_">console</span>,<span class="hljs-title function_">log</span>(iterator.<span class="hljs-title function_">next</span>())<br><span class="hljs-comment">//结果：done指的是是否已迭代完成</span><br>&#123;<span class="hljs-attr">value</span>: <span class="hljs-string">&#x27;孙悟空&#x27;</span>, <span class="hljs-attr">done</span>: <span class="hljs-literal">false</span>&#125;<br>&#123;<span class="hljs-attr">value</span>: <span class="hljs-string">&#x27;猪八戒&#x27;</span>, <span class="hljs-attr">done</span>: <span class="hljs-literal">false</span>&#125;<br>&#123;<span class="hljs-attr">value</span>: <span class="hljs-string">&#x27;唐僧&#x27;</span>, <span class="hljs-attr">done</span>: <span class="hljs-literal">false</span>&#125;<br>&#123;<span class="hljs-attr">value</span>: <span class="hljs-string">&#x27;沙僧&#x27;</span>, <span class="hljs-attr">done</span>: <span class="hljs-literal">false</span>&#125;<br>&#123;<span class="hljs-attr">value</span>: <span class="hljs-literal">undefined</span>, <span class="hljs-attr">done</span>: <span class="hljs-literal">true</span>&#125;<br></code></pre></td></tr></table></figure><p>3）自定义遍历数据（相当于重写，将length和value换掉即可）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> num = &#123;<br> <span class="hljs-attr">name</span>:<span class="hljs-string">&quot;数字&quot;</span>,<br> <span class="hljs-attr">stus</span>:[<br>     <span class="hljs-string">&#x27;1&#x27;</span>,<br>     <span class="hljs-string">&#x27;2&#x27;</span>,<br>     <span class="hljs-string">&#x27;3&#x27;</span>,<br>     <span class="hljs-string">&#x27;4&#x27;</span><br> ],<br> <span class="hljs-comment">//下面是手动添加的  </span><br> [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>]()&#123;<br>     <span class="hljs-comment">//索引变量</span><br>     <span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span><br>     <br>     <span class="hljs-keyword">let</span> _this = <span class="hljs-variable language_">this</span><br>     <span class="hljs-keyword">return</span>&#123;<br>         <span class="hljs-attr">next</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>             <span class="hljs-keyword">if</span>(index &lt; _this.<span class="hljs-property">stus</span>.<span class="hljs-property">length</span>)&#123;<br>                  <span class="hljs-keyword">let</span> result = &#123; <span class="hljs-attr">value</span>:_this.<span class="hljs-property">stus</span>[index] , <span class="hljs-attr">done</span>:<span class="hljs-literal">false</span>&#125;<br><br>                  index++<br>                  <span class="hljs-keyword">return</span> result<br>             &#125;<span class="hljs-keyword">else</span>&#123;<br>                 <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">value</span>:<span class="hljs-literal">undefined</span>, <span class="hljs-attr">done</span>:<span class="hljs-literal">true</span>&#125;<br>             &#125;<br>         &#125;<br>     &#125;<br> &#125;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> item <span class="hljs-keyword">of</span> num)&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(item)<br>&#125;<br><span class="hljs-comment">//结果：</span><br><span class="hljs-number">1</span><br><span class="hljs-number">2</span><br><span class="hljs-number">3</span><br><span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p><strong>迭代器和foe循环的关系：</strong>for…of可以直接返回迭代器中value的值，也就是说迭代器是for循环的内部实现</p></blockquote><h4 id="13-生成器"><a href="#13-生成器" class="headerlink" title="13.生成器"></a>13.生成器</h4><blockquote><p>1）定义：一种特殊的函数，用于创建自定义迭代器对象</p><p>2）语法：在function和函数名之间加一个 *  </p><p>3）yield关键字：会将生成器函数代码进行分割，每次使用next执行的时候碰到一个yield都会暂停（yield后者一条语句也会执行）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> * <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;111&#x27;</span>);<br>   <span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;一直没有耳朵&#x27;</span>;<br>   <span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;一只没有眼睛&#x27;</span>;<br>   <span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;真奇怪&#x27;</span>;<br>&#125;<br><span class="hljs-keyword">let</span> tiger = <span class="hljs-title function_">fn</span>()<br><span class="hljs-comment">// tiger.next()</span><br><span class="hljs-comment">// tiger.next()</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> item <span class="hljs-keyword">of</span> tiger)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(item);<br>&#125;<br></code></pre></td></tr></table></figure><p>4）参数传递：next里也可以传递参数，它将作为前一个yield（相对于当前next迭代停止的yield）的返回值（而不是yield后面的值）</p><p>​      为什么是前一个？因为 next每次碰到yield都会停止，这时不好执行，必须到下一个yield才可把给上一个yield赋返回值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> * <span class="hljs-title function_">gen</span>(<span class="hljs-params">arg</span>)&#123;<br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arg);<br> <span class="hljs-keyword">let</span> one = <span class="hljs-keyword">yield</span> <span class="hljs-number">111</span>;<br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(one);<br> <span class="hljs-keyword">let</span> two = <span class="hljs-keyword">yield</span> <span class="hljs-number">222</span>;<br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(two);<br> <span class="hljs-keyword">let</span> three = <span class="hljs-keyword">yield</span> <span class="hljs-number">333</span>;<br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(three);<br> <span class="hljs-keyword">let</span> four = <span class="hljs-keyword">yield</span> <span class="hljs-number">444</span>;<br>&#125;<br><span class="hljs-keyword">let</span> iterator = <span class="hljs-title function_">gen</span>(<span class="hljs-string">&#x27;AAA&#x27;</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iterator.<span class="hljs-title function_">next</span>());<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iterator.<span class="hljs-title function_">next</span>(<span class="hljs-string">&#x27;BBB&#x27;</span>));<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iterator.<span class="hljs-title function_">next</span>(<span class="hljs-string">&#x27;CCC&#x27;</span>));<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iterator.<span class="hljs-title function_">next</span>(<span class="hljs-string">&#x27;DDD&#x27;</span>));<br><span class="hljs-comment">//结果：</span><br><span class="hljs-variable constant_">AAA</span><br><span class="hljs-attr">value</span>: <span class="hljs-number">111</span>, <span class="hljs-attr">done</span>: <span class="hljs-literal">false</span>&#125;<br><span class="hljs-variable constant_">BBB</span><br>&#123;<span class="hljs-attr">value</span>: <span class="hljs-number">222</span>, <span class="hljs-attr">done</span>: <span class="hljs-literal">false</span>&#125;<br><span class="hljs-variable constant_">CCC</span><br>&#123;<span class="hljs-attr">value</span>: <span class="hljs-number">333</span>, <span class="hljs-attr">done</span>: <span class="hljs-literal">false</span>&#125;<br><span class="hljs-variable constant_">DDD</span><br>&#123;<span class="hljs-attr">value</span>: <span class="hljs-number">444</span>, <span class="hljs-attr">done</span>: <span class="hljs-literal">false</span>&#125;<br></code></pre></td></tr></table></figure><p>5）对异步编程的影响</p><p>异步任务：文件操作、网络操作(ajax、request)、数据库操作</p><p>回调地狱：回调函数层层嵌套调用，代码复杂</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js">需求：1s 输出 <span class="hljs-number">111</span>，再过2s输出 <span class="hljs-number">222</span>，再过3s输出<span class="hljs-number">333</span><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">111</span>)<br> <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">222</span>)<br>      <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">333</span>)<br>      &#125;,<span class="hljs-number">3000</span>)<br> &#125;,<span class="hljs-number">2000</span>)<br>&#125;,<span class="hljs-number">1000</span>)<br>为什么要嵌套？<br>因为要再过几秒，因此是在上面的基础上<br></code></pre></td></tr></table></figure><p>6）示例</p><ul><li>使用生成器函数解决回调地狱：生成器函数与其他函数来回调用，这时next就相当于指挥部，来指出下个调用哪个。</li></ul><p>​       实质：简单来说，就是通过生成器函数将多个定时器分开调用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">one</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">111</span>)<br>        iterator.<span class="hljs-title function_">next</span>()<br>    &#125;,<span class="hljs-number">1000</span>)<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">two</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">222</span>)<br>        iterator.<span class="hljs-title function_">next</span>()<br>    &#125;,<span class="hljs-number">2000</span>)<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">three</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">333</span>)<br>        iterator.<span class="hljs-title function_">next</span>()<br>    &#125;,<span class="hljs-number">3000</span>)<br>&#125;<br><span class="hljs-keyword">function</span> * <span class="hljs-title function_">gen</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">yield</span> <span class="hljs-title function_">one</span>();<br>    <span class="hljs-keyword">yield</span> <span class="hljs-title function_">two</span>();<br>    <span class="hljs-keyword">yield</span> <span class="hljs-title function_">three</span>();<br>&#125;<br><span class="hljs-keyword">let</span> iterator = <span class="hljs-title function_">gen</span>()<br>iterator.<span class="hljs-title function_">next</span>()<br></code></pre></td></tr></table></figure><ul><li><p>三个任务：获取用户数据、获取订单、获取商品，这三个任务都是1s执行，因此有异步问题，我要确保这三个任务是按顺序来执行的，这三个任务执行后还可以把数据返回，可以使用生成器来解决</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getUsers</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>        <span class="hljs-keyword">let</span> data = <span class="hljs-string">&#x27;用户数据&#x27;</span><br>        iterator.<span class="hljs-title function_">next</span>(data)<br>    &#125;,<span class="hljs-number">1000</span>)<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getOrders</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>        <span class="hljs-keyword">let</span> data = <span class="hljs-string">&#x27;订单数据&#x27;</span><br>        iterator.<span class="hljs-title function_">next</span>(data)<br>    &#125;,<span class="hljs-number">1000</span>)<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getGoods</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>        <span class="hljs-keyword">let</span> data = <span class="hljs-string">&#x27;商品数据&#x27;</span><br>        iterator.<span class="hljs-title function_">next</span>(data)<br>    &#125;,<span class="hljs-number">1000</span>)<br>&#125;<br><span class="hljs-keyword">function</span> * <span class="hljs-title function_">gen</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">let</span> users = <span class="hljs-keyword">yield</span> <span class="hljs-title function_">getUsers</span>();<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(users)<br>    <span class="hljs-keyword">let</span> orders = <span class="hljs-keyword">yield</span> <span class="hljs-title function_">getOrders</span>();<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(orders)<br>    <span class="hljs-keyword">let</span> goods = <span class="hljs-keyword">yield</span> <span class="hljs-title function_">getGoods</span>();<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(goods)<br>&#125;<br><span class="hljs-keyword">let</span> iterator = <span class="hljs-title function_">gen</span>()<br>iterator.<span class="hljs-title function_">next</span>()<br></code></pre></td></tr></table></figure></li></ul></blockquote><h4 id="14-Promise"><a href="#14-Promise" class="headerlink" title="14.Promise"></a>14.Promise</h4><blockquote><p>1）基本介绍与使用</p><ul><li><p>介绍</p><p>解决异步编程的方案，他是一个构造函数，它封装了 异步操作并可以获取其成功或失败的结果</p></li><li><p>基本使用</p><p>过程：由Promise参数函数的两个参数（只能调用一个）来决定p的状态（初始化、失败、成功），然后p通过then进行回调，第一个函数是成功时执行并返回数据，第二个函数失败时调用的函数并返回数据</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve,reject</span>)&#123;<br>            <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>                <span class="hljs-comment">// let data = &#x27;数据库中的数据&#x27;</span><br>                <span class="hljs-comment">// resolve(data)</span><br>                <span class="hljs-keyword">let</span> error = <span class="hljs-string">&#x27;数据读取失败&#x27;</span><br>                <span class="hljs-title function_">reject</span>(error)<br>            &#125;,<span class="hljs-number">1000</span>)<br>       &#125;)<br><br>p.<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">value</span>)=&gt;</span>&#123;<br>     <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value)<br>&#125;,<span class="hljs-function">(<span class="hljs-params">reason</span>)=&gt;</span>&#123;<br>     <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reason)<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>2）封装读取操作</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 1.导入模块</span><br><span class="hljs-keyword">let</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;fs&quot;</span>)<br><br><span class="hljs-comment">// 2.调用方法读取文件</span><br><span class="hljs-comment">// fs.readFile(&#x27;C://Users//K22070055//Desktop//部署流程//项目从git上到部署完成的流程.txt&#x27;,(error,data)=&gt;&#123;</span><br>     <br><span class="hljs-comment">//    if(error) throw error</span><br><br><span class="hljs-comment">//    console.log(data.toString());</span><br><span class="hljs-comment">// &#125;)</span><br><br><span class="hljs-comment">// 3.使用promise封装</span><br><span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br><br>     fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;C:1//Users//K22070055//Desktop//部署流程//项目从git上到部署完成的流程.txt&#x27;</span>,<span class="hljs-function">(<span class="hljs-params">error,data</span>)=&gt;</span>&#123;<br>     <br>     <span class="hljs-keyword">if</span>(error) <span class="hljs-title function_">reject</span>(error)<br><br>     <span class="hljs-title function_">resolve</span>(data)<br><br>    &#125;)<br><br>&#125;)<br><br>p.<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">value</span>)=&gt;</span>&#123;<br>   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value.<span class="hljs-title function_">toString</span>())<br>&#125;,<span class="hljs-function">(<span class="hljs-params">reason</span>)=&gt;</span>&#123;<br>   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;读取失败&#x27;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><p>3）封装ajax请求（代码更清晰）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> p =<span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(resolve,reject) =&gt; &#123;<br>  <span class="hljs-comment">//1.创建对象</span><br>  <span class="hljs-keyword">const</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>()<br>  <br>  <span class="hljs-comment">//2.初始化</span><br>  xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;GET&#x27;</span>,<span class="hljs-string">&#x27;api&#x27;</span>)<br>    <br>  <span class="hljs-comment">//3.发送</span><br>  xhr.<span class="hljs-title function_">send</span>()<br>    <br>  <span class="hljs-comment">//4.绑定事件，处理响应结果</span><br>  xhr.<span class="hljs-property">onreadystatechange</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>      <span class="hljs-comment">//判断</span><br>      <span class="hljs-keyword">if</span>(xhr.<span class="hljs-property">readyState</span> === <span class="hljs-number">4</span>)&#123;<br>          <span class="hljs-comment">//判断响应状态码 200-299</span><br>          <span class="hljs-keyword">if</span>(xhr.<span class="hljs-property">status</span> &gt;= <span class="hljs-number">200</span> &amp;&amp; xhr.<span class="hljs-property">status</span> &lt; <span class="hljs-number">300</span>)&#123;<br>              <span class="hljs-title function_">resolve</span>(xhr.<span class="hljs-property">response</span>)<br>          &#125;<span class="hljs-keyword">else</span>&#123;<br>              <span class="hljs-title function_">reject</span>(xhr.<span class="hljs-property">status</span>)<br>          &#125;<br>      &#125;<br>  &#125;<br>&#125;<br><br>p.<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">value</span>)=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value)<br>&#125;,<span class="hljs-function">(<span class="hljs-params">reason</span>)=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(reason)<br>&#125;)<br></code></pre></td></tr></table></figure><p>4）Promise的then方法：返回值仍然是个Promise对象，其状态是由回调函数执行结果决定</p><p>​      规则：1.若回调函数返回值是个 非Promise对象，则 状态为成功，返回值为对象的成功值</p><p>​                  2.若回调函数返回值是个Promise对象，则 内部promise返回的状态 等于 外部then返回对象的状态</p><p>​                  3.用throw抛出错误，则then状态也为失败</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> resulr = p.<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">value</span>)=&gt;</span>&#123;<br>    <span class="hljs-comment">//1.非promise类型，则返回promise的状态为成功，因为有具体的值</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;i love you&#x27;</span><br>    <span class="hljs-comment">//2.promise类型</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>        <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;ok&#x27;</span>)<br>       <span class="hljs-comment">// reject(&#x27;fail&#x27;)</span><br>    &#125;)<br>    <span class="hljs-comment">//3.抛出错误</span><br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;出错啦！&#x27;</span>)<br>&#125;,<span class="hljs-function">(<span class="hljs-params">reason</span>)=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(reason)<br>&#125;)<br><br><span class="hljs-comment">//既然then返回的还是promise对象，则可以使用链式调用，逐步解决一个个异步任务</span><br><br>p.<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">value</span>)=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value)<br>&#125;,<span class="hljs-function">(<span class="hljs-params">reason</span>)=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(reason)<br>&#125;).<span class="hljs-property">p</span>.<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">value</span>)=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value)<br>&#125;,<span class="hljs-function">(<span class="hljs-params">reason</span>)=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(reason)<br>&#125;)<br></code></pre></td></tr></table></figure><p>本质：返回非promise对象就直接出结果了，否则继续使用链式调用</p><p>5）实践：多个文件内容读取</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>)<br><br><span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>     <br>     fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;C://Users//K22070055//Desktop//部署流程//K8S &amp; docker &amp;  rancher.txt&#x27;</span>,<span class="hljs-function">(<span class="hljs-params">err,data</span>)=&gt;</span>&#123;<br>          <br>          <span class="hljs-keyword">if</span>(err) <span class="hljs-title function_">reject</span>(err)<br><br>          <span class="hljs-title function_">resolve</span>(data)<br>     &#125;)<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">value</span>)=&gt;</span>&#123;<br>   <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br><br>          fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;C://Users//K22070055//Desktop//部署流程//项目从git上到部署完成的流程.txt&#x27;</span>,<span class="hljs-function">(<span class="hljs-params">err,data</span>)=&gt;</span>&#123;<br>              <br>          <span class="hljs-keyword">if</span>(err) <span class="hljs-title function_">reject</span>(err)<br>      <br>          <span class="hljs-title function_">resolve</span>([value,data])<br>       &#125;)<br>   &#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">value</span>)=&gt;</span>&#123;<br>       <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value.<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;\r\n&#x27;</span>))<br>   &#125;,<span class="hljs-function">(<span class="hljs-params">reason</span>)=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(reason)<br> &#125;)<br>&#125;,<span class="hljs-function">(<span class="hljs-params">reason</span>)=&gt;</span>&#123;<br>   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(reason)<br>&#125;)<br></code></pre></td></tr></table></figure></blockquote><h4 id="15-Set（自动去重）、Map"><a href="#15-Set（自动去重）、Map" class="headerlink" title="15.Set（自动去重）、Map"></a>15.Set（自动去重）、Map</h4><blockquote><p>Set方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">size</span>()<br><span class="hljs-title function_">add</span>()<br><span class="hljs-title function_">delete</span>()<br><span class="hljs-title function_">has</span>()<br><span class="hljs-title function_">clear</span>()<br></code></pre></td></tr></table></figure><p>Map方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">size</span>()<br><span class="hljs-title function_">set</span>(键,值)<br><span class="hljs-title function_">get</span>()<br><span class="hljs-title function_">has</span>()<br><span class="hljs-title function_">clear</span>()<br></code></pre></td></tr></table></figure></blockquote><h4 id="16-Class"><a href="#16-Class" class="headerlink" title="16.Class"></a>16.Class</h4><blockquote><p>1）使用和java中一摸一样，只有构造函数名字是需要一定是constructor</p><p>2）提一下 static 在原本ES5中的实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Phone</span>(<span class="hljs-params"></span>)&#123;<br> <br>&#125;<br><span class="hljs-title class_">Phone</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;手机&#x27;</span><br><span class="hljs-title class_">Phone</span>.<span class="hljs-property">change</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;我可以改变世界&quot;</span>)<br>&#125;<br>这里添加的name、change都是构造函数<span class="hljs-title class_">Phone</span>的静态成员，把<span class="hljs-title class_">ES5</span>中的函数名看成类型就行<br>注意：<span class="hljs-title class_">ES5</span>中静态方法实例是访问不到的，因为这是放在构造函数里面的，不走原型链<br></code></pre></td></tr></table></figure><p>3）继承与java对比的小区别：</p><ul><li><p>ES6用super代替ES5的call帮助子类初始化</p></li><li><p>属性放在实例里，方法还自动是放 它隐式原型指向的对象上，而父方法放在则放在 再上一层隐式原型指向的对象上——即方法的保存还是遵循ES5，只是用法变了</p></li></ul><p>4）重写与java对比的小区别</p><ul><li>子类可以直接写再写一遍父类的方法，然后对内容进行重写，不需要override标识符</li></ul><p>5）get和set与java对比的小区别</p><ul><li>get/set 关键字后面 是 属性/方法 名字，而java中 get/set和名字写在一起，比如setName</li></ul></blockquote><h4 id="17-数值扩展"><a href="#17-数值扩展" class="headerlink" title="17.数值扩展"></a>17.数值扩展</h4><blockquote><ul><li><p>Number.EPSILON 是 js 的最小精度</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">equal</span>(<span class="hljs-params">a,b</span>)&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">abs</span>(a-b) &lt; <span class="hljs-title class_">Number</span>.<span class="hljs-property">EPSILON</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>进制表示（0b—二进制，0o—八进制，0x—十六进制），直接写在数的前面，表示是对应进制的数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-number">0b1010</span><br><span class="hljs-number">0o777</span><br><span class="hljs-number">0xfff</span><br></code></pre></td></tr></table></figure></li><li><p>Number.finite()，检测是否是有限的数</p></li><li><p>Number.isNaN()</p></li><li><p>Number.parseInt()</p></li><li><p>Number.isInteger()</p></li><li><p>Math.trunc()，可以将数值小数部分去掉</p></li><li><p>Math.sign()，判断是否是正数</p></li></ul></blockquote><h4 id="18-对象扩展"><a href="#18-对象扩展" class="headerlink" title="18.对象扩展"></a>18.对象扩展</h4><blockquote><ul><li><p>Object.is(obj1,obj2) ——- 判断两个对象是否完全相等（任意对象），更加简单、准确，比如两个NaN直接用===就不相等，而Object.is却相等</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">is</span>(<span class="hljs-number">120</span>,<span class="hljs-number">121</span>))<span class="hljs-comment">//false</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">is</span>(<span class="hljs-title class_">NaN</span>,<span class="hljs-title class_">NaN</span>))<span class="hljs-comment">//true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">is</span>(<span class="hljs-title class_">NaN</span> === <span class="hljs-title class_">NaN</span>))<span class="hljs-comment">//false</span><br></code></pre></td></tr></table></figure></li><li><p>Object.assign(obj1,obj2) ——- 一样的属性，会用后面的更新，不一样的则保存</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> config1 = &#123;<br>    <span class="hljs-attr">host</span>:<span class="hljs-string">&#x27;127.0.0.1&#x27;</span>,<br>    <span class="hljs-attr">port</span>:<span class="hljs-number">3306</span>,<br>    <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;root&#x27;</span>,<br>    <span class="hljs-attr">pass</span>:<span class="hljs-string">&#x27;root&#x27;</span>,<br>    <span class="hljs-attr">test</span>:<span class="hljs-string">&#x27;test&#x27;</span><br>&#125;<br><span class="hljs-keyword">const</span> config2 = &#123;<br>    <span class="hljs-attr">host</span>:<span class="hljs-string">&#x27;128.0.0.1&#x27;</span>,<br>    <span class="hljs-attr">port</span>:<span class="hljs-number">3307</span>,<br>    <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;root1&#x27;</span>,<br>    <span class="hljs-attr">pass</span>:<span class="hljs-string">&#x27;root1&#x27;</span>,<br>    <span class="hljs-attr">test1</span>:<span class="hljs-string">&#x27;test1&#x27;</span><br>&#125;<br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(config1,config2)<br></code></pre></td></tr></table></figure></li><li><p>Object.setPrototype、Object.getPrototype 设置/获取原型对象，一般不这么设置，效率低下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> school = &#123;<br>     <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;just&#x27;</span><br>&#125;<br><span class="hljs-keyword">const</span> s = &#123;<br>     <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;s&#x27;</span><br>&#125;<br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">setPrototypeOf</span>(school,s)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(school));<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(school);<br></code></pre></td></tr></table></figure></li></ul></blockquote><h4 id="19-模块化"><a href="#19-模块化" class="headerlink" title="19.模块化"></a>19.模块化</h4><blockquote><p>1）ES6之前的规范</p><ul><li>CommonJS  =&gt; NodeJS、Browserfy</li><li>AMD             =&gt; requireJS</li><li>CMD             =&gt; seaJS</li></ul><p>2）ES6模块化语法一</p><p>​        <strong>暴露方式</strong></p><p>​        <u>分别暴露：只单独暴露某个数据</u></p><ul><li><p>export 规定模块的对外接口—–放在js文件中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">let</span> sss = &#123;<br>    <span class="hljs-attr">school</span>:<span class="hljs-string">&#x27;just&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>import 导入其他模块的功能，语法格式如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script type=<span class="hljs-string">&#x27;module&#x27;</span>&gt;<span class="hljs-comment">//表示会引入模块</span><br>    <span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> m1 <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;路径&quot;</span><br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p><u>统一暴露</u></p><p>暴露接口时用{}放入所有数据</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> data1 = <span class="hljs-number">8</span><br><br><span class="hljs-keyword">let</span> <span class="hljs-title function_">data2</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;data2&#x27;</span>)<br>&#125;<br><br><span class="hljs-keyword">export</span>&#123;data1,data2&#125;<br></code></pre></td></tr></table></figure><p><u>默认暴露</u></p><p>导入时需要多写个default，表示这个通过默认暴露的数据，就相当于类名</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span>&#123;<br>    <span class="hljs-attr">school</span>:<span class="hljs-string">&#x27;just&#x27;</span>,<br>    <span class="hljs-attr">change</span>:<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;change~&#x27;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> m3 <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;...&#x27;</span><br>m3.<span class="hljs-property">default</span>.<span class="hljs-title function_">change</span>()<br></code></pre></td></tr></table></figure><p><strong>导入方式</strong></p><p><u>前面都是通用的导入方式</u></p><p><u>解构赋值方式</u></p><p>选择模块中其中几个（对象属性名要一致，要不然不知道选哪个）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; school, teach&#125; <span class="hljs-keyword">from</span> &#123;...&#125;<br><span class="hljs-keyword">import</span> &#123; school <span class="hljs-keyword">as</span> just, findJob&#125; <span class="hljs-keyword">from</span> &#123;...&#125;<span class="hljs-comment">//不能重名，可以用as起别名</span><br></code></pre></td></tr></table></figure><p>默认导入一定要起别名，因为引入的来自多个文件的数据，可能都是default数据，因此要区分</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123;<span class="hljs-keyword">default</span> <span class="hljs-keyword">as</span> m3&#125;<br></code></pre></td></tr></table></figure><p><u>简便形式</u></p><p>只针对默认暴露，为什么叫默认暴露，因为简便的默认引入就是针对他的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> school <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;...&#x27;</span><br></code></pre></td></tr></table></figure></li></ul><p>3）ES6模块化语法二</p><p>将 导入的语句 全部放在一个入口文件 .js 中，然后HTML文件中 再通过script引入，解偶了</p><p>4）模块化引入npm包</p><p>先用npm下载包，然后在js引入</p><p>5）babel对模块化的代码替换</p><p>由于并不是所有浏览器都像谷歌浏览器兼容性好，因此有时需要babel可将代码转换为ES5的代码。了解即可，后面webpack会做这些工作</p></blockquote><h3 id="ES7新特性"><a href="#ES7新特性" class="headerlink" title="ES7新特性"></a>ES7新特性</h3><h4 id="1-Arrary-prototype-include"><a href="#1-Arrary-prototype-include" class="headerlink" title="1.Arrary.prototype.include"></a>1.Arrary.prototype.include</h4><blockquote><p>1）前言：之前都是使用includeOf进行判断的某元素是否存在于数组之中，使用起来总有些不方便，返回值是一个数字，-1表示不存在</p><p>2）用法如下，返回值为布尔值，用于判断很方便</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> mingzhu = [<span class="hljs-string">&#x27;三国演义&#x27;</span>，<span class="hljs-string">&#x27;水浒传&#x27;</span>，<span class="hljs-string">&#x27;西游记&#x27;</span>,<span class="hljs-string">&#x27;红楼梦&#x27;</span>]<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(mingzhu.<span class="hljs-title function_">includes</span>(<span class="hljs-string">&#x27;三国演义&#x27;</span>))<span class="hljs-comment">//true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(mingzhu.<span class="hljs-title function_">includes</span>(<span class="hljs-string">&#x27;金瓶梅&#x27;</span>))<span class="hljs-comment">//false</span><br></code></pre></td></tr></table></figure></blockquote><h4 id="2-幂运算"><a href="#2-幂运算" class="headerlink" title="2.幂运算 **"></a>2.幂运算 **</h4><blockquote><p>1）用法如下，效果等同于Math.pow(2,10)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span> ** <span class="hljs-number">10</span>)<span class="hljs-comment">//1024</span><br></code></pre></td></tr></table></figure></blockquote><h3 id="ES8新特性"><a href="#ES8新特性" class="headerlink" title="ES8新特性"></a>ES8新特性</h3><h4 id="1-async和await"><a href="#1-async和await" class="headerlink" title="1.async和await"></a>1.async和await</h4><blockquote><p>1）介绍：async和await的结合使用可以让异步代码同步执行</p><p>2）async函数：用async修饰的函数</p><ul><li><p>返回值特性</p><p><u>如果返回值不是个promise对象，那么返回值就是一个（执行）成功的Promise</u></p><p><u>用throw抛出错误，则返回的是失败的Promise</u></p><p><u>如果返回值是个promise对象，那么返回值根据情况而定的Promise</u></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-comment">// return &#x27;尚硅谷&#x27;</span><br>  <span class="hljs-comment">//  throw new Error(&#x27;出错啦&#x27;)</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>      <span class="hljs-comment">// resolve(&#x27;Success&#x27;)</span><br>      <span class="hljs-title function_">reject</span>(<span class="hljs-string">&#x27;Failed&#x27;</span>)<br>  &#125;)<br>&#125;<br><br><span class="hljs-keyword">const</span> result = <span class="hljs-title function_">fn</span>()<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result)<br><br>result.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span>=&gt;</span>&#123;<br>   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);<br>&#125;,<span class="hljs-function"><span class="hljs-params">reason</span>=&gt;</span>&#123;<br>   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">warn</span>(reason);<br>&#125;)<br></code></pre></td></tr></table></figure><p>3）await表达式：后面接一个Promise对象，表达式整体返回值是成功的Promise结果值，如果这个Promise对象返回的是失败的值，则会报错，需要trycatch</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>  <span class="hljs-comment">//  resolve(&#x27;用户数据&#x27;)</span><br>  <span class="hljs-title function_">reject</span>(<span class="hljs-string">&#x27;失败啦&#x27;</span>)<br>&#125;)<br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">try</span>&#123;<br>    <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> p;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result);<br>  &#125;<span class="hljs-keyword">catch</span>(e)&#123;<br>    &#125;<br>&#125;<br><span class="hljs-title function_">main</span>()<br></code></pre></td></tr></table></figure><p>4）练习async和await读取文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>)<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">readHarvest</span>(<span class="hljs-params">params</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>    fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&quot;./my harvest.txt&quot;</span>,<span class="hljs-string">&#x27;utf8&#x27;</span>,<span class="hljs-function">(<span class="hljs-params">err,data</span>)=&gt;</span>&#123;<br>      <span class="hljs-comment">// 将err传给用reject，让这个异步任务在后面某个时候获取 </span><br>      <span class="hljs-keyword">if</span>(err) <span class="hljs-title function_">reject</span>(err) <br>      <span class="hljs-title function_">resolve</span>(data)<br>    &#125;)<br>  &#125;)<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">readREADME</span>(<span class="hljs-params">params</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>    fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&quot;./README.md&quot;</span>,<span class="hljs-string">&#x27;utf8&#x27;</span>,<span class="hljs-function">(<span class="hljs-params">err,data</span>)=&gt;</span>&#123;<br>      <span class="hljs-comment">// 将err传给用reject，让这个异步任务在后面某个时候获取 </span><br>      <span class="hljs-keyword">if</span>(err) <span class="hljs-title function_">reject</span>(err) <br>      <span class="hljs-title function_">resolve</span>(data)<br>    &#125;)<br>  &#125;)<br>&#125;<br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"></span>)&#123;<br>  <br>  <span class="hljs-comment">// 使用async + await可以使得原本是异步的代码想同步代码一样清晰</span><br><br>  <span class="hljs-keyword">const</span> harvest = <span class="hljs-keyword">await</span> <span class="hljs-title function_">readHarvest</span>()<br><br>  <span class="hljs-keyword">const</span> readME = <span class="hljs-keyword">await</span> <span class="hljs-title function_">readREADME</span>()<br><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(harvest);<br><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(readME);<br><br>&#125;<br><br><span class="hljs-title function_">main</span>()<br></code></pre></td></tr></table></figure></li></ul></blockquote><h4 id="2-对象方法扩展"><a href="#2-对象方法扩展" class="headerlink" title="2.对象方法扩展"></a>2.对象方法扩展</h4><blockquote><p><strong>Object.keys、Object.entries、Object.values</strong></p><p>1）介绍：entries，入口，作为Map函数的入口，可传入Map构造函数里初始化Map</p><p>2）格式：数组，里面每个元素还是数组，其中第一个元素是属性，第二个元素是值（可能也是个数组，因为值可以是多个）</p><p>3）用法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> school = &#123;<br><span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;尚硅谷&#x27;</span>,<br><span class="hljs-attr">cities</span>:[<span class="hljs-string">&#x27;背景&#x27;</span>,<span class="hljs-string">&#x27;上海&#x27;</span>,<span class="hljs-string">&#x27;深圳&#x27;</span>],<br><span class="hljs-attr">subject</span>:[<span class="hljs-string">&#x27;前端&#x27;</span>,<span class="hljs-string">&#x27;Java&#x27;</span>,<span class="hljs-string">&#x27;大数据&#x27;</span>,<span class="hljs-string">&#x27;运维&#x27;</span>]<br>&#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(school));<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">values</span>(school));<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">entries</span>(school));<br><span class="hljs-comment">// 可以这么理解：entries，入口，作为Map函数的入口</span><br><span class="hljs-keyword">const</span> m = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">entries</span>(school))<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(m.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;name&#x27;</span>));<br></code></pre></td></tr></table></figure><p><strong>Object.getOwnPropertyDescriptors</strong></p><p>1）介绍：对象属性的描述对象，即属性配置了一些特性，可能用于克隆这样特性的属性</p><p>2）用法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertyDescriptors</span>(school));<br><span class="hljs-comment">// 以上输出的结果就是如下的name格式</span><br><span class="hljs-keyword">const</span> obj = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-literal">null</span>,&#123;<br><span class="hljs-attr">name</span>:&#123;<br>   <span class="hljs-attr">value</span>:<span class="hljs-string">&#x27;尚硅谷&#x27;</span>,<br>   <span class="hljs-attr">writable</span>:<span class="hljs-literal">true</span>,<br>   <span class="hljs-attr">enumerable</span>:<span class="hljs-literal">true</span>,<br>   <span class="hljs-attr">configurable</span>:<span class="hljs-literal">true</span><br>&#125;<br>&#125;)<br></code></pre></td></tr></table></figure></blockquote><h3 id="ES9新特性"><a href="#ES9新特性" class="headerlink" title="ES9新特性"></a>ES9新特性</h3><h4 id="1-Rest参数（…）引入了在对象中的使用，之前是只能在数组中使用"><a href="#1-Rest参数（…）引入了在对象中的使用，之前是只能在数组中使用" class="headerlink" title="1.Rest参数（…）引入了在对象中的使用，之前是只能在数组中使用"></a>1.Rest参数（…）引入了在对象中的使用，之前是只能在数组中使用</h4><h4 id="2-正则扩展"><a href="#2-正则扩展" class="headerlink" title="2.正则扩展"></a>2.正则扩展</h4><blockquote><p><strong>命名捕获分组</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 定义一个字符串</span><br><span class="hljs-keyword">const</span> str = <span class="hljs-string">&#x27;&lt;a href=&quot;http://www.atguigu.com&quot;&gt;尚硅谷&lt;/a&gt;&#x27;</span><br><br><span class="hljs-comment">// const regx = /&lt;a href=&quot;(.*)&quot;&gt;(.*)&lt;\/a&gt;/</span><br><br><span class="hljs-comment">// const result = regx.exec(str)</span><br><br><span class="hljs-comment">// console.log(result);</span><br><br><span class="hljs-comment">// 通过语法?&lt;定义一个名字&gt;语法，就可以从 正则结果中的 group中去单独拿出来 匹配的部分内容</span><br><span class="hljs-keyword">const</span> regx = <span class="hljs-regexp">/&lt;a href=&quot;(?&lt;url&gt;.*)&quot;&gt;(?&lt;text&gt;.*)&lt;\/a&gt;/</span><br><br><span class="hljs-keyword">const</span> result = regx.<span class="hljs-title function_">exec</span>(str)<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result);<br></code></pre></td></tr></table></figure><p><strong>正向断言</strong></p><p>解释：断言指的是判断；正向指根据后面的内容断言（从左往后看是正向）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> str = <span class="hljs-string">&#x27;JS5211314你知道么555啦啦啦&#x27;</span><br><span class="hljs-comment">// \d:先判断数字，+:重复不止一次，():类似于if判断的括号，?=:是否等于,即匹配后面为啦的数字</span><br><span class="hljs-keyword">const</span> regx = <span class="hljs-regexp">/\d+(?=啦)/</span><br><span class="hljs-keyword">const</span> result = regx.<span class="hljs-title function_">exec</span>(str)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result);<br></code></pre></td></tr></table></figure><p><strong>反向断言</strong></p><p>解释：根据前面的条件来判断并匹配</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> str = <span class="hljs-string">&#x27;JS5211314你知道么555啦啦啦&#x27;</span><br><span class="hljs-comment">// &lt;表示反向，即前面为么的数字</span><br><span class="hljs-keyword">const</span> regx = <span class="hljs-regexp">/(?&lt;=么)\d+/</span><br><span class="hljs-keyword">const</span> result = regx.<span class="hljs-title function_">exec</span>(str)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result);<br></code></pre></td></tr></table></figure><p><strong>dotAll模式</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> str = <span class="hljs-string">`</span><br><span class="hljs-string">&lt;ul&gt;</span><br><span class="hljs-string"> &lt;li&gt;</span><br><span class="hljs-string">   &lt;a&gt;肖生克的救赎&lt;/a&gt;</span><br><span class="hljs-string">   &lt;p&gt;上映时间:&lt;/p&gt;</span><br><span class="hljs-string"> &lt;/li&gt;</span><br><span class="hljs-string"> &lt;li&gt;</span><br><span class="hljs-string">   &lt;a&gt;阿甘正传&lt;/a&gt;</span><br><span class="hljs-string">   &lt;p&gt;上映时间:&lt;/p&gt;</span><br><span class="hljs-string"> &lt;/li&gt;</span><br><span class="hljs-string">&lt;/ul&gt;</span><br><span class="hljs-string">`</span><br><span class="hljs-comment">// 没有dotAll的情况下，想要匹配肖生克的救赎、上映时间:得加很多\s</span><br><span class="hljs-keyword">const</span> regx = <span class="hljs-regexp">/&lt;li&gt;\s+&lt;a&gt;(.*?)&lt;\/a&gt;\s+&lt;p&gt;(.*?)&lt;\/p&gt;\s+&lt;\/li&gt;/</span><br><span class="hljs-keyword">const</span> result = regx.<span class="hljs-title function_">exec</span>(str)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result);<br><br><span class="hljs-comment">// .是指可以匹配所有字符，以下是有dotAll的情况,表示在最后加s，那么.可以匹配任意字符</span><br><span class="hljs-keyword">const</span> regx = <span class="hljs-regexp">/&lt;li&gt;.*?&lt;a&gt;(.*?)&lt;\/a&gt;.*?&lt;p&gt;(.*?)&lt;\/p&gt;/g</span>s<br><span class="hljs-keyword">let</span> result;<br><span class="hljs-keyword">const</span> data = []<br><span class="hljs-keyword">while</span> (result=regx.<span class="hljs-title function_">exec</span>(str)) &#123;<br>data.<span class="hljs-title function_">push</span>(&#123;<span class="hljs-attr">title</span>:result[<span class="hljs-number">1</span>],<span class="hljs-attr">time</span>:result[<span class="hljs-number">2</span>]&#125;)<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);<br></code></pre></td></tr></table></figure></blockquote><h3 id="ES10新特性"><a href="#ES10新特性" class="headerlink" title="ES10新特性"></a>ES10新特性</h3><blockquote><p><strong>Object.fromEntries</strong></p><p>解释：（数组）类型的键值对，转化为对象，因为对象形式用的更多</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 可以这么理解：Entries默认指的是(有键值对形式的)数组，那么Object.fromEntries就是从数组转化为Object</span><br><span class="hljs-keyword">const</span> result = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">fromEntries</span>([<br>[<span class="hljs-string">&#x27;name&#x27;</span>,<span class="hljs-string">&#x27;尚硅谷&#x27;</span>],<br>[<span class="hljs-string">&#x27;address&#x27;</span>,<span class="hljs-string">&#x27;上海&#x27;</span>]<br>])<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;传入二维数组时：&#x27;</span>+result);<br><br><span class="hljs-comment">// Map和Entries是有关系的，内容都是键值对，只是前者只是键值对，后者还可以是数组形式的，Entries形式更多因此也可以传入Map</span><br><span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>()<br>map.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;name&#x27;</span>,<span class="hljs-string">&#x27;周杰&#x27;</span>)<br><span class="hljs-keyword">const</span> result1 = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">fromEntries</span>(map)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;传入Map对象时：&#x27;</span>+result1);<br><br><span class="hljs-comment">// 这是Object.fromEntries的逆运算，从对象再转化为数组，是ES8的方法</span><br><span class="hljs-keyword">const</span> result2 = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">entries</span>(&#123;<br><span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;尚硅谷&#x27;</span><br>&#125;)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Object.fromEntries的逆运算为：&#x27;</span>+result2);<br></code></pre></td></tr></table></figure><p>trimStart和trimEnd</p><p>解释：从字面意思来看就知道，一个是清除左边空白，一个是清除右边空白，算是对字符串的处理，对空白的清除更加有针对性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> str = <span class="hljs-string">&#x27;    i love you       &#x27;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">trimStart</span>());<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">trimEnd</span>());<br></code></pre></td></tr></table></figure><p>flat和flatMap</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// flat有平的意思,在这里是把高阶数组变平(降阶)</span><br><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,[<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>]]<br><span class="hljs-comment">// 将二维数组变成一维数组(把里面那层数组符号去掉)</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">flat</span>());<br><br><span class="hljs-comment">// 如果是想把三维数组降为一维的话,需要指定深度,默认是1(一维数组是0)</span><br><span class="hljs-keyword">const</span> arr2 = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,[<span class="hljs-number">6</span>,[<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>]]]<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr2.<span class="hljs-title function_">flat</span>(<span class="hljs-number">2</span>));<br><br><span class="hljs-comment">// 还有个flatMap方法,它能在使用Map(返回一个新的数组)的同时,对含有多维数组的结果进行降阶</span><br><span class="hljs-keyword">const</span> arr3 = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr3.<span class="hljs-title function_">flatMap</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> [item * <span class="hljs-number">10</span>]));<br></code></pre></td></tr></table></figure><p>Symbol.prototype.description</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> s = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;尚硅谷&#x27;</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(s.<span class="hljs-property">description</span>)<br></code></pre></td></tr></table></figure></blockquote><h3 id="ES11新特性"><a href="#ES11新特性" class="headerlink" title="ES11新特性"></a>ES11新特性</h3><blockquote><p>类中的私有属性，在变量前用#表示</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br>name;<br>#age;<br>#weight;<br><br><span class="hljs-title function_">constructor</span>(<span class="hljs-params">name,age,weight</span>)&#123;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name<br><span class="hljs-variable language_">this</span>.#age = age<br><span class="hljs-variable language_">this</span>.#weight = weight<br>&#125;<br>&#125; <br><br><span class="hljs-keyword">const</span> girl = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;周杰&#x27;</span>,<span class="hljs-number">23</span>,<span class="hljs-string">&#x27;56kg&#x27;</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(girl.#age); <span class="hljs-comment">//报错,私有属性不可访问</span><br></code></pre></td></tr></table></figure><p>Promise.allSettled()、Promise.all()</p><p>传入一个数组，存放Promise对象，调用后可返回各个Promise对象异步任务的返回结果</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br><span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;商品数据 - 1&#x27;</span>)<br>&#125;, <span class="hljs-number">1000</span>);<br>&#125;)<br><br><span class="hljs-keyword">const</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br><span class="hljs-comment">// resolve(&#x27;商品数据 - 1&#x27;)</span><br><span class="hljs-title function_">reject</span>(<span class="hljs-string">&#x27;出错啦!&#x27;</span>)<br>&#125;, <span class="hljs-number">1000</span>);<br>&#125;)<br><br><span class="hljs-comment">// allSettled指的是执行传进来的所有promise对象的异步任务,最外面的Promise是成功的,里面的就看定义是什么，这里的Settled指都展开来看，能看到每个对象执行结果</span><br><span class="hljs-keyword">const</span> result = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">allSettled</span>([p1,p2])<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result);<span class="hljs-comment">// 返回一个数组,值是每个promise对象的异步任务的结果</span><br><span class="hljs-comment">// 只有all但没有settled表示,只有所有promise对象成功才能成功,一旦有一个失败最后整体就是失败</span><br><span class="hljs-keyword">const</span> result2 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([p1,p2])<br></code></pre></td></tr></table></figure><p>str.allMatched()</p><p>可对正则结果批量提取</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> str = <span class="hljs-string">`</span><br><span class="hljs-string">&lt;ul&gt;</span><br><span class="hljs-string">&lt;li&gt;</span><br><span class="hljs-string">&lt;a&gt;肖生克的救赎&lt;/a&gt;</span><br><span class="hljs-string">&lt;p&gt;上映时间:&lt;/p&gt;</span><br><span class="hljs-string">&lt;/li&gt;</span><br><span class="hljs-string">&lt;li&gt;</span><br><span class="hljs-string">&lt;a&gt;阿甘正传&lt;/a&gt;</span><br><span class="hljs-string">&lt;p&gt;上映时间:&lt;/p&gt;</span><br><span class="hljs-string">&lt;/li&gt;</span><br><span class="hljs-string">&lt;/ul&gt;</span><br><span class="hljs-string">`</span><br><span class="hljs-keyword">const</span> regx = <span class="hljs-regexp">/&lt;li&gt;.*?&lt;a&gt;(.*?)&lt;\/a&gt;.*?&lt;p&gt;(.*?)&lt;\/p&gt;/</span>sg<br><br><span class="hljs-comment">// str.matchAll使用matchAll可以匹配所有结果,但返回值只是个可迭代的对象,还需要循环遍历或者展开才能拿到最里面的数据</span><br><span class="hljs-keyword">const</span> result = str.<span class="hljs-title function_">matchAll</span>(regx)<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result);<br><br><span class="hljs-comment">// for(let v of result)&#123;</span><br><span class="hljs-comment">//   console.log(v);</span><br><span class="hljs-comment">// &#125;</span><br><br><span class="hljs-keyword">const</span> arr = [...result]<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr);<br></code></pre></td></tr></table></figure><p>可选字符?</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">main</span>(<span class="hljs-params">config</span>) &#123;<br><span class="hljs-comment">//  const dbHost = config &amp;&amp; config.db &amp;&amp; config.db.host</span><br><span class="hljs-comment">// 可用?判断是否存在,如果不存在就会返回undefined,这样写更简单</span><br><span class="hljs-keyword">const</span> dbHost = config?.<span class="hljs-property">db</span>?.<span class="hljs-property">host</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(dbHost);<br>&#125;<br><br><span class="hljs-title function_">main</span>(&#123;<br><span class="hljs-attr">db</span>:&#123;<br><span class="hljs-attr">host</span>:<span class="hljs-string">&#x27;127.0.0.1&#x27;</span>,<br><span class="hljs-attr">username</span>:<span class="hljs-string">&#x27;root&#x27;</span><br>&#125;,<br><span class="hljs-attr">cache</span>:&#123;<br><span class="hljs-attr">host</span>:<span class="hljs-string">&#x27;127.0.0.2&#x27;</span>,<br><span class="hljs-attr">username</span>:<span class="hljs-string">&#x27;admin&#x27;</span><br>&#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>动态import</p><p>在用到的时候再加载</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> btn = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;btn&#x27;</span>)<br><br>btn.<span class="hljs-property">onclick</span> = <span class="hljs-function">()=&gt;</span>&#123;<br><span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./hello&#x27;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">module</span> =&gt;</span> &#123;<br><span class="hljs-variable language_">module</span>.<span class="hljs-title function_">hello</span>()<br>&#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>BigInt</p><p>转化为大整数，用于大数运算</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 后缀加上n表示大整数----和java有点类似</span><br><span class="hljs-keyword">let</span> n = <span class="hljs-number">121n</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">typeof</span>(n));<br><br><span class="hljs-comment">// 也可以用函数转化成大整数，加后缀要简单些</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">typeof</span>(<span class="hljs-title class_">BigInt</span>(<span class="hljs-number">123</span>)));<br><br><span class="hljs-keyword">const</span> number = <span class="hljs-title class_">Number</span>.<span class="hljs-property">MAX_SAFE_INTEGER</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(number+<span class="hljs-number">1</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(number+<span class="hljs-number">2</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">BigInt</span>(number)+<span class="hljs-number">2n</span>);<br></code></pre></td></tr></table></figure><p>globalThis</p><p>全局对象，某个对象想全局使用就赋值给它</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>ES</category>
      
    </categories>
    
    
    <tags>
      
      <tag>知识点</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS高级</title>
    <link href="/2023/03/04/JS%E9%AB%98%E7%BA%A7/"/>
    <url>/2023/03/04/JS%E9%AB%98%E7%BA%A7/</url>
    
    <content type="html"><![CDATA[<h2 id="基本数据类型以及使用"><a href="#基本数据类型以及使用" class="headerlink" title="基本数据类型以及使用"></a>基本数据类型以及使用</h2><h4 id="1-和-的区别："><a href="#1-和-的区别：" class="headerlink" title="1.===和==的区别："></a>1.===和==的区别：</h4><p>前者是完全相等，后者会做数据类型转换</p><h4 id="2-typeof返回的是数据类型的字符串表达"><a href="#2-typeof返回的是数据类型的字符串表达" class="headerlink" title="2.typeof返回的是数据类型的字符串表达"></a>2.typeof返回的是数据类型的字符串表达</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a)---------<span class="hljs-literal">undefined</span> 表示这是个未定义的值<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(type a)----------<span class="hljs-string">&#x27;undefined&#x27;</span> 表示这个变量的数据类型为未定义，数据类型用字符串表达<br></code></pre></td></tr></table></figure><h4 id="3-null数据类型是Object，而undefined就是’undefined’，因此这两个还是有区别的，并不是-类型都是它本身"><a href="#3-null数据类型是Object，而undefined就是’undefined’，因此这两个还是有区别的，并不是-类型都是它本身" class="headerlink" title="3.null数据类型是Object，而undefined就是’undefined’，因此这两个还是有区别的，并不是 类型都是它本身"></a>3.null数据类型是Object，而undefined就是’undefined’，因此这两个还是有区别的，并不是 类型都是它本身</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a,<span class="hljs-keyword">typeof</span> a,<span class="hljs-keyword">typeof</span> a === <span class="hljs-string">&#x27;undefined&#x27;</span>,a === <span class="hljs-literal">undefined</span>)<br><br>      a = <span class="hljs-literal">null</span><br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a, <span class="hljs-keyword">typeof</span> a,<span class="hljs-keyword">typeof</span> a === <span class="hljs-string">&#x27;null&#x27;</span>)<br></code></pre></td></tr></table></figure><h4 id="4-复杂对象中的函数调用，如何捋清楚—看每一次访问-调用-返回的是什么"><a href="#4-复杂对象中的函数调用，如何捋清楚—看每一次访问-调用-返回的是什么" class="headerlink" title="4.复杂对象中的函数调用，如何捋清楚—看每一次访问(调用)返回的是什么"></a>4.复杂对象中的函数调用，如何捋清楚—看每一次访问(调用)返回的是什么</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> b1 = &#123;<br>       <span class="hljs-attr">b2</span>: [<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;2&#x27;</span>,<span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span>],<br>       <span class="hljs-attr">b3</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>           <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;外函数&#x27;</span>)<br>           <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>               <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;zhoujie&#x27;</span><br>           &#125;<br>       &#125;<br>     &#125;<br><br>     <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(b1.<span class="hljs-title function_">b3</span>()())<br></code></pre></td></tr></table></figure><h4 id="5-typeof无法区分判断-Object与null、Object与Array，因为它们都是Object-引用-类型"><a href="#5-typeof无法区分判断-Object与null、Object与Array，因为它们都是Object-引用-类型" class="headerlink" title="5.typeof无法区分判断 Object与null、Object与Array，因为它们都是Object(引用)类型"></a>5.typeof无法区分判断 Object与null、Object与Array，因为它们都是Object(引用)类型</h4><h4 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a><strong>面试题</strong></h4><h4 id="6-undefined和null的区别？"><a href="#6-undefined和null的区别？" class="headerlink" title="6.undefined和null的区别？"></a>6.undefined和null的区别？</h4><p>undefined是定义未赋值，而null定义并赋值了，只是值为null</p><blockquote><p>补充：再加个xxx is not defined</p><p>xxx is not defined：没有定义</p></blockquote><h4 id="7-什么时候用null？"><a href="#7-什么时候用null？" class="headerlink" title="7.什么时候用null？"></a>7.什么时候用null？</h4><p>1.初始赋值，表明即将赋值为对象类型</p><p>2.结束前赋值，表明此对象为垃圾对象，即将被回收</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> b = <span class="hljs-literal">null</span><br><br>   b = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br><br>   b = <span class="hljs-literal">null</span><br></code></pre></td></tr></table></figure><h4 id="8-如何严格区分变量类型和数据类型？"><a href="#8-如何严格区分变量类型和数据类型？" class="headerlink" title="8.如何严格区分变量类型和数据类型？"></a>8.如何严格区分变量类型和数据类型？</h4><p>变量类型：包含 基本类型和引用类型（保存的是地址），</p><p>数据类型：包含 基本类型和对象类型</p><p>可以这么记：数据比较抽象，只看表面，而变量接受的是一个具体的值，因此是里面的地址</p><h4 id="9-在js中调用函数传递参数时，是值传递还是引用传递？"><a href="#9-在js中调用函数传递参数时，是值传递还是引用传递？" class="headerlink" title="9.在js中调用函数传递参数时，是值传递还是引用传递？"></a>9.在js中调用函数传递参数时，是值传递还是引用传递？</h4><p>值传递，只是传的这个值 可以是基本值也可以是地址</p><h4 id="10-JS引擎如何释放内存？"><a href="#10-JS引擎如何释放内存？" class="headerlink" title="10.JS引擎如何释放内存？"></a>10.JS引擎如何释放内存？</h4><p>1.局部变量：函数执行完自动释放</p><p>2.对象：成为垃圾对象==&gt;被垃圾回收器回收</p><hr><h4 id="11-函数内的所有局部变量在函数调用时产生，在调用结束时就被清理了"><a href="#11-函数内的所有局部变量在函数调用时产生，在调用结束时就被清理了" class="headerlink" title="11.函数内的所有局部变量在函数调用时产生，在调用结束时就被清理了"></a>11.函数内的所有局部变量在函数调用时产生，在调用结束时就被清理了</h4><h4 id="12-JS中直接用对象赋值的相当于-定义和实例化同步进行，好处是不用那么麻烦了，定义了后就直接用，需要注意的是-对象赋值时，属性后面是冒号（因为是键值对）"><a href="#12-JS中直接用对象赋值的相当于-定义和实例化同步进行，好处是不用那么麻烦了，定义了后就直接用，需要注意的是-对象赋值时，属性后面是冒号（因为是键值对）" class="headerlink" title="12.JS中直接用对象赋值的相当于 定义和实例化同步进行，好处是不用那么麻烦了，定义了后就直接用，需要注意的是 对象赋值时，属性后面是冒号（因为是键值对）"></a>12.JS中直接用对象赋值的相当于 定义和实例化同步进行，好处是不用那么麻烦了，定义了后就直接用，需要注意的是 对象赋值时，属性后面是冒号（因为是键值对）</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> b = &#123;<br>    <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;zhoujie&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="13-在访问对象属性时，除了可以直接-访问，也可以用-‘属性名’-访问，后面这种相当于-把属性和值看成键值对"><a href="#13-在访问对象属性时，除了可以直接-访问，也可以用-‘属性名’-访问，后面这种相当于-把属性和值看成键值对" class="headerlink" title="13.在访问对象属性时，除了可以直接.访问，也可以用[‘属性名’]访问，后面这种相当于 把属性和值看成键值对"></a>13.在访问对象属性时，除了可以直接.访问，也可以用[‘属性名’]访问，后面这种相当于 把属性和值看成键值对</h4><ul><li><p>什么时候使用[‘属性名’]？有什么好处?</p><p>好处：用.的方式有时会失效，而[‘属性名’]是通用的</p><p>When：</p><p>1）属性名包含特殊字符时，因为对象的属性的命名也遵循基本命名规则，可以这么理解：它新加了一个[]就是为了能够海纳百川 从而改进.的方式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = &#123;&#125;<br><span class="hljs-comment">// 添加一个属性content-type   </span><br><span class="hljs-comment">// a.content-type = &#x27;text/json&#x27;</span><br>  <br>a[<span class="hljs-string">&#x27;content-type&#x27;</span>] = <span class="hljs-string">&#x27;text/json&#x27;</span><br></code></pre></td></tr></table></figure><p>2）变量名不确定</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> proName = <span class="hljs-string">&#x27;myAge&#x27;</span><br><span class="hljs-keyword">var</span> value = <span class="hljs-number">18</span><br>a.<span class="hljs-property">proName</span> = value<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a)----&#123;content-<span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;text/json&#x27;</span>, <span class="hljs-attr">proName</span>: <span class="hljs-number">18</span>&#125;<br>  <br>a[proName] = value<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a)----&#123;content-<span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;text/json&#x27;</span>, <span class="hljs-attr">proName</span>: <span class="hljs-number">18</span>, <span class="hljs-attr">myAge</span>: <span class="hljs-number">18</span>&#125;<br></code></pre></td></tr></table></figure><p> 原因：[]多做了一步变量替换，它是先将proName替换为myAge，然后a再去添加myAge属性，而.的方式直接认为proName就是属性名</p><p> 注意点：[]放变量不要加引号，加了引号那就是proName字符常量了</p></li></ul><h4 id="14-原来new也可以调用函数？因为函数也是一个对象"><a href="#14-原来new也可以调用函数？因为函数也是一个对象" class="headerlink" title="14.原来new也可以调用函数？因为函数也是一个对象"></a>14.原来new也可以调用函数？因为函数也是一个对象</h4><h4 id="15-可以调用对象中不存在的方法"><a href="#15-可以调用对象中不存在的方法" class="headerlink" title="15.可以调用对象中不存在的方法"></a>15.可以调用对象中不存在的方法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">test.<span class="hljs-property">call</span>/<span class="hljs-title function_">apply</span>(obj)-------临时将test作为obj的函数来调用<br><span class="hljs-comment">//可以这么理解：call就相当于test作为求职者来寻找雇主boj</span><br><span class="hljs-comment">//            apply就相当于雇主obj叫求职者test来应聘</span><br></code></pre></td></tr></table></figure><h4 id="16-常见的回调函数"><a href="#16-常见的回调函数" class="headerlink" title="16.常见的回调函数"></a>16.常见的回调函数</h4><p>什么是回调函数？你定义的、你没有调用、但它最终却执行了（某个时刻自己执行）</p><p>1）dom事件回调函数</p><p>2）定时器回调函数</p><p>3）ajax请求回调函数</p><p>4）生命周期回调函数</p><h4 id="17-window-function"><a href="#17-window-function" class="headerlink" title="17.window.$ = function(){}"></a>17.window.$ = function(){}</h4><p>​       代表给window对象自定义一个函数，既然是widow对象，那么这个自定义函数就是在页面加载时就产生</p><h4 id="18-匿名对象中的函数：左边属性名，右边函数名"><a href="#18-匿名对象中的函数：左边属性名，右边函数名" class="headerlink" title="18.匿名对象中的函数：左边属性名，右边函数名"></a>18.匿名对象中的函数：左边属性名，右边函数名</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"> &#123;<br>   <span class="hljs-attr">test</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>       ...<br>   &#125;<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">如果test函数已知，则 直接test()整个放入，而前面的test相当于test()别名，调用别名test就等于test()</span><br><span class="hljs-comment">为什么一定左边是个名字，因为对象 中元素都是键值对 格式的，左边是名字，右边是具体值</span><br><span class="hljs-comment">*/</span><br> <span class="hljs-variable language_">window</span>.<span class="hljs-property">$</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>   <span class="hljs-attr">test</span>:test<br>&#125;<br>$.<span class="hljs-title function_">test</span>()<br></code></pre></td></tr></table></figure><h4 id="19-关于this"><a href="#19-关于this" class="headerlink" title="19.关于this"></a>19.关于this</h4><p>1.函数其实本质上都是通过某个对象调用的，如果没有直接指定就是window，也就是为什么location.href其实就是window.location.href，即location其实就是window的方法</p><p>   test()，那么这个函数打印出的this指的是window</p><p>2.有直接指定的 那this就是它的调用者</p><p>   p.test—-this为p</p><p>  var p1 = new test()—-this为新创建的对象p1</p><p>  p.call(obj)：obj—-p把掌控权交给了obj，因此是objs</p><h4 id="20-关于分号"><a href="#20-关于分号" class="headerlink" title="20.关于分号"></a>20.关于分号</h4><p>1）在 小括号 前面要加分号——因为会把前面的值 当成 函数名 来调用</p><p>2）在 中括号 前面加分号——-因为会把前面的值 当成数组名 来调用</p><p>解决方法：在这两者之前面 加分号 </p><h4 id="21-js中是没有类的，只有对象。似乎-函数在承担着一些-以前类的职责，比如-原型就是函数才有的，而原型就相当于封装好的类；比如new-function，太像了。而这里面的对象似乎经常作为-匿名对象出现，直接传入具体的值。"><a href="#21-js中是没有类的，只有对象。似乎-函数在承担着一些-以前类的职责，比如-原型就是函数才有的，而原型就相当于封装好的类；比如new-function，太像了。而这里面的对象似乎经常作为-匿名对象出现，直接传入具体的值。" class="headerlink" title="21.js中是没有类的，只有对象。似乎 函数在承担着一些 以前类的职责，比如 原型就是函数才有的，而原型就相当于封装好的类；比如new function，太像了。而这里面的对象似乎经常作为 匿名对象出现，直接传入具体的值。"></a>21.js中是没有类的，只有对象。似乎 函数在承担着一些 以前类的职责，比如 原型就是函数才有的，而原型就相当于封装好的类；比如new function，太像了。而这里面的对象似乎经常作为 匿名对象出现，直接传入具体的值。</h4><h2 id="函数高级"><a href="#函数高级" class="headerlink" title="函数高级"></a>函数高级</h2><h4 id="22-函数的prototype属性"><a href="#22-函数的prototype属性" class="headerlink" title="22.函数的prototype属性"></a>22.函数的prototype属性</h4><p>1）每个函数都会有一个prototype属性，它指向一个空对象</p><p>2）这个空对象有一个constructor属性，它指向函数本身（可以这么记：构造函数和类名（函数名）同名）</p><p>3）可以给原型对象添加属性（一般是方法），目的是 给接受这个 方法的实例对象拥有添加的属性（方法）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Date</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);<br><br>     <span class="hljs-keyword">function</span> <span class="hljs-title function_">Fun</span>(<span class="hljs-params"></span>)&#123;<br><br>     &#125;<br><br>     <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Fun</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Fun</span>);<br><br>     <span class="hljs-comment">// 手动给Fun函数的原型添加函数test</span><br>     <span class="hljs-title class_">Fun</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">test</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>)&#123;<br>          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;the added method&quot;</span>);<br>     &#125;<br>     <span class="hljs-comment">/**</span><br><span class="hljs-comment">      * 让实例对象使用，在访问、修改里面的方法时需要通过prototype，但是真正实例化使用的时候</span><br><span class="hljs-comment">      * 还是直接让函数自己去</span><br><span class="hljs-comment">      * */</span> <br>     <span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Fun</span>()<br>     p.<span class="hljs-title function_">test</span>()<br></code></pre></td></tr></table></figure><h4 id="23-显式原型和隐式原型"><a href="#23-显式原型和隐式原型" class="headerlink" title="23.显式原型和隐式原型"></a>23.显式原型和隐式原型</h4><p>1）每个函数都有个显式原型prototype，显式原型是函数创建时自动创建的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Fn</span>(<span class="hljs-params"></span>)&#123;<br>    ...<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Fn</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);<br></code></pre></td></tr></table></figure><p>2）每个实例都有隐式原型______proto_（因此只有对象才有），是Fn在实例化的时候，内部执行了 this.<strong><strong>proto</strong></strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> fn = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Fn</span>()<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(fn.<span class="hljs-property">__proto__</span>)<br></code></pre></td></tr></table></figure><p>3）<strong>每个实例的隐式原型的值 = 其构造函数的显式原型的值</strong>  （其实就是上面两点的值是相等的，说得这么绕是因为想 将两者联系起来，因为构造函数其实就是函数本身，变量代换了属于是）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Fn</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>===fn.<span class="hljs-property">__proto__</span>)<br></code></pre></td></tr></table></figure><h4 id="25-变量为声明打印的话是会报错：not-defined，这个和打印为-‘undefined’不一样，前者是未定义，后者是定义未赋值"><a href="#25-变量为声明打印的话是会报错：not-defined，这个和打印为-‘undefined’不一样，前者是未定义，后者是定义未赋值" class="headerlink" title="25.变量为声明打印的话是会报错：not defined，这个和打印为 ‘undefined’不一样，前者是未定义，后者是定义未赋值"></a>25.变量为声明打印的话是会报错：not defined，这个和打印为 ‘undefined’不一样，前者是未定义，后者是定义未赋值</h4><h4 id="26-var和function的变量提升（只是声明提前，如果有值还得在赋值的地方才有效）"><a href="#26-var和function的变量提升（只是声明提前，如果有值还得在赋值的地方才有效）" class="headerlink" title="26.var和function的变量提升（只是声明提前，如果有值还得在赋值的地方才有效）"></a>26.var和function的变量提升（只是声明提前，如果有值还得在赋值的地方才有效）</h4><p>1）变量声明的提升</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-number">10</span><br>------------相当于<br><span class="hljs-keyword">var</span> a<br>a = <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><p>2）声明式函数或函数表达式的提升，整体提升（变量和后面的赋值整体往上）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">a</span>(<span class="hljs-params"></span>)&#123;&#125;<br>------------相当于<br><span class="hljs-keyword">var</span> a<br>a = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;&#125;<br></code></pre></td></tr></table></figure><p>3）同名函数声明时，会把后面的替换前面的（默认后面的事最新的更改），而且在编译器中还不会报错，，难道是为了 保存记录，方便 出问题了 来追踪并查找bug吗？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">a</span>(<span class="hljs-params"></span>)&#123; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;123&#x27;</span>)&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">a</span>(<span class="hljs-params"></span>)&#123; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;456&#x27;</span>)&#125;<br>------------------------------相当于<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">a</span>(<span class="hljs-params"></span>)&#123; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;456&#x27;</span>)&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="面试题-1"><a href="#面试题-1" class="headerlink" title="面试题"></a>面试题</h4><p>4）函数变量的提升比var变量提升的优先级高，声明更靠前</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-number">10</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fun</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">var</span> b = <span class="hljs-number">11</span><br>&#125;<br>--------------相当于<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fun</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">var</span> b = <span class="hljs-number">11</span><br>&#125;<br><span class="hljs-keyword">var</span> a<br>a = <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><p>5）如果变量与函数<strong>同名</strong>了，<strong>此时函数声明与变量声明只声明一个</strong>，并且变量<strong>没有赋值</strong>，那么函数优先级更高，原理如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">a</span>(<span class="hljs-params"></span>)&#123;&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">a</span>())<br>--------------相当于<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">a</span>(<span class="hljs-params"></span>)&#123;&#125;-----变量不会声明<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">a</span>())<br></code></pre></td></tr></table></figure><p>6）如果变量与函数<strong>同名</strong>了，并且变量 <strong>赋值了</strong>，那么变量优先级更高（不管谁先声明，因为函数总是在变量前面的），原理如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-number">10</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">a</span>(<span class="hljs-params"></span>)&#123;&#125;<br>--------------相当于<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">a</span>(<span class="hljs-params"></span>)&#123;&#125;<br>a = <span class="hljs-number">10</span><br><span class="hljs-title function_">a</span>()<span class="hljs-comment">//报错，此时a是个变量</span><br></code></pre></td></tr></table></figure><hr><h4 id="27-原型链"><a href="#27-原型链" class="headerlink" title="27.原型链"></a>27.原型链</h4><p><img src="/2023/03/04/JS%E9%AB%98%E7%BA%A7/%E5%8E%9F%E5%9E%8B%E9%93%BE1.png" alt="原型链1"></p><p><strong>作用：查找对象的属性（方法）</strong></p><p><strong>容易混淆的点：这里面通过原型链往后找的只是本身的原型（类），即本身是原型的实例，这个和父类没有关系</strong></p><p><img src="/2023/03/04/JS%E9%AB%98%E7%BA%A7/%E5%8E%9F%E5%9E%8B%E9%93%BE2.png" alt="原型链2"></p><p><strong>这两张图的联系的重点：实例的隐式原型 = 其构造函数的显式原型 在两张图如何体现</strong></p><p>1）在第二张图如何体现？</p><p>比如 实例Foo的_proto__ = Function的prototype，因此它们都指向 Function的prototype，其中Foo的prototype并没有在第一张图体现出来，因为第一张图没有画以Foo为构造函数的原型，必须要有别的proto__指向它</p><p>2）第一张图图如何体现？</p><p>比如 实例fn的_proto__ = Fn实例对象的prototype（都是0x456）</p><p><strong>补充：</strong>完整的图</p><p><img src="/2023/03/04/JS%E9%AB%98%E7%BA%A7/%E5%8E%9F%E5%9E%8B%E9%93%BE.jpg" alt="原型链"></p><p>1）Object<strong>的原型对象</strong>是顶层，再往上找不到了，因此它的_proto是null，即Object.prototype.proto__ = null</p><p>2）Function.prototype 是Object 的实例（Object才是顶层）</p><p>3）所有函数都是Function的实例（从proto__可以看出来）</p><h4 id="28-原型链的属性问题"><a href="#28-原型链的属性问题" class="headerlink" title="28.原型链的属性问题"></a>28.原型链的属性问题</h4><p>1）实例查找属性也是先 本身-&gt;原型链</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Fn</span>(<span class="hljs-params"></span>)&#123;<br>    <br>&#125;<br><span class="hljs-title class_">Fn</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">aaa</span> = <span class="hljs-string">&#x27;xxx&#x27;</span><br><span class="hljs-keyword">var</span> fn = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Fn</span>()<br>cosole.<span class="hljs-title function_">log</span>(fn.<span class="hljs-property">aaa</span>)-------可以访问，但是不建议放在原型链中，见（<span class="hljs-number">3</span>）<br></code></pre></td></tr></table></figure><p>2）在修改值的时候，不会查找原型链，如果不存在，会在函数本身中创建（优先在函数本身中处理属性）</p><p>3）属性一般放在函数本身中，而方法一般放在原型链中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Fn</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-attr">aaa</span>:<span class="hljs-string">&#x27;111&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>对于（3）为什么要这么做？</p><p>可以这么理解：一个函数（类）的各个实例属性一般不同，但是方法（功能）大差不差，最多像java中重写</p><h4 id="29-使用原型的好处"><a href="#29-使用原型的好处" class="headerlink" title="29.使用原型的好处"></a>29.使用原型的好处</h4><p>所有实例共享属性和方法，不用再每个实例都添加一遍了</p><h4 id="30-怎么通过原型链看A是不是B的实例（instance-of的原理）？"><a href="#30-怎么通过原型链看A是不是B的实例（instance-of的原理）？" class="headerlink" title="30.怎么通过原型链看A是不是B的实例（instance of的原理）？"></a>30.怎么通过原型链看A是不是B的实例（instance of的原理）？</h4><p>A 通过自己的proto_链找，有B的原型就说明A是B的实例（多条路都可以）</p><hr><h4 id="面试题-2"><a href="#面试题-2" class="headerlink" title="面试题"></a>面试题</h4><p>（1）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">A</span>(<span class="hljs-params"></span>)&#123;<br>    <br>&#125;<br>A.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">n</span> = <span class="hljs-number">1</span><br><span class="hljs-keyword">var</span> b = <span class="hljs-keyword">new</span> <span class="hljs-title function_">A</span>()<br>A.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = &#123;<br>    n : <span class="hljs-number">2</span>,<br>    m : <span class="hljs-number">3</span><br>&#125;<br><span class="hljs-keyword">var</span> c = <span class="hljs-keyword">new</span> <span class="hljs-title function_">A</span>()<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(b.<span class="hljs-property">m</span>,b.<span class="hljs-property">n</span>,c.<span class="hljs-property">m</span>,c.<span class="hljs-property">n</span>)<span class="hljs-comment">// 1 undefined 2 3</span><br></code></pre></td></tr></table></figure><p><img src="/2023/03/04/JS%E9%AB%98%E7%BA%A7/%E9%9D%A2%E8%AF%95%E9%A2%9801.png" alt="面试题01"></p><p><strong>关键点：在堆里新建一个对象后，赋值给 A.prototype 后，直接更改了指向</strong></p><p> （2）完整的图记住就可以了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">F</span>(<span class="hljs-params"></span>)&#123;&#125;<br><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">a</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;a&#x27;</span>)<br>&#125;<br><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">b</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;b&#x27;</span>)<br>&#125;<br><span class="hljs-keyword">var</span> f = <span class="hljs-keyword">new</span> <span class="hljs-title function_">F</span>()<br>f.<span class="hljs-title function_">a</span>() ---- a<br>f.<span class="hljs-title function_">b</span>() ----报错 b不是函数<br>F.<span class="hljs-title function_">a</span>() ---- a<br>F.<span class="hljs-title function_">b</span>() ---- b<br></code></pre></td></tr></table></figure><hr><h4 id="31-执行上下文"><a href="#31-执行上下文" class="headerlink" title="31.执行上下文"></a>31.执行上下文</h4><p><strong>（1）全局执行上下文</strong></p><p>全局预处理会执行以下操作：</p><ul><li>将window作为全局执行上下文</li><li>将所有变量和函数的声明提前并放入全局执行上下文中</li><li>将this指向window</li></ul><p><strong>（2）函数执行上下文（虚拟的，存在于栈中）</strong></p><p>函数在调用时会执行以下操作：</p><ul><li>将形参作为函数执行上下文的属性</li><li>将arguments（形参列表）作为函数执行上下文的属性</li><li>将所有 局部声明的 变量和函数的声明 提前并放入函数执行上下文中</li></ul><p><strong>函数执行上下文 什么时候被创建 ？调用时才会被创建，但是创建后使用之前肯定已经准备好的</strong></p><h4 id="32-执行上下文栈"><a href="#32-执行上下文栈" class="headerlink" title="32.执行上下文栈"></a>32.执行上下文栈</h4><p><strong>（1）执行上下文的个数怎么看？</strong></p><p>n（函数调用的次数）+1，嵌套一次就会叠加一层</p><p><strong>（2）执行上下文栈的运行机制？</strong></p><p> 先放入 window全局执行上下文，然后放入一个个函数，函数在调用完后就会出战，最终留下window在栈里</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-number">10</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-title function_">foo</span>()<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;aaa&#x27;</span>)<br>&#125;<br><span class="hljs-title function_">bar</span>()<br><span class="hljs-title function_">push</span>(<span class="hljs-variable language_">window</span>)-&gt;<span class="hljs-title function_">push</span>(bar)-&gt;<span class="hljs-title function_">push</span>(foo)-&gt;<span class="hljs-title function_">pop</span>(foo)-&gt;<span class="hljs-title function_">pop</span>(bar) 最终留下<span class="hljs-variable language_">window</span><br></code></pre></td></tr></table></figure><hr><h4 id="面试题-3"><a href="#面试题-3" class="headerlink" title="面试题"></a>面试题</h4><p><strong>（1）在看递归的打印时，一定要注意临界时的输出情况，别漏了</strong></p><p><strong>（2）变量与函数同名问题</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> c = <span class="hljs-number">1</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">c</span>(<span class="hljs-params">c</span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(c)<br>&#125;<br><span class="hljs-title function_">c</span>(<span class="hljs-number">2</span>)<span class="hljs-comment">//c不是函数 ，考的还是变量与函数同名问题，下次要有意识地注意看名字</span><br></code></pre></td></tr></table></figure><p><strong>（3）if内部的定义的变量仍然是 全局的，只有函数内才是局部的，因此依然会变量提升</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">if</span>(!(b <span class="hljs-keyword">in</span> <span class="hljs-variable language_">window</span>))&#123;<br>    <span class="hljs-keyword">var</span> b = <span class="hljs-number">1</span><br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(b)<span class="hljs-comment">//undefined</span><br></code></pre></td></tr></table></figure><hr><h4 id="33-作用域-amp-作用域链与执行上下文"><a href="#33-作用域-amp-作用域链与执行上下文" class="headerlink" title="33.作用域&amp;作用域链与执行上下文"></a>33.作用域&amp;作用域链与执行上下文</h4><p><strong>作用域内寻找变量的过程：先从当前执行上下文找，没有然后再到外面的执行上下文，找不到就报错。到执行上下文上找是因为变量提升，那里有所有定义好的变量——-寻找的路径就是作用域链</strong></p><p><img src="/2023/03/04/JS%E9%AB%98%E7%BA%A7/%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE.png"></p><p><strong>区别1：先后顺序不同</strong></p><ul><li>全局执行上下文是在全局作用域确定之后，全局代码执行之前生成</li><li>函数执行上下文是在函数调用时，函数代码执行之前生成</li></ul><p><strong>区别2：变化发展的不同</strong></p><ul><li>作用域是静态的，只要代码一生成，就一直存在</li><li>执行上下文是动态的，全局执行上下文在预加载时生成，函数执行上下文在调用时，且在调用结束后被释放</li></ul><p><strong>联系：</strong></p><ul><li><p>执行上下文环境是属于作用域内的（如上图）</p><p><strong>原型链和作用域链总结：原型链是用来找方法的，作用域链是用来找变量的</strong></p><hr><h3 id="面试题-4"><a href="#面试题-4" class="headerlink" title="面试题"></a>面试题</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> x = <span class="hljs-number">10</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x)<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">show</span>(<span class="hljs-params">f</span>)&#123;<br>    <span class="hljs-keyword">var</span> x = <span class="hljs-number">20</span><br>    <span class="hljs-title function_">fn</span>()<br>&#125;<br><span class="hljs-title function_">show</span>(fn)<span class="hljs-comment">//10</span><br></code></pre></td></tr></table></figure><p><strong>（1）千万不能认为嵌套调用函数就是直接把函数代码拿过来，这在js行不通</strong></p><p><strong>（2）考的是 函数作用域在 代码生成后就定下来了 ，因此本体fn的作用域就是上面，找不到再网上找 那就是10</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//题目：</span><br><span class="hljs-keyword">var</span> x = <span class="hljs-number">10</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(fn)<br>&#125;<br><span class="hljs-title function_">fn</span>()<br>-------------------------<br><span class="hljs-comment">//结果：</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(fn)<br>&#125;<br>-------------------------<br><span class="hljs-comment">//题目：</span><br><span class="hljs-keyword">var</span> obj = &#123;<br>    <span class="hljs-attr">fn2</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(fn2)<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">fn2</span>)<br>    &#125;<br>&#125;<br>obj.<span class="hljs-title function_">fn2</span>()<br>-------------------------<br> <span class="hljs-comment">//结果：</span><br> fn2 is not defined <br> <span class="hljs-attr">fn2</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(fn2)<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">fn2</span>)<br>    &#125;<br></code></pre></td></tr></table></figure><p>  <strong>（1）打印 函数名 得到的是 整个函数（全貌），相当于这个名字代表的是函数的全貌</strong></p><p>  <strong>（2）会在哪找一定要确定这个东西属于哪个作用域（注意作用域只有全局和函数内），这里fn寻找过程：function内-&gt;全局作用域</strong></p><p>  **（3）想要找到对象内的属性（方法），注意善用this **</p></li></ul><hr><h4 id="34-闭包"><a href="#34-闭包" class="headerlink" title="34.闭包"></a>34.闭包</h4><p><strong>经典案例</strong></p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs xml">//实现点击提示是哪个按钮<br>   <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>点击<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>点击<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>点击<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">       <span class="hljs-comment">/**</span></span><br><span class="hljs-comment"><span class="language-javascript">        * 需求：点击按钮，提示这是第几个按钮</span></span><br><span class="hljs-comment"><span class="language-javascript">       */</span></span><br><span class="language-javascript">      <span class="hljs-keyword">var</span> buttons = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementsByTagName</span>(<span class="hljs-string">&#x27;button&#x27;</span>)</span><br><span class="language-javascript">      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>,length = buttons.<span class="hljs-property">length</span>; i &lt; length; i++)&#123;</span><br><span class="language-javascript">          <span class="hljs-keyword">var</span> btn = buttons[i]  <span class="hljs-comment">//必须要单独声明一个btn，因为要给每个btn添加点击事件</span></span><br><span class="language-javascript">          btn.<span class="hljs-property">index</span> = i</span><br><span class="language-javascript">          btn.<span class="hljs-property">onclick</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript">              <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;第&#x27;</span>+(<span class="hljs-variable language_">this</span>.<span class="hljs-property">index</span>+<span class="hljs-number">1</span>)+<span class="hljs-string">&#x27;个按钮&#x27;</span>);  <span class="hljs-comment">//this表示当前btn，否则报错</span></span><br><span class="language-javascript">          &#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript">      &#125;</span><br><span class="language-javascript">      <span class="hljs-comment">//第二种：用闭包(稍后再说)</span></span><br><span class="language-javascript">      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>,length = buttons.<span class="hljs-property">length</span>; i &lt; length; i++)&#123;</span><br><span class="language-javascript">        (<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript">              <span class="hljs-keyword">var</span> btn = buttons[i]  <span class="hljs-comment">//必须要单独声明一个btn，因为要给每个btn添加点击事件</span></span><br><span class="language-javascript">              <span class="hljs-comment">//btn.index = i</span></span><br><span class="language-javascript">               btn.<span class="hljs-property">onclick</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript">              <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;第&#x27;</span>+(<span class="hljs-variable language_">this</span>.<span class="hljs-property">index</span>+<span class="hljs-number">1</span>)+<span class="hljs-string">&#x27;个按钮&#x27;</span>);  <span class="hljs-comment">//this表示当前btn，否则报错</span></span><br><span class="language-javascript">          &#125;</span><br><span class="language-javascript">        &#125;)()</span><br><span class="language-javascript">      &#125;</span><br><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>   解答：调用length次，生成length个闭包，每个闭包单独保存i<br></code></pre></td></tr></table></figure><p><strong>产生：嵌套函数中内部函数访问外部函数的变量（属性），<u><em>并且外部函数调用时</em></u>，就产生了闭包</strong></p><p><strong>定义：内部函数对外部函数的应用</strong></p><p><strong>常见闭包：</strong></p><p>（1）将函数作为另一个函数的返回值，既然是返回值，就肯定会再次调用，由于闭包的特点：内部函数的变量会一直存在内存中，因此再次调用访问的还是第一次生成的变量</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn1</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">fn2</span>(<span class="hljs-params"></span>)&#123;<br>        a++  <span class="hljs-comment">//引用函数外部变量，产生闭包</span><br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a)<br>    &#125;<br>    <span class="hljs-keyword">return</span> fn2<br>&#125;<br><span class="hljs-keyword">var</span> f = <span class="hljs-title function_">fn1</span>()<br><span class="hljs-title function_">f</span>()<span class="hljs-comment">// 3 ---- 第一次调用fn2</span><br><span class="hljs-title function_">f</span>()<span class="hljs-comment">// 4 ---- 再次调用fn2，访问的是之前的a</span><br></code></pre></td></tr></table></figure><p>（2）函数作为另一个函数参数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params">msg,time</span>)&#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-title function_">alert</span>(msg) <span class="hljs-comment">//访问函数外部变量msg，产生闭包</span><br>    &#125;,time)<br>&#125;<br><span class="hljs-title function_">fn</span>(<span class="hljs-string">&#x27;zhoujie&#x27;</span>,<span class="hljs-number">2000</span>)<br></code></pre></td></tr></table></figure><p><strong>闭包作用：</strong></p><p>1）函数内部的变量可以继续保存在内存中，方便下次使用，延长了局部变量的生命周期。（既然你需要外部的变量，那就满足它无后顾之忧）</p><p>​    <strong>新的问题：那这个变量什么时候被释放？</strong></p><ul><li><p>对象成为垃圾对象（该对象没有引用指向它）</p></li><li><p>不使用的时候（既然没有使用需求，为什么还要开辟空间来准备呢）</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn1</span>(<span class="hljs-params"></span>)&#123;<br>    -------------------------------------此时就已经产生了闭包(变量提升)<br>    <span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">fn2</span>(<span class="hljs-params"></span>)&#123;<br>        a++  <span class="hljs-comment">//引用函数外部变量，产生闭包</span><br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a)<br>    &#125;------------------------------------这里整个fn2就会被释放，因为没有被使用<br>     <span class="hljs-keyword">function</span> <span class="hljs-title function_">fn3</span>(<span class="hljs-params"></span>)&#123;<br>        a++  <span class="hljs-comment">//引用函数外部变量，产生闭包</span><br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a)<br>    &#125;<br>    <span class="hljs-keyword">return</span> fn3<br>&#125;<br><span class="hljs-comment">//fn1()----------------------------------这里fn1调用结束后，如果没有变量指向fn3(返回值)，那fn3就会成为垃圾对象，准备被销毁，那闭包中的变量也没了</span><br><span class="hljs-keyword">var</span> f = <span class="hljs-title function_">fn1</span>()<br><span class="hljs-title function_">f</span>()<br></code></pre></td></tr></table></figure><p>​     <strong>这两点说的是一个意思，都是指成为垃圾对象</strong></p><p>2）让函数外部可以操作函数内部的数据（局部变量）（本来外部是不能访问局部变量的 ）</p><p><strong>闭包的生命周期</strong></p><p>产生：在嵌套内部函数执行完函数定义时（需要调用外部函数）就产生了，当然这个内部函数要引用外部变量</p><p>死亡：在嵌套内部函数成为垃圾对象时（和前面提出的问题是一样的）</p><p><strong>闭包的应用 —- 自定义JS模块</strong></p><p><strong>步骤：</strong></p><ul><li>第一种</li></ul><p>1）在js文件中定义函数myModule，注意返回值是一个返回多个属性（方法）的对象</p><p>2）在html文件中引用并 var module = myModule()，module.doSomething()</p><ul><li>第二种</li></ul><p>1）在js文件中定义为 IIFE 函数，这时返回值是：window.myModule01 = { }</p><p>2）在html文件中引用并 直接 myModule01.doSomething()</p><blockquote><p>其实是 一样的，相当于前者后函数执行（实例化）调用，后者是 先成为window的一部分并自动执行（实例化），那么引入就可以直接用了</p></blockquote><p><strong>闭包与其他语言中类的异曲同工之处：</strong></p><blockquote><p>这一切的一切都是因为 js中没有类只有对象！因此利用函数充当类，用函数局部变量外部不可见充当私有属性（对象的属性默认是公有的），用 闭包 充当 类中函数访问成员变量，用返回值为对象充当 类调用方法</p></blockquote><p><strong>闭包的缺点：</strong></p><blockquote><p>当你不需要再使用闭包内的数据时，如果没有及时释放，那那片内存就一直被占用着，造成内存泄露</p><p>解决办法：能不用就不用，就算用了要及时赋值给null</p></blockquote><p><strong>内存溢出与内存泄漏</strong></p><blockquote><p>内存溢出：当程序需要的内存超过剩余的内存时，就会抛出内存溢出的错误</p><p>内存泄露：占用的内存没有被释放，积累多了就会导致内存溢出，这个泄露指的是在总内存</p><p>常见的内存泄漏：</p><ul><li>意外的全局变量</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>)&#123;<br>    a = <span class="hljs-number">1</span> --------------------------------- 没有用<span class="hljs-keyword">var</span>定义的变量都是全局变量，函数调用结束后并不会销毁，这样定义越来越多，久而久之也会溢出的<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">fn2</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a)<br>    &#125;<br>    <span class="hljs-keyword">return</span> fn2<br>&#125;<br><span class="hljs-keyword">var</span> f = <span class="hljs-title function_">fn</span>()<br><span class="hljs-title function_">f</span>()<br></code></pre></td></tr></table></figure><ul><li>没有及时清理的定时器或回调函数</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> intervalId = <span class="hljs-built_in">setInterval</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(--------)<br>&#125;)<br><span class="hljs-built_in">clearInterval</span>() ---------------------------不清理的话，它会一直隔段时间就执行<br></code></pre></td></tr></table></figure><ul><li>闭包</li></ul></blockquote><hr><h4 id="面试题-5"><a href="#面试题-5" class="headerlink" title="面试题"></a>面试题</h4><blockquote><p>对象内的函数的this要注意区分：如果属性是一个函数此时调用的this就是obj的this(因为属性和对象挂钩)，如果直接return function(){}这时回往window找，因为这是个匿名函数和对象无关</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;the window&#x27;</span><br><span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;My Obj&#x27;</span><br>    <span class="hljs-attr">getNameFunc</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span><br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-title function_">alert</span>(obj.<span class="hljs-title function_">getNameFunc</span>()())-------the <span class="hljs-variable language_">window</span>，无闭包<br><br><span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;the window&#x27;</span><br><span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;My Obj&#x27;</span><br>    <span class="hljs-attr">getNameFunc</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">var</span> that = <span class="hljs-variable language_">this</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>            <span class="hljs-keyword">return</span> that.<span class="hljs-property">name</span><br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-title function_">alert</span>(obj.<span class="hljs-title function_">getNameFunc</span>()())-------<span class="hljs-title class_">My</span> <span class="hljs-title class_">Obj</span>，有闭包<br></code></pre></td></tr></table></figure><hr><h2 id="对象高级"><a href="#对象高级" class="headerlink" title="对象高级"></a>对象高级</h2><h4 id="35-对象创建模式"><a href="#35-对象创建模式" class="headerlink" title="35.对象创建模式"></a><strong>35.对象创建模式</strong></h4><blockquote><p>（1）Object构造函数法 —– 相当于动态创建</p><p>先new 一个对象，然后再手动添加属性和方法</p><p>场景：适用于刚开始不知道对象的属性，但是代码多</p><p>（2）对象字面量法 —– 相当于静态创建</p><p>全放在一个对象字面量中，字面量是指属性值已经定下来了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> obj = &#123;<br> <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;a&#x27;</span>,<br> <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,<br> <span class="hljs-attr">getName</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>     <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span><br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>场景：对象内的数据已经确定，适用于一个对象，多个对象可能会代码重复</p><p>（3）工厂模式 —– 相当于 对象字面量法的封装，弥补了缺点，在工厂里准备好，出来时动态变换</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createPerson</span>(<span class="hljs-params">name,age</span>)&#123;<br> <span class="hljs-keyword">var</span> obj = &#123;    <br>     <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;a&#x27;</span>,    <br>     <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,    <br>     <span class="hljs-attr">getName</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;       <br>      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>    <br>   &#125;<br> &#125;<br> <span class="hljs-keyword">return</span> obj<br>&#125;<br><span class="hljs-keyword">var</span> p1 = <span class="hljs-title function_">createPerson</span>(<span class="hljs-string">&#x27;Tom&#x27;</span>,<span class="hljs-number">12</span>)<br><span class="hljs-keyword">var</span> p2 = <span class="hljs-title function_">createPerson</span>(<span class="hljs-string">&#x27;Bob&#x27;</span>,  <span class="hljs-number">13</span>)<br></code></pre></td></tr></table></figure><p>场景：需要创建多个对象，但是没有一个具体的类型，在用到一个具体类型时又要重新写个工厂</p><p>（4）属性放在构造函数中，方法放在原型中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params">name,age</span>)&#123;<br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name<br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age<br>&#125;<br>fn.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">setName</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">name</span>)&#123;<br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name<br>&#125;<br><span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title function_">fn</span>(<span class="hljs-string">&#x27;Tom&#x27;</span>,<span class="hljs-number">18</span>)<br></code></pre></td></tr></table></figure><p>优点：既是动态，又是函数放在公共的位置（原型），省内存、高效</p></blockquote><h4 id="36-继承形式"><a href="#36-继承形式" class="headerlink" title="36.继承形式"></a>36.继承形式</h4><p><strong>原理：</strong></p><blockquote><p>属性是存在于实例中，方法是存在于prototype指向的Object实例，那我通过子类型的prototype改变地址，指向父类的实例，那么我子类不就既能访问父类实例中的属性，又能通过父类实例的proto_找到其存放的方法</p></blockquote><p><strong>（1）通过原型链继承</strong></p><p><strong>步骤：</strong></p><blockquote><p>将子类型的原型指向父类型的实例</p></blockquote><blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 父函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Super</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">supProp</span>= <span class="hljs-string">&#x27;SP&#x27;</span><br>&#125;<br><span class="hljs-comment">// 父函数添加方法</span><br><span class="hljs-title class_">Super</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">showSuperProp</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>   <span class="hljs-comment">//因为用的是this,因此是在Super里面找函数表达式的this访问都是从左边这个变量找</span><br>   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">supProp</span>)<br>&#125;<br><span class="hljs-comment">// 子函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Sub</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">subProp</span>= <span class="hljs-string">&#x27;SP&#x27;</span><br>&#125;<br><span class="hljs-comment">// 继承</span><br><span class="hljs-title class_">Sub</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Super</span>()<br><span class="hljs-comment">// 将子类型的constructor指向它自己原型的构造函数(此处是手动添加的)</span><br><span class="hljs-title class_">Sub</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> = <span class="hljs-title class_">Sub</span><br><span class="hljs-title class_">Sub</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">showSubProp</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>. subProp)<br>&#125;<br><span class="hljs-keyword">var</span> sub =<span class="hljs-keyword">new</span> <span class="hljs-title class_">Sub</span>()<br>sub.<span class="hljs-title function_">showSuperProp</span>()<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(sub);<br><br></code></pre></td></tr></table></figure></blockquote><p><img src="/2023/03/04/JS%E9%AB%98%E7%BA%A7/%E7%BB%A7%E6%89%BF.png" alt="继承"></p><p><strong>（2）借用构造函数继承</strong></p><blockquote><p>子类型借用 call 函数调用父函数的构造函数来帮助子构造函数来添加初始化属性。这是一种伪继承，因为仅仅是通过调用并复制父类型的属性来添加的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">father</span>(<span class="hljs-params">name,age</span>)&#123; <br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name  <br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">child</span>(<span class="hljs-params">name,age,price</span>)&#123; <br>  father.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>,name,age) <span class="hljs-comment">//相当于this.father(name,age)</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">price</span> = price<br>&#125;<br><span class="hljs-keyword">var</span> c = <span class="hljs-keyword">new</span> <span class="hljs-title function_">child</span>(<span class="hljs-string">&#x27;111&#x27;</span>,<span class="hljs-number">18</span>,<span class="hljs-number">19</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(c.<span class="hljs-property">name</span>);<br></code></pre></td></tr></table></figure></blockquote><p><strong>（3）组合继承</strong></p><blockquote><p>组合前面两种方法，这样就可以完全继承父类型的属性和方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 父函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Super</span>(<span class="hljs-params">name,age</span>)&#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age<br>&#125;<br><span class="hljs-comment">// 父函数添加方法</span><br><span class="hljs-title class_">Super</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">showSuperProp</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>   <span class="hljs-comment">//因为用的是this,因此是在Super里面找函数表达式的this访问都是从左边这个变量找</span><br>   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span>)<br>&#125;<br><span class="hljs-comment">// 子函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Sub</span>(<span class="hljs-params">name,age,price</span>)&#123;<br>   <span class="hljs-title class_">Super</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>,name,age)<br>   <span class="hljs-variable language_">this</span>.<span class="hljs-property">price</span> = price<br>&#125;<br><span class="hljs-comment">// 继承</span><br><span class="hljs-title class_">Sub</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Super</span>()<br><span class="hljs-comment">// 将子类型的constructor指向它自己原型的构造函数(此处是手动添加的)</span><br><span class="hljs-title class_">Sub</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> = <span class="hljs-title class_">Sub</span><br><span class="hljs-title class_">Sub</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">showSubProp</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>. subProp)<br>&#125;<br><span class="hljs-keyword">var</span> sub =<span class="hljs-keyword">new</span> <span class="hljs-title class_">Sub</span>(<span class="hljs-string">&#x27;zhoujie&#x27;</span>,<span class="hljs-number">18</span>,<span class="hljs-number">1808080</span>)<br>sub.<span class="hljs-title function_">showSuperProp</span>()<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(sub.<span class="hljs-property">name</span>);<br></code></pre></td></tr></table></figure></blockquote><p><strong>解答疑惑：为什么第一种方法也可以访问到父类型的属性，还需要第二种方法来添加属性呢？</strong></p><p>不规范。我们规定 属性要放在实例中，而方法放在原型链中。第一种方法通过实例找的其实是父类型的实例，而不是子类型的实例</p><h4 id="37-关于constructor"><a href="#37-关于constructor" class="headerlink" title="37.关于constructor"></a>37.关于constructor</h4><p><strong>位置：</strong> </p><blockquote><p>作为属性 存放在构造函数原型指向的实例对象 上，但它的值是 构造函数的地址（箭头又指回去了），箭头的起始端就是存放该属性的地方</p></blockquote><p><img src="/2023/03/04/JS%E9%AB%98%E7%BA%A7/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0.png" alt="构造函数"></p><p><strong>规则：</strong></p><blockquote><p>一定要指向该 protrotype的构造函数</p></blockquote><p><strong>使用场景：</strong></p><blockquote><p>在进行继承之后，子类型的constructor指向的为 父类的构造函数，因此要重新指定一下。</p></blockquote><blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Sub</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> = <span class="hljs-title class_">Sub</span><br></code></pre></td></tr></table></figure></blockquote><p><strong>思考：既然能手动添加constructor在Super实例里，说明访问constructor是只能通过函数对象（就像上面那样），否则就如果可以通过实例访问的话，Super实例访问的constructor就是Sub的了</strong> </p><h4 id="38-有关prototype-amp-prototype-amp-proto"><a href="#38-有关prototype-amp-prototype-amp-proto" class="headerlink" title="38.有关prototype&amp;[[prototype]]&amp;___proto"></a>38.有关prototype&amp;[[prototype]]&amp;___proto</h4><blockquote><p>（1）每个对象的都有___proto，在创建实例时生成</p><p>（2）每个函数都有prototype，在声明函数时生成</p><p>（3）[[prototype]]就是___proto，不同写法而已</p></blockquote><h4 id="39-有关函数的新理解"><a href="#39-有关函数的新理解" class="headerlink" title="39.有关函数的新理解"></a>39.有关函数的新理解</h4><blockquote><p>看成 类里面的构造函数就行了，函数名的值在js中本来就是构造函数的值</p></blockquote><hr><h4 id="面试题-6"><a href="#面试题-6" class="headerlink" title="面试题"></a>面试题</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fun</span>(<span class="hljs-params">n,o</span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(o)<br>    <span class="hljs-attr">fun</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params">m</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">fun</span>(m,n)<br>    &#125;<br>&#125;<br><span class="hljs-keyword">var</span> a = <span class="hljs-title function_">fun</span>(<span class="hljs-number">0</span>)<br>a.<span class="hljs-title function_">fun</span>(<span class="hljs-number">1</span>)<br>a.<span class="hljs-title function_">fun</span>(<span class="hljs-number">2</span>)<br>a.<span class="hljs-title function_">fun</span>(<span class="hljs-number">3</span>)<br><br><span class="hljs-keyword">var</span> b = <span class="hljs-title function_">fun</span>(<span class="hljs-number">0</span>).<span class="hljs-title function_">fun</span>(<span class="hljs-number">1</span>).<span class="hljs-title function_">fun</span>(<span class="hljs-number">3</span>)<br><br><span class="hljs-keyword">var</span> c = <span class="hljs-title function_">fun</span>(<span class="hljs-number">0</span>).<span class="hljs-title function_">fun</span>(<span class="hljs-number">1</span>)<br>c.<span class="hljs-title function_">fun</span>(<span class="hljs-number">2</span>)<br>c.<span class="hljs-title function_">fun</span>(<span class="hljs-number">3</span>)<br><br>结果：<br><span class="hljs-literal">undefined</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <br><span class="hljs-literal">undefined</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span><br><span class="hljs-literal">undefined</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>考点：</strong></p><blockquote><p>1）只有调用外部函数才会生成闭包</p><p>2）只要只有一个闭包，那么就不会再引用新的外部变量，直到产生新的闭包</p></blockquote><hr><h2 id="线程机制与事件"><a href="#线程机制与事件" class="headerlink" title="线程机制与事件"></a>线程机制与事件</h2><h4 id="40-进程与线程"><a href="#40-进程与线程" class="headerlink" title="40.进程与线程"></a>40.进程与线程</h4><blockquote><p>1）线程池：存放线程对象的容器，便于复用线程对象</p><p>2）程序是单线程还是多线程的是看一个进程中最多有几个线程</p><p>3）js是单线程的</p><p>4）浏览器是多线程的（一个进程处理多个请求）</p><p>5）浏览器是单进程还是多进程看浏览器（现在基本都是多进程，比如新IE、chrome）</p></blockquote><h4 id="42-浏览器内核"><a href="#42-浏览器内核" class="headerlink" title="42.浏览器内核"></a>42.浏览器内核</h4><blockquote><p>1）浏览器内核是浏览器运行最核心的程序</p><p>2）浏览器内核是由多个模块组成</p><ul><li> js引擎 —- 负责js程序的编译和运行</li><li> html,css文档解析模块：负责文本的解析</li><li> DOM/CSS模块：负责dom/css在内存中的相关处理 —— 将标签处理为对象</li><li> 布局和渲染模块：负责页面的布局和效果的绘制</li></ul><p>…… 以上为主线程，下面为分线程</p><ul><li>定时器模块：负责定时器的管理</li><li>时间相应模块：负责事件的管理</li><li>网络请求模块：负责ajax的请求</li></ul></blockquote><h4 id="43-js是单线程执行的"><a href="#43-js是单线程执行的" class="headerlink" title="43.js是单线程执行的"></a>43.js是单线程执行的</h4><blockquote><p>1）为什么js要用单线程模式？</p><p>因为多线程会带来同步问题</p></blockquote><h4 id="44-有关定时器"><a href="#44-有关定时器" class="headerlink" title="44.有关定时器"></a>44.有关定时器</h4><blockquote><p>1）定时器真的是定时执行的吗？</p><p>不是，会有一些延迟</p><p>2）定时器回调函数是在分线程执行的吗？</p><p>在主线程执行</p></blockquote><h4 id="45-事件循环模型"><a href="#45-事件循环模型" class="headerlink" title="45.事件循环模型"></a>45.事件循环模型</h4><p><img src="/2023/03/04/JS%E9%AB%98%E7%BA%A7/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%A8%A1%E5%9E%8B.png" alt="事件循环模型"></p><p><strong>过程：</strong></p><blockquote><p>先执行主线程（执行栈）中的同步代码（初始代码），每碰到一个异步任务 由分线程WebAPIs中的模块管理，放到回调队列（异步队列）中，等主线程执行完之后，就会从回调队列中一个一个取出来到主线程中执行再执行</p></blockquote><p><strong>分线程和回调队列执行顺序并不确定</strong></p><blockquote><p>比如 点击事件，等主线程中执行完，就会拿回调队列中的任务执行，可能执行了之后，我都还没点击，因此这时 分线程的点击事件在 回调队列中的任务后面执行</p></blockquote><h4 id="Web-Workers多线程"><a href="#Web-Workers多线程" class="headerlink" title="Web Workers多线程"></a>Web Workers多线程</h4><blockquote><p>1）定义：它是HTML5为js提供的多线程解决方案</p><p>2）用途：可将一些计算量大的代码交给web Worker作为分线程运行而不冻结用户界面</p><p>3）特点：分线程完全受主线程控制，且无法操控DOM（一旦主线程指定了worker文件，那么文件的this对象默认是worker，而不是window，也自然不好操控DOM）</p><p><img src="/2023/03/04/JS%E9%AB%98%E7%BA%A7/webWorker.png" alt="webWorker"></p><p>4）缺点：</p><ul><li>慢（需要来回发送接收消息）</li><li>不能操作DOM（本身局限）</li><li>并不是所有浏览器都支持</li><li>不能跨域</li><li>————————————–因此公司基本不用，但是要了解</li></ul></blockquote>]]></content>
    
    
    <categories>
      
      <category>Js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>知识点以及面试题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>我的第一篇博客</title>
    <link href="/2023/03/02/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
    <url>/2023/03/02/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<p>终于把Gitee Pages给弄好了，第一次认证的时候竟然说是人像模糊导致认证不通过？那还不是我的iphone13pro人像模式拍照，近处聚焦，远处虚化导致的（好吧，不装了，哈哈），下次知道了如果不想要背景虚化的话拍照要调成正常照片模式。</p><p>之前呢，喜欢每天在博客园上写一些生活上的感悟，由于内容比较私人吧，因此分在“日记”一栏中，也就是不发布出来的，只有自己能看到。但是慢慢地，我发现只有自己能看到的话，就缺少监督，写东西很容易偷懒，能省则省，比如因为某件事明白了某个道理，虽然说自己能看懂，但是缺少一个细致地复盘的过程，这样印象就不深，可能过几天，这个感悟又忘了，也就是输出太少了；另一方面呢，我之前每天记的一些东西，太零散了，不成体系，而且，这些感悟，它缺少一定时间的实践来验证，因此需要过一段时间来写出一篇高质量的文章，那这种公开的博客就很适合写进去。</p><p>今天还是主要说了下，弄博客的原因，由于时间比较仓促，就先写到这里，以后我会在这里写一些技术性的文章还有生活上的感悟。</p>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>生活感悟</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>开启博客的缘由</title>
    <link href="/2023/03/02/%E5%BC%80%E9%80%9A%E5%8D%9A%E5%AE%A2%E7%9A%84%E7%BC%98%E7%94%B1/"/>
    <url>/2023/03/02/%E5%BC%80%E9%80%9A%E5%8D%9A%E5%AE%A2%E7%9A%84%E7%BC%98%E7%94%B1/</url>
    
    <content type="html"><![CDATA[<p>之前在查询技术问题的时候，经常看到别人精心布置的博客，羡慕不已，也幻想过拥有一个属于自己的博客，之前总是觉得没时间搞，想着自己的想法写在一些平台上不是一样的嘛，其实现在看来只是”没有追求”罢了。</p><p>看着自己精美的博客，自己不仅心情变得更好了，而且相比一些平台也更乐于去维护，这是一方面；</p><p>另一方面，“轻易得到的都不会珍惜”，平台上的博客使用门槛低，而且有时候我写一些生活方面的东西，可能比较私人，就不发出来，不发出来就不认真写，久而久之容易养成不认真做事的习惯。</p>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>生活感悟</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
