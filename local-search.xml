<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/04/11/React%E5%AD%A6%E4%B9%A0/"/>
    <url>/2024/04/11/React%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>ElementuUI</title>
    <link href="/2024/04/07/ElementuUI/"/>
    <url>/2024/04/07/ElementuUI/</url>
    
    <content type="html"><![CDATA[<h1 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h1><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a><strong>验证</strong></h3><blockquote><ul><li><p>验证项 只能作用于 :model 中的数据</p></li><li><p>验证项的 <strong>命名以及类型</strong> 需要 === 表单v-model绑定的变量（类型默认string，整数的话 表单项需要用v-model.number来和验证项的 type=’integer’进行比较）</p></li><li><p>触发时机：change事件要注意 一定得是 v-model值发生变化才会触发</p><p>所以 change事件 一般用于 select选项框（随便选一个值都会变），而blur事件是用于input的</p><blockquote><p>change事件如果设置了不为空的验证，需要在最后按钮提交的时候，进行手动验证，才会有反应！</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">this</span>.<span class="hljs-property">$refs</span>[formName].<span class="hljs-title function_">validate</span>(<span class="hljs-function">(<span class="hljs-params">valid</span>) =&gt;</span> &#123;<br>                <span class="hljs-keyword">if</span> (valid) &#123;<br>                    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;submit!&#x27;</span>);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;error submit!!&#x27;</span>);<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;&#125;);<br></code></pre></td></tr></table></figure></blockquote></li><li><p>有全部验证和单独验证两种</p><ul><li><p>如果把rules写在了e-form上，那么就需要针对每个都要写 验证规则</p></li><li><p>单独验证就写在 el-form-item上，例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">el-form-item</span> <span class="hljs-attr">prop</span>=<span class="hljs-string">&quot;和v-model一样&quot;</span> <span class="hljs-attr">:rules</span>=<span class="hljs-string">&quot;[</span></span><br><span class="hljs-string"><span class="hljs-tag">                                        &#123;...&#125;,</span></span><br><span class="hljs-string"><span class="hljs-tag">                                        &#123;...&#125;</span></span><br><span class="hljs-string"><span class="hljs-tag">                                        ]&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">el-form-item</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul></li></ul></blockquote><h3 id="布局"><a href="#布局" class="headerlink" title="布局"></a><strong>布局</strong></h3><blockquote><p>label-width和label-position这两个属性很重要。</p><p>label-width：标签的长度，一般设置100px</p><p>label-position：标签有长度，但是文字不一定有那么长，这时可以设置文字在标签容器内的位置，left|right|top</p></blockquote><h3 id="单选框"><a href="#单选框" class="headerlink" title="单选框"></a><strong>单选框</strong></h3><blockquote><ul><li>v-model绑定的值 需要是 数字类型，这样初始化才能自动选中 对应选项</li></ul></blockquote><h3 id="时间选择器"><a href="#时间选择器" class="headerlink" title="时间选择器"></a><strong>时间选择器</strong></h3><blockquote><ul><li><p>如何只显示 年月日，并且v-model绑定的数据也是 年月日？</p><p>直接加format=”yyyy-MM-dd” value-format=”yyyy-MM-dd”</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;el-date-picker v-model=&quot;form.specificCycle&quot; type=&quot;date&quot; placeholder=&quot;选择日期&quot; <br>                format=&quot;yyyy-MM-dd&quot; value-format=&quot;yyyy-MM-dd&quot;&gt;<br>&lt;/el-date-picker&gt;<br></code></pre></td></tr></table></figure></li></ul></blockquote><h3 id="发送验证码按钮"><a href="#发送验证码按钮" class="headerlink" title="发送验证码按钮"></a><strong>发送验证码按钮</strong></h3><blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">el-button</span> <span class="hljs-attr">:disabled</span>=<span class="hljs-string">&quot;countdown &gt; 0&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;startCountdown&quot;</span>&gt;</span><br>    &#123;&#123; countdown &gt; 0 ? countdown + &#x27;秒&#x27; : &#x27;发送验证码&#x27; &#125;&#125;<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">el-button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script&gt;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-attr">countdown</span>: <span class="hljs-number">0</span>,<br>      <span class="hljs-attr">timer</span>: <span class="hljs-literal">null</span><br>    &#125;;<br>  &#125;,<br>  <span class="hljs-attr">methods</span>: &#123;<br>    <span class="hljs-title function_">startCountdown</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">countdown</span> = <span class="hljs-number">59</span>;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">timer</span> = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">countdown</span> &gt; <span class="hljs-number">0</span>) &#123;<br>          <span class="hljs-variable language_">this</span>.<span class="hljs-property">countdown</span>--;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-built_in">clearInterval</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">timer</span>);<br>          <span class="hljs-variable language_">this</span>.<span class="hljs-property">timer</span> = <span class="hljs-literal">null</span>;<br>        &#125;<br>      &#125;, <span class="hljs-number">1000</span>);<br>    &#125;<br>  &#125;,<br>  <span class="hljs-title function_">beforeDestroy</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">timer</span>) &#123;<br>      <span class="hljs-built_in">clearInterval</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">timer</span>);<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">timer</span> = <span class="hljs-literal">null</span>;<br>    &#125;<br>  &#125;,<br>  <span class="hljs-attr">watch</span>: &#123;<br>       <span class="hljs-attr">countdown</span>: &#123;<br>           <span class="hljs-title function_">handler</span>(<span class="hljs-params">newVal</span>) &#123;<br>               <span class="hljs-variable language_">this</span>.<span class="hljs-property">countdown</span> = newVal<br>           &#125;<br>       &#125;<br>   &#125;<br>&#125;;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure></blockquote><h3 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h3><blockquote><ul><li><p>调整内置样式：需要加     ::v-deep</p><p>将el-form-item的label加粗</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">  ::v-deep .el-form-item__label &#123;<br>          <span class="hljs-attribute">font-weight</span>:bold<br>&gt;&#125;<br></code></pre></td></tr></table></figure></li></ul></blockquote><h3 id="label内容换行"><a href="#label内容换行" class="headerlink" title="label内容换行"></a><strong>label内容换行</strong></h3><blockquote><ul><li>加上 ：或 v-bind，用于允许识别特殊字符</li><li>双引号里面需要 加 单引号 ‘’，否则 右边就是个字符串，无法识别，再加一层单引号 才可以识别</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">el-form-item</span> <span class="hljs-attr">:label</span>=<span class="hljs-string">&quot;&#x27;内容/n(换行)&#x27;&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">el-form-item</span>&gt;</span><br></code></pre></td></tr></table></figure></blockquote><h3 id="输入框长度限制"><a href="#输入框长度限制" class="headerlink" title="输入框长度限制"></a>输入框长度限制</h3><blockquote><p>加上 show-word-limit、type=”text/textarea”、    maxlength=”10” 即可</p><ul><li><p>但是 在 disabled 状态下，字符限制 会消失，解决方案：</p><p>去掉show-word-limit，直接 用插槽的方式自己做（记住插槽使用方式）</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">el-input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;form.productTags&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;请输入&quot;</span></span><br><span class="hljs-tag">                            <span class="hljs-attr">:disabled</span>=<span class="hljs-string">&quot;operator == &#x27;edit&#x27;&quot;</span> <span class="hljs-attr">maxlength</span>=<span class="hljs-string">&quot;6&quot;</span>&gt;</span><br>                            <span class="hljs-tag">&lt;<span class="hljs-name">template</span> #<span class="hljs-attr">suffix</span>&gt;</span><br>                                <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;character-count&quot;</span>&gt;</span>&#123;&#123; form.productTags.length &#125;&#125;/6<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>                            <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br>                        <span class="hljs-tag">&lt;/<span class="hljs-name">el-input</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul></blockquote><h1 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h1><h3 id="属性列宽度"><a href="#属性列宽度" class="headerlink" title="属性列宽度"></a><strong>属性列宽度</strong></h3><blockquote><ul><li><p>直接在el-table-column上的width=”纯数字”加即可，改一个其他会列会自适应缩小</p></li><li><p>不要在el-table-column上来加布局，就算是行内样式也不一定能生效，因为它内置可能有优先级更高的布局，解决办法：里面重新设置一个div来设置布局</p></li><li><p><template slot-scope="scope"></template></p><p>一定要紧挨着el-table-column否则scope不生效</p></li><li><p>el-table-column实现可拖拽式操作</p><ol><li><p>import Sortable from “sortablejs”;—-需要用的组件内</p></li><li><p>在需要拖拽的位置添加点击方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * <span class="hljs-doctag">@description</span>: 拖拽操作</span><br><span class="hljs-comment">  * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">*</span>&#125;</span><br><span class="hljs-comment">  * key-&gt;el-table的class名字</span><br><span class="hljs-comment">  * tableDataForSort-&gt;要拖拽的list</span><br><span class="hljs-comment">  */</span><br> <span class="hljs-title function_">handleRow</span>(<span class="hljs-params">key</span>) &#123;<br>     <span class="hljs-keyword">let</span> tbody = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<br>         <span class="hljs-string">`.<span class="hljs-subst">$&#123;key&#125;</span> .el-table__body-wrapper tbody`</span><br>     );<br>     <span class="hljs-keyword">if</span> (!tbody) <span class="hljs-keyword">return</span>;<br>     <span class="hljs-keyword">let</span> list = [...<span class="hljs-variable language_">this</span>.<span class="hljs-property">tableDataForSort</span>];<br>     <span class="hljs-keyword">let</span> that = <span class="hljs-variable language_">this</span>;<br>     <span class="hljs-keyword">let</span> options = &#123;<br>         <span class="hljs-attr">animation</span>: <span class="hljs-number">500</span>, <span class="hljs-comment">//动画时长</span><br>         <span class="hljs-title function_">onEnd</span>(<span class="hljs-params">&#123; newIndex, oldIndex &#125;</span>) &#123;<br>             <span class="hljs-keyword">if</span> (newIndex !== oldIndex) &#123;<br>                 <span class="hljs-keyword">const</span> currRow = list.<span class="hljs-title function_">splice</span>(oldIndex, <span class="hljs-number">1</span>)[<span class="hljs-number">0</span>];<br>                 list.<span class="hljs-title function_">splice</span>(newIndex, <span class="hljs-number">0</span>, currRow);<br>                 that.<span class="hljs-property">tableDataForSort</span> = [];<br>                 that.$nextTick(<span class="hljs-function">() =&gt;</span> &#123;<br>                     that.<span class="hljs-property">tableDataForSort</span> = list;<br>                 &#125;);<br>             &#125;<br>         &#125;,<br>     &#125;;<br>     <span class="hljs-title class_">Sortable</span>.<span class="hljs-title function_">create</span>(tbody, options);<br> &#125;<br></code></pre></td></tr></table></figure></li></ol></li></ul></blockquote><h1 id="布局-1"><a href="#布局-1" class="headerlink" title="布局"></a>布局</h1><p><strong>如何实现除了flex布局的justify-content以外的任意位置布局？</strong></p><blockquote><p>使用el-col 的 :span属性，一共分为了24个span，某个盒子想要占多少个span，直接在上面写上，一般配合el-row一起使用</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html">&gt;<span class="hljs-tag">&lt;<span class="hljs-name">el-row</span>&gt;</span><br>// 各12，等于平分 <br><span class="hljs-tag">&lt;<span class="hljs-name">el-col</span> <span class="hljs-attr">:span</span>=<span class="hljs-string">&quot;12&quot;</span>&gt;</span><br>   1<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">el-col</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">el-col</span> <span class="hljs-attr">:span</span>=<span class="hljs-string">&quot;12&quot;</span>&gt;</span><br>   1<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">el-col</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">el-row</span>&gt;</span><br></code></pre></td></tr></table></figure></blockquote><p><strong>文字的布局直接使用text-align，盒子的布局才用flex那些</strong></p>]]></content>
    
    
    <categories>
      
      <category>UI框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ElementuUI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端高频面试题(进阶)</title>
    <link href="/2024/02/15/%E5%89%8D%E7%AB%AF%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-%E8%BF%9B%E9%98%B6/"/>
    <url>/2024/02/15/%E5%89%8D%E7%AB%AF%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-%E8%BF%9B%E9%98%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><h3 id="盒子快速居中的方法（字节）"><a href="#盒子快速居中的方法（字节）" class="headerlink" title="盒子快速居中的方法（字节）"></a>盒子快速居中的方法（字节）</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//  方法太多，但是找个最快的方法，只需两步！！！</span><br>&lt;head&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="language-css"><span class="language-xml">     <span class="hljs-selector-class">.con</span>&#123;</span></span><br><span class="language-css"><span class="language-xml">       <span class="hljs-attribute">width</span>: <span class="hljs-number">500px</span>;</span></span><br><span class="language-css"><span class="language-xml">       <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;</span></span><br><span class="language-css"><span class="language-xml">       <span class="hljs-attribute">background-color</span>: aquamarine;</span></span><br><span class="language-css"><span class="language-xml">       <span class="hljs-attribute">margin</span>: auto;----------- 第二步</span></span><br><span class="language-css"><span class="language-xml">     &#125;</span></span><br><span class="language-css"><span class="language-xml">     <span class="hljs-comment">/* (1) 父元素要有长和宽，子元素才有空间水平和垂直居中，否则会自适应为子元素的长和宽，也是为了节省空间</span></span></span><br><span class="hljs-comment"><span class="language-css"><span class="language-xml">        (2) 浏览器屏幕不知道多大，只能用100%的写法</span></span></span><br><span class="hljs-comment"><span class="language-css"><span class="language-xml">        </span></span></span><br><span class="hljs-comment"><span class="language-css"><span class="language-xml">        (3) 在有空间并且在flex布局下，直接写margin:auto可以直接水平、垂直居中</span></span></span><br><span class="hljs-comment"><span class="language-css"><span class="language-xml">     */</span></span></span><br><span class="language-css"><span class="language-xml">     <span class="hljs-selector-tag">body</span>,<span class="hljs-selector-tag">html</span>&#123;</span></span><br><span class="language-css"><span class="language-xml">       <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;</span></span><br><span class="language-css"><span class="language-xml">       <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;</span></span><br><span class="language-css"><span class="language-xml">       <span class="hljs-attribute">display</span>: flex;-------------- 第一步</span></span><br><span class="language-css"><span class="language-xml">     &#125;</span></span><br><span class="language-css"><span class="language-xml">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></span><br>&lt;/head&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;con&quot;</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>快速居中定位<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><blockquote><p>不推荐，父元素设置宽高100%都不行，必须要html、body同时设置，而且还要保证被居中的元素的父元素要和body一样大、或者没有父元素</p></blockquote><h3 id="padding和margin的区别（深信服、字节）"><a href="#padding和margin的区别（深信服、字节）" class="headerlink" title="padding和margin的区别（深信服、字节）"></a>padding和margin的区别（深信服、字节）</h3><p>在于作用的对象不同，前者作用域自身，后者作用于外部对象（为什么答这一点？找到最容易混淆的、面试官最想听到的，不要说定义这种废话）</p><h3 id="vm和百分比的区别（字节）"><a href="#vm和百分比的区别（字节）" class="headerlink" title="vm和百分比的区别（字节）"></a>vm和百分比的区别（字节）</h3><p>前者有继承关系（针对父元素），后者只和设备的屏幕有关系</p><h3 id="行内和块级元素（字节）"><a href="#行内和块级元素（字节）" class="headerlink" title="行内和块级元素（字节）"></a>行内和块级元素（字节）</h3><p>前者 大小（宽和高） 由 内容 决定，后者 宽度（因为是块级，管不到高度） 有继承关系（不设置看父元素，就是往外撑大）</p><h3 id="如何让谷歌浏览器支持小字体（字节）"><a href="#如何让谷歌浏览器支持小字体（字节）" class="headerlink" title="如何让谷歌浏览器支持小字体（字节）"></a>如何让谷歌浏览器支持小字体（字节）</h3><p>由于谷歌浏览器字体默认最小12px，想要更小，就要使用缩放</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">// 为了兼容所有浏览器，都要设置一遍，上面是 WebKit 内核浏览器，下面是现代所有浏览器的，弥补下其他浏览器<br>-web-<span class="hljs-attribute">transform</span>: <span class="hljs-built_in">scale</span>(<span class="hljs-number">0.5</span>)<br>transform: <span class="hljs-built_in">scale</span>(<span class="hljs-number">0.5</span>)<br></code></pre></td></tr></table></figure><h1 id="Js"><a href="#Js" class="headerlink" title="Js"></a>Js</h1><h3 id="var和let（字节）"><a href="#var和let（字节）" class="headerlink" title="var和let（字节）"></a>var和let（字节）</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 1. var有声明提升---先上车后补票</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a) <span class="hljs-comment">// undefined</span><br><span class="hljs-keyword">var</span> a = <span class="hljs-string">&#x27;Jace Zhou&#x27;</span><br><br><span class="hljs-comment">// 2.var有声明覆盖---套牌车</span><br><span class="hljs-keyword">var</span> name2 = <span class="hljs-string">&#x27;2&#x27;</span><br><span class="hljs-keyword">var</span> name2 = <span class="hljs-string">&#x27;3&#x27;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name2) <span class="hljs-comment">// 3</span><br><br><span class="hljs-comment">// 3.var没有局部作用域---红杏出墙</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fun2</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>    <br>  &#125;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i) <span class="hljs-comment">// 5</span><br>&#125;<br>----------------------------以后都要用<span class="hljs-keyword">let</span>，<span class="hljs-keyword">let</span>可以解决上面所有的问题<br></code></pre></td></tr></table></figure><blockquote><p>思路：全局-&gt;局部，都是有关声明</p></blockquote><h3 id="深拷贝与浅拷贝"><a href="#深拷贝与浅拷贝" class="headerlink" title="深拷贝与浅拷贝"></a>深拷贝与浅拷贝</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 基本数据类型，只有赋值，严格上；来说没有拷贝概念，要说也是 深拷贝(互不打扰)</span><br><span class="hljs-keyword">let</span> a = <span class="hljs-number">1</span><br><span class="hljs-keyword">let</span> b = a<br>b = <span class="hljs-number">2</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a,b)<span class="hljs-comment">// 1,2</span><br><br><span class="hljs-comment">// 数组和对象都是浅拷贝(藕断丝连)</span><br><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br><span class="hljs-keyword">let</span> arrNew = arr<br>arrNew.<span class="hljs-title function_">push</span>(<span class="hljs-number">4</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr,arrNew)<span class="hljs-comment">// 都是[1,2,3,4]</span><br><br><span class="hljs-comment">// 配合解构赋值，解构赋值是一维的深拷贝，多维就是浅拷贝---因为多维内层地址是一样的</span><br><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br><span class="hljs-keyword">let</span> arrNew = [...arr]<br>arrNew[<span class="hljs-number">0</span>].<span class="hljs-title function_">push</span>(<span class="hljs-number">4</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr,arrNew)<span class="hljs-comment">// 123; 1234</span><br><br><span class="hljs-keyword">let</span> arr = [[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]]<br><span class="hljs-keyword">let</span> arrNew = [...arr]<br>arrNew[<span class="hljs-number">0</span>].<span class="hljs-title function_">push</span>(<span class="hljs-number">7</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr,arrNew)<span class="hljs-comment">// 都是 1,2,3,4,5,6,7</span><br><br><span class="hljs-comment">// 引用类型的深拷贝如何使用？</span><br><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br><span class="hljs-keyword">let</span> arrNew = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(arr)) <span class="hljs-comment">// 能解决80%的深拷贝，而且JSON方法还有这个好处：原来是什么结构(这里是数组)，转换后还是什么结构,这也是为什么叫拷贝了</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arrNew);<br><br>  <span class="hljs-comment">// 剩下20%指的是 函数类型 无法拷贝，因为JSON只能处理纯数据的，包含逻辑的无法处理</span><br>  <span class="hljs-comment">// 如何手写深拷贝数据 ----------- 针对引用数据类型</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">deepClone</span>(<span class="hljs-params">source</span>)&#123;<br>  <span class="hljs-keyword">const</span> targetObject = source.<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Array</span> ? [] : &#123;&#125;<br>  <span class="hljs-comment">// in 可以搞数组也可以搞对象</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> keys <span class="hljs-keyword">in</span> source) &#123;<br>    <span class="hljs-comment">// 这里还要判断是不是自己的属性是因为只要拷贝自身属性,而不要原型上的</span><br>    <span class="hljs-keyword">if</span> (source.<span class="hljs-title function_">hasOwnProperty</span>(keys)) &#123;<br>      <span class="hljs-comment">// source[keys] 不管是对象还是数组都是可以通过[key]获取值的</span><br>      <span class="hljs-keyword">if</span> (source[keys] &amp;&amp; <span class="hljs-keyword">typeof</span> source[keys] === <span class="hljs-string">&#x27;object&#x27;</span>) &#123; <br>          targetObject[keys] = <span class="hljs-title function_">deepClone</span>(source[keys])<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>          targetObject[keys] = source[keys]<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> targetObject<br>&#125;<br><br><span class="hljs-comment">// 阿里三层代码文化：</span><br><span class="hljs-number">1.</span>运行代码 -- 能用就行<br><span class="hljs-number">2.</span>容错代码 -- 有健壮性<br><span class="hljs-number">3.</span>维护型代码 -- 方便维护<br></code></pre></td></tr></table></figure><blockquote><p>最不缺的就是Vue工程师，如何增加竞争力？React、node、数据结构与算法、工程化、浏览器</p></blockquote><h3 id="this指向"><a href="#this指向" class="headerlink" title="this指向"></a>this指向</h3><blockquote><p>复习+查漏补缺</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// (1)普通this，指向上一层的调用者，可以结合看当前的在哪个作用域</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fun</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>) <br>&#125;<br><span class="hljs-title function_">fun</span>()-------------- <span class="hljs-variable language_">window</span>，因为<span class="hljs-title function_">fun</span>()=&gt;<span class="hljs-variable language_">window</span>.<span class="hljs-title function_">fun</span>()<br><br><span class="hljs-keyword">let</span> obj = &#123;<br>    <span class="hljs-attr">a</span>:<span class="hljs-number">1</span>,<br>    <span class="hljs-attr">b</span>:&#123;<br>        <span class="hljs-attr">fun</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)<br>        &#125;<br>    &#125;<br>&#125;<br>obj.<span class="hljs-property">b</span>.<span class="hljs-title function_">fun</span>()-----------------b，永远指向上一层的调用者，可以结合看当前的在哪个作用域<br><br><span class="hljs-comment">// (2)箭头函数，没有当前箭头函数的作用域和this，始终指向 函数声明时 所在作用于下的this的值，即忽略本该有的作用域和this，往外去找！  -------这里 函数声明时 所在作用于下的this的值会往外去找：window</span><br><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fun</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>       <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>)<br>    &#125;,<span class="hljs-number">500</span>)<br>&#125;<br><span class="hljs-title function_">fun</span>(&#123;<span class="hljs-attr">a</span>:<span class="hljs-number">2</span>&#125;) ------------------ <span class="hljs-number">1</span>，不看当前箭头函数的作用域，往外一层看<br><span class="hljs-comment">// (3)注意！外面要用var定义，不能用let定义！因为let定义的是块级作用域，只供它后面代码直接使用，而全局作用域只能是var定义的，往外找的也是全局作用域的值！------------ 不太对，暂时还是默认let和var是一样的全局作用域，虽然不知为什么用let定义是打印undefined</span><br><br><span class="hljs-comment">// (4)如何改变this指向？call、apply、bind</span><br>fun.<span class="hljs-title function_">call</span>(&#123;<span class="hljs-attr">a</span>:<span class="hljs-number">2</span>&#125;)<span class="hljs-comment">// -------2 将fun交给&#123;a:2&#125;这个对象</span><br><br><span class="hljs-comment">// (5)call、apply、bind的区别？</span><br>call---&gt;参数是对象，apply---&gt;参数是数组<br>call、apply改变<span class="hljs-variable language_">this</span>指向之后还会调用一次函数，而bind只会改变<span class="hljs-variable language_">this</span>指向不会调用函数<br></code></pre></td></tr></table></figure><h3 id="new关键字"><a href="#new关键字" class="headerlink" title="new关键字"></a>new关键字</h3><p><strong>new的一瞬间做了什么？let person = new Person()</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// (1)创建一个空对象（初始化备用对象）</span><br><span class="hljs-keyword">let</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>()<br><span class="hljs-comment">// (2)设置原型（有通道拿到你所有的数据）</span><br>obj.<span class="hljs-property">_proto_</span> = <span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span><br><span class="hljs-comment">// (3)更改this指向（供别人调用）</span><br><span class="hljs-keyword">let</span> result = <span class="hljs-title class_">Person</span>.<span class="hljs-title function_">call</span>(obj)————————<span class="hljs-title class_">Person</span>在改变指向之后会执行函数，又因为是构造函数，会返回一个新创建的对象（和obj类似，obj是备用的）<br><span class="hljs-comment">// (4)判断返回值类型</span><br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> (result) == <span class="hljs-string">&#x27;object&#x27;</span>)&#123;<br>      person = result <br>&#125;<span class="hljs-keyword">else</span>&#123;<br>      person = obj<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>补充知识点：只有用new关键字的函数名，这时这个函数才是一个构造函数</p></blockquote><h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><p><strong>let obj1 = Object.create(null)和let obj2 = {}有什么区别？</strong></p><blockquote><p>结果都是一个空对象，只是前者没有原形链，后者有。</p><p>如何区分使用场景？如果不需要用到原形链上的数据，就第一种，比如在for循环中 第二种还会遍历原型上的数据，效率会低下</p></blockquote><h3 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h3><p><strong>如何实现一个事件委托？</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;ul id=<span class="hljs-string">&quot;ul&quot;</span>&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>0<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>4<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>5<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br>&lt;/ul&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;btn&quot;</span>&gt;</span>点击添加li<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-comment">//  将li委托到ul上，由于ul是包含li的，因为点击li就等于点击ul，就能触发事件</span></span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-keyword">let</span> ul = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;ul&#x27;</span>)</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-comment">// event是当前事件的对象</span></span></span><br><span class="language-javascript"><span class="language-xml">  ul.<span class="hljs-property">onclick</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>)&#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// 此event就是可以获取ul上的属性</span></span></span><br><span class="language-javascript"><span class="language-xml">    event = event || <span class="hljs-variable language_">window</span>.<span class="hljs-property">event</span> <span class="hljs-comment">// 旧版浏览器是window.event，为了兼容</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">let</span> target = event.<span class="hljs-property">target</span> <span class="hljs-comment">// target为目标节点</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// nodeName就是目标节点的节点类型，这里是li，默认必须要是大写</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">if</span>(target.<span class="hljs-property">nodeName</span> == <span class="hljs-string">&#x27;LI&#x27;</span>)&#123;</span></span><br><span class="language-javascript"><span class="language-xml">       <span class="hljs-title function_">alert</span>(target.<span class="hljs-property">innerHTML</span>)</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-comment">// 按钮动态添加li，还能够触发</span></span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-keyword">let</span> btn = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;btn&#x27;</span>)</span></span><br><span class="language-javascript"><span class="language-xml">  btn.<span class="hljs-property">onclick</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;</span></span><br><span class="language-javascript"><span class="language-xml">     <span class="hljs-keyword">let</span> li = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;li&#x27;</span>)</span></span><br><span class="language-javascript"><span class="language-xml">     li.<span class="hljs-property">textContent</span> = ul.<span class="hljs-property">children</span>.<span class="hljs-property">length</span></span></span><br><span class="language-javascript"><span class="language-xml">     ul.<span class="hljs-title function_">appendChild</span>(li)</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p><strong>事件委托的好处（为什么要用事件委托）？</strong></p><ul><li>减少绑定次数，提高了性能</li><li>可处理动态元素（添加和删除），方便管理和维护</li></ul><h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><p><strong>概念+用法</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 以送女朋友礼物为例</span><br>      <span class="hljs-keyword">let</span> isRemember = <span class="hljs-literal">true</span><br>      <span class="hljs-keyword">let</span> birthGift = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123; <span class="hljs-comment">// 一开始new Promise就是提供resolve,reject处理异步问题</span><br>        <span class="hljs-keyword">if</span>(isRemember)&#123;<br>             <span class="hljs-keyword">let</span> lvBag = &#123;<br>                <span class="hljs-attr">color</span>: <span class="hljs-string">&#x27;gold&#x27;</span>,<br>                <span class="hljs-attr">price</span>: <span class="hljs-string">&#x27;$999&#x27;</span><br>             &#125;<br>             <span class="hljs-title function_">resolve</span>(lvBag)<br>          &#125;<span class="hljs-keyword">else</span>&#123;<br>             <span class="hljs-keyword">let</span> err = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;加班去了，忘了！&#x27;</span>)<br>             <span class="hljs-title function_">reject</span>(err)<br>          &#125;<br>      &#125;)<br>      <span class="hljs-comment">// 普通调用</span><br>      <span class="hljs-comment">// function fn() &#123;</span><br>      <span class="hljs-comment">//   birthGift</span><br>      <span class="hljs-comment">//   .then((fullfilled)=&gt;&#123;</span><br>      <span class="hljs-comment">//      console.log(fullfilled);</span><br>      <span class="hljs-comment">//   &#125;)</span><br>      <span class="hljs-comment">//   .catch((rejected)=&gt;&#123;</span><br>      <span class="hljs-comment">//      console.log(rejected);</span><br>      <span class="hljs-comment">//   &#125;)</span><br>      <span class="hljs-comment">// &#125;</span><br>      <span class="hljs-comment">// fn()</span><br><br>      <span class="hljs-comment">// 链式调用,如果原本then的回调返回的也是promise，那么可以继续then，承上启下</span><br>      <span class="hljs-keyword">let</span> <span class="hljs-title function_">supplyGift</span> = (<span class="hljs-params">lv</span>) =&gt; &#123;<br>          <span class="hljs-keyword">let</span> lip = &#123;<br>             <span class="hljs-attr">color</span>:<span class="hljs-string">&#x27;red&#x27;</span>,<br>             <span class="hljs-attr">price</span>: <span class="hljs-string">&#x27;$888&#x27;</span><br>          &#125;<br>          <span class="hljs-comment">// 整合作为最后的数据给他人使用</span><br>          <span class="hljs-keyword">let</span> msg = &#123;<br>             lv,<br>             lip,<br>             <span class="hljs-attr">msg</span>:<span class="hljs-string">`将收到包包颜色: <span class="hljs-subst">$&#123;lv.color&#125;</span>, 口红颜色: <span class="hljs-subst">$&#123;lip.color&#125;</span>`</span><br>          &#125;<br>          <span class="hljs-comment">// resolve是promise的静态方法，不需要new</span><br>          <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(msg)<br>      &#125;<br>      <span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>) &#123;<br>        birthGift<br>        .<span class="hljs-title function_">then</span>(supplyGift)<br>        .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">fullfilled</span>)=&gt;</span>&#123;<br>           <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(fullfilled);<br>        &#125;)<br>        .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">rejected</span>)=&gt;</span>&#123;<br>           <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(rejected.<span class="hljs-property">message</span>);<br>        &#125;)<br>      &#125;<br>      <span class="hljs-title function_">fn</span>()<br></code></pre></td></tr></table></figure><blockquote><p>下面是关于promise的一些自己的思考：</p><p>（1）到底什么是异步？</p><p>简单来说就是 不会因为要执行当前的任务 而暂时阻塞影响到下面任务的执行</p><p>（2）异步是怎么实现的？</p><p>通过事件循环机制：碰到异步操作先放入队列中，先继续执行主线程代码，主线程代码执行完毕之后，再从队列中拿异步操作出来执行，所以说异步并不是说和主线程代码同步执行，而是先执行同步代码，再执行异步代码。</p><p>（3）事件循环机制处理的对象包括哪些，它们的顺序是什么？</p><p>包括 宏任务和微任务。</p><p>宏任务：定时器、IO操作（后端特有）、网络请求、setImmediate(后端特有）、requestAnimationFrame（用于浏览器执行下一帧动画的函数） ————– 耗时的操作</p><p>微任务：promise().then、process.nextTick（后端特有） ————–紧急的操作</p><p>执行顺序：第一个宏任务（主线程）-&gt;微任务-&gt;宏任务</p><p>（4）可以说说setImmediate于setTimeout的区别吗？</p><p>setImmediate中的Immediate是立刻的意思，但是并不是说setImmediate比定时器限制性，相反定时器是在事件循环的第一个阶段：timers阶段，而setImmediate是在事件循环的最后阶段：check阶段，一般来说是 定时器（时间设置为0的话）比setImmediate先执行，但是 可能在timers阶段用来处理定时器的线程不够了，定时器未能及时执行，此时就可以 使用setImmediate在后面的check帮它执行</p><p>（5）宏任务和微任务是前端和后端都有的概念吗？为什么你这里标注了有些是后端特有的？</p><p>因为，前端浏览器的事件循环机制和Nodejs事件循环机制是不同的，不是一个东西，但是概念类似，也都有宏任务和微任务的概念，只是处理的任务不同，浏览器的事件循环机制是一般处理网络请求等，而后端处理io操作等；</p><p>（6）回到promise，从基本使用来看，promise其实也就是在做一个数据传递的工作，那为什么还要用promise？</p><p>因为异步操作的数据返回的时间是不定的，而promise它是解决异步操作的优雅的解决方案。哪里体现优雅了？最优雅的是 写法上不用像以前的回调地狱那样代码冗长、可读性差；相反，promise的then方法易于理解、可读性强。</p><p>（7）为什么then方法里面的参数是一个函数，而不直接通过then的返回值获取数据？</p><p>既然要获取返回的数据，那肯定是要对数据进行处理的，而不是简单返回，如果设计成let result = then()，还要在外面写数据处理的逻辑，那直接在then函数的参数里面 1）接收数据 2）对数据进行处理 3）数据来了，函数还能自动执行，那不是一举三得？这个也是回调函数的优点。</p><p>（8）在底层then方法的回调函数是什么时候添加的，又是什么时候调用的？是调用then方法的时候调用的吗？</p><p>不是，看似是调用then方法时调用的，其实是在 then方法实现中 添加，而在resolve/reject方法中 调用的，为什么？我们的需求是 要在状态改变（pending-&gt;fullfiled、pending-&gt;rejected）时，调用回调函数，最源头来看，什么时候状态改变？就是调用resolve/reject时；为什么 在 then方法实现中 添加？因为then方法在调用时 回调函数的声明才传进来，这里是最先接触到回调函数的，一传进来就立马缓存下来。</p><p><u>思路:</u> 异步概念-&gt;如何实现异步，涉及到事件循环机制-&gt;事件循环机制有什么，如何运作-&gt;回到promise</p></blockquote><p><strong>手写一个promise（美团、字节）</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">myPromise</span>(<span class="hljs-params">excutor</span>) &#123;<br>          <span class="hljs-comment">// 1.Promise构造函数的基本结构(变量和函数)</span><br>          <span class="hljs-keyword">let</span> self = <span class="hljs-variable language_">this</span> <span class="hljs-comment">// self便于理解</span><br>          self.<span class="hljs-property">status</span> = <span class="hljs-string">&#x27;pending&#x27;</span><br>          <span class="hljs-comment">// resolve,reject函数传递数据后的缓存</span><br>          self.<span class="hljs-property">value</span> = <span class="hljs-string">&#x27;&#x27;</span><br>          self.<span class="hljs-property">reason</span> = <span class="hljs-string">&#x27;&#x27;</span><br>          <span class="hljs-comment">// 添加缓存数组</span><br>          self.<span class="hljs-property">fullfilledCallbacks</span> = []<br>          self.<span class="hljs-property">rejectedCallbacks</span> = []<br><br>          <span class="hljs-comment">// 4.开始处理resolve、reject，需要这两函数传值</span><br>          <span class="hljs-keyword">function</span> <span class="hljs-title function_">resolve</span>(<span class="hljs-params">value</span>)&#123;<br>              <span class="hljs-comment">// 需要判断是pendning，因为操作是不可逆的，只能从pending-&gt;fullfilled</span><br>              <span class="hljs-keyword">if</span>(self.<span class="hljs-property">status</span> == <span class="hljs-string">&#x27;pending&#x27;</span>)&#123;<br>                <span class="hljs-comment">// 缓存值(后面会用到)，更改状态</span><br>                 self.<span class="hljs-property">value</span> = value<br>                 self.<span class="hljs-property">status</span> = <span class="hljs-string">&#x27;fullfilled&#x27;</span><br><br>                <span class="hljs-comment">// 7.状态改变时调用回调(仅调用，这时还没有链式串起来)</span><br>                self.<span class="hljs-property">fullfilledCallbacks</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">callback</span>) =&gt;</span> <span class="hljs-title function_">callback</span>(value))<br>              &#125;<br>          &#125;<br><br>          <span class="hljs-keyword">function</span> <span class="hljs-title function_">reject</span>(<span class="hljs-params">reason</span>) &#123;<br>            <span class="hljs-keyword">if</span>(self.<span class="hljs-property">status</span> == <span class="hljs-string">&#x27;pending&#x27;</span>)&#123;<br>                <span class="hljs-comment">// 缓存值，更改状态</span><br>                 self.<span class="hljs-property">reason</span> = reason<br>                 self.<span class="hljs-property">status</span> = <span class="hljs-string">&#x27;rejected&#x27;</span><br><br>                 self.<span class="hljs-property">rejectedCallbacks</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">callback</span>) =&gt;</span> <span class="hljs-title function_">callback</span>(reason))<br>              &#125;<br>          &#125;<br><br>          self.<span class="hljs-property">resolve</span> = resolve<br>          self.<span class="hljs-property">reject</span> = reject<br><br>          <span class="hljs-comment">// excutor是一个函数，它有两个函数参数resolve,reject，用于控制状态</span><br>          <span class="hljs-comment">// 在这里要立即执行，以便执行传入Promise的回调</span><br>          <span class="hljs-keyword">try</span> &#123;<br>              <span class="hljs-title function_">excutor</span>(resolve,reject)<br>          &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>            <span class="hljs-comment">// 有错误刚好利用自带的处理错误的函数，返回给回调函数</span><br>              <span class="hljs-title function_">reject</span>(error)<br>          &#125;<br>      &#125;<br><br>      <span class="hljs-comment">// 2.不管什么状态，都可以通过then方法来获取结果，即then方法是所有promise实例必须有的，可以放入原型中</span><br>      myPromise.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">then</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">onFullFilled,onRejected</span>) &#123;<br>        <span class="hljs-keyword">let</span> self = <span class="hljs-variable language_">this</span><br>        <span class="hljs-comment">// 5.要处理传过来的resolve、reject，是就用，不是就继续resolve、reject给下一次执行回调</span><br>         onFullFilled = <span class="hljs-keyword">typeof</span> onFullFilled === <span class="hljs-string">&#x27;function&#x27;</span> ?<br>        <span class="hljs-comment">//  5.1 不是函数的情况写的有点粗糙，运行有点问题:undefined，但是这不是重点，重点是知道会传给下一次就行了</span><br>         onFullFilled : <span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>)&#123; self.<span class="hljs-title function_">resolve</span>(data) &#125;<br>         onRejected = <span class="hljs-keyword">typeof</span> onRejected === <span class="hljs-string">&#x27;function&#x27;</span> ?<br>         onRejected : <span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>)&#123; self.<span class="hljs-title function_">reject</span>(data) &#125;<br><br>        <span class="hljs-comment">// 6.将回调缓存 1.0版本，不能支持链式调用，因为没有返回Promise对象，因为只有返回Promise对象才能调用then</span><br>        <span class="hljs-comment">//  let self = this</span><br>        <span class="hljs-comment">//  if(self.status == &#x27;pending&#x27;)&#123;</span><br>        <span class="hljs-comment">//     self.fullfilledCallbacks.push(onFullFilled)</span><br>        <span class="hljs-comment">//     self.rejectedCallbacks.push(onRejected)</span><br>        <span class="hljs-comment">//  &#125;</span><br>        <span class="hljs-comment">// 9.下面是2.0版本，加了链式调用判断，若不需链式调用，直接resolve(x)执行函数</span><br>        <span class="hljs-comment">// 为什么又要重新定义self?上面的用不了?</span><br>        <span class="hljs-keyword">if</span>(self.<span class="hljs-property">status</span> === <span class="hljs-string">&#x27;fullfilled&#x27;</span>)&#123;<br>          <span class="hljs-comment">// 9.1返回Promise是为了链式调用</span><br>          <span class="hljs-comment">// 9.2为什么是返回new myPromise而不是Promise?</span><br>          <span class="hljs-comment">// 现在都是自己手写Promise源码，你这调用现成的还算什么手写promise</span><br>           <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title function_">myPromise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>               <span class="hljs-keyword">try</span> &#123;<br>                  <span class="hljs-keyword">let</span> x = <span class="hljs-title function_">onFullFilled</span>(self.<span class="hljs-property">value</span>)<br>                  x <span class="hljs-keyword">instanceof</span> myPromise ? x.<span class="hljs-title function_">then</span>(resolve,reject) : <span class="hljs-title function_">resolve</span>(x)<span class="hljs-comment">// 注意传的是x，而不是self.value</span><br>               &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>                  <span class="hljs-title function_">reject</span>(error)<br>               &#125;<br><br>           &#125;)<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(self.<span class="hljs-property">status</span> === <span class="hljs-string">&#x27;rejected&#x27;</span>)&#123;<br>           <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title function_">myPromise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>              <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">let</span> x = <span class="hljs-title function_">onRejected</span>(self.<span class="hljs-property">reason</span>)<br>                x <span class="hljs-keyword">instanceof</span> myPromise ? x.<span class="hljs-title function_">then</span>(resolve,reject) : <span class="hljs-title function_">resolve</span>(x)<br>              &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>                <span class="hljs-title function_">reject</span>(error)<br>              &#125;<br>           &#125;)<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(self.<span class="hljs-property">status</span> === <span class="hljs-string">&#x27;pending&#x27;</span>)&#123;<br>          <span class="hljs-comment">// 9.3为什么pending还要加Promise?因为可能是第一次调用这时状态没有变化，但是后续可能会链式调用</span><br>           <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title function_">myPromise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>              <span class="hljs-comment">// 9.4为什么这里push里面不是直接传onFullFilled?</span><br>              <span class="hljs-comment">// 因为要根据判断是否链式调用，直接传onFullFilled就是直接执行，没有链式调用的</span><br>               self.<span class="hljs-property">fullfilledCallbacks</span>.<span class="hljs-title function_">push</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>                  <span class="hljs-keyword">let</span> x = <span class="hljs-title function_">onFullFilled</span>(self.<span class="hljs-property">value</span>)<br>                  x <span class="hljs-keyword">instanceof</span> myPromise ? x.<span class="hljs-title function_">then</span>(resolve,reject) : <span class="hljs-title function_">resolve</span>(x)<br>               &#125;)<br><br>               self.<span class="hljs-property">rejectedCallbacks</span>.<span class="hljs-title function_">push</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>                  <span class="hljs-keyword">let</span> x = <span class="hljs-title function_">onRejected</span>(self.<span class="hljs-property">reason</span>)<br>                  x <span class="hljs-keyword">instanceof</span> myPromise ? x.<span class="hljs-title function_">then</span>(resolve,reject) : <span class="hljs-title function_">reject</span>(x)<br>               &#125;)<br>           &#125;)<br>        &#125;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 为什么三种状态都要进行判断?</span><br><span class="hljs-comment">         * 因为无论是第一次还是后续链式调用传过来的函数可能返回Promise可能不反回，这个说不准</span><br><span class="hljs-comment">         * 因此每次都要判断是否继续链式调用</span><br><span class="hljs-comment">         * */</span>  <br><br>      &#125;<br><br>      myPromise.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">catch</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">fn</span>)&#123;<br>        <span class="hljs-comment">// 10.直接用then方法，因为then里面有对rejected状态的处理</span><br>        <span class="hljs-comment">// 10.1 就这么记忆:原型上的函数的this是可以追踪到构造函数的</span><br>         <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">then</span>(<span class="hljs-literal">null</span>,fn)<br>      &#125;<br><br>      <span class="hljs-comment">// 3.无法执行?在构造函数添加excutor来立即执行</span><br>      <span class="hljs-keyword">let</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title function_">myPromise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>         <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;测试数据&#x27;</span>);<br><br>          <span class="hljs-comment">//  8.验证: 处理异步操作</span><br>          <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>              <span class="hljs-title function_">resolve</span>(<span class="hljs-number">99</span>)<br>          &#125;,<span class="hljs-number">2000</span>)<br>      &#125;)<br>      <span class="hljs-comment">// p1.then((data)=&gt;&#123;console.log(data);&#125;)</span><br>      p1.<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">data1</span>)=&gt;</span>&#123;  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(&#123;<span class="hljs-attr">data1</span>:data1,<span class="hljs-attr">data2</span>:<span class="hljs-string">&#x27;链式数据&#x27;</span>&#125;)&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">dataTotal</span>)=&gt;</span>&#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(dataTotal);&#125;)<br></code></pre></td></tr></table></figure><p><img src="/2024/02/15/%E5%89%8D%E7%AB%AF%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-%E8%BF%9B%E9%98%B6/%E6%89%8B%E5%86%99promise%E7%BB%93%E6%9E%9C.png" alt="结果"></p><h1 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h1><h3 id="从哪方面可以性能优化？"><a href="#从哪方面可以性能优化？" class="headerlink" title="从哪方面可以性能优化？"></a>从哪方面可以性能优化？</h3><ul><li>加载<ol><li>使用CDN加载静态资源（CDN会将资源缓存在各个服务器中，获取资源时会寻找最近的服务器节点）</li><li>减小文件大小（webpack等工具进行压缩，比如去除空格换行）</li><li>减少http请求（精灵图的图片合并、文件合并等）</li><li>SSR服务端渲染</li><li>懒加载</li></ol></li><li>减少DOM操作，减少回流和重绘、文档碎片（一个临时文档，可以把所有文档操作添加入文档碎片，最后合并到文档中，只会有一次回流和重绘）</li></ul><p><img src="/2024/02/15/%E5%89%8D%E7%AB%AF%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-%E8%BF%9B%E9%98%B6/%E6%80%A7%E8%83%BD%E4%BD%93%E7%B3%BB.png" alt="性能体系"></p><p><img src="/2024/02/15/%E5%89%8D%E7%AB%AF%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-%E8%BF%9B%E9%98%B6/%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88.png" alt="技术方案"></p><h3 id="懒加载原理"><a href="#懒加载原理" class="headerlink" title="懒加载原理"></a>懒加载原理</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;style&gt;<br>    <span class="hljs-comment">/* 图片一定要设置宽和高，否则图片会变形、布局会混乱，导致一些意外的问题 */</span><br>     img&#123;<br>       <span class="hljs-attr">width</span>: 400px;<br>       <span class="hljs-attr">height</span>: 400px;<br>       <span class="hljs-attr">display</span>: block;<br>       margin-<span class="hljs-attr">bottom</span>: 50px;<br>     &#125;<br>  &lt;/style&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>   &lt;img src=&quot;./images/loading.gif&quot; data-src=&quot;./images/perf.png&quot;&gt;<br>   &lt;img src=&quot;./images/loading.gif&quot; data-src=&quot;./images/tech.png&quot;&gt;<br>   &lt;img src=&quot;./images/loading.gif&quot; data-src=&quot;./images/jechen.png&quot;&gt;<br>   &lt;img src=&quot;./images/loading.gif&quot; data-src=&quot;./images/web Worker.png&quot;&gt;<br><br>   &lt;script&gt;<br>      let num = document.getElementsByTagName(&quot;img&quot;).length // 4<br>      let img = document.getElementsByTagName(&quot;img&quot;) // 4个节点<br>      let n = 0 // 用于防止下次加载再次重新加载<br> <br>      lazyLoad()<br>      window.onscroll = lazyLoad<br><br>      function lazyLoad()&#123;<br>         let seeHeight = document.documentElement.clientHeight // 可视高度(屏幕高度)<br>         let scrollTop = document.documentElement.scrollTop || document.body.scrollTop // 滚动条上面空隙高度(为了加载下面的图片)<br>         for(let i = n;i&lt;num;i++)&#123;<br>           if(img[i].offsetTop &lt; (seeHeight + scrollTop))&#123;<br>              if(img[i].getAttribute(&quot;src&quot;) == &quot;./images/loading.gif&quot;)&#123;<br>                 img[i].src = img[i].getAttribute(&quot;data-src&quot;)<br>              &#125;<br>              n = i+1; // 防止下次重复加载<br>           &#125;<br>         &#125;<br>      &#125;<br>   &lt;/script&gt; <br></code></pre></td></tr></table></figure><blockquote><p>下面贴一张前端工程师的发展之路：</p><p><img src="/2024/02/15/%E5%89%8D%E7%AB%AF%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-%E8%BF%9B%E9%98%B6/%E5%89%8D%E7%AB%AF%E5%8F%91%E5%B1%95%E4%B9%8B%E8%B7%AF.png" alt="前端发展之路"></p><p>第一年：10k，第二年15k，第三年18k，第五年20k </p><p>（工作年限是参考，关键还得看你的技术，进门容易，进阶难）</p><p><img src="/2024/02/15/%E5%89%8D%E7%AB%AF%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-%E8%BF%9B%E9%98%B6/%E5%A4%A7%E5%89%8D%E7%AB%AF%E6%97%B6%E4%BB%A3%E7%9A%84%E6%8A%80%E6%9C%AF%E5%9B%BE%E8%B0%B1.png" alt="大前端时代的技术图谱"></p><p>其中，5、6是加分项，大厂必备。若果能把这6项都搞懂了，至少20k以上</p><p><img src="/2024/02/15/%E5%89%8D%E7%AB%AF%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-%E8%BF%9B%E9%98%B6/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%89%8D%E6%B2%BF%E5%9C%B0%E8%96%AA%E8%B5%84.png" alt="程序员前言阵地"></p><p>大佬对于跳槽的看法：如果 跳槽后在试用期的工资 = 前一家公司的全薪，再跳，否则划不来（涨一两千）</p></blockquote><h1 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h1><h3 id="Vue底层原理"><a href="#Vue底层原理" class="headerlink" title="Vue底层原理"></a>Vue底层原理</h3><p><strong>前后端分离的根本原因是什么？</strong></p><p>因为MVVM模式中的VM（viewmodel），即视图模型，它相当于MVC模式的C-controller，可以临时存放数据了，不完全依赖后端了（数据只能传给后端），这时才有了前后端分离。</p><p><strong>Vue的历史？</strong></p><blockquote><p>Vue1.0版本：</p><p>此时没有虚拟DOM，每个数据都有一个watcher</p><p>优点：一对一更新，效率高，不需要中间步骤</p><p>缺点：更新节点太多时，会大量操作DOM，违背数据驱动初心</p><p>Vue2.0版本：</p><p>引入了虚拟DOM的概念</p></blockquote><p><strong>v-model的实现原理？</strong></p><p>事件绑定+数据劫持</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;input type=<span class="hljs-string">&quot;text&quot;</span> id=<span class="hljs-string">&quot;input&quot;</span>&gt;<br>&lt;br&gt;<br>内容: <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;span&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-keyword">let</span> obj = &#123;&#125;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-comment">// 数据劫持</span></span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(obj,<span class="hljs-string">&#x27;username&#x27;</span>,&#123;</span></span><br><span class="language-javascript"><span class="language-xml">     <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>)&#123;</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;取值&#x27;</span>);<span class="hljs-comment">// 正常来说，是需要一个另外在Js定义的中间变量来返回出去,然后在set里面修改这个变量的</span></span></span><br><span class="language-javascript"><span class="language-xml">     &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">     <span class="hljs-title function_">set</span>(<span class="hljs-params">val</span>)&#123;</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;span&#x27;</span>).<span class="hljs-property">innerText</span> = val</span></span><br><span class="language-javascript"><span class="language-xml">     &#125;</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;)</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-comment">// 绑定事件</span></span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;input&#x27;</span>).<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;keyup&#x27;</span>,<span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      obj.<span class="hljs-property">username</span> = event.<span class="hljs-property">target</span>.<span class="hljs-property">value</span></span></span><br><span class="language-javascript"><span class="language-xml">  &#125;)</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p><strong>Vue2.0的响应式原理？</strong></p><blockquote><p>简单来说：数据劫持（劫持数据）+发布订阅模式（将劫持的数据应用到模板）</p><p>js代码实现如下：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 订阅器模型</span><br><span class="hljs-keyword">let</span> dep = &#123;<br>  <span class="hljs-comment">// 订阅者</span><br>  <span class="hljs-attr">clientList</span>: &#123;&#125;,<br>  <span class="hljs-comment">// 添加订阅者,key为用户唯一id,fn是这个用户的某个订阅内容的回调----fn相当于wacher主动添加到Dep中</span><br>  <span class="hljs-attr">listen</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">key, fn</span>) &#123;<br>     (<span class="hljs-variable language_">this</span>.<span class="hljs-property">clientList</span>[key] || (<span class="hljs-variable language_">this</span>.<span class="hljs-property">clientList</span>[key] = [])).<span class="hljs-title function_">push</span>(fn)<br>  &#125;,<br>  <span class="hljs-comment">// 推送方法：针对某个用户的订阅内容，循环执行订阅内容的回调以添加(填充)消息</span><br>  <span class="hljs-comment">// 调用时相当于Dep通知wacher更新数据(调用fn)</span><br>  <span class="hljs-attr">trigger</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 从arguments中获取函数传递过来的参数，有下面可知第一个参数是指哪个用户，于是用shift</span><br>    <span class="hljs-keyword">let</span> key = <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">shift</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">arguments</span>),<br>      fns = <span class="hljs-variable language_">this</span>.<span class="hljs-property">clientList</span>[key]<br>    <br>    <span class="hljs-comment">// 若该用户没有订阅内容，则不推送</span><br>    <span class="hljs-keyword">if</span> (!fns || fns.<span class="hljs-property">length</span> == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    <br>    <span class="hljs-comment">// 否则循环填充用户对应的各个订阅内容，这个改变this指向是因为在填充内容是要用到当前上下文的数据</span><br>    <span class="hljs-comment">// arguments是订阅内容回调执行的所需参数</span><br>    <span class="hljs-comment">// 这个循环等于如下写法：</span><br>    <span class="hljs-comment">// for (let i = 0; i &lt; fns.length; i++)&#123;</span><br>    <span class="hljs-comment">//   let fn = fns[i];</span><br>    <span class="hljs-comment">//   fn.apply(this,arguments)</span><br>    <span class="hljs-comment">// &#125;</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, fn; fn = fns[i++];)&#123;<br>       <span class="hljs-comment">// arguments就相当于下面的text参数，注意用apply而不是call，这里arguments是类数组</span><br>       fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>,<span class="hljs-variable language_">arguments</span>)<br>    &#125;<br>  &#125;<br>&#125;<br><span class="hljs-comment">// 数据劫持</span><br><span class="hljs-keyword">let</span> dataHijack = <span class="hljs-keyword">function</span> (<span class="hljs-params">&#123; data, dataTarget, targetView, selector &#125;</span>) &#123;<br>  <span class="hljs-keyword">let</span> value = <span class="hljs-string">&#x27;&#x27;</span>,<span class="hljs-comment">// 数据劫持的临时变量</span><br>    el = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(selector) <span class="hljs-comment">// 获取选择器</span><br>  <br>    <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(data,dataTarget,&#123;<br>      <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;取值&#x27;</span>);<br>        <span class="hljs-keyword">return</span> value<br>      &#125;,<br>      <span class="hljs-title function_">set</span>(<span class="hljs-params">val</span>) &#123;<br>        value = val<br>        <span class="hljs-comment">// 推送消息，通知订阅者，给targetView这个用户推送消息val</span><br>        dep.<span class="hljs-title function_">trigger</span>(targetView,val)<br>      &#125;<br>    &#125;)<br>  <br>  <span class="hljs-comment">// 添加订阅者,targetView看作是订阅者id,它订阅的内容就是更新text</span><br>  dep.<span class="hljs-title function_">listen</span>(targetView, <span class="hljs-keyword">function</span> (<span class="hljs-params">text</span>) &#123;<br>      el.<span class="hljs-property">innerHTML</span> = text<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>引入上述js并使用如下</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 引入js并使用</span><br>  订阅者<span class="hljs-number">1</span>的视图: <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;span-view1&quot;</span>&gt;</span>111<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br>  订阅者<span class="hljs-number">2</span>的视图: <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;span-view2&quot;</span>&gt;</span>222<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./index.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">       <span class="hljs-comment">// 用于拦截的对象，也是用于更新视图的中间对象</span></span></span><br><span class="language-javascript"><span class="language-xml">       <span class="hljs-keyword">let</span> obj = &#123;&#125;</span></span><br><span class="language-javascript"><span class="language-xml">       </span></span><br><span class="language-javascript"><span class="language-xml">       <span class="hljs-title function_">dataHijack</span>(&#123;</span></span><br><span class="language-javascript"><span class="language-xml">         <span class="hljs-attr">data</span>: obj,</span></span><br><span class="language-javascript"><span class="language-xml">         <span class="hljs-attr">dataTarget</span>: <span class="hljs-string">&#x27;one&#x27;</span>,<span class="hljs-comment">//订阅者需要的属性</span></span></span><br><span class="language-javascript"><span class="language-xml">         <span class="hljs-attr">targetView</span>: <span class="hljs-string">&#x27;userTest1&#x27;</span>,<span class="hljs-comment">//订阅者名字1</span></span></span><br><span class="language-javascript"><span class="language-xml">         <span class="hljs-attr">selector</span>: <span class="hljs-string">&#x27;.span-view1&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml">       &#125;)</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">       <span class="hljs-title function_">dataHijack</span>(&#123;</span></span><br><span class="language-javascript"><span class="language-xml">         <span class="hljs-attr">data</span>: obj,</span></span><br><span class="language-javascript"><span class="language-xml">         <span class="hljs-attr">dataTarget</span>: <span class="hljs-string">&#x27;two&#x27;</span>,<span class="hljs-comment">//临时添加的属性</span></span></span><br><span class="language-javascript"><span class="language-xml">         <span class="hljs-attr">targetView</span>: <span class="hljs-string">&#x27;userTest2&#x27;</span>,<span class="hljs-comment">//订阅者名字2</span></span></span><br><span class="language-javascript"><span class="language-xml">         <span class="hljs-attr">selector</span>: <span class="hljs-string">&#x27;.span-view2&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml">       &#125;)</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">       <span class="hljs-comment">// 如下操作以及在浏览器手动更改值 会自动修改到模板上</span></span></span><br><span class="language-javascript"><span class="language-xml">       obj.<span class="hljs-property">one</span> = <span class="hljs-string">&#x27;测试值1&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml">       obj.<span class="hljs-property">two</span> = <span class="hljs-string">&#x27;测试值2&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><blockquote><p>Vue3的响应式原理：见———————-&gt;Vue2和Vue3响应式数据的处理的不同</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>面试题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端综合</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端高频面试题-基础</title>
    <link href="/2024/01/03/%E5%89%8D%E7%AB%AF%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%9F%BA%E7%A1%80/"/>
    <url>/2024/01/03/%E5%89%8D%E7%AB%AF%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><h3 id="1-说一下CSS盒模型"><a href="#1-说一下CSS盒模型" class="headerlink" title="1.说一下CSS盒模型"></a><strong>1.说一下CSS盒模型</strong></h3><blockquote><p>是什么：在HTML上任何一个元素都可以看成一个CSS盒模型</p><p>有什么：对于标准盒模型来说，包含四个属性：margin、border、padding、content</p><p>​               但是对于IE盒模型来说，只有两个属性：margin、content（已包含border、padding）</p><p>对于有什么如何区分：通过属性box-sizing来设置两种模型:content-box-&gt;标准盒模型</p><p>​                                                                                                    border-box-&gt;IE盒模型</p></blockquote><h3 id="2-CSS选择器的优先级"><a href="#2-CSS选择器的优先级" class="headerlink" title="2.CSS选择器的优先级"></a>2.CSS选择器的优先级</h3><blockquote><p>是什么：它是CSS三大特性之一，三大特性是：继承性、重叠性（相同优先级选择哪个）、优先级</p><p>（如何记忆三大特性？继承性和优先级都可能涉及重叠性，即后设置的都会覆盖先设置的，继承性不用选择直接拿来用，优先级还要选一下，那就这么记：重叠性-&gt;继承性-&gt;优先级）</p><p>有什么：!important（强制生效，可修改默认样式）&gt; 行内标签 &gt; id选择器 &gt; 类选择器（包括 属性值类选择器：[class=’属性名’]；*[class^=’prefix-‘],=，*是通配符，^=表时匹配前缀） &gt; 标签选择器 &gt; 全局选择器（*{}）</p></blockquote><h3 id="3-隐藏元素的方法有哪些？"><a href="#3-隐藏元素的方法有哪些？" class="headerlink" title="3.隐藏元素的方法有哪些？"></a>3.隐藏元素的方法有哪些？</h3><blockquote><ol><li>display:none（不占空间，彻底消除）</li><li>visibility:hidden或opacity:0（占空间，仅仅是视觉上看不到）</li><li>clip-path裁剪（占空间，裁剪时相当于复制一份裁再展示）</li><li>绝对定位，比如 left: -9999px; （脱离文档流，不占空间）</li></ol></blockquote><h3 id="4-px和rem的区别是什么？"><a href="#4-px和rem的区别是什么？" class="headerlink" title="4.px和rem的区别是什么？"></a>4.px和rem的区别是什么？</h3><blockquote><p>px是指像素，而rem的全称是”root em”，root是指它是以html为参照物的，em是另外一个单位，它是以父元素的字体大小为参照物，如果默认父元素fontsize:1px，1em = 16px，父元素变它就变，综上所述： rem是指以html的font-size为参照物的大小单位，html的font-size大，1rem就大</p><p>使用em或rem单位的好处是什么？</p><p>可以用在多个地方需要相同字体大小的场景，而且便于维护：想要一起变，只要改基准的font-size即可</p></blockquote><h3 id="5-重绘和重排有什么区别？"><a href="#5-重绘和重排有什么区别？" class="headerlink" title="5.重绘和重排有什么区别？"></a>5.重绘和重排有什么区别？</h3><blockquote><p>重排（回流）是指 元素的布局，例如位置和大小，发生变化后元素的重新排列（元素的删除添加、用js改变大小）</p><p>重绘是指 元素的颜色等发生变化的重新绘制</p><p>重绘和重排涉及到浏览器渲染机制，可以说下吗？</p><ul><li>解析HTML生成DOM树</li><li>同时解析CSS样式生成CSSOM树</li><li>解析js，比如事件等</li><li>将DOM树和CSSOM树合并成渲染树（render tree）</li><li>触发 重排-&gt;重绘-&gt;展示页面</li></ul></blockquote><h3 id="6-无宽高让一个元素水平垂直居中的方式有哪些？"><a href="#6-无宽高让一个元素水平垂直居中的方式有哪些？" class="headerlink" title="6.无宽高让一个元素水平垂直居中的方式有哪些？"></a>6.无宽高让一个元素水平垂直居中的方式有哪些？</h3><blockquote><ol><li><p>flex或者grid（为什么放在一起，首先是最常用的，而且使用起来几乎一样，grid仅仅是just-content换成了just-item，且都设置为center）</p></li><li><p>绝对定位+transform:tranlate(-50%,-50%)</p></li><li><p>绝对定位+margin（使用时）</p><p>父元素相对定位，子元素绝对定位，并且把 上下左右设置为0（别影响margin的使用），margin:auto（可以放开手脚）</p></li></ol><p>直接记 无宽高的，这样不管问到有没有宽高的，都回答这个</p></blockquote><h3 id="7-CSS中哪些元素可以继承？哪些不可以？"><a href="#7-CSS中哪些元素可以继承？哪些不可以？" class="headerlink" title="7.CSS中哪些元素可以继承？哪些不可以？"></a>7.CSS中哪些元素可以继承？哪些不可以？</h3><blockquote><p>以下属性可以继承，其他的基本不可以：</p><ol><li>字体类属性：font-size</li><li>文字类属性：line-height</li><li>可见性属性：visibility:hidden</li><li>列表类属性：list-style</li><li>表格类属性：border-color</li></ol><p>为什么，如何记忆？这些文字、用于展示文字的列表、表格 都是最常用的，常用的都有继承性，不太常用的就不需要有继承性</p></blockquote><h3 id="8-有没有用过预处理器？"><a href="#8-有没有用过预处理器？" class="headerlink" title="8.有没有用过预处理器？"></a>8.有没有用过预处理器？</h3><blockquote><p>是什么：它们是一种工具，在CSS的基础上增加了一些新的特性，比如变量、混入以及导入等，增强了样式的可维护性、可重用性以及可拓展性</p><p>有什么以及区别：有sass、scss、less三种，下面说一下它们的区别，除了上面说的特性以外，sass只支持严格的缩进写法，而scss、less支持大括号；而less相对于scss又更加简单直观，比如去除掉了scss中混入的使用的写法（原来在scss混入需要在前面加@minin，然后再用@include引入，less全部去掉了）</p></blockquote><h3 id="9-精灵图和base64的区别是什么？"><a href="#9-精灵图和base64的区别是什么？" class="headerlink" title="9.精灵图和base64的区别是什么？"></a>9.精灵图和base64的区别是什么？</h3><blockquote><p>精灵图：它可以利用 将多个图片合并成一张图片 的特性，从而减少图片HTTP的请求，达到提高页面加载性能的目的，但是不便于维护（图片的修改需要重新生成精灵图）</p><p>base64：它可以将图片的二进制转化为64位的字符串，随着页面的渲染一同渲染不需要额外的HTTP请求，也提高了页面加载性能，并解决了图片跨域问题，但是增加了文件体积</p><p>使用场景：</p><p>精灵图：适合图片较多且图片不用修改的场景</p><p>base64：适合图片较少的场景</p><p>如何实现的？（原理）</p><p>精灵图：合并图只能通过自己编辑合并，然后就是通过图片的background-position修改需要展示哪个小图片</p><p>base64：可通过canvas的toDataURL方法将图片转换为64位字符串</p><p><u>回答A与B区别的模板：</u></p><p><u>A是什么，有什么优点、缺点</u></p><p><u>B是什么，有什么优点、缺点</u></p><p><u>根据 各自 优缺点，回答 使用场景</u></p><p><u>往深处挖掘：各自实现的原理是什么？</u></p></blockquote><h3 id="10-canvas是什么？"><a href="#10-canvas是什么？" class="headerlink" title="10.canvas是什么？"></a>10.canvas是什么？</h3><blockquote><p>canvas是一个可编程的画布，通过js代码可以绘制图形、处理图像以及渲染动画等</p></blockquote><h3 id="11-svg格式了解多少？"><a href="#11-svg格式了解多少？" class="headerlink" title="11.svg格式了解多少？"></a>11.svg格式了解多少？</h3><blockquote><p>优点：它内部是基于数学矢量的计算（内部实现）—-&gt;可缩放还不失真、体积小（不像像素图象还要存储颜色信息，它是渲染时才绘制颜色）、下载速度快</p><p>​           它是基于XML的文本（实际存储形式）—-&gt;可被搜索</p><p>​           可以转化为base64来引入（如何使用）</p></blockquote><h3 id="12-H5C3（HTML5、CSS3）的语义化的理解"><a href="#12-H5C3（HTML5、CSS3）的语义化的理解" class="headerlink" title="12.H5C3（HTML5、CSS3）的语义化的理解"></a>12.H5C3（HTML5、CSS3）的语义化的理解</h3><blockquote><p>就是在写 HTML标签时，规范使用如下标签：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">header</span>&gt;</span><br> ...<br><span class="hljs-tag">&lt;<span class="hljs-name">nav</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">nav</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">aside</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">aside</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">main</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">main</span>&gt;</span><br>&lt;footer...<span class="hljs-tag">&lt;/<span class="hljs-name">footer</span>&gt;</span><br> ...<br><span class="hljs-tag">&lt;/<span class="hljs-name">header</span>&gt;</span><br></code></pre></td></tr></table></figure><p>有如下好处：</p><p>对于程序员来说：易读、易于理解，开发者一起便于维护，提高开发效率</p><p>对于搜索引擎来说：可以提高搜索引擎优化（SEO）效果</p></blockquote><h3 id="13-H5C3有哪些新特性？"><a href="#13-H5C3有哪些新特性？" class="headerlink" title="13.H5C3有哪些新特性？"></a>13.H5C3有哪些新特性？</h3><blockquote><p>HTML5：思路-&gt;从语义化标签入手，每个语义化里面可能会装什么内容-&gt;header-&gt;aside-&gt;main</p><ul><li>语义化标签</li><li>本地存储（放在header中的个人头像信息，需要从这获取）</li><li>音频标签video（放在header中的背景音乐，可以切换音乐）</li><li>浏览器提供了 地理位置 API（aside中可作为选项供用户查看）</li><li>画布canvas（main中显示可视化图形，类似echarts）</li></ul><p>CSS3：思路-&gt;选择（选择器）哪个盒子（模型）添加  样式-&gt;布局、边框 包围-&gt;动画</p><ul><li><p>盒子模型</p></li><li><p>选择器</p></li><li><p>flex布局（水平垂直居中）</p></li><li><p>边框、阴影效果（阴影盒子）</p></li><li><p>动画效果（盒子内部有什么动画–鸡你太美）</p><p>即 一个带阴影的盒子内部有个鸡你太美的动画</p></li></ul></blockquote><h3 id="14-rem是如何做到适配的？"><a href="#14-rem是如何做到适配的？" class="headerlink" title="14.rem是如何做到适配的？"></a>14.rem是如何做到适配的？</h3><blockquote><p>利用rem根据html的font-size大小作为基准为单位的特性。比如 移动端屏幕宽度（或高度）不一样，那么我就可以 把html的font-size大小设置为 当前屏幕的宽度，这样在 当前屏幕的div大小，就可以用rem表示（0.5rem屏幕的一半），这样不管什么宽度的屏幕，都可以设置成 屏幕的一半宽度（例子）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;!-- em是针对父元素的适配单位，而rem是只针对<span class="hljs-title function_">html</span>(root即根部)的适配单位<br>    比如html的fontSize为50px，然后body的字体设置为<span class="hljs-number">50</span>%，那么这个1em/1rem就为25px<br>--&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="language-css"><span class="language-xml">  <span class="hljs-selector-id">#box</span>&#123;</span></span><br><span class="language-css"><span class="language-xml">     <span class="hljs-attribute">width</span>: <span class="hljs-number">0.5rem</span>;</span></span><br><span class="language-css"><span class="language-xml">     <span class="hljs-attribute">height</span>: <span class="hljs-number">0.5rem</span>;</span></span><br><span class="language-css"><span class="language-xml">     <span class="hljs-attribute">background-color</span>: red;</span></span><br><span class="language-css"><span class="language-xml">  &#125;</span></span><br><span class="language-css"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></span><br>&lt;/head&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- 方法就是 html根元素的字体大小 = 屏幕区的宽</span></span><br><span class="hljs-comment"><span class="language-xml">    目的是想把 1rem设置成整个屏幕的宽，那下次某个盒子想要设置成占整个屏幕多大比例，那直接 1rem/x</span></span><br><span class="hljs-comment"><span class="language-xml">    比如 某个盒子想要占屏幕的一半，那设置完之后就可以设置宽高为0.5rem-&gt;特指整个屏幕的一半，这样不管是什么分辨率都可以设置 </span></span><br><span class="hljs-comment"><span class="language-xml">    Ps：这里的字体大小默认是 指的是rem或em的单位</span></span><br><span class="hljs-comment"><span class="language-xml">   --&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;</span></span><br><span class="language-xml">    </span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&#x27;text/javascript&#x27;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"> <span class="hljs-variable language_">window</span>.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">     <span class="hljs-comment">// 整个屏幕的宽</span></span></span><br><span class="language-javascript"><span class="language-xml">     <span class="hljs-keyword">var</span> width = <span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>.<span class="hljs-property">clientWidth</span></span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">     <span class="hljs-keyword">var</span> htmlNode = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;html&#x27;</span>)</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">     htmlNode.<span class="hljs-property">style</span>.<span class="hljs-property">fontSize</span> = width + <span class="hljs-string">&#x27;px&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">     <span class="hljs-comment">// 以上三个步骤是为了当前屏幕单位 都为1rem</span></span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"> &#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure></blockquote><h3 id="15-解决了哪些移动端兼容问题？"><a href="#15-解决了哪些移动端兼容问题？" class="headerlink" title="15.解决了哪些移动端兼容问题？"></a>15.解决了哪些移动端兼容问题？</h3><blockquote><ol><li><p>安卓环境input框的placeholder文字设置行高（为了垂直居中）之后会偏上</p><p>解决方法：input框有placeholder属性时不要设置行高，安卓环境可能自己默认样式就是偏高的</p><p>解决方法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">autocorrect</span>=<span class="hljs-string">&#x27;off&#x27;</span> <span class="hljs-attr">autocapitalize</span>=<span class="hljs-string">&#x27;off&#x27;</span> /&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>移动端在字体小于12px时，会显示异常（模糊、不清晰）</p><p>解决方法：使用transform先放大一倍，再缩小一倍。这边看似什么也没做，但里面涉及到了字体渲染时会用到的技术：抗锯齿化技术，在字体渲染到页面上之后字体的边缘是会呈现锯齿状的，因此在每次字体渲染时会使用抗锯齿化技术使得字体边缘变得平滑，这里先放大再缩小等于 重新抗锯齿化 一次。</p></li><li><p>IOS在input框设置disabled之后字体显示异常（比较灰暗）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">  <span class="hljs-selector-tag">input</span><span class="hljs-selector-attr">[type=button]</span>&#123;<br>    <span class="hljs-attribute">opacity</span>:<span class="hljs-number">1</span>// 把字体显示正常:不透明度=&gt;<span class="hljs-number">1</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>IOS在设置 overflow:auto/scroll 添加滚动条滑动时，会卡顿，就是 屏幕跟不上手动滑动的频率。</p><p>-webkit-overflow-scrolling: touch —————— 内置滚动改为触摸事件</p></li><li><p>IOS在填写文本时，碰到数字会自动识别成电话号码</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&#x27;format-detection&#x27;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&#x27;telephone=no&#x27;</span> /&gt;</span><br></code></pre></td></tr></table></figure></li></ol><p>​          meta：元标签，用来全局设置一些东西的，name设置什么，content内容是什么</p><p><u>思路</u>：登陆页面填写input（前-中【异常用小字体检验】-后）-&gt;登陆后划到最底端进行评论</p></blockquote><h3 id="16-display-none-、-visibility-hidden-和-opacity-0-之间的区别？"><a href="#16-display-none-、-visibility-hidden-和-opacity-0-之间的区别？" class="headerlink" title="16.display:none 、 visibility:hidden 和 opacity:0 之间的区别？"></a>16.display:none 、 visibility:hidden 和 opacity:0 之间的区别？</h3><blockquote><ul><li><p>是否占空间</p><p>display:none不占</p><p>visibility:hidden占</p><p>opacity:0占</p></li><li><p>是否继承</p><p>display:none无法继承（父元素都没了）</p><p>visibility:hidden可以继承（通过设置子元素 visibility:visible 来显示子元素）</p><p>opacity:0可以继承（ <u>但是  不能设置子元素 opacity:0 来先重新显示</u>）</p></li><li><p>事件绑定</p><p>display:none无法触发</p><p>visibility:hidden无法触发</p><p>opacity:0可以触发</p></li><li><p>动画</p><p>display:none无法触发transition</p><p>visibility:hidden无法触发transition</p><p>opacity:0可以触发transition</p></li></ul><p><u>思路</u>：都是指看不见，display:none啥都没了不谈了，另外两个 看不到又占空间 还不如继承给别人用（子元素可能会有要显示的需求）呢，在真正用的时候，一个是手动使用（事件），另一个是自动使用（动画）</p><p>程度：display（直接无了） &gt; visibility（功能性失效） &gt; opacity（继承很特殊）</p></blockquote><h3 id="17-弹性布局flex1-0增加了那些属性？"><a href="#17-弹性布局flex1-0增加了那些属性？" class="headerlink" title="17.弹性布局flex1.0增加了那些属性？"></a>17.弹性布局flex1.0增加了那些属性？</h3><blockquote><p>gap：弹性布局元素之间的间距</p><p>flex-basis：主轴方向各元素的初始大小</p></blockquote><h3 id="18-数据大屏适配方案有哪些？"><a href="#18-数据大屏适配方案有哪些？" class="headerlink" title="18.数据大屏适配方案有哪些？"></a>18.数据大屏适配方案有哪些？</h3><blockquote><p>常用的是以下两种：</p><ol><li>vw和vh（和下面的rem类似）：<ul><li>是什么：它是只视口的宽高，就是不管屏幕尺寸多少，那么100vh和100vw那就是占满整个屏幕的宽高的</li><li>如何适配：利用实际屏幕和UI稿的大小比例，计算所有元素应当是多少vw和vh</li><li>优点：可以动态针对某个元素进行计算，有针对性；当UI稿和实际屏幕尺寸不一致的时候，不会出现留白情况</li></ul></li><li>scale缩放：<ul><li>是什么：利用transform的scale属性整体按比例进行缩放</li><li>如何适配：<ul><li>按什么比例缩放：按照宽和高较小的缩放比例缩放，比如 实际屏幕宽/UI稿设计宽 = 2.5， 实际屏幕高/UI稿设计高 = 3，为了不让元素顶出去顶出去，最终按照2.5比例缩放</li><li>缩放基点问题：正常缩放是按照原来盒子中心进行缩放，如果直接缩放，也会有元素顶出去顶出去，应该要把基点放到屏幕正中心，如何做到？先利用定位top:50%，left:50%把盒子左上角放到中间，再把缩放基准按照这个左上角缩放，缩放完毕后，再利用translate:(-50%,-50%)把盒子拉回原处</li></ul></li><li>优点：代码少，简单；不用做单独做额外的适配</li></ul></li></ol><p>Ps：屏幕尺寸有====&gt;4：3、16：9（最常见）、21：9等</p></blockquote><h3 id="19-移动端屏幕适配的方案有哪些？"><a href="#19-移动端屏幕适配的方案有哪些？" class="headerlink" title="19.移动端屏幕适配的方案有哪些？"></a>19.移动端屏幕适配的方案有哪些？</h3><blockquote><ol><li><p>rem+动态计算html的fontSize（把屏幕宽或高设置为html的fontSize，而得出其他元素的多少rem）</p><p>也可以利用媒体查询计算fontSize，它可以根据屏幕宽高高度动态设置fontSize</p></li><li><p>vw和vh</p></li></ol></blockquote><h1 id="Js"><a href="#Js" class="headerlink" title="Js"></a>Js</h1><h3 id="1-Js由哪三部分组成？"><a href="#1-Js由哪三部分组成？" class="headerlink" title="1.Js由哪三部分组成？"></a>1.Js由哪三部分组成？</h3><blockquote><ol><li>ECMA script：它是js的核心，描述了js的语法，比如var、数组等</li><li>文档对象模型（DOM）：它把HTML页面看成标签构成的文档，提供API可以与页面交互</li><li>浏览器对象模型（BOM）：可提供与浏览器相关的API，与浏览器窗口交互</li></ol></blockquote><h3 id="2-Js有哪些内置对象"><a href="#2-Js有哪些内置对象" class="headerlink" title="2.Js有哪些内置对象?"></a>2.Js有哪些内置对象?</h3><blockquote><p>Boolean、Number、String、Array、Function、Object、Math、Date…</p><p>记忆技巧？数据类型-&gt;最常用的数据处理（Math、Date）</p><p>最常用的几个以及对应方法:</p><p>String：splice（切割）、split（根据特殊符号分成各个数组）、toString</p><p>Array：splice（最强数组方法，可增、删、改）、filter（过滤）、</p><p>Math：max()、min()、abs()、sqrt()</p><p>Date：getYear()…</p></blockquote><h3 id="3-操作数组的方法有哪些（常用）？"><a href="#3-操作数组的方法有哪些（常用）？" class="headerlink" title="3.操作数组的方法有哪些（常用）？"></a>3.操作数组的方法有哪些（常用）？</h3><blockquote><p>改变原数组：push()、pop()、unshift()、shift()、splice()、reverse()、sort()</p><p>记忆技巧？后（增删）、前（增删）、任意位置（增删）、简单排序（颠倒）、复杂排序</p><p>不改变原数组：filter（过滤器）、reduce（累加器）、map（元素任意处理）、join（连接成字符串）</p><p>记忆技巧？过滤获取部分-&gt;累加获取更多-&gt;reduce是map的特殊实现-&gt;数据处理完了连接成字符串来使用</p></blockquote><h3 id="4-对数据类型的检测方式有哪些？"><a href="#4-对数据类型的检测方式有哪些？" class="headerlink" title="4.对数据类型的检测方式有哪些？"></a>4.对数据类型的检测方式有哪些？</h3><blockquote><p>typeof ———————- 只能针对基本数据类型</p><p>intance of——————-只能针对引用类型</p><p>constructor—————–可以针对基本数据类型、引用类型，但是如果 原型被手动篡改 ，将判断错误（通过找原型名字）</p><p>Object.prototype.toString.call—万能方法，优先使用，可以针对基本数据类型、引用类型，基本不会出错，除非篡改 this指向或重写toString方法（很少会）（toString-&gt;结果是字符，call改变this获取后面的上下文环境的类型）</p><p>如何记忆？前两者都只针对一个，过于局限，后两者都是和原型有关系，且 通用，只是constructor 有可能圆形只想被篡改，推荐用Object.prototype.toString.call，这也是放在Object.prototype上的原因</p></blockquote><h3 id="5-请你说说闭包"><a href="#5-请你说说闭包" class="headerlink" title="5.请你说说闭包"></a>5.请你说说闭包</h3><blockquote><p>什么是闭包？是一个对象，key-value形式</p><p>形成条件？1）函数嵌套2）内部函数引用外部函数变量3）外部函数执行时</p><p>优缺点？优点：延长外部函数局部变量的生命周期；缺点：容易造成内存泄露</p><p>如何避免内存泄露？即使销毁。如何销毁？若外部函数执行后没有新的指向会自动成为垃圾对象被销毁，如果有新的指向，需要手动设置为null</p><p>使用场景？函数的防抖与节流、第三方库</p></blockquote><h3 id="6-请你说说内存泄露"><a href="#6-请你说说内存泄露" class="headerlink" title="6.请你说说内存泄露"></a>6.请你说说内存泄露</h3><blockquote><p>什么是内存泄露？指分配了内存，不使用时内存无法被释放的情况。</p><p>有哪些常见的内存泄露？</p><ul><li>不使用的全局变量（声明在函数外的都算，或者函数内部没有用var、let或const定义的，否则局部作用域一结束就会被回收）</li><li>定时器未清除</li><li>闭包的不正确使用（没有手动置空）</li></ul></blockquote><h3 id="7-事件委托是什么？"><a href="#7-事件委托是什么？" class="headerlink" title="7.事件委托是什么？"></a>7.事件委托是什么？</h3><blockquote><p>什么是 事件委托？就是利用 事件冒泡 将子元素的事件 绑定到父元素上</p><p>事件委托有什么好处？减少绑定的次数，提高性能</p><p>如何阻止事件委托？</p><ol><li>addEventListen(‘事件名’,function(event){ event.stopPropagation })</li><li>addEventListen(‘事件名’,回调,false) // false为事件冒泡，true为事件捕获</li></ol><p>阻止事件委托的使用场景？子元素可以有自己的事件，不需要触发父元素事件</p><p>什么是事件捕获？</p><p>事件冒泡是从内向外传播，而事件捕获相反，由外向内传播，它们都是事件传播的方式。以下是例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;body&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;outer&quot;</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;inner&quot;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;btn&quot;</span>&gt;</span>Click me!<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">   <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;btn&#x27;</span>).<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Button clicked&#x27;</span>);</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;);</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;inner&#x27;</span>).<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Inner div clicked (bubbling)&#x27;</span>);</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;);</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;outer&#x27;</span>).<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Outer div clicked (bubbling)&#x27;</span>);</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;);</span></span><br><span class="language-javascript"><span class="language-xml">    </span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;outer&#x27;</span>).<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Outer div clicked (capturing)&#x27;</span>);</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;, <span class="hljs-literal">true</span>);</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;inner&#x27;</span>).<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Inner div clicked (capturing)&#x27;</span>);</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;, <span class="hljs-literal">true</span>);</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br>&lt;/body&gt;<br><br><span class="hljs-comment">// 结果</span><br><span class="hljs-title class_">Outer</span> div clicked (capturing)<br><span class="hljs-title class_">Inner</span> div clicked (capturing)<br><span class="hljs-title class_">Button</span> clicked<br><span class="hljs-title class_">Inner</span> div clicked (bubbling)<br><span class="hljs-title class_">Outer</span> div clicked (bubbling)<br></code></pre></td></tr></table></figure><p>事件触发的顺序遵循事件传播的三个阶段：默认传播方向为 事件捕获-&gt;目标-&gt;事件冒泡，和事件添加的顺序无关（即使先添加事件冒泡，还是先打印捕获）</p></blockquote><h3 id="8-基本数据类型和引用数据类型的区别是什么？"><a href="#8-基本数据类型和引用数据类型的区别是什么？" class="headerlink" title="8.基本数据类型和引用数据类型的区别是什么？"></a>8.基本数据类型和引用数据类型的区别是什么？</h3><blockquote><p>各有什么：</p><p>基本数据类型：String、Number、Boolean、null、undefined和Symbol</p><p>引用数据类型：Array、Function、Object</p><p>区别：存储位置的不同</p><p>基本数据类型的值和引用数据类型的地址 存放在栈内存中，而引用类型的值 存放在 堆内存中</p></blockquote><h3 id="9-说一下原型链"><a href="#9-说一下原型链" class="headerlink" title="9.说一下原型链"></a>9.说一下原型链</h3><blockquote><p>什么是原型？原型是用来为所有实例共享属性和方法的（一般是方法），通过prototype将方法放在原型上，不用全部存放在构造函数上了。</p><p>实例如何访问到原型的方法？通过隐式原型_proto_______，因为它指向构造函数的原型，因此可以访问到</p><p>原型链又是什么？在通过_proto_______往原型上找时可能没找到，此时又会向原型的原型去找，这样一直网上找的路径像一条链一样，故称原型链，下面附一张图：</p></blockquote><p><img src="/2024/01/03/%E5%89%8D%E7%AB%AF%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%9F%BA%E7%A1%80/%E5%8E%9F%E5%9E%8B%E9%93%BE.png" alt="原型链"></p><h3 id="10-new关键字做了什么"><a href="#10-new关键字做了什么" class="headerlink" title="10.new关键字做了什么"></a>10.new关键字做了什么</h3><blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">newFun</span>(<span class="hljs-params">Fun,args</span>)&#123;<br> <span class="hljs-comment">// 1. 创建一个空对象</span><br>    <span class="hljs-keyword">let</span> obj = &#123;&#125;<br> <span class="hljs-comment">// 2. 将空对象的__proto___指向(为了获取构造函数的属性和方法)</span><br>    obj.<span class="hljs-property">__proto__</span> = <span class="hljs-title class_">Fun</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span><br> <span class="hljs-comment">// 3. 改变this指向，将Fun的this指向到obj身上，并把构造函数需要的参数传过来</span><br>    <span class="hljs-keyword">let</span> result = <span class="hljs-title class_">Fun</span>.<span class="hljs-title function_">apply</span>(obj,args)<br> <span class="hljs-comment">// 4.判断返回的结果，若为 引用类型，则返回该引用类型，否则返回空对象</span><br>    <span class="hljs-keyword">return</span> result instance <span class="hljs-keyword">of</span> <span class="hljs-string">&#x27;object&#x27;</span> ? result : obj<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params">name</span>)&#123;<br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name <br>&#125;<br><br>fn.<span class="hljs-property">protptype</span>.<span class="hljs-property">say</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;hi&#x27;</span>)<br>&#125;<br><br><span class="hljs-keyword">let</span> p1 = <span class="hljs-title function_">newFun</span>(fn,<span class="hljs-string">&#x27;张三&#x27;</span>) <span class="hljs-comment">// 这里就是用newFun来代替new关键字，就是new的内部实现</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p1.<span class="hljs-property">name</span>) <span class="hljs-comment">// 张三</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p1)<br></code></pre></td></tr></table></figure></blockquote><h3 id="11-Js是如何实现继承的？"><a href="#11-Js是如何实现继承的？" class="headerlink" title="11.Js是如何实现继承的？"></a>11.Js是如何实现继承的？</h3><blockquote><p>有四种方式：</p><ul><li><p>通过原型链的方式：将子类构造函数 原型 指向 父类的实例</p><p>子类.prototype = new 父类()</p><p>为什么是指向父类的实例而不是原型？</p><p>因为实例有原型链，指向实例就可以一直往上找想要的数据，而不是只在父类上找</p><p>缺点：无法传递参数给父亲进行动态父类数据初始化</p></li><li><p>借用父类构造函数：在子类构造函数内，调用父类构造函数并用call更改this指向，指向子类</p><p>function child(){</p><p>​      parent.call(this,’参数’)</p><p>}</p><p>为什么？调用父类构造函数是为了初始化，更改this指向是为了让子类使用</p><p>优缺点：改进了原型链的方式可以传参，但是无法共享父类数据，函数都是在构造函数中定义的</p></li><li><p>组合式：结合以上两种方式，即：</p><p>子类.prototype = new 父类()</p><p>function child(){</p><p>​      parent.call(this,’参数’)</p><p>}</p><p>优缺点：解决了上面的问题，但是又会调用两次父类构造函数</p></li><li><p>用ES6的class的entends和super关键字，必须先调用super，再初始化子类数据，在子类内部使用super.数据 获取继承过来的数据</p><p>class 子类 entends 父类{</p><p>​      constructor(参数){</p><p>​             super(参数)</p><p>​             初始化子类数据</p><p>​      }</p><p>}</p><p>本质：extends内部做了将子类和父类原型链关联的操作，而super类似call调用传参并改this，只是不需要调用两次父类构造函数</p><p>优缺点：更加完善，但是不是所有浏览器都支持ES6的class</p><p>为什么一定要必须先调用super，再初始化子类数据？</p><p>因为要确保父类先初始化完毕后，这样子类才能继承过来使用，否则父类的数据都没有值的。</p></li></ul></blockquote><h3 id="12-Js设计原理是什么？（问题太大，答案也不太好）"><a href="#12-Js设计原理是什么？（问题太大，答案也不太好）" class="headerlink" title="12.Js设计原理是什么？（问题太大，答案也不太好）"></a>12.Js设计原理是什么？（问题太大，答案也不太好）</h3><blockquote><p>包含以下几个部分：Js引擎、执行上下文、调用栈、事件循环、回调函数</p><p>Js引擎-&gt;编译成可执行代码，让代码去执行</p><p>执行上下文-&gt;可调用浏览器的API</p><p>调用栈-&gt;Js单线程就是不断地从调用栈取出代码来执行，比如函数压栈</p><p>事件循环和回调-&gt;处理异步问题，当调用栈为空时，再去除事件队列中的回调函数，不断循环</p><p>思路：先编译能识别代码-&gt;需要用到API-&gt;在调用栈执行代码-&gt;碰到异步问题 用事件循环和回调解决</p></blockquote><h3 id="13-Js中关于this指向问题"><a href="#13-Js中关于this指向问题" class="headerlink" title="13.Js中关于this指向问题"></a>13.Js中关于this指向问题</h3><blockquote><ol><li><p>一般来说，this永远指向最后调用它的对象（可能层级太多），比如单独函数调用fn()，其实也是window.fn()；如果没有调用者，那就只想全局作用域下的this（浏览器window，Nodejs为global）</p></li><li><p>new fn()，这里面涉及到this指向的改变，指向了实例</p></li><li><p>说到this指向更改，call、apply、bind都可以改变，区别后面会说，但是不能是箭头函数，因为箭头函数本身就没有this的概念，更不用说更改</p></li><li><p>箭头函数是没有this的，直接忽略箭头函数那段代码，然后看当前this在哪，默认来看this指向  箭头函数的外层函数的this（父作用域下的this），没有外层函数就window，其实就是当箭头函数不存在</p></li><li><p>说到箭头函数这样的特殊函数，还有个特殊函数：匿名函数，永远指向window，因为默认没有调用者</p><hr><p>以上是ES5的this指向，下面说说ES6以及以后：</p><p>由于现在前端js越往后越趋向于后端的面向对象的理念，需要像后端这种类中的this自动绑定到</p></li></ol><p>思路：一般性this指向-&gt;特殊例子new，因为new没有调用者，涉及this更改-&gt;如何更改?call、apply、bind，但是不是箭头函数-&gt;那就说箭头函数-&gt;和箭头函数一样的特殊函数</p></blockquote><h3 id="14-script标签中defer和async的区别是什么？"><a href="#14-script标签中defer和async的区别是什么？" class="headerlink" title="14.script标签中defer和async的区别是什么？"></a>14.script标签中defer和async的区别是什么？</h3><blockquote><p>两者都不会阻塞页面的渲染，都属异步处理方案，不同的是：</p><p>defer：会等待页面解析、渲染完毕才会执行，优点是 保证了js执行顺序</p><p>async：不会等待页面处理完毕，和页面处理 并行处理，优点是 执行效率会更高</p><p>各自使用场景：需要保证执行脚本的顺序 -&gt; defer，否则 -&gt;async</p><p>如何记忆？看翻译：defer-&gt;推迟，async-&gt;异步（一般是指并行）</p><p>下面附代码例子：注意修饰的是script脚本！</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Defer Example<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">defer</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;script1.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">defer</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;script2.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>    <br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Async Example<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">async</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;script1.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">async</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;script2.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br></code></pre></td></tr></table></figure></blockquote><h3 id="15-定时器最小执行时间各为多少？"><a href="#15-定时器最小执行时间各为多少？" class="headerlink" title="15.定时器最小执行时间各为多少？"></a>15.定时器最小执行时间各为多少？</h3><blockquote><p>setTimeout最小执行时间为4ms</p><p>setInterval最小执行时间为10ms</p><p>以上是HTML5规定的，不同浏览器可能有误差，但是至少得要有4ms</p><p>为什么要这么规定？</p><p>为了浏览器的性能，如果最小执行时间是0ms，且有多个这样的定时器的话，那么在短时间内就会执行大量的任务，这对浏览器的性能造成负面影响。</p></blockquote><h3 id="16-call、apply和bind有什么区别"><a href="#16-call、apply和bind有什么区别" class="headerlink" title="16.call、apply和bind有什么区别"></a>16.call、apply和bind有什么区别</h3><blockquote><p>都是用于改变this指向和执行函数的，区别如下：</p><ul><li><p>call、apply和bind的区别在于：call、apply会立刻执行函数，而bind不会，bind第一次执行会返回一个改变了this指向的新的函数，再在第二次执行才会执行函数（使用场景例子：添加点击事件时用bind绑定，用户点击时执行）</p></li><li><p>call和apply的区别在于：前者参数传递的是对象，后者是数组。又call比apply性能要好，且数组可以用扩展运算符放入对象中，因此call用的比较多</p></li></ul></blockquote><h3 id="17-在使用递归的时候有没有遇到什么问题？"><a href="#17-在使用递归的时候有没有遇到什么问题？" class="headerlink" title="17.在使用递归的时候有没有遇到什么问题？"></a>17.在使用递归的时候有没有遇到什么问题？</h3><blockquote><p>递归是指：在函数中自己调用自己</p><p>问题：一定要有return的出口，否则无限制地调用函数，会导致调用栈溢出</p></blockquote><h3 id="18-如何实现一个深拷贝？"><a href="#18-如何实现一个深拷贝？" class="headerlink" title="18.如何实现一个深拷贝？"></a>18.如何实现一个深拷贝？</h3><blockquote><p>有三种方式实现深拷贝：</p><ol><li><p>用扩展运算符，缺点：只能实现第一层的深拷贝，多层就是浅拷贝了，因为涉及到多层展开仍然是个对象，地址还是一样的</p></li><li><p>json.parse(json.stringfy())，先转换为字符串，再转换为json，缺点：无法针对函数转换，因为函数转换为字符串就是个函数名，无法把内部逻辑转换</p></li><li><p>手写一个深拷贝，以解决上面的问题：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">deepClone</span>(<span class="hljs-params">source</span>)&#123;<br>    <span class="hljs-keyword">let</span> newObj = source.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> == <span class="hljs-string">&#x27;object&#x27;</span> ? &#123;&#125; : []<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> keys <span class="hljs-keyword">in</span> source)&#123;<br>        <span class="hljs-comment">// 要判断下Source上的属性是否是继承自原型的,因为只要拷贝自身属性,而不要原型上的</span><br>        <span class="hljs-keyword">if</span>(source.<span class="hljs-title function_">hasOwnproperty</span>(keys))&#123;<br>            <span class="hljs-keyword">let</span> value = newObj[keys]<br>            <span class="hljs-keyword">if</span>(value &amp;&amp; value.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> == <span class="hljs-string">&#x27;object&#x27;</span>)&#123;<br>                newObj[keys] = <span class="hljs-title function_">deepClone</span>(value)<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                newObj[keys] = value<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol></blockquote><h3 id="19-说一下Js事件循环"><a href="#19-说一下Js事件循环" class="headerlink" title="19.说一下Js事件循环"></a>19.说一下Js事件循环</h3><blockquote><p>是什么：Js事件循环是Js处理异步操作的机制，下面说说这个机制的过程是什么</p><p>过程：Js主线程碰到同步任务时，会放在执行栈（专门用来执行任务的数据结构，先进来的后执行，执行完毕移除栈顶任务）中来执行，一旦碰到异步任务，就会添加放在任务队列中，等到执行栈中任务执行完毕，就会从任务队列中去除异步任务到执行栈中执行，就这样一旦执行栈为空便从任务队列去取异步任务来执行，循环往复的过程就是事件循环。</p><p>什么是异步？</p><p>就是 不会因为要执行当前的任务 而阻塞下面任务的执行。</p><p>异步任务分为哪些？</p><p>宏任务：定时器、requestAnimationFrame（下一次动画帧执行函数）、网络请求、setImmediate（任务添加到当前宏任务的末尾—后端特有）、IO操作（文件读写—后端特有）</p><p>如何记忆？在定时器、动画中进行网络请求，让后端在setImmediate处理IO操作</p><p>微任务：promise(回调).then()、process.nextTick（把任务添加到当前微任务的末尾–后端特有）</p><p>宏任务和微任务的处理顺序是什么？</p><p>浏览器端：第一个宏任务（主线程）-&gt;微任务-&gt;宏任务（微任务优先级比宏任务优先级高，因为微任务一般处理紧急任务，而宏任务一般处理耗时的操作），每个宏任务之间会进行一次页面渲染</p><p>Nodejs：在6个阶段，每一个阶段完成后都会去执行一批微任务（有的话）</p><p>你这里面说有些是后端特有的是什么意思？</p><p>因为在前端浏览器和后端Nodejs都有一个事件循环机制，功能是类似的，都有宏任务和微任务，只是 浏览器端的事件循环机制是处理前端异步操作的，后端Nodejs的事件循环机制是处理后端异步操作的（注意：Nodejs本身是单线程的，但是可能会碰到一些事件循环机制处理不了的一些需要大量计算的异步任务，这时候可能会借助多线程的模块处理）。</p><p>setImmediate和setTimeout（时间延迟设置为0）的区别是什么？</p><p>setImmediate是会让任务添加到当前事件循环的末尾来执行。两者区别在于：setTimeout是在事件循环的第一个阶段timer，处理的，而setImmediate则在末尾check阶段，如果setTimeout延迟为0ms的话，setTimeout会比setImmediate先执行。</p><p>如何记忆？事件循环机制阶段的不同</p><p>为什么要用到任务队列来处理异步操作？</p><p>因为Js是单线程的，没有多线程来处理异步操作，只能先放在队列中稍后执行。</p><p>​    为什么Js是单线程的？</p><p>​    因为多线程会带来很多同步问题，比如死锁（举例子就说路面上的堵车，都在等待其他人腾出空间，但是也腾不出空间而造成的僵局）。</p><p><u>思路：</u>是什么-&gt;过程-&gt;涉及到异步-&gt;异步任务（有后端特有的任务以及区别）-&gt;任务队列</p></blockquote><h3 id="20-什么是防抖和节流"><a href="#20-什么是防抖和节流" class="headerlink" title="20.什么是防抖和节流"></a>20.什么是防抖和节流</h3><blockquote><p>这两者都是避免频繁触发事件来提高性能的。</p><p>防抖：防止不必要的操作（抖动），来节省资源，只在必要的时刻（<u>集中触发的最后一次</u>）触发</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">debounce</span>(<span class="hljs-params">fn,delay</span>)&#123;<br> <span class="hljs-keyword">var</span> timer;<br> <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>)&#123;<br>     <span class="hljs-comment">// 只要在delay内多次触发，前一次即将到达delay的时间要执行fn时，就会被下一次给clear掉了</span><br>     <span class="hljs-comment">// 只要时间到达了dalay，就被看做是确定要触发了，比如用户输入停下来了，用户停下来之前都不会触发</span><br>     <span class="hljs-built_in">clearTimeout</span>(timer)<br>     timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>     <span class="hljs-title function_">fn</span>()<br>    &#125;,delay)<br> &#125;<br>&#125;<br><br><span class="hljs-comment">// 为了好的效果，delay不能设置太小-&gt;触发仍会频繁，也不能设置太大-&gt;用户输入完了等半天，要预估好 用户操作大致要花多长时间</span><br></code></pre></td></tr></table></figure><p>使用场景：用户输入框、搜索框</p><p>节流：直接通过<u>降低</u><u>频率</u>来避免频繁触发事件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">throttle</span>(<span class="hljs-params">fn,delay</span>)&#123;<br> <span class="hljs-keyword">var</span> lastTime;<br> <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>     <span class="hljs-keyword">var</span> nowTime = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>()<br>     <span class="hljs-comment">// 规定在delay内执行一次，比防抖容易理解</span><br>     <span class="hljs-keyword">if</span>(now - lastTime &gt; delay)&#123;<br>         <span class="hljs-title function_">fn</span>()<br>         lastTime = nowTime<br>     &#125;<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用场景：滚动条 设置 图片懒加载 的事件（也可以通过判断高度来实现–用得更多）</p><p>用 花钱 来比喻：防抖是 只去买有用的生活必需品，节流是 针对奢侈品 少买。</p></blockquote><h3 id="21-什么是json？"><a href="#21-什么是json？" class="headerlink" title="21.什么是json？"></a>21.什么是json？</h3><blockquote><p>json是一个字符串的数据格式，用大括号包裹，内容是键值对的形式，并用逗号分隔。</p><p>它经常用在前后端数据交互时传输数据、配置文件比如package.json</p><p>数据交互时如果不是json数据，可以使用序列化（JSON.stringfy）和反序列化（JSON.parse）进行转换，当然这两个函数还可以用来实现深拷贝。</p></blockquote><h3 id="22-函数内部有执行上下文环境吗？"><a href="#22-函数内部有执行上下文环境吗？" class="headerlink" title="22.函数内部有执行上下文环境吗？"></a>22.函数内部有执行上下文环境吗？</h3><blockquote><p>有，但是它是虚拟地存在于栈中，在函数内是无法打印出来的，如果在函数打印this，它会往外面找，也就是全局作用域下的this-&gt;window。</p><p>但是一旦在函数内添加了属性和方法，内部会添加到的栈中，想要访问也可以通过this拿出来。</p></blockquote><h1 id="ES"><a href="#ES" class="headerlink" title="ES"></a>ES</h1><h3 id="1-ES5和ES6有什么区别？"><a href="#1-ES5和ES6有什么区别？" class="headerlink" title="1.ES5和ES6有什么区别？"></a>1.ES5和ES6有什么区别？</h3><blockquote><p>ES是指ECMAScript，它是Js的组成部分，另外两个部分是BOM、DOM</p><p>ES5-&gt;ECMAScript5，即在2009年ECMAScript第五次修订，也称为ECMAScript2009</p><p>ES6-&gt;ECMAScript6，即在2015年ECMAScript第六次修订，也称为ECMAScript2015</p></blockquote><h3 id="2-ES6有哪些新特性？"><a href="#2-ES6有哪些新特性？" class="headerlink" title="2.ES6有哪些新特性？"></a>2.ES6有哪些新特性？</h3><blockquote><p><strong>变量的声明</strong></p><p>新增了let和const，有以下特性：</p><ul><li>没有变量提升</li><li>会有暂时性死区的问题（不能先使用再声明）</li><li>不能重复定义</li><li>有块级作用域</li></ul><p><u>思路</u>：针对var的特性的不足来，从var的声明（变量提升-&gt;数量一多-&gt;重复声明；范围一广-&gt;也会覆盖-&gt;全局作用域）</p><p><strong>基本数据类型</strong></p><p>新增了一个Symbol类型，特性如下：</p><ul><li><p>独一无二的属性</p></li><li><p>不想被发现的特性</p></li></ul><p>针对第二点，可以是的数据私有化：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> _age = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;age&#x27;</span>);<br><span class="hljs-keyword">const</span> _getAge = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;getAge&#x27;</span>);<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">age</span>) &#123;<br>    <span class="hljs-variable language_">this</span>[_age] = age;<br>  &#125;<br><br>  [_getAge]() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>[_age];<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> john = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-number">30</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(john.<span class="hljs-property">_age</span>); <span class="hljs-comment">// undefined，私有属性无法直接访问</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(john.<span class="hljs-title function_">_getAge</span>()); <span class="hljs-comment">// TypeError，私有方法无法直接调用</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(john[_age]); <span class="hljs-comment">// undefined，通过 Symbol 访问私有属性也无法获取到</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(john[_getAge]()); <span class="hljs-comment">// 输出: 30，只有通过对应 Symbol 的方法才能获取私有属性值</span><br></code></pre></td></tr></table></figure><p><u>思路</u>：有不想被发现的特性-&gt;私有化</p><p><strong>数组</strong></p><p>数组在定义时：</p><p>可以用到 解构赋值和扩展运算，对数据 进行 拆分赋值 和合并</p><p>数组在处理数据时：</p><p>可以用到 for循环遍历，有 of（item-&gt;单个元素） 和 in（item-&gt;下标） 之分</p><p>处理数据有更便捷、自带的函数：</p><p>set-&gt;自动去重；</p><p>map-&gt;键可任意，可配合forEach遍历（和数组关联起来了）</p><p><u>思路</u>：数组定义时，元素的拆分-&gt;解构赋值与合并-&gt;扩展运算符；数组定义后要遍历处理数据-&gt;for的in和of-&gt;自带函数更方便地处理-&gt;set和map的好处</p><p><strong>导入外部模块</strong></p><p>新增class-&gt;继承（见上面继承方式）</p><p>新增暴露和导入，将写的class导入，首先有几种暴露方式：</p><ul><li>分别暴露（每个数据写个export）</li><li>统一暴露（最后用个对象{}包裹）</li><li>默认暴露（边暴露便定义并写在一个对象中）</li></ul><p>导入方式：</p><ul><li>导入所有（import * as 别名）</li><li>解构赋值方式（import {挑选}）</li><li>默认导入（import 别名）—–只针对默认暴露</li></ul><p><u>思路</u>：class一般专门定义在一个js文件中，再倒入使用</p><p><strong>函数</strong></p><p>函数的形参，可以用到解构赋值，目的是更快速地拿到对象中的属性</p><p>​                           会用到默认参数，此参数用于一般不会更改的情况</p><p>​                           会用到扩展运算符的rest参数，通常叫…args</p><p>新增箭头函数，先说下它的参数：</p><ul><li>没有普通函数的arguments，取而代之的是args，功能一样，和简写的箭头函数更搭配</li></ul><p>再说下 关于this指向带来的特性：</p><ul><li>它完全没有this的概念</li><li>没有this就不能当作构造函数new一个实例，因为new涉及到this的更改，都没有this，也无法更改</li><li>不能作为构造函数，就没有原型，因为原型是构造函数才有的</li><li>不能用call、apply、bind更改this指向</li><li>this指向外层最近的函数的指向（父作用域下的this），就是直接忽视箭头函数</li></ul><p><u>思路</u>：普通函数：形参的处理-&gt;解构赋值-&gt;默认参数-&gt;扩展运算符；</p><p>​            特殊函数（函数的简写）：由外到内</p><p>​                  外：形参</p><p>​                  内：没有this的概念-&gt;没有new的概念（要改变this）-&gt;没有作为构造函数-&gt;没有原型；那怎么改？就算 call、apply、bind也无法改变；那this怎么看？指向它最近外层函数的this（就是忽视整个箭头函数即可）</u></p><p><strong>对象</strong></p><p>对象的属性和函数新增简写形式：</p><ul><li>已经有属性和函数，直接写属性名和函数名即可，不需要写冒号:</li><li>对于函数的声明可以直接写成函数形式：fn(){}</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> a = &#123;<br>    属性,<br>    函数<span class="hljs-number">1</span>,<br>    <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>)&#123;...&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><u>思路</u>：不需要冒号来简写</p><p><strong>发送异步请求</strong></p><p>新增Promise</p><p>目的：解决回调地狱的问题</p><p>什么是回调地狱？</p><p>在promise之前，如果碰到有多个异步任务有依赖关系，这时候只能通过嵌套的回调函数来实现，这就形成了 回调地狱，可读性差（要看很多行）-&gt;可维护性差（难以查找来修改）</p><p>有什么：自身包括 resolve、reject、all、allSettled、race方法</p><p>​               all、allSettled的区别？都是传入数组，存放着所有promise，返回一个新的promise结果（相当于then），前者是 有一个失败，就返回失败，后者 都会返回成功的结果，里面有所有promise的结果。</p><p>​              race方法-&gt;哪个promise先执行完毕就返回哪个promise的结果，race-&gt;找竞速为第一名的</p><p>​                             使用场景：超时机制-&gt;网络请求超过一定时间就弹出错误信息，就是看成功还是失败看哪个先来。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fetchWithTimeout</span>(<span class="hljs-params">url, timeout</span>) &#123;<br>  <span class="hljs-comment">// 创建一个待定的 Promise 对象，该对象在超时后返回一个默认值或错误信息</span><br>  <span class="hljs-keyword">let</span> timeoutPromise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;Request timed out&#x27;</span>));<br>    &#125;, timeout);<br>  &#125;);<br><br>  <span class="hljs-comment">// 发起请求的 Promise 对象</span><br>  <span class="hljs-keyword">let</span> fetchPromise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-title function_">fetch</span>(url)<br>      .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> response.<span class="hljs-title function_">json</span>())<br>      .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;<br>        <span class="hljs-title function_">resolve</span>(data);<br>      &#125;)<br>      .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>        <span class="hljs-title function_">reject</span>(error);<br>      &#125;);<br>  &#125;);<br><br>  <span class="hljs-comment">// 使用 Promise.race() 等待任意一个 Promise 对象完成</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">race</span>([fetchPromise, timeoutPromise]);<br>&#125;<br><br><span class="hljs-comment">// 使用示例</span><br><span class="hljs-title function_">fetchWithTimeout</span>(<span class="hljs-string">&#x27;https://api.example.com/data&#x27;</span>, <span class="hljs-number">5000</span>)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Request succeeded:&#x27;</span>, data);<br>  &#125;)<br>  .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Request failed:&#x27;</span>, error.<span class="hljs-property">message</span>);<br>  &#125;);<br><br></code></pre></td></tr></table></figure><p>​               原型上包括 then、catch方法</p><p>如何使用的？</p><p>将异步操作用Promsie包裹，成功用resolve把值传递出，此时状态由pending-&gt;resolved，否则用reject传递失败结果，状态由pending-&gt;rejected，最后用then、catch的回调函数获取结果</p><p>为什么值传递出去，then方法里就可以获取到？原理是什么？</p><p>内部实现用到了发布订阅模式。在Promise的内部会针对状态成功和状态失败的回调函数的数组，在then方法里，会把传进来的回调函数添加到回调数组中（这时就是订阅了，为了以后获得消息），然后再在Promise构造函数内部的Resolve和Reject函数里会逐一执行刚刚的回调函数数组，并且会把resolve和reject传过来的value参数传入回调函数中（这时就是发布了），最终在链式调用then时就可以获得依次执行回调的结果了。</p><p>——&gt;链式是如何实现的？（比较难，说个大致了解即可）</p><p>我说个大致了解啊：刚刚说了用于链式调用的各个回调被存放在回调数组中，怎么实现在调用then的时候按顺序执行呢？就是在每次执行回调时先判断下返回值是否为Promise，是的话用then继续调用，不是的话就resolve出去。</p><p><u>思路</u>：目的-&gt;有什么（先介绍有什么才能更好地说明如何使用）-&gt;如何使用-&gt;原理</p><p><strong>数据回来展示</strong></p><p>新增模板字符串，可以把变量 插入 字符串中</p><p><u>整体思路</u>：定义数据（基本类型、数组、函数、对象）-&gt;引入外部数据-&gt;处理数据-&gt;发送异步请求-&gt;返回数据-&gt;展示</p></blockquote><h3 id="3-Promise和Async、Await的区别是什么？"><a href="#3-Promise和Async、Await的区别是什么？" class="headerlink" title="3.Promise和Async、Await的区别是什么？"></a>3.Promise和Async、Await的区别是什么？</h3><blockquote><p>共同点：都是处理异步操作的解决方案。</p><p>使用区别：Promise-&gt;见上面；而Async修饰一个返回Promise对象的异步函数，Await则可以等待一个Promise对象的解决</p><p>后者优势：最大的优势就是 Async、Await可以像编写同步代码一样处理异步操作，更加易读、易于理解。</p></blockquote><h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1><h3 id="1-Ajax是什么？如何实现的？"><a href="#1-Ajax是什么？如何实现的？" class="headerlink" title="1.Ajax是什么？如何实现的？"></a>1.Ajax是什么？如何实现的？</h3><blockquote><p>定义：它是一个实现交互式网页的技术，可以在保证页面不刷新的情况下，和服务器交互数据并更新部分内容</p><p><u>思路</u>：什么技术-&gt;功能（页面不刷新-&gt;用户体验好，更新部分内容-&gt;场景用得多）</p><p>实现过程（<u>思路</u>）：利用xmlHttpRequest对象，先服务器发送请求并返回数据，最终用Js更新页面部分内容，具体如下：</p><ol><li>创建一个xmlHttpRequest对象</li><li>利用该对象的open函数打开连接</li><li>利用该对象的send函数向服务器发送数据</li><li>利用onreadystate change事件监听通信状态</li><li>服务器返回数据</li><li>利用Js将数据更新到页面上</li></ol><p>onload事件和onreadystatechange事件有什么区别？</p><p>onload事件是在请求成功时触发，而onreadystatechange事件是在请求的整个过程的状态（更全：请求-&gt;连接-&gt;发送数据-&gt;返回数据）变化了都会触发，简而言之，处理成功的结果用onload，处理请求的请求过程中间状态用onreadystatechange。</p><p><u>思路</u>：顾名思义，load-&gt;加载完成，statechange-&gt;中间状态改变</p></blockquote><h3 id="2-get和post有什么区别？"><a href="#2-get和post有什么区别？" class="headerlink" title="2.get和post有什么区别？"></a>2.get和post有什么区别？</h3><blockquote><p>使用场景：get一般用于获取数据，post一般用于提交数据</p><p>参数位置：get放在URL中，post则放在body中</p><p>参数编码：get只能用类似于键值对的方式进行编码，而post支持很多种（json格式、纯文本格式、二进制-&gt;上传文件）</p><p>安全性：get把参数放在URL中，安全性比post要差</p><p>参数限制：由于URL长度有限制，于是get的参数是由长度限制的，而post没有</p><p>缓存：get由于一般只是获取服务区数据，因此设有缓存机制来提高性能，而post提交数据会改变服务器数据，因此没有缓存机制。</p><p><u>思路</u>：使用场景-&gt;使用过程（传递的参数-&gt;参数如何编码的-&gt;安全性(1)-&gt;参数的限制(2)-&gt;数据回来 是否可缓存）</p></blockquote><h3 id="3-HTTP协议规定的请求头和响应头各包含什么？"><a href="#3-HTTP协议规定的请求头和响应头各包含什么？" class="headerlink" title="3.HTTP协议规定的请求头和响应头各包含什么？"></a>3.HTTP协议规定的请求头和响应头各包含什么？</h3><blockquote><p>请求头：</p><ul><li>User-Agent：通常指浏览器标识，指浏览器代理用户的标识（我是谁）</li><li>Referer：表示浏览器URL，用于防盗（我从哪来，避免其他网站获取网页资源）</li><li>Host（发给谁）</li><li>Authortization：权限信息（出示身份才能获取）</li><li>Content-Type（准备发送什么类型的数据）</li><li>Cookie（用什么存储-自动携带，存储个性化配置等）</li><li>Accept（希望返回什么类型的数据）</li><li>if-mdified-since或者if-none-match（得到数据后是否请求缓存—协商缓存）</li></ul><p>响应头：</p><ul><li>Server（我是谁）</li><li>Location（发给谁）</li><li>Content-Type（准备发送什么类型的数据）</li><li>Set-Cookie（用什么存储）</li><li>Expires/Cache-Control-强缓存、Lasted-Modified/Etag-协商缓存（决定是否让浏览器缓存下来）</li><li>Access-Control-Allow-Origin：设置允许的跨域来源（如果你是跨域的，下一次访问允许谁能访问）</li></ul></blockquote><h3 id="4-说一下同源策略"><a href="#4-说一下同源策略" class="headerlink" title="4.说一下同源策略"></a>4.说一下同源策略</h3><blockquote><p><a href="http://www.example.com:3000/vue.js">http://www.example.com:3000/vue.js</a></p><p>协议   域名   子域名              端口号   资源</p><p>同源策略是指 协议、域名、端口号这三者有一个不同，就会收到跨域限制，即无法请求数据，这么做的目的以及好处是 避免来自不同域之间通信时受到攻击，从而降低风险。</p><p>如何实现跨域？有以下四种方式。</p><ol><li><p>jsonp</p><p>定义：通过利用script标签不受跨域限制的特点（因为外部脚本的来源经常来自不同的域，如果限制，无法满足动态加载的需求），利用script发送get请求实现跨域。</p><p>缺点：但是不推荐使用，因为不能完全保证script内的代码没有恶意代码来窃取隐私信息从而形成XSS攻击。</p><p>配合者：需要客户端和服务器端同时配置才可以，服务端配置和cors一样。</p></li><li><p>cors</p><p>只需要在服务器端配置响应头的选项，比如Access-Control-Allow-Origin等，因为浏览器是默认支持cors的。</p><p>有如上的优点，推荐使用这种方式的</p></li><li><p>websocket</p><p>它是一种可以实现实时的全双工通信的方式，一旦连接建立，客户端和服务器端可以相互发送请求。由于双向通信通产需要在不同域之间进行，因此websocket没有跨域限制，可以利用websocket进行跨域请求。</p></li><li><p>反向代理</p><p>它是利用在客户端和目标服务器之间添加一个中转站用来代理服务器（代理客户端是正向代理，代理服务器就是反向代理）操作来实现的跨域。</p><p>如何实现的？</p><p>这个中转站通常和客户端是同源的，这保证了客户端和中转站不受跨域限制，而中转站和目标服务器 都是服务器，服务器之间通信不会涉及到像浏览器端有用户的隐私数据，因为服务器之间是没有类似跨域限制这种限制的，这保证了中转站和目标服务器可以通畅无阻，最终实现了客户端与目标服务器的跨域请求。</p></li></ol></blockquote><h3 id="5-什么是无感登录？"><a href="#5-什么是无感登录？" class="headerlink" title="5.什么是无感登录？"></a>5.什么是无感登录？</h3><blockquote><p>就是 避免频繁登录给 用户带来不好的体验，最典型的就是 token过期后，会自动获取新的token并重新跳转</p><p>如何实现？</p><ul><li>在前端响应器中，判断状态码如果是401-&gt;token过期，则重新调用获取token的接口，并且重新请求页面地址 ———– 推荐第一种</li><li>也可以 用定时器，定时器 定时刷新token，但是时间不好把控，时间太短浪费网络资源</li></ul></blockquote><h3 id="6-如何实现大文件上传？"><a href="#6-如何实现大文件上传？" class="headerlink" title="6.如何实现大文件上传？"></a>6.如何实现大文件上传？</h3><blockquote><p>大文件上传通常会碰到 上传速度慢、网络中断 的问题</p><p>针对上面的问题，通常有以下两个策略：</p><ul><li><p>分片上传：</p><ol><li><p>将大文件按照一定规则分片（利用fs.splice），可以固定大小平分，这样的话最后一片大小会比较小，需要单独处理（如下）（有了分片个数和已发送分片就可以制作进度条了）；也可以根据网络情况分片（如下使用浏览器自带的API），网络情况差就分得小一些，根据网络负载能力来。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">splitFile</span>(<span class="hljs-params">file, chunkSize</span>) &#123;<br>  <span class="hljs-keyword">const</span> fileSize = file.<span class="hljs-property">size</span>;<br>  <span class="hljs-keyword">const</span> totalChunks = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">ceil</span>(fileSize / chunkSize);<span class="hljs-comment">// 个数</span><br>  <span class="hljs-keyword">const</span> chunks = [];<br>  <br>  <span class="hljs-keyword">let</span> start = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">let</span> end = chunkSize;<br>    <br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; totalChunks; i++) &#123;<br>  <span class="hljs-keyword">let</span> chunk;<br>  <br>  <span class="hljs-comment">// 最后一块单独处理</span><br>  <span class="hljs-keyword">if</span> (i === totalChunks - <span class="hljs-number">1</span>) &#123;<br>    chunk = file.<span class="hljs-title function_">slice</span>(start);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    chunk = file.<span class="hljs-title function_">slice</span>(start, end);<br>  &#125;<br>  <br>  chunks.<span class="hljs-title function_">push</span>(chunk);<br>  <br>  start = end;<br>  end = start + chunkSize;<br>&#125;<br>    <br>  <span class="hljs-keyword">return</span> chunks;<br>&#125;<br><br><span class="hljs-comment">// 示例用法</span><br><span class="hljs-keyword">const</span> file = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;fileInput&#x27;</span>).<span class="hljs-property">files</span>[<span class="hljs-number">0</span>];<br><span class="hljs-keyword">const</span> chunkSize = <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>; <span class="hljs-comment">// 1MB</span><br><span class="hljs-keyword">const</span> chunks = <span class="hljs-title function_">splitFile</span>(file, chunkSize);<br></code></pre></td></tr></table></figure><blockquote><p>检测网络情况：</p><p>在前端（客户端）可以通过浏览器提供的API如<code>navigator.connection</code>或第三方库来获取当前网络类型、效果和速度等信息。例如，<code>navigator.connection.type</code>可以返回网络类型（如wifi、4G、3G等），<code>navigator.connection.effectiveType</code>可以返回网络效果（如”slow-2g”、”4g”等），<code>navigator.connection.downlink</code>可以返回当前网络的下载速度。</p></blockquote></li><li><p>将分片一个个上传，同时，记录每个分片的序列号，用于给服务端检查是否有遗漏的，保证完整性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 客户端</span><br><span class="hljs-keyword">let</span> sequenceNumber = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">processFileBlock</span>(<span class="hljs-params">fileBlock</span>) &#123;<br>  <span class="hljs-comment">// 递增计数器</span><br>  sequenceNumber++;<br><br>  <span class="hljs-comment">// 将序列号与文件块一同发送给服务端</span><br>  <span class="hljs-title function_">sendFileBlock</span>(fileBlock, sequenceNumber);<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">sendFileBlock</span>(<span class="hljs-params">fileBlock, sequenceNumber</span>) &#123;<br>  <span class="hljs-comment">// 发送文件块和序列号给服务端</span><br>  <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-comment">// 服务端</span><br><span class="hljs-keyword">let</span> expectedSequenceNumber = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">receiveFileBlock</span>(<span class="hljs-params">fileBlock, sequenceNumber</span>) &#123;<br>  <span class="hljs-comment">// 根据接收到的序列号与期望的序列号进行比对</span><br>  <span class="hljs-keyword">if</span> (sequenceNumber === expectedSequenceNumber + <span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-comment">// 序列号正确，处理文件块</span><br>    <span class="hljs-title function_">processFileBlock</span>(fileBlock);<br><br>    <span class="hljs-comment">// 更新期望的序列号</span><br>    expectedSequenceNumber++;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 序列号不匹配，要求重传缺失的文件块</span><br>    <span class="hljs-title function_">requestMissingFileBlock</span>(expectedSequenceNumber + <span class="hljs-number">1</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>服务端在检查完所有的分片之后，利用fs模块的可读流和可写流进行合并</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);<br><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);<br><br><span class="hljs-comment">// 分片文件所在的目录</span><br><span class="hljs-keyword">const</span> chunkDir = <span class="hljs-string">&#x27;path/to/chunk-directory&#x27;</span>;<br><span class="hljs-comment">// 合并后的文件名和目录</span><br><span class="hljs-keyword">const</span> finalFile = <span class="hljs-string">&#x27;path/to/final-file.ext&#x27;</span>;<br><br><span class="hljs-comment">// 读取分片文件夹中的所有分片文件</span><br><span class="hljs-keyword">const</span> chunkFiles = fs.<span class="hljs-title function_">readdirSync</span>(chunkDir);<br><br><span class="hljs-comment">// 按照分片序号进行排序</span><br>chunkFiles.<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> <span class="hljs-title class_">Number</span>(a.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;-&#x27;</span>)[<span class="hljs-number">1</span>]) - <span class="hljs-title class_">Number</span>(b.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;-&#x27;</span>)[<span class="hljs-number">1</span>]));<br><br><span class="hljs-comment">// 创建一个可写流，用于写入合并后的文件</span><br><span class="hljs-keyword">const</span> writeStream = fs.<span class="hljs-title function_">createWriteStream</span>(finalFile);<br><br><span class="hljs-comment">// 逐个读取分片文件并写入到合并文件中</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; chunkFiles.<span class="hljs-property">length</span>; i++) &#123;<br>  <span class="hljs-keyword">const</span> chunkPath = path.<span class="hljs-title function_">join</span>(chunkDir, chunkFiles[i]);<br><br>  <span class="hljs-comment">// 使用 fs.createReadStream 创建一个可读流</span><br>  <span class="hljs-keyword">const</span> readStream = fs.<span class="hljs-title function_">createReadStream</span>(chunkPath);<br><br>  readStream.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;end&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-comment">// 当读取结束后，删除当前分片文件</span><br>    fs.<span class="hljs-title function_">unlinkSync</span>(chunkPath);<br>  &#125;);<br><br>  <span class="hljs-comment">// 将读取的分片文件写入到合并文件中</span><br>  readStream.<span class="hljs-title function_">pipe</span>(writeStream, &#123; <span class="hljs-attr">end</span>: <span class="hljs-literal">false</span> &#125;);<br>&#125;<br><br><span class="hljs-comment">// 在合并完成后，关闭可写流</span><br>writeStream.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;finish&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-comment">// 合并完成，进行一些后续的操作</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;分片合并完成&#x27;</span>);<br>&#125;);<br><br><span class="hljs-comment">// 关闭可写流</span><br>writeStream.<span class="hljs-title function_">end</span>();<br></code></pre></td></tr></table></figure></li></ol></li><li><p>断点续传：</p><p>怎么判断网络中断？</p><p>它可以检测网络是否中断（心跳机制-定时发送亲求检查网络情况），来决定是否中断请求（如下），并且下一次在中断分片出继续上传，无需从头开始上传（根据上面分片的序列号即可）。</p><p>心跳机制：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs js">  <span class="hljs-comment">// 定义心跳请求的URL</span><br>  <span class="hljs-keyword">const</span> heartbeatUrl = <span class="hljs-string">&#x27;https://example.com/heartbeat&#x27;</span>;<br>  <br>  <span class="hljs-comment">// 定义心跳间隔时间（毫秒）</span><br>  <span class="hljs-keyword">const</span> heartbeatInterval = <span class="hljs-number">3000</span>;<br>  <br>  <span class="hljs-keyword">let</span> heartbeatTimer;<br>  <br>  <span class="hljs-comment">// 发送心跳请求</span><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">sendHeartbeat</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">fetch</span>(heartbeatUrl)<br>      .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span> (!response.<span class="hljs-property">ok</span>) &#123;<br>          <span class="hljs-title function_">handleNetworkError</span>();<br>        &#125;<br>      &#125;)<br>      .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>        <span class="hljs-title function_">handleNetworkError</span>();<br>      &#125;);<br>  &#125;<br>  <br>  <span class="hljs-comment">// 处理网络中断</span><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleNetworkError</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Network connection lost.&#x27;</span>);<br>    <span class="hljs-comment">// 进行其他处理，如中断上传、保存已上传的文件块信息等</span><br>  &#125;<br>  <br>  <span class="hljs-comment">// 开始心跳检测</span><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">startHeartbeat</span>(<span class="hljs-params"></span>) &#123;<br>    heartbeatTimer = <span class="hljs-built_in">setInterval</span>(sendHeartbeat, heartbeatInterval);<br>  &#125;<br>  <br>  <span class="hljs-comment">// 停止心跳检测</span><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">stopHeartbeat</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-built_in">clearInterval</span>(heartbeatTimer);<br>  &#125;<br>  <br>  <span class="hljs-comment">// 示例：开始心跳检测</span><br><span class="hljs-title function_">startHeartbeat</span>();<br></code></pre></td></tr></table></figure><p>如何手动中断请求？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js">  <span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;axios&#x27;</span>;<br>  <br>  <span class="hljs-comment">// 创建取消令牌，告诉cancelTokenSource.cancel方法哪个请求要取消</span><br>  <span class="hljs-keyword">const</span> cancelTokenSource = axios.<span class="hljs-property">CancelToken</span>.<span class="hljs-title function_">source</span>();<br>  <br>  <span class="hljs-comment">// 发起请求</span><br>  axios.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;https://example.com/upload&#x27;</span>, file, &#123;<br>    <span class="hljs-attr">cancelToken</span>: cancelTokenSource.<span class="hljs-property">token</span><br>  &#125;)<br>    .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> &#123;<br>      <span class="hljs-comment">// 请求成功的处理逻辑</span><br>    &#125;)<br>    .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">thrown</span> =&gt;</span> &#123;<br>      <span class="hljs-keyword">if</span> (axios.<span class="hljs-title function_">isCancel</span>(thrown)) &#123;<br>        <span class="hljs-comment">// 中断请求的处理逻辑</span><br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 其他网络错误的处理逻辑</span><br>      &#125;<br>    &#125;);<br>  <br>  <span class="hljs-comment">// 当需要中断上传时</span><br>cancelTokenSource.<span class="hljs-title function_">cancel</span>(<span class="hljs-string">&#x27;取消上传&#x27;</span>);<br></code></pre></td></tr></table></figure><p>结合上面两种方法，实现了大文件上传，既保证了上传速度（分片数据小），又保证了文件的完整性（序列号）</p></li></ul><p><u>思路</u>：slice进行切片-&gt;给每个chunk添加chunk指纹（web worker计算md5，因为hash值计算比较耗时，放在主线程会阻塞）-&gt;上传时询问该chunk是否已上传-&gt;后端用文件流合并；</p><p>​           断点续传：由于网络原因自动重传（在catch里面判断是否是Network问题）以及手动暂停（xhr.abort=&gt;axios.cancelToken），再手动重传，重传是记录已经上传的chunk数组，然后重传到所有chunk里遍历，找到没有上传的</p></blockquote><h3 id="7-如果请求的数据没有过来该怎么办？"><a href="#7-如果请求的数据没有过来该怎么办？" class="headerlink" title="7.如果请求的数据没有过来该怎么办？"></a>7.如果请求的数据没有过来该怎么办？</h3><blockquote><p>如果可以不用展示，那就 隐藏，等数据来了再展示</p><p>如果必须要展示，可以 设置 默认值</p><p>——————-Vue3中的Suspense组件配合插槽 就实现了，有数据和没数据时该如何处理</p></blockquote><h3 id="8-如何封装一个axios？"><a href="#8-如何封装一个axios？" class="headerlink" title="8.如何封装一个axios？"></a>8.如何封装一个axios？</h3><blockquote><ol><li>下载axios模块</li><li>创建一个axios实例，初始化配置，比如baseUrl</li><li>配置请求（config加token等）、相应拦截器（把res用promise返回出去）</li><li>export暴露出去</li><li>用import引进来封装各个接口（url、method等）并使用</li></ol></blockquote><h1 id="Npm"><a href="#Npm" class="headerlink" title="Npm"></a>Npm</h1><h3 id="1-npm的底层环境是什么？"><a href="#1-npm的底层环境是什么？" class="headerlink" title="1.npm的底层环境是什么？"></a>1.npm的底层环境是什么？</h3><blockquote><p>npm是指 node package manage，node包管理器，底层环境是Nodejs</p><p>一旦安装了Nodejs，npm也会一并安装，它包含网站—查阅包的地方、命令行—-下载包的地方、注册表—存储包的地方，下载完了便会显示在package.json文件中。</p><p><u>思路</u>：是什么-&gt;环境-&gt;npm如何使用一套流程</p></blockquote><h3 id="2-pnpm相比于npm优势在哪？"><a href="#2-pnpm相比于npm优势在哪？" class="headerlink" title="2.pnpm相比于npm优势在哪？"></a>2.pnpm相比于npm优势在哪？</h3><blockquote><ul><li><p><strong>更快</strong>：支持并行下载</p></li><li><p><strong>更节省空间：</strong>同一个包在磁盘中只存在一份，避免包的重复下载</p></li></ul></blockquote><h1 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h1><h3 id="1-浏览器存储方式有哪些？"><a href="#1-浏览器存储方式有哪些？" class="headerlink" title="1.浏览器存储方式有哪些？"></a>1.浏览器存储方式有哪些？</h3><blockquote><p>Cookie、sessionStorage、localStorage、indexedDB</p><p>既然是存储方法，下面说下关于 存多大、存多长时间、存什么内容 它们时间的区别：</p><p>大小限制：Cookie（4KB）&lt; 【sessionStorage、localStorage】（5MB）&lt; indexedDB（浏览器上的数据库，比较大）</p><p>存储时间：sessionStorage &lt;【 Cookie（任意设置）、localStorage（一直保存在浏览器） 】除非用户或者程序员手动清除&lt; indexedDB （除非手动清除）</p><p>存储内容：【Cookie、sessionStorage、localStorage】-&gt;只能字符串，indexedDB-&gt;任意类型</p></blockquote><h3 id="2-token是存储在cookie中还是localStorage中？"><a href="#2-token是存储在cookie中还是localStorage中？" class="headerlink" title="2.token是存储在cookie中还是localStorage中？"></a>2.token是存储在cookie中还是localStorage中？</h3><blockquote><p>什么是token？token是验证身份的令牌，是指用户验证登陆后服务器把凭证经过加密等方式得到的字符串序列</p><p>存在cookie中和存在localStorage中有什么不一样？</p><p>存在cookie中：登陆后默认会自动将cookie（如果存储在cookie中的话）一同并入请求选项中（想着已经登陆了后续自动帮你配上，不用手动添加token），缺点是会受到跨域限制（怕多个域通信受到攻击），而且还会受到CSRF攻击。</p><p>存在localStorage中：需要手动从localStorage获取token并添加至请求选项中，但是会受到XSS攻击。</p><p>存在哪里更好？</p><p>localStorage，因为存在cookie中，也有被XSS攻击的可能性，因为XSS是js脚本注入，只要通过document.cookie就能拿到，综上所述，存在cookie中，既会受到CSRF攻击又会受到XSS攻击，内存还小，有跨域限制，而存在localStorage中，只有可能有XSS攻击，只要有充足预防措施即可。</p><p>为什么不放在sessionStorage中？</p><p>因为放在sessionStorage中每个标签数据是独立的，无法实现共享。</p><p><u>思路</u>：是什么-&gt;介绍特点-&gt;如何选择</p></blockquote><h3 id="3-什么是XSS攻击和CSRF攻击以及如何预防？"><a href="#3-什么是XSS攻击和CSRF攻击以及如何预防？" class="headerlink" title="3.什么是XSS攻击和CSRF攻击以及如何预防？"></a>3.什么是XSS攻击和CSRF攻击以及如何预防？</h3><blockquote><p>XSS攻击：指跨站脚本，攻击者将恶意脚本注入到受害者网站中，来窃取隐私信息发送到攻击者自己的网站中</p><p>预防XSS：既然是诸如脚本，1）一开始可以防止注入，把用户输入的一些字符串（&lt;&gt;等）进行转义2）设置HTTP头中的安全标记，如Content-Security-Policy（CSP），可以指定哪些资源可被加载，从而减少XSS攻击的风险</p><p>CSRF攻击：指跨站请求伪装，字面意思就知道 是攻击者伪装成用户发送请求，执行恶意操作，比如利用电子邮件、社交媒体发送链接引诱用户去点击</p><p>预防CSRF：在敏感操作的请求中加入CSRF令牌，该令牌是服务器生成的随机值，需要和用户会话关联，攻击者无法伪造</p></blockquote><h3 id="4-token登录流程？"><a href="#4-token登录流程？" class="headerlink" title="4.token登录流程？"></a>4.token登录流程？</h3><blockquote><ol><li>客户端输入完账号密码请求登录</li><li>服务器收到请求，验证账号密码</li><li>验证通过后将凭证经过加密等方式生成token返回给客户端</li><li>客户端收到token后，后续的请求都需要带上token</li><li>服务器只有验证了token才会返回数据</li></ol></blockquote><h3 id="5-你了解过JWT吗？"><a href="#5-你了解过JWT吗？" class="headerlink" title="5.你了解过JWT吗？"></a>5.你了解过JWT吗？</h3><blockquote><p>先说一下为什么会出现这样的技术：对于传统的认证方式来说，服务器端生成完token后还需要在服务器端自己保存一份以便下次验证使用，但是如果在在分布式应用中，一个应用程序的各个服务可能分布在各个服务器上，为了每个服务正常访问，都需要保存一份token信息，这增加了服务器的开销，这是第一点；第二，对于没有保存token信息的服务器来说，等于就闲置了，这就导致了负载不均衡的问题。</p><p>而JWT的出现解决了以上的问题：它叫json web token，指在web应用中以json的形式存储认证信息，有如下特点：</p><ol><li>无状态性：服务端不需要存储验证信息来验证</li><li>安全性比较高：JWT是有专门的加密算法</li></ol><p>下面结合JWT的典型使用场景：单点登录来说明JWT的使用流程和原理：</p><p>在单点登录场景中，通常涉及到分布式应用，比如一个企业想要登录一次就可以访问多个子系统，那单点登录会有一个认证中心，所有用户登录后会先在认证中心处进行验证：</p><p>那JWT涉及到三个部分：头部、载荷、签名，认证中心验证信息后会对JWT的头部和载荷并通过64base加密并结合私钥生成签名（token）的部分，同时生成一份公钥，并把整个JWT返回给用户，下次用户访问不同的服务都要带上这个JWT，不同的服务获取到JWT先解密，并且结合公钥计算，看最后的结果是否等于签名的值，如果相等，则说明验证通过，说明JWT在传输过程中保持完整，否则回到验证中心去验证。</p><p><u>你了解过…吗？答题模版</u></p><p><u>知道一个知识点 为什么会有它（为什么），就等于知道了它的定义、应用场景；知道了它的内部实现（如何），就等于深刻理解了它的所有特点</u></p></blockquote><h3 id="6-页面渲染的过程是什么？"><a href="#6-页面渲染的过程是什么？" class="headerlink" title="6.页面渲染的过程是什么？"></a>6.页面渲染的过程是什么？</h3><blockquote><ol><li>解析HTML标签生成DOM树</li><li>解析CSS样式生成CSSOM</li><li>解析js代码，处理事件等和HTML有关联的操作</li><li>将DOM树和CSSOM树合成渲染树</li><li>根据渲染树计算页面布局（元素的位置和大小）—- 回流</li><li>给元素绘制颜色 —- 重绘</li><li>将绘制好的元素渲染到页面上</li></ol></blockquote><h3 id="7-DOM树和渲染树有什么区别？"><a href="#7-DOM树和渲染树有什么区别？" class="headerlink" title="7.DOM树和渲染树有什么区别？"></a>7.DOM树和渲染树有什么区别？</h3><blockquote><p>最关键的区别就是 DOM树是HTML文档的抽象表示，而渲染树是 最后实际用于渲染页面的树结构，这样一来会带来以下的不同：</p><ul><li>渲染树不包含像header、meta还有隐藏元素 这样与渲染无关的标签，而DOM树包含</li></ul></blockquote><h3 id="8-说一下浏览器的缓存策略"><a href="#8-说一下浏览器的缓存策略" class="headerlink" title="8.说一下浏览器的缓存策略"></a>8.说一下浏览器的缓存策略</h3><blockquote><p>分为两种，强缓存和协商缓存。</p><p>强缓存：由服务器端触发，浏览器端收到通知则将html、css、image等缓存下来，下次加载页面直接从缓存中获取</p><p>协商缓存：缓存之前需向服务器端发送缓存请求，一旦服务器端同意，才缓存</p><p>如何触发？针对HTTP的版本触发方法不一样，如下：</p><p>强缓存：</p><ul><li>HTTP1.0，服务端响应头用 Expires触发，设置浏览器缓存到什么时候</li><li>HTTP1.1以及以后，服务端响应头用 CacheControl触发，由于可能服务器在不同国家地区有时差，设置绝对时间不准确，可以用CacheControl设置相对时间，即多长时间内会缓存</li></ul><p>协商缓存：</p><ul><li>HTTP1.0，请求头：If-Modified-Since，响应头：Last-Modified，通过匹配修改时间是否一直来判断是否缓存，一致则缓存，否则并不缓存</li><li>HTTP1.1以及以后，请求头：If-None-Match，响应头：ETag（Entity，非常笼统的概念，概括为页面的资源，看成一个实体），由于修改时间不一致内容不一定不一致，为了提高性能，直接匹配 修改的值本身，如果值相等，则缓存，否则不缓存</li></ul><p>协商缓存服务器端会返回304状态码，表示可缓存。</p></blockquote><h3 id="9-什么是搜索引擎优化（SEO）？"><a href="#9-什么是搜索引擎优化（SEO）？" class="headerlink" title="9.什么是搜索引擎优化（SEO）？"></a>9.什么是搜索引擎优化（SEO）？</h3><blockquote><p>搜索引擎优化（SEO）是指提高网页在搜索引擎结果中的排名的一系列技术。</p><p>如何优化？从原理上来说，搜索引擎分析的是HTML标签的内容和格式，只要 能帮助搜索引擎分析HTML的都可以优化，有如下几种方式（暂时）：</p><ul><li>优化关键词，即 内容尽量包含 搜索较多的关键词，便于搜索引擎直接获取想要的内容</li><li>优化HTML内容，即 HTML段落的内容尽量有层次，便于搜索引擎分析</li><li>优化HTML结构，尽量使用语义化标签（见上面），便于搜索引擎分析</li></ul></blockquote><h3 id="10-浏览器的安全机制是什么？"><a href="#10-浏览器的安全机制是什么？" class="headerlink" title="10.浏览器的安全机制是什么？"></a>10.浏览器的安全机制是什么？</h3><blockquote><p>基本上有以下四种安全机制：</p><ol><li>同源策略：是浏览器最基本的安全机制，用来限制不同源（协议、域名、端口）之间的网络请求，减少了被攻击的可能性</li><li>HTTPS协议：相对于HTTP本质上是加了一层SSL的加密协议，使得客户端和服务端在传输过程中是不可见的，即使被第三方拦截，也无法被获取</li><li>预防XSS和CSRF攻击：见上面</li><li>沙盒机制：<ul><li>为什么叫沙盒呢？是说它把各个标签页看成沙盒一样，相互隔离，不通标签页是相互独立的，一个标签碰到问题了也不会影响整个浏览器</li><li>然后，它也能针对当前的标签页对电脑数据的访问进行限制，比如文件系统、系统设置</li><li>接着还能对当前页允许访问的资源进行资源使用限制，防止网页崩溃</li></ul></li></ol></blockquote><h1 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h1><h3 id="1-Webpack具体做了什么事情，各有什么好处？"><a href="#1-Webpack具体做了什么事情，各有什么好处？" class="headerlink" title="1.Webpack具体做了什么事情，各有什么好处？"></a>1.Webpack具体做了什么事情，各有什么好处？</h3><blockquote><ol><li>生成依赖图：webpack会找到入口文件（Vue中就是main.js），分析代码中的依赖关系，最终生成依赖图，此依赖图展现了各个模块以及依赖关系</li><li>代码转换：对于每个模块，会利用各种加载器（loader），比如babel-loader可将ES6语法-&gt;ES5语法（CommonJs）、scss-loader可将Scss等预处理文件-&gt;Css文件、url-loader可将图片URL-&gt;dataURL（转换为base64编码）</li><li>代码分割（可选）：可能模块比较多，代码分割可以将代码按模块分类单独放在各个文件里，实现按需加载，比如按需加载首屏加载所需代码，提高首屏加载速度</li><li>资源优化：会对各个模块的代码进一步的优化，比如代码压缩合并（针对单个模块，去除换行、空格、把公共代码单独放入一个文件）等，目的是减少单个文件体积，提高加载速度</li><li>模块打包：如果不进行代码分割，按理来说所有的js代码都会打包在bundle.js文件里，其中bundle.js文件会包含渲染函数（render函数），Vue在加载应用时就会执行render函数来渲染页面</li></ol></blockquote><h3 id="2-Webpack打包后主要生成了哪些文件？"><a href="#2-Webpack打包后主要生成了哪些文件？" class="headerlink" title="2.Webpack打包后主要生成了哪些文件？"></a>2.Webpack打包后主要生成了哪些文件？</h3><blockquote><ol><li>index.html：项目主要的HTML文件，也就是单页面应用的主页面</li><li>图片和其他静态资源（字体）</li><li>bundle.js以及其他模块js文件</li><li>css样式文件</li></ol><p>在index.html里会引入图片、bundle.js、css文件来加载应用</p></blockquote><h3 id="3-Webpack打包和不打包的区别？"><a href="#3-Webpack打包和不打包的区别？" class="headerlink" title="3.Webpack打包和不打包的区别？"></a>3.Webpack打包和不打包的区别？</h3><blockquote><p>webpack打包后有以下优点是不打包所没有额度</p><ol><li><p>更好地支持</p><p>webpack在第一阶段会代码转换，利用babel等工具把一些语法转换为浏览器能识别的语法，会将ES6语法-&gt;ES5语法（CommonJs）、Scss等预处理文件-&gt;Css文件、图片-&gt;dataURL（转换为base64编码）</p></li><li><p>提高加载速度</p><p>webpack在代码分割、资源优化阶段可以大大减小包的大小，从而提高加载速度</p></li></ol></blockquote><h3 id="4-Webpack的基本配置文件（webpack-config-js）中的entry、output、module、plugins等核心选项分别用来做什么？"><a href="#4-Webpack的基本配置文件（webpack-config-js）中的entry、output、module、plugins等核心选项分别用来做什么？" class="headerlink" title="4.Webpack的基本配置文件（webpack.config.js）中的entry、output、module、plugins等核心选项分别用来做什么？"></a>4.Webpack的基本配置文件（webpack.config.js）中的entry、output、module、plugins等核心选项分别用来做什么？</h3><blockquote><p>entry：入口文件，可以为一个或多个</p><p>output：输出配置，比如路径</p><p>module：配置loader处理css文件、style文件等，优化构建速度，比如css-loader、style-loader、file-loader，一句话：帮助webpack处理相应文件的</p><p>plugins：用一些第三方的插件做一些辅助性的处理，比如CleanWebpackPlugin，可以每次构建前清空构建目录</p></blockquote><h3 id="5-如何通过Webpack配置实现代码拆分（code-splitting）等优化和懒加载（lazy-loading）？"><a href="#5-如何通过Webpack配置实现代码拆分（code-splitting）等优化和懒加载（lazy-loading）？" class="headerlink" title="5.如何通过Webpack配置实现代码拆分（code splitting）等优化和懒加载（lazy loading）？"></a>5.如何通过Webpack配置实现代码拆分（code splitting）等优化和懒加载（lazy loading）？</h3><blockquote><p><strong>Webpack的所有优化都是在optimization配置项下</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">optimization</span>:&#123;<br>    <span class="hljs-comment">// 代码分割</span><br>    <span class="hljs-attr">splitChunks</span>:&#123;<br>        <span class="hljs-attr">cacheGroups</span>:&#123;<br>            <span class="hljs-comment">// 提取公共模块</span><br>            <span class="hljs-attr">common</span>:&#123;chunk名字以及目录&#125;,<br>            <span class="hljs-comment">// 按照组件分块</span><br>            <span class="hljs-attr">components</span>:&#123;chunk名字以及目录&#125;<br>        &#125;<br>    &#125;,<br>    <span class="hljs-comment">// Tree Shaking</span><br>    <span class="hljs-attr">minimize</span>:<span class="hljs-literal">true</span>,<br>    <span class="hljs-comment">// 压缩Js和Css文件,注意terserPlugin需要安装webpack对应版本，比如webpack4-&gt;terserPlugin4,webpack默认安装5版本的</span><br>    <span class="hljs-attr">minimizer</span>:&#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title function_">terserPlugin</span>(&#123;<br>            <span class="hljs-comment">// 缓存js文件</span><br>            <span class="hljs-attr">cache</span>:<span class="hljs-literal">true</span>，<br>            <span class="hljs-attr">terserOptions</span>:&#123;<br>               <span class="hljs-comment">// 去除console、debugger语句</span><br>               <span class="hljs-attr">compress</span>:&#123;<br>                  <span class="hljs-attr">drop_console</span>:<span class="hljs-literal">true</span><br>                  <span class="hljs-attr">drop_debugger</span>:<span class="hljs-literal">true</span><br>               &#125;<br>            &#125;<br>        &#125;),<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">OptimizeCSSAssetsPlugin</span>(&#123;<br>            <span class="hljs-comment">// 有三种模式default(去除空格等)、medium(浏览器兼容,比如加上其他浏览器前缀,谷歌和Safari都是-webkit-,而火狐是-moz-)、advanced(针对重复选择器去重等)</span><br>            <span class="hljs-attr">cssProcessorPluginOptions</span>: &#123;<br>                 <span class="hljs-attr">preset</span>: [<span class="hljs-string">&#x27;default&#x27;</span>, &#123; <span class="hljs-attr">discardComments</span>: &#123; <span class="hljs-attr">removeAll</span>: <span class="hljs-literal">true</span> &#125; &#125;]<br>              &#125;<br>        &#125;),<br>        <span class="hljs-comment">// 需要配合服务端配置才可以(ngix)</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">CompressWebpackPlugin</span>(&#123;<br>            <span class="hljs-attr">test</span>:<span class="hljs-regexp">/\.(js|html|css)$/</span>,压缩的文件类型<br>            <span class="hljs-attr">threhold</span>:<span class="hljs-number">10240</span>,<span class="hljs-comment">//单位B,超过10KB就进行压缩</span><br>        &#125;)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>懒加载：</strong></p><p>一旦代码中使用了import的语法，webpack自动会进行懒加载处理</p></blockquote><h3 id="6-Webpack中的哪些配置选项或插件可以帮助提高构建速度？"><a href="#6-Webpack中的哪些配置选项或插件可以帮助提高构建速度？" class="headerlink" title="6.Webpack中的哪些配置选项或插件可以帮助提高构建速度？"></a>6.Webpack中的哪些配置选项或插件可以帮助提高构建速度？</h3><blockquote><p>在module配置项中添加thread-loader可开启多线程处理</p><p>还有一些css-loader、style-loader、file-loader</p></blockquote><h3 id="7-你对Vite构建工具有哪些了解？它与Webpack相比有什么优势？"><a href="#7-你对Vite构建工具有哪些了解？它与Webpack相比有什么优势？" class="headerlink" title="7.你对Vite构建工具有哪些了解？它与Webpack相比有什么优势？"></a>7.你对Vite构建工具有哪些了解？它与Webpack相比有什么优势？</h3><blockquote><p>Vite是新一代前端构建工具，相较于Webpack，它省去了 代码转化、分析以及打包的动作，直接按需加载编译服务器的代码，所以会更快</p></blockquote><h1 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h1><h3 id="1-v-show和v-if的区别"><a href="#1-v-show和v-if的区别" class="headerlink" title="1.v-show和v-if的区别"></a>1.v-show和v-if的区别</h3><blockquote><p>两者都是用来显示隐藏元素的，区别如下：</p><ol><li>从原理上来看：v-show是通过控制display的值来显示和隐藏的；而v-if是通过对DOM元素的添加和删除实现显示和隐藏的</li><li>从对象上来说：<ul><li>既然v-if是直接对DOM操作的，性能较低，效率低，而v-show效率高</li><li>如果DOM标签包含事件，v-if的显示和隐藏会涉及事件的绑定以及解绑；如果DOM标签包含组件，v-if还会涉及到组件的编译、实例化、渲染以及挂载。而v-show仅仅是简单的CSS样式切换。</li></ul></li></ol></blockquote><h3 id="2-如何理解MVVM的？"><a href="#2-如何理解MVVM的？" class="headerlink" title="2.如何理解MVVM的？"></a>2.如何理解MVVM的？</h3><blockquote><p>它是一种软件架构（相当于文章的大纲）模式，全称是Model-View-ViewModel，这三个部分实现了</p><ol><li>前端可以临时存储数据（前后端分离之前都是用的MVC模式，数据只能依赖后端，通过C-Controller分发数据）</li><li>将数据和视图进行双向绑定：用户可以修改View数据，ViewModel可监听到并通知Model数据的修改；同时，ViewModel也可以将Model数据的修改更新到View上。整个过程是自动地，无需认为操作。</li></ol><p>Ps：这个问题后续估计会提问：v-model的实现原理（MVVM的具体技术）、响应式原理，面试官不问就不用说那么多，对于MVVM就讲个 定义-&gt;历史（与MVC的关系）-&gt;功能。</p></blockquote><h3 id="3-v-for中的key有什么作用？"><a href="#3-v-for中的key有什么作用？" class="headerlink" title="3.v-for中的key有什么作用？"></a>3.v-for中的key有什么作用？</h3><blockquote><p>key是DOM元素的唯一标识</p><p>作用：主要就是用来辅助虚拟DOM比对新旧节点来复用DOM元素，提高性能，否则就会胡乱地就地复用，增加不必要的重新渲染。</p><p>使用key的注意点：要确保key值唯一，并且不要使用自带的index作为key值（仍然会出现胡乱地就地复用，比如列表原来index 0-1-2，在首部添加一个元素，会把后面的元素往后顶，但index值不变，0-1-2-3，出现了混乱复用）</p><p><u>思路</u>：在回答xxx有什么作用时，模板：定义-&gt;作用（先解释是什么，再说有什么作用）-&gt;如何使用</p></blockquote><h3 id="4-说一下你对生命周期的理解"><a href="#4-说一下你对生命周期的理解" class="headerlink" title="4.说一下你对生命周期的理解"></a>4.说一下你对生命周期的理解</h3><blockquote><ol><li>beforeCreate：实例创建之前，此时 数据、方法无法访问</li><li>created：实例创建完成，已经完成了数据监测（数据劫持–数据的准备工作），可以修改数据但是不会更新到页面，因为还没挂载</li><li>beforeMount：挂载之前，完成了模板编译（具体见下面），生成了虚拟DOM，即将渲染页面</li><li>mounted：页面已经渲染完成并挂载到页面，可以访问DOM元素也可以发送异步请求（目的是得到数据给页面展示，由于页面已经初始化就可以把数据放心放在页面了–但是可能会卡顿，见下面）</li><li>beforeUpdate：页面更新之前，数据是新的，但页面是旧的</li><li>Updated：页面已经更新完毕，此时不要修改数据，已经为时已晚</li><li>beforeDestory：销毁之前，这里可以销毁定时器等</li><li>destoryed：已销毁</li></ol><p>keep-alive组件缓存专属：</p><ul><li>activiated：激活时</li><li>deactiviated：销毁时</li></ul></blockquote><h3 id="5-模板编译的原理"><a href="#5-模板编译的原理" class="headerlink" title="5.模板编译的原理"></a>5.模板编译的原理</h3><blockquote><ol><li>解析模板生成AST（抽象语法树 Abstract Async Tree），它是一种树状结构，描述了模板中模板字符串、指令等模板语法之间的关系</li><li>对AST进行静态标记（Vue3才提出来的内容），指出哪些元素是静态的，告知虚拟DOM哪些元素不需进行比对，为虚拟DOM的工作减轻了负担</li><li>针对AST生成render函数，一旦执行render函数，就会生成虚拟DOM</li></ol></blockquote><h3 id="6-Vue3生命周期有哪些变化？"><a href="#6-Vue3生命周期有哪些变化？" class="headerlink" title="6.Vue3生命周期有哪些变化？"></a>6.Vue3生命周期有哪些变化？</h3><blockquote><ol><li>用setup函数代替了beforeCreate和created（如果要打印sepup函数和beforeCreate，sepup比beforeCreate还先执行）</li><li>其他函数前面都加上了on，更易于理解</li><li>beforeDestory、destoryed -&gt;onBeforeUnMounted、onUnMounted，与挂载一一对应</li></ol></blockquote><h3 id="7-父子生命周期函数的执行顺序"><a href="#7-父子生命周期函数的执行顺序" class="headerlink" title="7.父子生命周期函数的执行顺序"></a>7.父子生命周期函数的执行顺序</h3><blockquote><ul><li><p>实例化、挂载</p><p>父beforeCreate-&gt;父created-&gt;父beforeMount-&gt;子beforeCreate-&gt;子created-&gt;子beforeMount-&gt;子mounted-&gt;父mounted（必须要实例所有内容包括子组件准备完毕才能挂载）</p></li><li><p>父组件更新</p><p>父beforeUpdate-&gt;父Updated</p></li><li><p>子组件更新</p><p>父beforeUpdate-&gt;子beforeUpdate-&gt;子Updated-&gt;父Updated</p></li><li><p>销毁</p><p>父beforeDestory-&gt;子beforeDestory-&gt;子destoryed -&gt;父destoryed </p></li></ul><p><u>原则</u>：子组件是父组件的一部分，因此碰到子组件会连带父组件，反过来不会</p></blockquote><h3 id="8-在created和mounted中请求数据有什么不同？"><a href="#8-在created和mounted中请求数据有什么不同？" class="headerlink" title="8.在created和mounted中请求数据有什么不同？"></a>8.在created和mounted中请求数据有什么不同？</h3><blockquote><p>created：在页面渲染之前</p><p>mounted：在页面渲染之后</p><p>使用场景：如果请求的数据 和DOM有关—-&gt;放在created中</p><p>​                                               和DOM无关—–&gt;放在mounted中</p><p>推荐放在created，有以下理由：</p><ul><li>更早地获取到服务端数据，减少loading时间（卡顿）</li><li>服务端渲染SSR（见下面）不支持mounted，可以保持统一性</li></ul></blockquote><h3 id="9-什么是服务端渲染（SSR）？"><a href="#9-什么是服务端渲染（SSR）？" class="headerlink" title="9.什么是服务端渲染（SSR）？"></a>9.什么是服务端渲染（SSR）？</h3><blockquote><p>就是 将浏览器端执行js代码的工作 放在服务端来做，服务端处理完，返回HTML字符串给浏览器，这么做有以下好处：</p><ul><li>浏览器减少了负担，加快了首屏加载速度</li><li>由于页面加载速度快了，也有助于SEO</li></ul></blockquote><h3 id="10-Vue中修饰符有哪些？"><a href="#10-Vue中修饰符有哪些？" class="headerlink" title="10.Vue中修饰符有哪些？"></a>10.Vue中修饰符有哪些？</h3><blockquote><ol><li>事件修饰符<ul><li>.capture：事件捕获模式，先触发当前事件再触发内部事件</li><li>.self：只会触发当前事件，不会被事件传播而影响被触发</li><li>.stop：阻止事件冒泡</li><li>.once：有且仅触发一次</li><li>.passive（消极-任由继续往后找）：不阻止/触发默认行为</li><li>.prevent：阻止默认行为</li><li>.native：仅触发原生事件，这些事件Vue没有，因为不常用</li></ul></li><li>v-model修饰符<ul><li>.number：将输入转化为数字</li><li>.trim：出入完去掉空格</li><li>.lazy：可以等输入完再触发事件（请求），类似函数防抖</li></ul></li><li>键盘修饰符<ul><li>keyup</li><li>keydown</li></ul></li><li>系统修饰符<ul><li>.ctrl</li><li>.alt</li></ul></li><li>鼠标修饰符<ul><li>.left</li><li>.middle</li><li>.right</li></ul></li></ol><p><u>思路</u>：事件修饰符（寻找亲戚：事件传播-近邻，默认行为-远亲，原生-远远亲）-&gt;键盘相关（表单（输入是为了触发请求，而lazy可以懒触发）-&gt;特殊）-&gt;鼠标</p></blockquote><h3 id="11-elementUI怎么做表单验证的？"><a href="#11-elementUI怎么做表单验证的？" class="headerlink" title="11.elementUI怎么做表单验证的？"></a>11.elementUI怎么做表单验证的？</h3><blockquote><ul><li>内置规则：在表单添加rules属性，rules中的每个表单项规则按照文档来</li><li>自定义规则：比如自己写个邮件验证的规则，然后放入validator属性中</li></ul></blockquote><h3 id="12-Vue中的组件通信有哪些？"><a href="#12-Vue中的组件通信有哪些？" class="headerlink" title="12.Vue中的组件通信有哪些？"></a>12.Vue中的组件通信有哪些？</h3><blockquote><ul><li><p>父子通信</p><p>props：父-&gt;子，$emit：子-&gt;父</p><p>$parent、$children：强制性获取父组件、子组件们（$children是个数组而$parent不是）的实例进行通信，获取到实例的属性或方法可以互传</p><p>$refs：几乎等同于$children，相比$children，优点是可以针对性获取实例，独立性更高</p></li><li><p>跨级通信</p><p>$attrs、$listeners：为了解决利用props的A-&gt;B-&gt;C逐层传递的臃肿问题而出现，A可以把多个数据、回调同时传递给B，B直接再把$attrs、$listeners传递给C即可，不需要先接受再命名传递（注意$attrs是除了B的props以外的数据，因为A可能有专门传递给B用的数据）</p><p>provide、inject：只能由上往下跨级传递，不能由下往上且不能同级传递，需统一数据流方向，否则不方便维护</p></li><li><p>同级通信</p><p>eventBus/发布订阅：和provide、inject一样有维护不便的问题</p><p>vuex</p></li></ul></blockquote><h3 id="13-为什么Vue中尽量使用箭头函数而不是传统函数？"><a href="#13-为什么Vue中尽量使用箭头函数而不是传统函数？" class="headerlink" title="13.为什么Vue中尽量使用箭头函数而不是传统函数？"></a>13.为什么Vue中尽量使用箭头函数而不是传统函数？</h3><blockquote><p>因为传统函数会有this指向问题，即按照原来的this指向规则可能会指向到原本不想要的对象上，因此直接使用箭头函数，取消当前函数的this，按照外部Vue实例内部来访问。</p></blockquote><h3 id="14-keep-alive组件是什么？如何使用的"><a href="#14-keep-alive组件是什么？如何使用的" class="headerlink" title="14.keep-alive组件是什么？如何使用的?"></a>14.keep-alive组件是什么？如何使用的?</h3><blockquote><p>它是Vue内置组件，可以对组件进行缓存，在组件进行切换时不需要销毁。</p><p>用keep-alive包裹组件，并利用include、exclude指定哪些组件需要缓存和不需要缓存的组件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;keep-live :include=组件数组 :exclude=组件数组&gt;<br>...<br>&lt;/keep-live&gt;<br></code></pre></td></tr></table></figure><p>好处就是 缓存活跃的组件，不需要重新渲染，提高性能以及用户体验</p></blockquote><h3 id="15-Vue路由怎么传参的？"><a href="#15-Vue路由怎么传参的？" class="headerlink" title="15.Vue路由怎么传参的？"></a>15.Vue路由怎么传参的？</h3><blockquote><ul><li><p>params参数：用于传递一些必要的参数，没有这个参数路由都无法匹配，例如用户ID，商品ID，必须要这个参数才能正常加载组件的</p><p>需要在路由配置动态URL片段，如/user/:id，刷新后params参数会丢失，因为刷新后路由初始化，路由都无法匹配了，参数当然也没了</p></li><li><p>query参数：用于传递一些非必要的参数，比如搜索框的关键字，可以传也可以不传，不传就搜索所有数据</p><p>刷新后路由能正常匹配，于是查询字符串的query参数也能保存，类似于get参数会显示在URL上</p><p>params参数、query参数都可以通过对象的形式传参，获取方式也类似</p></li><li><p>props传参：用于传递组件自身需要的一些复杂属性，比如父子通过路由传值</p><p>要在路由文件中加上props，再在子组件中用props接受</p></li></ul></blockquote><h3 id="16-什么是单页面应用（SPA）？"><a href="#16-什么是单页面应用（SPA）？" class="headerlink" title="16.什么是单页面应用（SPA）？"></a>16.什么是单页面应用（SPA）？</h3><blockquote><p>是指整个应用只有一个HTML文件，页面的内容会根据用户的交互动态地呈现。</p><p>单页面应用（SPA）主要是利用前端路由来实现的：通过监听路由的URL变化来加载不同的组件，从而实现动态地更新内容。</p></blockquote><h3 id="17-Vue中的hash模式和history模式有什么区别？"><a href="#17-Vue中的hash模式和history模式有什么区别？" class="headerlink" title="17.Vue中的hash模式和history模式有什么区别？"></a>17.Vue中的hash模式和history模式有什么区别？</h3><blockquote><p><strong>从原理上来看：</strong></p><p>hash模式是通过hashChange事件来监听URL的hash值（#以及后面的，会存储在location.hash中）的变化来匹配路由规则并加载对应组件的（路由规则以及组件资源在浏览器端的缓存中-bundle.js文件，匹配时会自动去掉#），这个过程是在浏览器端进行的，不会向服务器发送HTTP请求</p><p>而history模式是通过popState事件（历史记录栈顶状态的变化）来监听历史记录的变化（最终获取的是pathname）来匹配路由规则并加载对应组件的（后面和hash模式一样，仅仅是监听的东西不一样），其中，在监听之前，是通过H5的API（H5才出的，因此兼容性没有hash模式好）：pushState（）和replaceState来存储并修改历史记录为监听历史记录做准备</p><p><strong>从用途上来看：</strong></p><p>hash模式始终都不会向服务器发送请求（除了请求组件需要的数据），单页面应用也倾向于使用Hash模式———适合在项目准备上线时设置</p><p>而history模式是 在刷新页面或者手动输入URL 时会向服务器请求资源并重复覆盖浏览器的缓存资源，入宫没有对应的资源，会出现404，但是可以在后端配置返回什么，就可以避免404—————-适合在开发阶段测试数据时使用</p></blockquote><h3 id="18-路由是怎么拦截的？"><a href="#18-路由是怎么拦截的？" class="headerlink" title="18.路由是怎么拦截的？"></a>18.路由是怎么拦截的？</h3><blockquote><p>在哪拦截：路由守卫中</p><p>如何拦截？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs vue">// 1.路由配置中在meta添加自定义属性来判断<br>&#123;<br>path:&#x27;index.html&#x27;,<br>name:&#x27;index&#x27;,<br>mata:&#123;<br>  reuqiredAuth:true  <br>&#125;<br>&#125;<br>// 2.路由守卫中判断<br>router.beforeEach((from,to,next)=&gt;&#123;<br> if(this.route.meta.reuqiredAuth)&#123;<br>   if(store.state.token)&#123;<br>     next()<br>  &#125;<br>&#125;<br>&#125;)<br></code></pre></td></tr></table></figure></blockquote><h3 id="19-如果路由中一个路由对象同时有redirect和component，Vue-Router会如何处理？"><a href="#19-如果路由中一个路由对象同时有redirect和component，Vue-Router会如何处理？" class="headerlink" title="19.如果路由中一个路由对象同时有redirect和component，Vue Router会如何处理？"></a>19.如果路由中一个路由对象同时有redirect和component，Vue Router会如何处理？</h3><blockquote><p>会优先使用redirect的组件，因为有重定向会立刻导航并加载重定向路径的组件，而忽视当前的组件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs vue">const routes = [<br>&#123;<br> path: &#x27;/example&#x27;,<br> component: ExampleComponent, // 示例组件<br> redirect: &#x27;/redirected&#x27; // 重定向路径<br>&#125;,<br>&#123;<br> path: &#x27;/redirected&#x27;,<br> component: RedirectedComponent // 重定向后显示的组件<br>&#125;<br>]<br></code></pre></td></tr></table></figure><p>会加载RedirectedComponent</p></blockquote><h3 id="20-路由有哪些守卫钩子，又是如何解析的？"><a href="#20-路由有哪些守卫钩子，又是如何解析的？" class="headerlink" title="20.路由有哪些守卫钩子，又是如何解析的？"></a>20.路由有哪些守卫钩子，又是如何解析的？</h3><blockquote><p><strong>分类</strong></p><p>先说下所有的钩子函数：全局守卫、路由独享路由、组件守卫。</p><p><strong>完整的导航解析流程</strong></p><ul><li>导航被触发，比如router.push()、router.replace()</li><li>调用失活组件的beforeRouteLeave守卫</li><li>调用全局前置守卫beforeEach，在这可以添加一些登录验证，这是验证是全局的，也就是它针对所有路由</li><li>调用重用组件的beforeRouteUpdate守卫，这个守卫专门在路由 的组件复用时调用，比如两个路由地址不同，但是对应组件是一样的，如果有路由的组件复用，调用完该守卫更新完毕就不会调用后面的守卫了</li><li>调用路由独享的守卫beforeEnter守卫，路由独享的守卫就这一个，专门为跳转当前路由之前做一些逻辑，比如也可以做登录验证，只是这个验证只针对当前路由</li><li>下面到了异步组件（使用import关键字的懒加载组件）的解析阶段</li><li>调用激活组件的beforeRouteEnter守卫，在该守卫中还没有实例化，无法使用this，可准备好异步数据给激活的组件</li><li>调用全局解析守卫beforeResolve，该守卫是解析的最后一步，也可以获取异步数据，只是这个数据一般是可能其他组件也要使用，比如用户的信息放入仓库</li><li>导航被确认。为什么要确认一下？表示要进入 下面路由的信息已经准备好。</li><li>调用全局后置守卫afterEach，目标路由已经跳转结束，可处理一些收尾工作，比如跳转到目标页面的对应位置</li><li>目标组件DOM渲染</li><li>调用全局前置守卫beforeRouteEnter的回调函数next()，调用此函数时已经实例化，并把实例作为参数传递给组件路由的下一阶段使用（意思就是说组件已经渲染好了进入该组件的钩子也该结束了）</li></ul></blockquote><h3 id="21-说一下Vue的动态路由"><a href="#21-说一下Vue的动态路由" class="headerlink" title="21.说一下Vue的动态路由"></a>21.说一下Vue的动态路由</h3><blockquote><p>动态路由是指加了权限控制的路由，最终实现的效果是：不同用户登陆后，显示不同的菜单功能，因为不同用户有不同权限</p><p>如何实现，大致分以下几步：</p><ol><li>登陆后获取用户的权限信息，比如角色信息</li><li>在路由配置中提前写好静态路由（不需要权限就可以访问的）和预制动态路由（admin所有能访问的路由），预制动态路由中必须要加上meta属性，包括icon（菜单图标）、title（菜单标题）、role（角色）等</li><li>用获取到的用户权限信息到预制动态路由中匹配，去找当前角色能访问的菜单功能，并最终重新生成一个新的路由</li><li>利用新的路由进行循环展示sideBar</li></ol></blockquote><h3 id="22-如何解决动态路由在刷新后二次加载路由（动态路由做权限管理碰到的问题）？"><a href="#22-如何解决动态路由在刷新后二次加载路由（动态路由做权限管理碰到的问题）？" class="headerlink" title="22.如何解决动态路由在刷新后二次加载路由（动态路由做权限管理碰到的问题）？"></a>22.如何解决动态路由在刷新后二次加载路由（动态路由做权限管理碰到的问题）？</h3><blockquote><p>使用动态路由做权限管理时通常会出现两个问题：</p><ul><li><p>动态路由添加后刷新 出现404/白屏</p><p><strong>原因：</strong>本来登录后把添加的路由会放入vuex中，然后在跳转首页时在beforeEnter里面会使用router.addRoute配合循环（vue2的addRoutes已经弃用了）动态添加路由，然后next()放行并展示 添加的菜单。但是 刷新后 Vuex数据会丢失，于是再进入新添加的路由，进入beforeEnter钩子时获取不到添加的路由地址，于是会出现404/白屏</p></li></ul><p>​       <strong>解决办法：</strong>在beforeEnter中加一个判断，如果vuex的路由为空，则重新生成一下动态路由，再重新添加。但是，要注意的是，由于 <strong>路由是动态添加的，而路由匹配是在beforeEnter之前做的事情</strong>，因此next放行是需要使用next({ …to, replace: true })：循环调用beforeEnter直到动态路由 成功添加后 并 匹配到地址后，再放行，其中replace是指不希望用户后退使用后退操作，因为可能前一个页面也是动态添加的，否则vuex的路由不为空（生成了路由）且to的地址不为空（成功添加了路由），才放行。</p><ul><li>不同用户登录后，动态路由会重复添加</li></ul><p>​       <strong>原因：</strong>不同用户登录后前一个用户动态添加的路由不会删除</p><p>​       <strong>解决办法：在动态添加路由之前使用空的路由对象的matcher替换当前路由对象的matcher</strong></p><p>​       router.matcher = new Router({ mode: ‘history’, base: ‘s-connect’, routes: [] }).matcher这么做的效果是：把路由配置可以重新替换而不是追加。</p></blockquote><h3 id="23-Vuex数据刷新后会丢失吗？怎么解决？"><a href="#23-Vuex数据刷新后会丢失吗？怎么解决？" class="headerlink" title="23.Vuex数据刷新后会丢失吗？怎么解决？"></a>23.Vuex数据刷新后会丢失吗？怎么解决？</h3><blockquote><p>会，因为Vuex中的数据是放在运行时内存中的，一旦刷新就得重新初始化。</p><p><strong>解决方法</strong>：使用浏览器缓存来存储，比如localStorage，一旦在Vuex获取到数据后便放入localStorage，然后监听浏览器刷新事件，一旦刷新了，在里面就用localStorage的数据</p></blockquote><h3 id="24-Watch和computed的区别？"><a href="#24-Watch和computed的区别？" class="headerlink" title="24.Watch和computed的区别？"></a>24.Watch和computed的区别？</h3><blockquote><p>要看区别主要要从 用途上以及过程上来看：<strong>computed是来计算data中的属性的，而watch是来监听属性并处理一些逻辑的。</strong></p><ol><li>computed函数需要return，而watch不用，因为它不一定需要返回展示</li><li>页面初始化时，computed是会计算的，而watch并不会，因为它不需要像computed立马需要展示computed不支持异步，还是一样需要赶快展示，而watch执行的回调本来就是请求数据去的，这就是异步的</li><li>computed支持缓存，即数据变化时才会重新计算（为了性能），而watch不会，因为依赖用户的交互值，每次都会变</li></ol><p><u>思路</u>：用途+使用的时间顺序</p></blockquote><h3 id="25-Vuex在什么场景下会使用？有什么属性？"><a href="#25-Vuex在什么场景下会使用？有什么属性？" class="headerlink" title="25.Vuex在什么场景下会使用？有什么属性？"></a>25.Vuex在什么场景下会使用？有什么属性？</h3><blockquote><p>场景：在需要数据共享的时候，比如用户信息</p><p>包括以下属性：</p><ul><li>Actions：请求异步数据，执行mutations函数</li><li>Mutations：直接修改state中的数据</li><li>State:存储数据的地方</li><li>Getters：state数据的计算属性</li></ul></blockquote><h3 id="26-Vue双向数据绑定原理是什么（100-会问）？"><a href="#26-Vue双向数据绑定原理是什么（100-会问）？" class="headerlink" title="26.Vue双向数据绑定原理是什么（100%会问）？"></a>26.Vue双向数据绑定原理是什么（100%会问）？</h3><blockquote><p><strong>1、先说一下双向绑定的组成部分：</strong></p><p>它包含view、model、view model三个部分，其中最重要的就是view model，使它实现的view和model的关联，双向绑定的原理最主要的就是view model的原理。</p><p>那view model它又包含两个部分，编译器和监听器，编译器实现view的变化影响model的变化，而model的变化影响view的变化是需要 【监听器+编译器】 一起实现的，后者其实就是指的是响应式。</p><p><strong>2、下面说响应式是怎么实现的（要用到监听器和编译器）：</strong></p><p>一开始该组件的的vue实例在初始化时对data数据进行响应式处理，这个过程发生在监听器中，在defineReactive中的Object.defineproperty进行数据劫持时会为每一个data中的属性创建一个Dep实例（订阅器），这个是依赖管理器，依赖是什么？指的是该数据相关的所有数据比如computed计算属性、监听器watch等，为什么要收集？因为要知道哪些数据后面可能要更新。</p><p>然后在编译器里，会开始寻找模版上的动态数据，比如指令、插值语法什么的，并初始化视图，一旦发现模版上有使用data中的动态数据，此时就会调用数据劫持中的getter函数，这时Dep就会开始收集依赖，同时为每一个依赖创建watcher，它是订阅者，来订阅Dep啥时候通知它数据变化了，它会为依赖绑定一个更新函数，为后续的更新做准备。一旦数据发生变化了，就会触发数据劫持的getter函数，此时Dep就会通知相应的watcher叫它执行相应的更新函数来实现响应式。watcher是怎么更新的，更新的策略是什么？一般来说，它会主动要求调度者scheduler将自己放到一个执行队列中，再下一个事件循环统一进行更新。这么做有以下好处：</p><ol start="2"><li>避免了频繁更新带来的性能问题</li></ol><p><strong>3、上面只是说了响应式的原理，下面说说编译器又如何让view的变化来影响model的：</strong></p><p>主要是通过在编译时对于使用到的事件的处理，通过事件可以让用户的操作影响到model中的数据，然后再通过上面的响应式，这就实现了双向绑定。</p></blockquote><h3 id="27-了解虚拟DOM和Diff算法吗？虚拟DOM的优缺点是什么？"><a href="#27-了解虚拟DOM和Diff算法吗？虚拟DOM的优缺点是什么？" class="headerlink" title="27.了解虚拟DOM和Diff算法吗？虚拟DOM的优缺点是什么？"></a>27.了解虚拟DOM和Diff算法吗？虚拟DOM的优缺点是什么？</h3><blockquote><p>我们手动频繁地去更新DOM是非常消耗性能的，因此就有了虚拟DOM，它是利用js对真实DOM的抽象表示，用来比对新旧节点的不同，针对不同点来更新真实DOM，这样就降低了更新DOM的频率，提高了性能。</p><p>而Diff算法就是用来给虚拟DOM比对新旧虚拟DOM的不同的，返回值是一个patch对象，它包含了所有新旧节点的不同之处。</p><p>Ps：可以把整个从头到尾的过程说一遍，从 编译-&gt;生成render函数-&gt;生成虚拟DOM-&gt;Diff算法的具体过程</p><p>优缺点：</p><ul><li>优点：减少DOM操作，提高性能</li><li>缺点：首次加载大量DOM时，还要进行虚拟DOM的计算，产生额外开销</li></ul></blockquote><h3 id="28-Vue和Jquery的区别是什么？"><a href="#28-Vue和Jquery的区别是什么？" class="headerlink" title="28.Vue和Jquery的区别是什么？"></a>28.Vue和Jquery的区别是什么？</h3><blockquote><ol><li>定义：Vue是js框架，用于构建交互式的页面；而Jquery是一个库，用于简化操作DOM、事件处理等</li><li>着重点：Vue是有双向数据绑定的概念的，数据和视图是自定更新的，因此更注重数据的处理，无需关心DOM的更新；而Jquery需要手动获取DOM并处理更新，更注重DOM的处理</li><li>前景：Vue更加流行，而Jquery在慢慢淘汰</li></ol></blockquote><h3 id="29-Vuex的响应式处理是什么？"><a href="#29-Vuex的响应式处理是什么？" class="headerlink" title="29.Vuex的响应式处理是什么？"></a>29.Vuex的响应式处理是什么？</h3><blockquote><p>Vuex是共享数据管理的工具。</p><p>Vuex的响应式处理其实就是 怎么通过修改state的值从而又更新到视图的，也就是把 修改值-&gt;获取值 的过程说一遍：</p><ol><li>使用Vue.use(vuex)，调用install方法，install方法内部又调用applyMixin方法（其实就是利用mixin混入）将vuex实例挂载到Vue实例身上，这样在任意组件内都可以使用this.$store来访问了</li><li>在Vue组件内去触发dispatch来调用actions的方法，可以异步请求数据存入store，也可以调用mutations来修改state数据</li><li>mutations直接修改state中的数据</li><li>用getters对state中的数据进行计算处理，方便组件直接使用，不需要额外的计算处理</li><li>在组件中把state的数据引入到data中，借助data中数据响应式特点更新到视图中（最关键）</li></ol></blockquote><h3 id="30-Vue中常用到的遍历方法有哪些？"><a href="#30-Vue中常用到的遍历方法有哪些？" class="headerlink" title="30.Vue中常用到的遍历方法有哪些？"></a>30.Vue中常用到的遍历方法有哪些？</h3><blockquote><ul><li><p>forEach———普通遍历</p><p>元素处理</p></li><li><p>filter————-过滤元素</p></li><li><p>reduce———-累加器</p></li><li><p>map————-数据处理</p><p>元素查找和判断</p></li><li><p>findIndex——返回返回满足条件的第一个元素索引</p></li><li><p>some————有一个满足则为true</p></li><li><p>every————全部满足才为true</p></li></ul></blockquote><h3 id="31-如何封装一个可复用的组件来使用？"><a href="#31-如何封装一个可复用的组件来使用？" class="headerlink" title="31.如何封装一个可复用的组件来使用？"></a>31.如何封装一个可复用的组件来使用？</h3><blockquote><ol><li>使用Vue.extends()创建一个组件</li><li>使用Vue.components()注册组件</li></ol><p>组件设计原则：</p><ul><li>组件原子化，一个组件只干一件事</li><li>并且干的事情，分工明确，比如 容器组件管数据（一般是父组件），展示组件管视图（一般是子组件）</li></ul></blockquote><h3 id="32-封装一个可复用的组件需要注意什么？"><a href="#32-封装一个可复用的组件需要注意什么？" class="headerlink" title="32.封装一个可复用的组件需要注意什么？"></a>32.封装一个可复用的组件需要注意什么？</h3><blockquote><p>除了上面的设计原则以外，这个可复用的组件要分父组件还是子组件（数据和事件的处理）：</p><ul><li>作为父组件来复用：<ol><li>把事件写在父组件中，子组件只负责触发事件，低耦合</li></ol></li><li>作为子组件来复用：<ol><li>不要在子组件请求数据，子组件一般只用来展示UI，况且要多次使用要避免多次请求数据，可以放在父组件请求</li><li>对于第一点，取而代之的是提供props来接受数据，数据流明确，便于维护</li></ol></li></ul></blockquote><h3 id="33-Vue的过滤器怎么使用？"><a href="#33-Vue的过滤器怎么使用？" class="headerlink" title="33.Vue的过滤器怎么使用？"></a>33.Vue的过滤器怎么使用？</h3><blockquote><p>Vue的过滤器 其实 就是 angular中的 管道，主要就是针对 文字进行处理，Vue中过滤器有以下两种：</p><ul><li><p>全局过滤器 ———– 任何组件都可以使用</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ada">Vue.filter(<span class="hljs-symbol">&#x27;add</span>&#x27;,<span class="hljs-keyword">function</span>(v)&#123; <span class="hljs-comment">-- 全局添加一个名为add的过滤器，小于10，则添加0</span><br>       <span class="hljs-keyword">return</span> v &lt; <span class="hljs-number">10</span> ? <span class="hljs-string">&#x27;0&#x27;</span>+v : <span class="hljs-type">v</span><br>&#125;)<br></code></pre></td></tr></table></figure></li><li><p>本地过滤器 ———–当前组件使用</p><p>和methods同级</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ada">filters:&#123; <span class="hljs-comment">------------------------------------------- 不止一个过滤器</span><br>       add:<span class="hljs-keyword">function</span>(v)&#123; <br>     <span class="hljs-keyword">return</span> v &lt; <span class="hljs-number">10</span> ? <span class="hljs-string">&#x27;0&#x27;</span>+v : <span class="hljs-type">v</span><br>     &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>用法：</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">data</span> | add&#125;&#125;</span><br></code></pre></td></tr></table></figure><p>注意：过滤器在Vue3中已经废除，因为 我们不希望在插值语法的形式太过复杂，不美观，推荐使用computed计算属性 ————- Vue3和Vue2的不同要好好记忆，很可能因为这个题被问到</p></blockquote><h3 id="34-Vue中如何做强制刷新？"><a href="#34-Vue中如何做强制刷新？" class="headerlink" title="34.Vue中如何做强制刷新？"></a>34.Vue中如何做强制刷新？</h3><blockquote><ul><li>location.reload() ————- 浏览器的API，强制重新请求服务器资源，类似于history模式下手动刷新页面</li><li>this.router.go(0) ————- 路由器的API，只会重新加载当前组件，不会重新请求服务器</li></ul></blockquote><h3 id="35-Vue3对于Vue2有什么不同"><a href="#35-Vue3对于Vue2有什么不同" class="headerlink" title="35.Vue3对于Vue2有什么不同?"></a>35.Vue3对于Vue2有什么不同?</h3><blockquote><p>说一两个当然容易，最重要的是要有条理地全部说出来，以下是思路：</p><p>入口文件-&gt;单个组件【Vue实例（生命周期函数-&gt;setup函数-&gt;变量（响应式数据（深浅响应式、与非响应式的转化））-&gt;组合式API（computed和watch）-&gt;自定义API-&gt;传递数据（provide/inject））-&gt;HTML模板（Fargment-&gt;Suspend-&gt;teleport）-&gt;Style样式（动画）】</p><p>详细总结链接：<a href="https://zhoujielovesinging.gitee.io/blog/2023/08/30/Vue3%E7%9B%B8%E5%AF%B9%E4%BA%8EVue2%E7%9A%84%E4%B8%8D%E5%90%8C%E7%94%A8%E6%B3%95/">https://zhoujielovesinging.gitee.io/blog/2023/08/30/Vue3%E7%9B%B8%E5%AF%B9%E4%BA%8EVue2%E7%9A%84%E4%B8%8D%E5%90%8C%E7%94%A8%E6%B3%95/</a></p></blockquote><h3 id="36-Vue的性能优化有哪些？"><a href="#36-Vue的性能优化有哪些？" class="headerlink" title="36.Vue的性能优化有哪些？"></a>36.Vue的性能优化有哪些？</h3><blockquote><p><strong>组件实例</strong></p><ul><li>按需第三方插件，比如加载UI组件模块</li><li>静态资源使用CDN加载（CDN会把静态资源缓存在各个服务器中，查找时会寻找最近的服务器寻找），例如用CDN加载图标库</li><li>不要把太多的数据放在data中，减少过多的数据劫持添加getter、setter</li><li>对象的层级不要太多，也是减少深层次过多的数据劫持</li><li>对于一些不用的变量（比如定时器），要及时清理</li><li>computed和watch要区分场景使用，比如computed的缓存性能不适合频繁修改数据的</li><li>使用防抖和节流来避免频繁触发事件</li><li>v-for给子元素绑定事件要使用事件委托，绑定一次即可</li></ul><p><strong>模板渲染</strong></p><ul><li>图片懒加载</li><li>图片多使用精灵图和SVG格式的（两者区别见上面）</li><li>区分v-if、v-show的使用场景，避免v-if频繁渲染节点</li><li>v-for要使用唯一的id并且不要和v-if一起使用（会先执行v-for先渲染再判断导致重复渲染），避免重复渲染</li><li>大数据的列表和表格要使用 虚拟列表、虚拟表格技术，可以实现看多少加载多少，翻页时再加载后面的</li></ul><p><strong>组件</strong></p><ul><li>使用异步组件（使用component组件渲染时再加载）</li><li>使用keep-alive组件</li></ul><p><strong>路由</strong></p><ul><li>使用路由懒加载（使用import和webpack代码分割）</li><li>使用动态路由</li></ul><p><strong>打包</strong></p><ul><li>减少文件体积（合并文件）</li><li>使用服务器端gzip压缩（可以使得静态文件体积减少50%-70%，可以用于webpack打包后的静态文件进一步压缩）</li></ul><p><strong>运行时</strong></p><ul><li>使用服务端渲染SSR或预渲染（第一次加载）</li><li>缓存：客户端缓存或服务端缓存 资源文件（后续加载）</li></ul><p><u>思路</u>：编程时（组件实例-&gt;HTML模板-&gt;组件级别-&gt;路由级别）-&gt;打包时-&gt;运行后</p></blockquote><h3 id="37-首屏如何优化？"><a href="#37-首屏如何优化？" class="headerlink" title="37.首屏如何优化？"></a>37.首屏如何优化？</h3><blockquote><p>由于问的是首屏，那么只需关注首屏加载用到的资源文件以及渲染内容，因此要去除一些 上一题性能优化中对于编程时提到的操作，直接关注打包后的资源以及运行的渲染即可。首屏优化分为 用户体验优化和加载速度优化。</p><ol><li><p>使用骨架图（指标不住本，仅仅提高用户体验）</p><p>骨架图是 数据还没到来时显示的页面 大致结构的样式，相比loading样式，用户体验更好</p></li><li><p>优化加载速度（从根本解决问题）</p><ul><li><p>打包</p><p>使用服务器端gzip压缩（可以使得静态文件体积减少50%-70%，可以用于webpack打包后的静态文件进一步压缩）打包后的静态文件</p></li><li><p>服务端渲染（有了SSR就不需要客户端处理js文件直接渲染）</p></li><li><p>加载js文件</p><p>静态资源使用CDN加载（CDN会把静态资源缓存在各个服务器中，查找时会寻找最近的服务器寻找），例如用CDN加载图标库</p></li><li><p>路由</p><ul><li>使用路由懒加载（使用import和webpack代码分割）</li><li>使用动态路由</li></ul></li><li><p>组件（页面加载时）</p><ul><li>非首屏组件异步加载</li><li>不重要的首屏组件延迟加载</li></ul></li><li><p>页面渲染</p><ul><li>图片懒加载</li><li>图片多使用精灵图和SVG格式的（两者区别见上面）</li><li>区分v-if、v-show的使用场景，避免v-if频繁渲染节点</li><li>v-for要使用唯一的id并且不要和v-if一起使用（会先执行v-for先渲染再判断导致重复渲染），避免重复渲染</li><li>大数据的列表和表格要使用 虚拟列表、虚拟表格技术，可以实现看多少加载多少，翻页时再加载后面的</li></ul></li></ul></li></ol><p><u>思路</u>：从打包后加载页面的视角来看</p></blockquote><h3 id="38-为什么Vue3比Vue2性能更好？"><a href="#38-为什么Vue3比Vue2性能更好？" class="headerlink" title="38.为什么Vue3比Vue2性能更好？"></a>38.为什么Vue3比Vue2性能更好？</h3><blockquote><p>将从编码、编译、打包三个方面来回答：</p><p>编码方面：</p><ul><li>主要是针对响应式处理进行了改进，由原先的Object.defineProperty变为ES6的Proxy来实现，由于Vue3中的proxy在初始化时使用了懒处理，即嵌套对象一开始指针对第一层进行响应式处理，只有到后面用到深层次的内容再处理，这样可以减少体积和提高加载速度</li></ul><p>编译方面：</p><ul><li>添加静态标记（每种标记表明更新不同内容，静态的不更新，动态的有选择地更新）、静态提升（将静态内容提升到render函数之外，在render函数里面只需对静态内容引用，避免重复处理）提升diff算法的性能</li><li>事件监听可以进行缓存（比如click函数内容的复用，不用每次点击都要绑定）</li></ul><p>打包方面：</p><ul><li>使用Tree Shaking对代码打包时去除不使用的代码，从而减小打包体积</li></ul></blockquote><h3 id="39-Vue3为什么要使用proxy（proxy比Object-defineProperty有什么优点）"><a href="#39-Vue3为什么要使用proxy（proxy比Object-defineProperty有什么优点）" class="headerlink" title="39.Vue3为什么要使用proxy（proxy比Object.defineProperty有什么优点）"></a>39.Vue3为什么要使用proxy（proxy比Object.defineProperty有什么优点）</h3><blockquote><ul><li><p>范围更广：</p><p>proxy能代理整个对象，而Object.defineProperty则只能代理某个属性，还需要递归来处理，proxy内部已经进行了递归处理</p></li><li><p>响应式操作更丰富：</p><p>Object.defineProperty只能针对数据的访问、修改响应式处理，而proxy还对删除、添加操作添加了响应式</p></li><li><p>异常处理更灵活：</p><p>proxy内部的Relect封装了try-catch，可自动捕获异常，而Object.defineProperty需要手动在外部添加</p></li><li><p>更安全：</p><p>proxy返回一个新对象，而Object.defineProperty是在原对象进行处理的，这样proxy不修改原数据结构会更加安全</p></li></ul><p><u>思路</u>：proxy对象由 外（范围）-&gt;内（操作-异常处理）-&gt;外（返回新对象）</p></blockquote><h3 id="40-说说你对组件的理解"><a href="#40-说说你对组件的理解" class="headerlink" title="40.说说你对组件的理解"></a>40.说说你对组件的理解</h3><blockquote><p>定义：组件其实是利用Vue.extend创建的一个VueComponent实例，类似于Vue的子类，拥有Vue类似的配置项</p><p>作用：可以将公共部分写在组件里面进行复用</p><p><img src="/2024/01/03/%E5%89%8D%E7%AB%AF%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%9F%BA%E7%A1%80/%E7%BB%84%E4%BB%B6%E5%AE%9E%E4%BE%8B%E4%B8%8EVue%E5%AE%9E%E4%BE%8B%E5%85%B3%E7%B3%BB.png" alt="组件实例与Vue实例关系"></p></blockquote><h3 id="41-为什么组件的data要写成函数形式不能写成对象形式？"><a href="#41-为什么组件的data要写成函数形式不能写成对象形式？" class="headerlink" title="41.为什么组件的data要写成函数形式不能写成对象形式？"></a>41.为什么组件的data要写成函数形式不能写成对象形式？</h3><blockquote><p>如果data写成对象形式，那么同一个组件在复用时，data都指向同一个地址，这样data内容一个修改了，另一个也会跟着修改，这样会造成数据混乱的情况。</p><p>而写成函数形式，每次都返回一个新的对象，这样可以保证数据的独立性，不会相互影响</p></blockquote><h3 id="42-你是如何规划项目文件的？"><a href="#42-你是如何规划项目文件的？" class="headerlink" title="42.你是如何规划项目文件的？"></a>42.你是如何规划项目文件的？</h3><blockquote><p>项目创建后大致结构已经确定，主要是针对src目录进行规划：</p><p>src</p><ul><li>components（公共组件）</li><li>views（路由组件）</li><li>utils（封装axios）</li><li>api</li><li>store</li><li>assets（图标、图片）</li><li>directives（可选，自定义指令）</li><li>styles（自定义样式）</li><li>router</li></ul><p><u>思路</u>：组件-&gt;组件实例（请求数据）-&gt;模板展示（图片、指令）-&gt;样式-&gt;路由（不同组件）</p></blockquote><h3 id="42-了解过nuxt-js框架吗？"><a href="#42-了解过nuxt-js框架吗？" class="headerlink" title="42.了解过nuxt.js框架吗？"></a>42.了解过nuxt.js框架吗？</h3><blockquote><p>它是一个基于Vue的服务端渲染框架，能够简化服务端渲染流程，最终可帮助SEO（主要目的）以及优化首屏加载时间。</p></blockquote><h3 id="43-Vue项目中如何提高SEO？"><a href="#43-Vue项目中如何提高SEO？" class="headerlink" title="43.Vue项目中如何提高SEO？"></a>43.Vue项目中如何提高SEO？</h3><blockquote><ul><li>服务端渲染（SSR）</li><li>预渲染：服务端将页面中的静态内容渲染成静态HTML页面返回给客户端，降低客户端渲染负担，但是不太适合频繁更新的页面</li></ul><p>理解：预渲染只针对静态内容，而SSR是针对所有内容，都是服务端来帮助客户端减轻压力的</p></blockquote><h3 id="44-为什么Vue2响应式属性要通过额外的API？"><a href="#44-为什么Vue2响应式属性要通过额外的API？" class="headerlink" title="44.为什么Vue2响应式属性要通过额外的API？"></a>44.为什么Vue2响应式属性要通过额外的API？</h3><blockquote><p><strong>对象</strong></p><ol><li>Object.defineProperty无法劫持新增的属性以及删除的属性</li><li>如果用Object.defineProperty遍历对象的每个属性添加响应式，效率会很低；而新增API可以手动的有选择性地添加相应是</li></ol><p><strong>数组</strong></p><ol><li>通过索引访问值和修改数组长度是无法触发响应式更新</li></ol></blockquote><h3 id="45-为什么Vue对于数组没有使用defineProperty-实现响应式？"><a href="#45-为什么Vue对于数组没有使用defineProperty-实现响应式？" class="headerlink" title="45.为什么Vue对于数组没有使用defineProperty 实现响应式？"></a>45.为什么Vue对于数组没有使用defineProperty 实现响应式？</h3><blockquote><p>如果对数组每一个元素都是用defineProperty进行数据劫持，性能会很低下，于是重写了7个方法，<strong>在方法内部调用Array原始方法之后再统一notify更新</strong></p></blockquote><h3 id="46-Vue使用了哪些设计模式？"><a href="#46-Vue使用了哪些设计模式？" class="headerlink" title="46.Vue使用了哪些设计模式？"></a>46.Vue使用了哪些设计模式？</h3><blockquote><ol><li>单例模式：vuex和vue router创建后会判断只有一个实例才会创建</li><li>观察者模式：响应式原理</li><li>发布订阅模式：$emit以及$on，还有promise原理</li><li>装饰器模式：@写在方法上面添加额外功能，一般对于防抖和节流可以封装成装饰器来使用</li><li>策略模式：对于minin混入的代码，有默认的混入策略：用引进来的替换原本的（如果重名的话）</li><li>工厂模式：根据参数生成实例，例如Vue.component(…)</li></ol><p><u>思路</u>：组件实例-&gt;引入文件-&gt;数据-&gt;事件-&gt;引入外部-&gt;整个组件</p></blockquote><h3 id="47-MVC和MVVM的区别"><a href="#47-MVC和MVVM的区别" class="headerlink" title="47.MVC和MVVM的区别"></a>47.<strong>MVC和MVVM的区别</strong></h3><blockquote><p>MVC它是传统的架构模式，一般是后端来用的。MVC是指Model、View、Controller三层，用户在VieW层请求数据，Controller负责转发用户的请求并把数据分发给Model中，最后由Model将数据再展示到View中，这是一个三角形闭环。</p><p>说到MVVM，需要说一下它的由来。</p><p>以前我们是将业务层逻辑（从Controller获取数据）还有展示逻辑（利用jquery）都嵌入在页面中，随着的项目的越来越复杂，代码会变得非常地臃肿，可维护性很差。这时就出现了MVVM架构模式。MVVM是前端的架构模式，分为Model、View、ViewModel，ViewModel实现了Model和View的双向绑定，它是没有像MVC的Controller那样有处理业务逻辑这一层的，它更专注于View层，而且Model和View之间是相互独立的，非常低耦合，Model和View并不知道它们的关系，这个关系交给ViewModel来负责，数据一到Model就会自动更新到View中。这样的模式不仅可以将前端页面和后端逻辑分开，各司其职，还可以做到自动更新，大大提高了开发效率。 </p><p>注意：Vue并没有完全遵循MVVM模式，因为Vue允许用$ref来操作view</p></blockquote><h3 id="48-Vue响应式原理中wacher是如何更新页面的（nextTick原理）？"><a href="#48-Vue响应式原理中wacher是如何更新页面的（nextTick原理）？" class="headerlink" title="48.Vue响应式原理中wacher是如何更新页面的（nextTick原理）？"></a>48.Vue响应式原理中wacher是如何更新页面的（nextTick原理）？</h3><blockquote><p>watcher它是把自己放在一个更新队列中，并且利用nextTick机制在下一次事件循环统统一针对更新对立进行更新，这样可以只进行一次DOM更新操作，避免重复DOM操作，提高了性能</p><p>nextTick机制是如何实现在下一次事件循环的tick才执行回调（在DOM更新完才执行回调）？</p><p>它是 将回调函数放入微任务队列去执行 实现的，当前主线程执行完，当前事件循环的DOM也更新完毕，这时再去执行微任务队列中的回调（注意是下一次事件循环的tick而不是整个时间循环）</p></blockquote><h3 id="49-Vue中有哪些指令？"><a href="#49-Vue中有哪些指令？" class="headerlink" title="49.Vue中有哪些指令？"></a>49.Vue中有哪些指令？</h3><blockquote><p><strong>渲染</strong></p><ul><li><p>编译阶段</p><p>v-pre ———不编译</p><p>v-cloak —–编译时显示的内容，避免页面闪动</p></li><li><p>展示阶段</p><p>v-show </p><p>v-for</p></li><li><p>展示后</p><p>v-once —–只展示一次</p></li></ul><p><strong>数据</strong></p><ul><li><p>固定HTML内容</p><p>v-text —– 只展示最终文字</p><p>v-html —- 一股脑地把HTML全部插入</p></li><li><p>data中数据</p><p>v-bind </p><p>v-model </p></li></ul><p><strong>事件</strong></p><p>v-on</p></blockquote><h3 id="50-怎样理解-Vue-的单项数据流？"><a href="#50-怎样理解-Vue-的单项数据流？" class="headerlink" title="50.怎样理解 Vue 的单项数据流？"></a>50.怎样理解 Vue 的单项数据流？</h3><blockquote><p>它指的是 数据总是从父组件传入子组件，而不允许子组件修改父组件的数据，这么做的目的是 避免子组件意外修改父组件的数据带来的问题</p><p>其中，虽然v-model可以修改，但是不推荐，开发环境也会报警告</p><p>如何处理？利用$emi触发事件来修改</p></blockquote><h3 id="51-v-if-和-v-for-为什么不建议一起使用？"><a href="#51-v-if-和-v-for-为什么不建议一起使用？" class="headerlink" title="51.v-if 和 v-for 为什么不建议一起使用？"></a>51.v-if 和 v-for 为什么不建议一起使用？</h3><blockquote><p>因为 v-for会在v-if之前解析，如果 v-if 条件不满足，那么又要销毁元素，这样就很影响性能</p><p>如何解决？</p><p>用计算属性计算 替换 v-if 判断逻辑，提前把数据筛选好即可</p></blockquote><h3 id="52-v-model原理？"><a href="#52-v-model原理？" class="headerlink" title="52.v-model原理？"></a>52.v-model原理？</h3><blockquote><p>v-model他只是v-bind和v-on的语法糖，v-bind实现了数据驱动试图，v-on实现了视图驱动数据，最终实现了双向数据绑定。</p><p>它会根据不同的元素标签使用不同的绑定的数据类型以及事件类型：</p><ul><li>text/textarea——– value值和input事件</li><li>select—————— value值和change事件</li><li>radio——————- checked值和change事件</li></ul></blockquote><h3 id="53-事件绑定原理？"><a href="#53-事件绑定原理？" class="headerlink" title="53.事件绑定原理？"></a>53.事件绑定原理？</h3><blockquote><p>可以对 双向数据绑定的原理 进行补充</p><p>需要先说明事件分类：原生事件、组件事件</p><p>原生事件是通过addEventListener方法实现的，而组件事件是通过$on实现的。</p><p>关系：如果需要在组件上使用原生事件，需要事件修饰符.native</p><p>下面说说组件事件用得到$on和$emit原理（原生事件是自带的，不好说）：$on和$emit维护了一个事件中心，使用了发布订阅者模式，$on是订阅者，在$on的时候将事件名放入事件中心，等待订阅内容，而$emit是发布者，在$emit的时候提供$on需要的事件</p></blockquote><h1 id="Echarts"><a href="#Echarts" class="headerlink" title="Echarts"></a>Echarts</h1><h3 id="1-echarts有用过吗？常用的组件有哪些？"><a href="#1-echarts有用过吗？常用的组件有哪些？" class="headerlink" title="1.echarts有用过吗？常用的组件有哪些？"></a>1.echarts有用过吗？常用的组件有哪些？</h3><blockquote><ol><li>legend（图例）</li><li>title</li><li>toolbox</li><li>yAxis</li><li>xAxis</li><li>series（name、type、data、markPoint、markLine）</li><li>toolTip</li></ol><p><u>思路</u>（折线图为例）：</p><ul><li>外框：从上往下，从左往右（图例-&gt;标题-&gt;工具栏-&gt;Y轴-&gt;X轴）</li><li>内容：画出来再对比（哪根线-&gt;类型-&gt;数据-&gt;标注-&gt;标线-&gt;提示框）</li></ul></blockquote><h1 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h1><h3 id="1-前端中产品的性能是指什么？如何衡量？"><a href="#1-前端中产品的性能是指什么？如何衡量？" class="headerlink" title="1.前端中产品的性能是指什么？如何衡量？"></a>1.前端中产品的性能是指什么？如何衡量？</h3><blockquote><p>当我们用性能去描述一个互联网产品的时候，主要看的是：</p><ul><li>首屏加载速度</li><li>用户操作流畅度（稳定性）</li><li>用户操作响应速度</li></ul><p>由于速度的快慢用个人主观感受来看因人而异，无法测量，因此业内制定了专业客观的、可测量的性能指标（如下）</p></blockquote><h3 id="2-性能优化指标有哪些？"><a href="#2-性能优化指标有哪些？" class="headerlink" title="2.性能优化指标有哪些？"></a>2.性能优化指标有哪些？</h3><blockquote><ul><li><p>首屏加载速度</p><p>FCP（页面加载到第一个元素渲染成功的时间）</p><p>LCP（页面加载到最大的元素渲染成功的时间）</p></li><li><p>用户操作流畅度</p><p>CLS（累计布局偏移）：如果应用不稳定，页面布局是会慢慢偏移的</p></li><li><p>用户操作响应速度</p><p>FID（First Input delay）：第一次交互并成功相应的时间</p></li></ul></blockquote><h3 id="3-性能优化分析工具有哪些？"><a href="#3-性能优化分析工具有哪些？" class="headerlink" title="3.性能优化分析工具有哪些？"></a>3.性能优化分析工具有哪些？</h3><blockquote><p>最主流：lighthouse（谷歌插件，要有外网权限）</p><p>webVitals：Edge可以用，可以直接挂在网页上，网页处理完毕，直接打开看所有参数，很方便</p></blockquote><h3 id="4-虚拟表格技术如何实现？"><a href="#4-虚拟表格技术如何实现？" class="headerlink" title="4.虚拟表格技术如何实现？"></a>4.虚拟表格技术如何实现？</h3><blockquote><p>就是通过在有限的窗口自定义想要渲染的item条数，然后在滚动过程中通过计算来替换视野中的数据</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">相对定位</span>;<span class="hljs-attr">overflow:auto</span> <span class="hljs-attr">:style</span>=<span class="hljs-string">&#x27;height:$&#123;想要展示的个数*一个item高度&#125;&#x27;</span>&gt;</span>// 可视区<br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">:style</span>=<span class="hljs-string">&#x27;height:$&#123;实际个数*一个item高度&#125;&#x27;</span>&gt;</span>// 占位，为了显现出滚动条<br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">绝对定位</span> <span class="hljs-attr">:style</span>=<span class="hljs-string">&#x27;top:$&#123;第一个元素离top偏移量&#125;&#x27;</span>&gt;</span>// 渲染区域<br>            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> &gt;</span>// 每一行<br>                循环展示<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>下面是滚动时的事件，替换元素：计算第一个元素新下标和偏移量(滚动时第一个元素有偏移量)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">strollEvent</span> = (<span class="hljs-params">event</span>)=&gt;&#123;<br>    <span class="hljs-comment">// 利用节流节省性能</span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-title function_">nowTime</span>() - lastTime)&#123;<br>         <span class="hljs-keyword">const</span> &#123;strollTop&#125; = event.<span class="hljs-property">target</span><br>         第一个元素新下标 = strollTop/一个item高度<br>         第一个元素偏移量 = strollTop<br>         更新lastTime<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>渲染个数少、节流 =&gt;双重提高性能</p></blockquote><h1 id="移动端"><a href="#移动端" class="headerlink" title="移动端"></a>移动端</h1><h3 id="1-什么是uni-app？"><a href="#1-什么是uni-app？" class="headerlink" title="1.什么是uni-app？"></a>1.什么是uni-app？</h3><blockquote><p>uni-app（unify）是一个基于Vue.js的跨平台开发框架（支持Web端、移动端（IOS、android）、小程序），它提供了一套统一的代码开发和发布流程，开发者只需开发一份代码，同时将应用发布到多个平台，大大提高了开发效率。</p></blockquote><h3 id="2-uni-app有没有做过分包？"><a href="#2-uni-app有没有做过分包？" class="headerlink" title="2.uni-app有没有做过分包？"></a>2.uni-app有没有做过分包？</h3><blockquote><p>uni-app分包和webpack的按照模块来代码分割 概念是类似的。</p><p>举例子：小程序会默认下载主包并启动页面，只有加载到分包的内容时才会下载对应的分包并加载</p><p>好处：提高下载速度和页面加载速度</p><p>如何分包：</p><p>subPackages里面配置 分包路径以及分包页面</p></blockquote><h3 id="3-如何利用Cordova对Vue项目进行打包？"><a href="#3-如何利用Cordova对Vue项目进行打包？" class="headerlink" title="3.如何利用Cordova对Vue项目进行打包？"></a>3.如何利用Cordova对Vue项目进行打包？</h3><blockquote><p>安装Cordova-&gt;创建一个Cordova项目-&gt;Cordova添加平台-&gt;将Vue在build之后的静态文件放入www文件夹-&gt;cordova run android</p></blockquote><h3 id="3-原生App、WebApp、混合App、h5有什么区别？"><a href="#3-原生App、WebApp、混合App、h5有什么区别？" class="headerlink" title="3.原生App、WebApp、混合App、h5有什么区别？"></a>3.原生App、WebApp、混合App、h5有什么区别？</h3><blockquote><p><strong>原生App：</strong></p><p>​      所有的api还有UI一整套都是用的android/ios官方提供的</p><p>​      优点：系统稳定，流畅度高</p><p>​      缺点：无法跨平台</p><p><strong>WebApp：</strong></p><p>​      用的是Web应用开发的技术（html、css、js）开发的移动端应用</p><p>​      优点：可跨平台</p><p>​      缺点：无法调用原生App的接口</p><p><strong>混合App（uniapp、cordova）：</strong></p><p>​      综合了原生App和混合App优点，一部分用WebApp的技术，一部分用原生App的接口</p><p><strong>h5</strong></p><p>​      单纯用html5技术开发的应用，更注重动画和交互效果，web和app都可以运行</p></blockquote><h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><h3 id="1-git从拉取代码到推送代码的流程是什么？"><a href="#1-git从拉取代码到推送代码的流程是什么？" class="headerlink" title="1.git从拉取代码到推送代码的流程是什么？"></a>1.git从拉取代码到推送代码的流程是什么？</h3><blockquote><p>git clone 远程仓库地址</p><p>-&gt;…修改内容</p><p>-&gt;git add .（添加到本地缓存区）</p><p>-&gt;git commit -m ‘feature/内容’（添加到本地仓库）</p><p>-&gt;git pull </p><p>-&gt;…处理可能的冲突</p><p>-&gt;git push </p><hr><p>以上是个人项目或小型项目，如果是大型项目，会要建立自己的分支，有效避免pull、commit的使用错误（相当于用merge来代替pull）：</p><p>git clone 远程仓库地址</p><p>-&gt;git checkout -b ‘自己的分支’（创建并切换到自己的分支）</p><p>-&gt;add、commit</p><p>-&gt;替换到master再pull一下保证只最新的</p><p>-&gt;再切换到自己的分支</p><p>-&gt;git merge develop（将自己分支的内容合并到develop分支上）</p></blockquote><h3 id="2-会什么要有暂存区？"><a href="#2-会什么要有暂存区？" class="headerlink" title="2.会什么要有暂存区？"></a>2.会什么要有暂存区？</h3><blockquote><p>因为暂存区可以帮助你选择性提交，一次提交只包含一个功能，这样可以让提交历史清晰，便于追踪问题。如果你要做一个功能B，但是在做的过程中发现还有bugA，此时可以把修改bugA先提交一版，然后再提交一版功能B</p></blockquote><h3 id="3-为什么是commit-gt-pull-gt-push，而不是pull-gt-commit-gt-push？"><a href="#3-为什么是commit-gt-pull-gt-push，而不是pull-gt-commit-gt-push？" class="headerlink" title="3.为什么是commit-&gt;pull-&gt;push，而不是pull-&gt;commit-&gt;push？"></a>3.为什么是commit-&gt;pull-&gt;push，而不是pull-&gt;commit-&gt;push？</h3><blockquote><p>因为可能 你和别人共同会修改同一个功能，你可能修改好了忘记commit直接pull，会把别人修改的覆盖你的，因为你不commit那么git是不知道你修改了；而先commit再pull，这是如果有冲突，可以和别人商量要哪个，再push</p></blockquote><h3 id="4-A合并B和B合并A，有什么区别？"><a href="#4-A合并B和B合并A，有什么区别？" class="headerlink" title="4.A合并B和B合并A，有什么区别？"></a>4.A合并B和B合并A，有什么区别？</h3><blockquote><p>A merge B是将A的内容合并到B中，B merge A是将B的内容合并到A中。</p><p>A merge B后会显示merge branch A into B</p></blockquote><h3 id="5-功能写错了并push了，如何回退代码？"><a href="#5-功能写错了并push了，如何回退代码？" class="headerlink" title="5.功能写错了并push了，如何回退代码？"></a>5.功能写错了并push了，如何回退代码？</h3><blockquote><p>一般来说需要回退到 commit之前，然后重新修改，再次commit。</p><ul><li>git reset –soft HEAD^ ————– 回退到上一次commit之前</li><li>git reset –soft commitId ———- 根据commitId ，回退到具体某次提交</li></ul></blockquote><h1 id="HR"><a href="#HR" class="headerlink" title="HR"></a>HR</h1><h3 id="1-你跳槽（离职）的原因是什么？"><a href="#1-你跳槽（离职）的原因是什么？" class="headerlink" title="1.你跳槽（离职）的原因是什么？"></a>1.你跳槽（离职）的原因是什么？</h3><blockquote><p><strong>原则：</strong>不要说上家的不好，说一些 不可抗力、个人发展瓶颈 体现上进心的原因<u>（真诚点不要套路）</u>，最后注意要感恩上一家公司的价值</p><p><strong>踩雷：</strong></p><p>同事相处不和谐 ————–&gt; 沟通能力不行</p><p>领导人品不好 —————–&gt; 不尊重领导</p><p><strong>方向：</strong> <strong>个人发展 技术提升</strong> 家庭问题</p><p><strong>回答</strong>：</p><p>主要是有两方面原因：</p><p>一方面，前公司确实经营不善，发展前景不太好，因为 公司内部有消息说 公司有面临倒闭的风险，那我肯定要早做打算吧，而且我之前刚毕业的时候本来就是想来 南京/苏州 这样的城市来学习实践的，想来见见世面；另一方面，我们公司做的项目，有很多是用angular框架做的，只有少部分使用Vue框架的，而我不太喜欢用这个框架，因为 我个人觉得这个框架 有点庞大，应用加载速度比较慢，影响开发效率，还有一些用法比如 双向绑定用法复杂，我喜欢用Vue框架开发，更简洁，而且也是主流嘛</p></blockquote><h3 id="2-工作到现在碰到的最难的问题是什么？怎么解决的？"><a href="#2-工作到现在碰到的最难的问题是什么？怎么解决的？" class="headerlink" title="2.工作到现在碰到的最难的问题是什么？怎么解决的？"></a>2.工作到现在碰到的最难的问题是什么？怎么解决的？</h3><blockquote><p><strong>原则：</strong>有一定难度的，并且不常见的</p><p><strong>踩雷：</strong></p><p>没有问题 —————— 都没做过什么事情，经历少</p><p>数据请求、页面渲染、路由请求等常见的应该会的 ————————–技术能力差</p><p><strong>思路：</strong></p><ol><li>一开始自行到处查资料去寻求解决办法</li><li>后来实在解决不了的请教同事、组长</li></ol><p><strong>范本：</strong></p><p>“在我的工作经历中，我遇到的最具挑战性的问题是在项目中遇到的性能优化难题。项目中页面加载速度较慢，影响用户体验。为了解决这个问题，我进行了深入的优化工作。首先，我利用开发者工具和性能分析工具对页面进行了详细的性能检测和分析，找到了导致页面加载缓慢的具体原因。然后，我针对性地优化了代码结构，减少了不必要的资源加载和提升了代码执行效率。同时，我还实现了懒加载、缓存和压缩等技术手段，进一步提升了页面加载速度和性能表现。经过持续的努力和测试验证，最终成功地解决了性能优化问题，提升了页面的加载速度，优化了用户体验。这个经历让我深刻意识到在面对困难时，需要耐心、积极主动地寻找解决方案，并不断学习和尝试新的技术，以提升自己的技能水平和解决问题的能力。”</p><p>————-这样的回答能够突出问题的难度和挑战性，同时展现了你对问题的认真分析、积极解决的态度和努力付出。这种回答符合面试官希望听到的体现困难、解决积极的标准要求，有助于展现你作为前端工程师的能力和素质。</p></blockquote><h3 id="3-你的优缺点是什么？"><a href="#3-你的优缺点是什么？" class="headerlink" title="3.你的优缺点是什么？"></a>3.你的优缺点是什么？</h3><blockquote><p>我的<strong>缺点</strong>是 我之前胆子比较小（缺点认知），有点怯场，不太敢在大家面前表达自己的观点，后来 我有私下去问资历比较老的同事咨询建议以及看了一些关于表达的一些书籍（非暴力沟通，感受并合理表达自己的需求请求），慢慢建立了自信，后来为了实践锻炼，我能够在百来人号面前进行主持。———— 以前的缺点</p><p>项目比较急的时候，有点急于求成，乱了自己的节奏，现在已经在慢慢改正，告知自己 急没有用，心静下来事情就解决了</p><p>我的优点是 我觉得我对于Vue框架的应用比较熟练，对原理也有一定了解，对于开发的工作任务的跟进是可以保证的，另外就是我的表达能力 还可以，喜欢与人交流，对于一些问题的处理能够和后端进行及时的沟通</p></blockquote><h3 id="4-如何协同工作？"><a href="#4-如何协同工作？" class="headerlink" title="4.如何协同工作？"></a>4.如何协同工作？</h3><blockquote><p>开发前开会议</p><p>利用一些工具（git）</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>面试题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端综合</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue中的性能优化</title>
    <link href="/2023/12/18/Vue%E4%B8%AD%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <url>/2023/12/18/Vue%E4%B8%AD%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<ol><li><p><strong>组件实例</strong></p><ul><li><p>按需第三方插件，比如加载UI组件模块</p></li><li><p>静态资源使用CDN加载（CDN会把静态资源缓存在各个服务器中，查找时会寻找最近的服务器寻找），例如用CDN加载图标库</p></li><li><p>不要把太多的数据放在data中，减少过多的数据劫持添加getter、setter</p><p><u>为什么？</u></p><p>因为 在实例化时，Vue会对data中的属性用object.defineproperty进行数据劫持使里面的数据都具有响应式的能力，如果把非响应式的数据放入data中，当数据变化时会给模版带俩不必要的重排和重绘，从而降低渲染性能。</p><p><u>那放在哪？</u></p><p>可以放到vm实例身上，并且还可以进一步用Object.freeze()冻结数据，避免多余的数据的处理</p><p><u>Object.freeze()有什么好处？</u></p><ul><li>数据有稳定性：它不能被增、删、改，可以避免程序员意外修改数据带来的错误</li><li>数据有安全性：可以避免不可信源来修改数据</li><li>提高数据的可维护性和可拓展性：使用这个方法可以让程序员知道哪些数据不需要修改，缩小了可维护、拓展的范围</li></ul></li><li><p>对象的层级不要太多，也是减少深层次过多的数据劫持</p></li><li><p>对于一些不用的变量（比如定时器），要及时清理</p></li><li><p>computed和watch要区分场景使用，比如computed的缓存性能不适合频繁修改数据的</p></li><li><p>使用防抖和节流来避免频繁触发事件</p></li><li><p>v-for给子元素绑定事件要使用事件委托，绑定一次即可</p></li></ul><p><strong>模板渲染</strong></p><ul><li>图片懒加载</li><li>图片多使用精灵图和SVG格式的（两者区别见上面）</li><li>区分v-if、v-show的使用场景，避免v-if频繁渲染节点</li><li>v-for要使用唯一的id并且不要和v-if一起使用（会先执行v-for先渲染再判断导致重复渲染），避免重复渲染</li><li>大数据的列表和表格要使用 虚拟列表、虚拟表格技术，可以实现看多少加载多少，翻页时再加载后面的</li></ul><p><strong>组件</strong></p><ul><li>使用异步组件（使用component组件渲染时再加载）</li><li>使用keep-alive组件</li></ul><p><strong>路由</strong></p><ul><li>使用路由懒加载（使用import和webpack代码分割）</li><li>使用动态路由</li></ul><p><strong>打包</strong></p><ul><li>减少文件体积（合并文件）</li><li>使用服务器端gzip压缩（可以使得静态文件体积减少50%-70%，可以用于webpack打包后的静态文件进一步压缩）</li></ul><p><strong>运行时</strong></p><ul><li>使用服务端渲染SSR或预渲染（第一次加载）</li><li>缓存：客户端缓存或服务端缓存 资源文件（后续加载）</li></ul><p><u>思路</u>：编程时（组件实例-&gt;HTML模板-&gt;组件级别-&gt;路由级别）-&gt;打包时-&gt;运行后</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>前端框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue中路由钩子函数</title>
    <link href="/2023/12/15/Vue%E4%B8%AD%E8%B7%AF%E7%94%B1%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0/"/>
    <url>/2023/12/15/Vue%E4%B8%AD%E8%B7%AF%E7%94%B1%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p><strong>分类</strong></p><p>先说下所有的钩子函数：全局守卫、路由独享路由、组件守卫。</p><p><strong>完整的导航解析流程</strong></p><ul><li>导航被触发，比如router.push()、router.replace()</li><li>调用失活组件的beforeRouteLeave守卫</li><li>调用全局前置守卫beforeEach，在这可以添加一些登录验证，这是验证是全局的，也就是它针对所有路由</li><li>调用重用组件的beforeRouteUpdate守卫，这个守卫专门在路由 的组件复用时调用，比如两个路由地址不同，但是对应组件是一样的，如果有路由的组件复用，调用完该守卫更新完毕就不会调用后面的守卫了</li><li>调用路由独享的守卫beforeEnter守卫，路由独享的守卫就这一个，专门为跳转当前路由之前做一些逻辑，比如也可以做登录验证，只是这个验证只针对当前路由</li><li>下面到了异步组件（使用import关键字的懒加载组件）的解析阶段</li><li>调用激活组件的beforeRouteEnter守卫，在该守卫中还没有实例化，无法使用this，可准备好异步数据给激活的组件</li><li>调用全局解析守卫beforeResolve，该守卫是解析的最后一步，也可以获取异步数据，只是这个数据一般是可能其他组件也要使用，比如用户的信息放入仓库</li><li>导航被确认。为什么要确认一下？表示要进入 下面路由的信息已经准备好。</li><li>调用全局后置守卫afterEach，目标路由已经跳转结束，可处理一些收尾工作，比如跳转到目标页面的对应位置</li><li>目标组件DOM渲染</li><li>调用全局前置守卫beforeRouteEnter的回调函数next()，调用此函数时已经实例化，并把实例作为参数传递给组件路由的下一阶段使用（意思就是说组件已经渲染好了进入该组件的钩子也该结束了）</li></ul>]]></content>
    
    
    <categories>
      
      <category>前端框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue中整个初始化过程在做什么（解析、编译、渲染模板）</title>
    <link href="/2023/12/15/Vue%E4%B8%AD%E6%95%B4%E4%B8%AA%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B%E5%9C%A8%E5%81%9A%E4%BB%80%E4%B9%88%EF%BC%88%E8%A7%A3%E6%9E%90%E3%80%81%E7%BC%96%E8%AF%91%E3%80%81%E6%B8%B2%E6%9F%93%E6%A8%A1%E6%9D%BF%EF%BC%89/"/>
    <url>/2023/12/15/Vue%E4%B8%AD%E6%95%B4%E4%B8%AA%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B%E5%9C%A8%E5%81%9A%E4%BB%80%E4%B9%88%EF%BC%88%E8%A7%A3%E6%9E%90%E3%80%81%E7%BC%96%E8%AF%91%E3%80%81%E6%B8%B2%E6%9F%93%E6%A8%A1%E6%9D%BF%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是Vue的初始化？"><a href="#什么是Vue的初始化？" class="headerlink" title="什么是Vue的初始化？"></a><strong>什么是Vue的初始化？</strong></h2><p>初始化可以算是从Vue实例化到页面初次渲染后的过程，大致可以分为<strong>解析-&gt;编译-&gt;渲染模板</strong>这三个过程。</p><h3 id="解析阶段"><a href="#解析阶段" class="headerlink" title="解析阶段"></a><strong>解析阶段</strong></h3><p>Vue解析器开始去<strong>解析模板字符串</strong>，比如插值语法、指令等内容。接着，将解析后的内容<strong>生成抽象语法树</strong>（abstract syntax tree-AST），这是一个方便分析和处理数据的数据结构，它描述了各个元素节点的属性以及它们之间的关系。同时，在生成AST的同时，会进行<strong>静态标记</strong>，即标记哪些节点是静态的，这样在后续的渲染过程中会跳过这些节点，来提高渲染性能。</p><h3 id="编译阶段"><a href="#编译阶段" class="headerlink" title="编译阶段"></a>编译阶段</h3><p>在生成好了AST之后，Vue会<strong>遍历AST</strong>各个节点，来<strong>转换成渲染函数</strong>（render），它包含了最终的渲染逻辑，比如指令的代码指令（比如v-if转换成三元表达式）。</p><h3 id="渲染模板阶段"><a href="#渲染模板阶段" class="headerlink" title="渲染模板阶段"></a>渲染模板阶段</h3><p>渲染函数准备好了，此阶段就去<strong>执行这个渲染函数</strong>，此时它将数据映射到DOM元素上，实现了视图的渲染，初始<strong>虚拟DOM</strong>就此生成，由于是第一次渲染不涉及<strong>diff算法</strong>的比对，因此直接将虚拟DOM的内容patch到<strong>真实DOM</strong>中，由此完成了渲染。</p><h2 id="有许多面试题都涉及初始化的过程"><a href="#有许多面试题都涉及初始化的过程" class="headerlink" title="有许多面试题都涉及初始化的过程"></a>有许多面试题都涉及初始化的过程</h2><h3 id="请说说编译原理"><a href="#请说说编译原理" class="headerlink" title="请说说编译原理"></a>请说说编译原理</h3><p>直接回答<strong>解析阶段+编译阶段，</strong>因为严格上来说，编译阶段是包含解析阶段的，因为解析是为了方便编译的，而生成render函数才是重点。</p><h3 id="什么是自定义指令？请说说原理"><a href="#什么是自定义指令？请说说原理" class="headerlink" title="什么是自定义指令？请说说原理"></a>什么是自定义指令？请说说原理</h3><p>它本质上是装饰器，是Vue对HTML元素的扩展，给HTML添加自定义功能。</p><p>它包含如下几个生命周期钩子：</p><ul><li>bind：只调用一次，在指令绑定的时候执行，通常在此阶段初始化指令的效果。</li><li>inserted：被绑定元素插入其父元素时执行，通常在此阶段添加指令想要的事件。</li><li>update：被绑定元素所在的模板更新时调用，且无论绑定值是否变化都会调用。什么是绑定值？即当前自定义指令执行的条件。</li><li>componentUpdated：被绑定元素所在的模板完成一次更新周期时调用。</li><li>unbind：只调用一次，解绑时调用。什么时候会解绑？组件销毁、v-if条件不满足等。</li></ul><p>原理：</p><ol><li><p>解析指令</p><p>在解析阶段解析指令，并把所有解析的指令保存在directives数组中，这个数组包含指令的各个信息。</p></li><li><p>生成指令代码</p><p>在编译阶段，根据directives数组中的信息并调用genDirectives函数来生成指令代码，这个指令代码其实就是render函数的一部分。</p></li><li><p>注册生命周期钩子</p><p>在编译阶段，将上面介绍的所有钩子注册到一个叫cbs（callbacks）对象中，方便管理</p></li><li><p>执行生命周期钩子</p><p>在渲染模板阶段，模板开始渲染，指令代码被转换成模板上指令对应的内容，同时也开始执行cbs中的生命周期钩子。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>前端框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue中的diff算法以及虚拟DOM优缺点</title>
    <link href="/2023/12/11/Vue%E4%B8%AD%E7%9A%84diff%E7%AE%97%E6%B3%95/"/>
    <url>/2023/12/11/Vue%E4%B8%AD%E7%9A%84diff%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h3 id="什么是diff算法？"><a href="#什么是diff算法？" class="headerlink" title="什么是diff算法？"></a><strong>什么是diff算法？</strong></h3><p><strong>1、先说下diff算法它的简介以及作用：</strong></p><p>它是通过比较新旧DOM树的差异来减少更新的次数，最终提高渲染的性能的一种算法。</p><p><strong>2、它的实现遵循两个原则：</strong></p><ol><li>在比较差异时肯定要遍历旧DOM树，它用的是深度优先遍历，为什么？因为可以更快地把当前节点树给遍历完，不需要像广度优先遍历那样在同层来回切换节点，节省了时间和空间（内存）</li><li>使用双端比较策略来减少遍历的次数</li></ol><p><strong>3、下面说说双端策略的具体实现：</strong></p><p>首先用两个数组存放新旧节点树的节点，真实DOM里面的节点和旧节点树内容一致，新旧节点数组各有头尾两个指针。</p><p>接着，使用四种比较策略：分别是</p><ul><li>旧头与新头</li><li>旧尾与新尾</li><li>旧头与新尾</li><li>旧尾与新头</li></ul><p>在比较时，一旦发现相同的节点，新旧节点的头尾指针会向中间靠拢，此时还会再确认旧节点的位置是否与新节点的一致，如果一致保持不动，否则在真实DOM中移动到新节点对应的位置，这是移动操作；</p><p>如果四种比较策略未找到相同节点，则会在旧节点数组头尾指针的区间内遍历，能找到便还是和刚刚一样移动，唯一的不同就是要把遍历到的节点给置空，为什么？后面会讲。</p><p>如果遍历后也没找到，那么就把这个节点根据新节点数组相应位置插入到真实DOM中，这个是插入操作；</p><p>当新节点数组的头指针大于尾指针时，比较结束，此时会在旧节点树的头尾指针区间遍历一下 看看是否有新节点数组不要的节点，即新节点树没有的节点，没有的就删除真实DOM中相应的节点，这是删除操作。前面有找到的节点置空也是为了减少这个环节遍历的比较次数，提高了性能，这样一来，最终保证了真实DOM和新节点数组的内容一致。</p><p><img src="/2023/12/11/Vue%E4%B8%AD%E7%9A%84diff%E7%AE%97%E6%B3%95/diff.png" alt="双端策略"></p><p><strong>有位大佬把这个过程做成了一个动画，可帮助理解：<a href="https://wanglin2.github.io/VNode_visualization_demo/">https://wanglin2.github.io/VNode_visualization_demo/</a></strong></p><p>有一个问题：如何判断是同一个节点？</p><p>判断当前节点的标签tag和key是否一致，并且这个key要保证唯一性，否则在比较子节点时才会发现不是一个节点，又要重绘和重排（也叫回流），性能低下。</p><p>什么是重绘和回流？</p><p>重绘是指对重新绘制元素的外观，比如样式，性能损耗少，而重排涉及到整个布局的变动，性能损耗大，例如元素的大小和位置，一般来说先进行重排，确定布局了，再重绘，确定外观。</p><p><strong>3、说到key的注意点，顺便说下diff算法的不足</strong></p><ol><li>key如果不唯一会出现胡乱的就地复用，带来多余的重新渲染</li><li>如果遍历的DOM数层级太多，性能也不高</li></ol><h3 id="虚拟DOM优缺点？"><a href="#虚拟DOM优缺点？" class="headerlink" title="虚拟DOM优缺点？"></a><strong>虚拟DOM优缺点？</strong></h3><p><strong>优点：</strong></p><ol><li>跨平台：不依赖于任何平台或浏览器API</li><li>提高渲染性能</li></ol><p><strong>缺点：</strong></p><ol><li>首次渲染页面时，由于多了一层虚拟DOM计算，要慢一些</li></ol>]]></content>
    
    
    <categories>
      
      <category>前端框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue中双向绑定和响应式的关系</title>
    <link href="/2023/12/09/Vue%E4%B8%AD%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E5%92%8C%E5%93%8D%E5%BA%94%E5%BC%8F%E7%9A%84%E5%85%B3%E7%B3%BB/"/>
    <url>/2023/12/09/Vue%E4%B8%AD%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E5%92%8C%E5%93%8D%E5%BA%94%E5%BC%8F%E7%9A%84%E5%85%B3%E7%B3%BB/</url>
    
    <content type="html"><![CDATA[<h3 id="什么是双向绑定？"><a href="#什么是双向绑定？" class="headerlink" title="什么是双向绑定？"></a><strong>什么是双向绑定？</strong></h3><p>当我们用javascript更改model数据时，view会更新，然后用户更新view时，model也会更新。</p><h3 id="双向绑定的原理？"><a href="#双向绑定的原理？" class="headerlink" title="双向绑定的原理？"></a><strong>双向绑定的原理？</strong></h3><p><strong>1、先说一下双向绑定的组成部分：</strong></p><p>它包含view、model、view model三个部分，其中最重要的就是view model，使它实现的view和model的关联，双向绑定的原理最主要的就是view model的原理。</p><p>那view model它又包含两个部分，编译器和监听器，编译器实现view的变化影响model的变化，而model的变化影响view的变化是需要 【监听器+编译器】 一起实现的，后者其实就是指的是响应式。</p><p><strong>2、下面说响应式是怎么实现的（要用到监听器和编译器）：</strong></p><p>一开始该组件的的vue实例在初始化时对data数据进行响应式处理，这个过程发生在监听器中，在defineReactive中的Object.defineproperty进行数据劫持时会为每一个data中的属性创建一个Dep实例（订阅器），这个是依赖管理器，依赖是什么？指的是该数据相关的所有数据比如computed计算属性、监听器watch等，为什么要收集？因为要知道哪些数据后面可能要更新。</p><p>然后在编译器里，会开始寻找模版上的动态数据，比如指令、插值语法什么的，并初始化视图，一旦发现模版上有使用data中的动态数据，此时就会调用数据劫持中的getter函数，这时Dep就会开始收集依赖，同时为每一个依赖创建watcher，它是订阅者，来订阅Dep啥时候通知它数据变化了，它会为依赖绑定一个更新函数，为后续的更新做准备。一旦数据发生变化了，就会触发数据劫持的getter函数，此时Dep就会通知相应的watcher叫它执行相应的更新函数来实现响应式。watcher是怎么更新的，更新的策略是什么？一般来说，watcher更新是异步的，它会主动要求调度者scheduler将自己放到一个执行队列中，再下一个事件循环统一进行更新。这么做有以下好处：</p><ol><li>保证了正确的执行顺序，可以避免执行顺序错乱的问题</li><li>避免了频繁更新带来的性能问题</li></ol><p><strong>3、上面只是说了响应式的原理，下面说说编译器又如何让view的变化来影响model的：</strong></p><p>主要是通过在编译时对于使用到的事件的处理，通过事件可以让用户的操作影响到model中的数据，然后再通过上面的响应式，这就实现了双向绑定。</p><p><img src="/2023/12/09/Vue%E4%B8%AD%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E5%92%8C%E5%93%8D%E5%BA%94%E5%BC%8F%E7%9A%84%E5%85%B3%E7%B3%BB/MVVM.png" alt="MVVM原理图"></p>]]></content>
    
    
    <categories>
      
      <category>前端框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ionic项目中碰到的问题合集</title>
    <link href="/2023/11/22/Ionic%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%A2%B0%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E5%90%88%E9%9B%86/"/>
    <url>/2023/11/22/Ionic%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%A2%B0%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E5%90%88%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<h2 id="打包指令"><a href="#打包指令" class="headerlink" title="打包指令"></a><strong>打包指令</strong></h2><p>npm i cordova（坑：不安装导致一直打包失败）</p><p>ionic cordova platform add android@版本号  添加安卓平台</p><p>ionic cordova platform remove android  移除安卓平台</p><p>ionic cordova build android    打包指令</p><p>ionic cordova build android –prod –release <strong>未签名版</strong></p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a><strong>问题</strong></h2><h3 id="cordova插件使用"><a href="#cordova插件使用" class="headerlink" title="cordova插件使用"></a>cordova插件使用</h3><p>​    插件使用前先注入app.moudle.ts中 在provide中声明</p><h4 id="退出插件"><a href="#退出插件" class="headerlink" title="退出插件"></a>退出插件</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">cordova plugin add cordova-plugin-app-<span class="hljs-keyword">exit</span><br>npm i cordova-plugin-app-<span class="hljs-keyword">exit</span><br>navigator[<span class="hljs-string">&#x27;app&#x27;</span>].exitApp();<br></code></pre></td></tr></table></figure><h4 id="扫码插件"><a href="#扫码插件" class="headerlink" title="扫码插件"></a>扫码插件</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs typescript">ionic cordova plugin add cordova-plugin-cszbar<br>npm install <span class="hljs-meta">@ionic</span>-native/zbar<br><br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">ZBar</span>, <span class="hljs-title class_">ZBarOptions</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@ionic-native/zbar/ngx&#x27;</span>;<br><br><span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> zbar: ZBar</span>) &#123; &#125;<br><br>...<br><br><span class="hljs-keyword">let</span> <span class="hljs-attr">options</span>: <span class="hljs-title class_">ZBarOptions</span> = &#123;<br>      <span class="hljs-attr">flash</span>: <span class="hljs-string">&#x27;off&#x27;</span>,<br>      <span class="hljs-attr">drawSight</span>: <span class="hljs-literal">false</span><br>    &#125;<br><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">zbar</span>.<span class="hljs-title function_">scan</span>(options)<br>   .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> &#123;<span class="hljs-comment">//扫描结果</span><br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result); <span class="hljs-comment">// Scanned code</span><br>   &#125;)<br>   .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(error); <span class="hljs-comment">// Error message</span><br>   &#125;);<br></code></pre></td></tr></table></figure><h4 id="键盘组件"><a href="#键盘组件" class="headerlink" title="键盘组件"></a>键盘组件</h4><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs oxygene">ionic cordova plugin <span class="hljs-keyword">add</span> cordova-plugin-ionic-keyboard<br>npm install @ionic-native/keyboard<br><br>import <span class="hljs-comment">&#123; Keyboard &#125;</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@ionic-native/keyboard/ngx&#x27;</span><span class="hljs-punctuation">;</span><br><br><span class="hljs-keyword">constructor</span><span class="hljs-params">(<span class="hljs-keyword">private</span> keyboard: Keyboard)</span> <span class="hljs-comment">&#123; &#125;</span><br><br>...<br><br><span class="hljs-title function_">this</span>.<span class="hljs-title function_">keyboard</span>.<span class="hljs-title function_">show</span><span class="hljs-params">()</span>;<br><br>this.keyboard.hide()<span class="hljs-punctuation">;</span><br></code></pre></td></tr></table></figure><h4 id="gradle的坑"><a href="#gradle的坑" class="headerlink" title="gradle的坑"></a>gradle的坑</h4><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">依賴下載failed<br><br>將C:\Users\K<span class="hljs-number">19122897</span>.WKSCN\.gradle下的gradle.properties文檔的後面四行注釋<br></code></pre></td></tr></table></figure><h4 id="导航栏不显示"><a href="#导航栏不显示" class="headerlink" title="导航栏不显示"></a>导航栏不显示</h4><p>aap.component.ts中添加如下代碼</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ionic">initializeApp() &#123;<br> this.platform.ready().then(() =&gt; &#123;<br>  this.statusBar.styleDefault();<br>  //顯示狀態欄<br>  if (this.platform.is(&#x27;android&#x27;)) &#123;<br>  this.statusBar.overlaysWebView(false);<br>this.statusBar.backgroundColorByHexString(&#x27;#616161&#x27;);<br> &#125;<br>  this.splashScreen.hide(<br> &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="ionic事件监听"><a href="#ionic事件监听" class="headerlink" title="ionic事件监听"></a>ionic事件监听</h3><h4 id="返回键监听"><a href="#返回键监听" class="headerlink" title="返回键监听"></a>返回键监听</h4><p><a href="https://ionicframework.com/docs/developing/hardware-back-button">https://ionicframework.com/docs/developing/hardware-back-button</a></p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs delphi">import <span class="hljs-comment">&#123; Platform &#125;</span> from <span class="hljs-string">&#x27;@ionic/angular&#x27;</span>;<br><br>...<br><br><span class="hljs-function"><span class="hljs-keyword">constructor</span><span class="hljs-params">(<span class="hljs-keyword">private</span> <span class="hljs-keyword">platform</span>: <span class="hljs-keyword">Platform</span>)</span> <span class="hljs-comment">&#123;</span></span><br><span class="hljs-comment"><span class="hljs-function">  this.platform.backButton.subscribeWithPriority(5, () =&gt; &#123;</span></span><br><span class="hljs-comment"><span class="hljs-function">    console.log(&#x27;Another handler was called!&#x27;);</span></span><br><span class="hljs-comment"><span class="hljs-function">  &#125;</span>);</span><br><br>  this.<span class="hljs-keyword">platform</span>.backButton.subscribeWithPriority(<span class="hljs-number">10</span>, (processNextHandler) =&gt; <span class="hljs-comment">&#123;</span><br><span class="hljs-comment">    console.log(&#x27;Handler was called!&#x27;);</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    processNextHandler();</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">  &#125;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Ionic5-Angular中使用EventEmitter事件驱动实现不同页面通讯"><a href="#Ionic5-Angular中使用EventEmitter事件驱动实现不同页面通讯" class="headerlink" title="Ionic5 Angular中使用EventEmitter事件驱动实现不同页面通讯"></a>Ionic5 Angular中使用EventEmitter事件驱动实现不同页面通讯</h4><p><a href="http://www.ionic.wang/article-index-id-204.html">http://www.ionic.wang/article-index-id-204.html</a></p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">npm install <span class="hljs-comment">--save eventemitter3</span><br></code></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs typescript">在服務中定義<br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Injectable</span>&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@angular/core&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123;<span class="hljs-title class_">EventEmitter</span>&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;eventemitter3&#x27;</span>;<br><span class="hljs-meta">@Injectable</span>(&#123;<br>  <span class="hljs-attr">providedIn</span>: <span class="hljs-string">&#x27;root&#x27;</span><br>&#125;)<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EventService</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-attr">eventEmit</span>: <span class="hljs-built_in">any</span>;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 定义发射事件</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">eventEmit</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">EventEmitter</span>();<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">//監聽</span><br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">EventService</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../services/event.service&#x27;</span>;<br><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">eventService</span>.<span class="hljs-property">eventEmit</span>.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;login&#x27;</span>,<span class="hljs-function">(<span class="hljs-params">result</span>)=&gt;</span>&#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;执行&#x27;</span>);<br>&#125;)<br><br><span class="hljs-comment">//發佈廣播</span><br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">EventService</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../services/event.service&#x27;</span>;<br><span class="hljs-title function_">ionViewDidLeave</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">eventService</span>.<span class="hljs-property">eventEmit</span>.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&#x27;login&#x27;</span>,<span class="hljs-string">&#x27;登录页面退出了&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="解決android10系統上無法訪問http請求"><a href="#解決android10系統上無法訪問http請求" class="headerlink" title="解決android10系統上無法訪問http請求"></a>解決android10系統上無法訪問http請求</h3><p><strong>android:usesCleartextTraffic=”true”</strong></p><p>將E:\mycase\mo\UI\11-18\1\platforms\android\app\src\main目錄下AndroidManifest.xml修改如下</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">application</span> <span class="hljs-attr">android:label</span>=<span class="hljs-string">&quot;Cha.Android&quot;</span> <span class="hljs-attr">android:usesCleartextTraffic</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">application</span>&gt;</span><br><br><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">manifest</span> <span class="hljs-attr">...</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.INTERNET&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">application</span></span><br><span class="hljs-tag">        <span class="hljs-attr">...</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:usesCleartextTraffic</span>=<span class="hljs-string">&quot;true&quot;</span> //<span class="hljs-attr">看这里</span></span><br><span class="hljs-tag">        <span class="hljs-attr">...</span>&gt;</span><br>        ...<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">application</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">manifest</span>&gt;</span><br><br>巨坑 o.0<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Ionic</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发问题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于做人的思考</title>
    <link href="/2023/11/14/%E5%85%B3%E4%BA%8E%E5%81%9A%E4%BA%BA%E7%9A%84%E6%80%9D%E8%80%83/"/>
    <url>/2023/11/14/%E5%85%B3%E4%BA%8E%E5%81%9A%E4%BA%BA%E7%9A%84%E6%80%9D%E8%80%83/</url>
    
    <content type="html"><![CDATA[<p>前两天参加了我亲姐的婚礼，我从我爸身上学到了一些做人的道理。</p><p><strong>永远不要想着占别人便宜，因为别人都是看在眼里的</strong></p><p>老爸在清点收到的红包时发现一个关系很好的朋友红包给了1000，老爸立马说要回200回去，不能多拿别人的钱，让别人说闲话。因为之前他们家儿子结婚老爸给了800（一般人都给的400），他可能觉得很讲义气，这次又多给了200，相当于还这个情，<u>也就是说这个200还不一定是他本意想给的，是出于人情世故，即这里面是可能有不情愿的成分的。</u></p><p>什么叫会做人？<u>就是 不能让别人不舒服来让自己舒服</u>。人与人交往永远是平等的，你让别人不舒服别人为什么要和你交往？也就是说把这200还回去就是为了把对方可能的不舒服给消除，让双方都舒服，这样关系才处得好。</p><p>对方一开始肯定是会说”不要回，我们这么熟的关系要回什么”，<u>记住，这些都是客套话，每个人都要面子的</u>，你要做的就是强硬一点说“要回的，你这给的太多了啊…，你要是不接收我可要生气了啊…”</p><p><strong>做事的细节体现做人的素养</strong></p><p>在接我姐吃回门饭时，老爸开车进小区后，我说车直接停在后门，从后面进比较快，否则要绕一大圈，老爸立马说”要从正大门走的，不能走后门的，要懂规矩”，我才反应过来，看来还是只想着自己了。这里其实还是体现了上面说的，不能让别人不舒服而让自己舒服。</p>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>人情世故</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue中路由的history和hash模式的区别</title>
    <link href="/2023/10/11/Vue%E4%B8%AD%E8%B7%AF%E7%94%B1%E7%9A%84history%E5%92%8Chash%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2023/10/11/Vue%E4%B8%AD%E8%B7%AF%E7%94%B1%E7%9A%84history%E5%92%8Chash%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<p><strong>从原理上来看：</strong></p><p>hash模式是通过hashChange事件来监听URL的hash值（#以及后面的，会存储在location.hash中）的变化来匹配路由规则并加载对应组件的（路由规则以及组件资源在浏览器端的缓存中-bundle.js文件，匹配时会自动去掉#），这个过程是在浏览器端进行的，不会向服务器发送HTTP请求</p><p>而history模式是通过popState事件（历史记录栈顶状态的变化）来监听历史记录的变化（最终获取的是pathname）来匹配路由规则并加载对应组件的（后面和hash模式一样，仅仅是监听的东西不一样），其中，在监听之前，是通过H5的API（H5才出的，因此兼容性没有hash模式好）：pushState（）和replaceState来存储并修改历史记录为监听历史记录做准备</p><p><strong>从用途上来看：</strong></p><p>hash模式始终都不会向服务器发送请求（除了请求组件需要的数据），单页面应用也倾向于使用Hash模式———适合在项目准备上线时设置</p><p>而history模式是 在刷新页面或者手动输入URL 时会向服务器请求资源并重复覆盖浏览器的缓存资源，入宫没有对应的资源，会出现404，但是可以在后端配置返回什么，就可以避免404—————-适合在开发阶段测试数据时使用</p>]]></content>
    
    
    <categories>
      
      <category>前端框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>import type和import的区别</title>
    <link href="/2023/10/11/type%E5%92%8Cimport%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2023/10/11/type%E5%92%8Cimport%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<p><strong>import</strong></p><p>可导入值、类型、模块等任何可导入的东西</p><p><strong>import type</strong></p><p>只能导入 类型数据，比如interface</p><p><strong>import什么都可导入，为什么还要import type？</strong></p><ul><li>代码易于理解：一看就知道导入的内容是什么</li><li>更加规范、严谨：加了关键字后可对导入的内容进行数据检查，若导入的不是类型，会报错</li></ul>]]></content>
    
    
    <categories>
      
      <category>Ts</category>
      
    </categories>
    
    
    <tags>
      
      <tag>知识点</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js中filter和map函数的区别</title>
    <link href="/2023/09/22/js%E4%B8%ADfilter%E5%92%8Cmap%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2023/09/22/js%E4%B8%ADfilter%E5%92%8Cmap%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<p><strong>前言</strong></p><p>这两个函数用的非常多，但是有一定相似之处：都是对数组数据的处理，搞清楚区别很有必要。</p><p><strong>filter</strong></p><p>对数组数据的过滤，找到满足条件的数据即可——–<strong>数据是原数据的子集</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br><br><span class="hljs-keyword">const</span> evenNumbers = numbers.<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">number</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> number % <span class="hljs-number">2</span> === <span class="hljs-number">0</span>; <span class="hljs-comment">// 筛选出偶数</span><br>&#125;);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(evenNumbers); <span class="hljs-comment">// 输出: [2, 4]</span><br></code></pre></td></tr></table></figure><p><strong>map</strong></p><p>对原数组数据进行处理，返回一个新数组——–<strong>一般不是子集，是新数据</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br><br><span class="hljs-keyword">const</span> multipliedNumbers = numbers.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">number</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> number * <span class="hljs-number">2</span>; <span class="hljs-comment">// 将每个数字乘以2</span><br>&#125;);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(multipliedNumbers); <span class="hljs-comment">// 输出: [2, 4, 6, 8, 10]</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>常用函数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>npm看似安装成功但没成功的情形</title>
    <link href="/2023/09/08/npm%E7%9C%8B%E4%BC%BC%E5%AE%89%E8%A3%85%E6%88%90%E5%8A%9F%E4%BD%86%E6%B2%A1%E6%88%90%E5%8A%9F%E7%9A%84%E6%83%85%E5%BD%A2/"/>
    <url>/2023/09/08/npm%E7%9C%8B%E4%BC%BC%E5%AE%89%E8%A3%85%E6%88%90%E5%8A%9F%E4%BD%86%E6%B2%A1%E6%88%90%E5%8A%9F%E7%9A%84%E6%83%85%E5%BD%A2/</url>
    
    <content type="html"><![CDATA[<p><img src="/2023/09/08/npm%E7%9C%8B%E4%BC%BC%E5%AE%89%E8%A3%85%E6%88%90%E5%8A%9F%E4%BD%86%E6%B2%A1%E6%88%90%E5%8A%9F%E7%9A%84%E6%83%85%E5%BD%A2/npm%E5%AE%89%E8%A3%85%E7%BB%93%E6%9E%9C.png" alt="npm安装结果"></p><p>像这种一堆警告而且还没报完的，说明没有安装成功，虽然还有up to date…</p><p><strong>解决方法</strong></p><p>使用cnpm安装</p><blockquote><p>优先还是使用npm，因为镜像仓库和原仓库不完全一致</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Npm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>npm操作问题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue2中父子传值和插槽的区别</title>
    <link href="/2023/09/07/Vue2%E4%B8%AD%E7%88%B6%E5%AD%90%E4%BC%A0%E5%80%BC%E5%92%8C%E6%8F%92%E6%A7%BD%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2023/09/07/Vue2%E4%B8%AD%E7%88%B6%E5%AD%90%E4%BC%A0%E5%80%BC%E5%92%8C%E6%8F%92%E6%A7%BD%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<p><strong>前言</strong></p><p>突然发现父子传值和插槽似乎有类似的功能，但是很迷糊，想要搞清楚一下</p><p><strong>父子传值</strong></p><p>父组件传数据给子组件使用</p><p><strong>插槽</strong></p><p>父组件自定义内容传递到自组建的插槽位置处</p><blockquote><p>顺便复习下种类：默认插槽（有默认位置）、具名插槽（有名字）、作用域插槽（需要子组件作用域内的数据，则向父组件传递，内容准备好了再传给子组件）</p></blockquote><p><strong>区别</strong></p><p>父子传值仅仅是把值给子组件，子组件要怎么使用，父组件并不关心</p><p>而插槽是子组件位置确定了，内容也确定了（父组件提供），即共同确定父子组件整体页面的显示</p>]]></content>
    
    
    <categories>
      
      <category>前端框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue2中父子传值的内部过程</title>
    <link href="/2023/09/07/Vue2%E4%B8%AD%E7%88%B6%E5%AD%90%E4%BC%A0%E5%80%BC%E7%9A%84%E5%86%85%E9%83%A8%E8%BF%87%E7%A8%8B/"/>
    <url>/2023/09/07/Vue2%E4%B8%AD%E7%88%B6%E5%AD%90%E4%BC%A0%E5%80%BC%E7%9A%84%E5%86%85%E9%83%A8%E8%BF%87%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p><strong>前言</strong></p><p>在学习Vue3中的Setup注意点，有专门提到父子传值，内容打破了我固有观念，有必要记录一下。</p><p><strong>广义上来看</strong></p><p>父组件的数据-&gt;子组件用props接受-&gt;props将数据交给vm的data-&gt;子组件到模板中使用</p><p><strong>从狭义上来看</strong></p><p>我们默认子组件是用props接受的，那万一子组件不用props接受呢？真的就用不了吗？</p><p>不，如果没有用props接受，<strong>那么会先存在vm.$attrs中，一旦使用props接受了，再把数据从vm.$attrs移交给props</strong>，后续和广义上的流程一样。</p><p><strong>也就是说：</strong>vm.$attrs相当于一个<strong>暂为保管的中转站</strong>，如果没有props接受，仍然可以用vm,attrs访问，相当于一个<strong>兜底</strong>的作用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;&#123;vm.<span class="hljs-property">atts</span>.数据&#125;&#125;<span class="hljs-comment">//使用方法</span><br></code></pre></td></tr></table></figure><blockquote><p>这种做法在其它部分有类似的地方：插槽</p><p>在子组件没有写<slot>标签时，插槽内容是暂存储在vm.slots里面的</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>前端框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Reactive对比Ref</title>
    <link href="/2023/09/07/Reactive%E5%AF%B9%E6%AF%94Ref/"/>
    <url>/2023/09/07/Reactive%E5%AF%B9%E6%AF%94Ref/</url>
    
    <content type="html"><![CDATA[<ul><li>从定义数据的角度：<ul><li>ref用来定义：<strong>基本数据类型</strong></li><li>reactive用来定义：<strong>引用数据类型（包括数组）</strong></li><li>ref也可以定义引用数据类型，只是它的内部使用的就是reactive的proxy</li></ul></li><li>从实现原理的角度<ul><li>ref通过<strong>Object.defineproperty</strong>的get和set实现响应式</li><li>reactive通过<strong>proxy</strong>实现响应式，通过<strong>reflect</strong>操作原对象的数据</li></ul></li><li>从使用的角度<ul><li>ref定义过的数据：在操作数据时需要**.value**，而访问数据不需要</li><li>reactive定义过的数据：在操作数据和访问数据时都不需要**.value**</li></ul></li></ul><p><strong>规范使用：尽量全都使用reactive</strong></p><p><strong>reactive不是无法对基本数据类型使用吗？</strong></p><p>不，有一个套路：将基本数据类型和引用类型全都包含在一个对象内，类似这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> data = <span class="hljs-title function_">reactive</span>(&#123;<br>    <span class="hljs-attr">material</span>:<span class="hljs-string">&#x27;材料&#x27;</span>,<br>    <span class="hljs-attr">person</span>:&#123;...&#125;,<br>&#125;)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue2中数据代理和数据劫持的关系</title>
    <link href="/2023/09/05/Vue2%E4%B8%AD%E6%95%B0%E6%8D%AE%E4%BB%A3%E7%90%86%E5%92%8C%E6%95%B0%E6%8D%AE%E5%8A%AB%E6%8C%81%E7%9A%84%E5%85%B3%E7%B3%BB/"/>
    <url>/2023/09/05/Vue2%E4%B8%AD%E6%95%B0%E6%8D%AE%E4%BB%A3%E7%90%86%E5%92%8C%E6%95%B0%E6%8D%AE%E5%8A%AB%E6%8C%81%E7%9A%84%E5%85%B3%E7%B3%BB/</url>
    
    <content type="html"><![CDATA[<p><strong>数据代理</strong></p><p>指的是将data中的属性代理到Vue实例中，方便通过Vue实例来访问data中的属性</p><p><strong>数据劫持</strong></p><p>通过Object.defineproperty对即将访问或更新的数据添加getter和setter函数来实现数据的响应</p><p><strong>关系</strong></p><p>先 数据代理，方便访问后，再进行 数据劫持，触发响应式更新。</p>]]></content>
    
    
    <categories>
      
      <category>前端框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue2和Vue3响应式数据的处理的不同</title>
    <link href="/2023/09/04/vue2%E5%92%8Cvue3%E5%93%8D%E5%BA%94%E5%BC%8F%E6%95%B0%E6%8D%AE%E7%9A%84%E5%A4%84%E7%90%86%E7%9A%84%E4%B8%8D%E5%90%8C/"/>
    <url>/2023/09/04/vue2%E5%92%8Cvue3%E5%93%8D%E5%BA%94%E5%BC%8F%E6%95%B0%E6%8D%AE%E7%9A%84%E5%A4%84%E7%90%86%E7%9A%84%E4%B8%8D%E5%90%8C/</url>
    
    <content type="html"><![CDATA[<p><strong>Vue2</strong></p><p>经过Object.defineproperty添加getter和setter来实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> person = &#123;<br>    <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;周杰&#x27;</span><br>&#125;<br><span class="hljs-comment">// 添加age属性</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineproperty</span>(person,<span class="hljs-string">&#x27;age&#x27;</span>,&#123;<br>      <span class="hljs-attr">configurable</span>:<span class="hljs-literal">true</span>;<span class="hljs-comment">//配置后可删除，但是无响应式</span><br>      <span class="hljs-attr">value</span>:<span class="hljs-number">19</span>,<br>      <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>,        <br>      <span class="hljs-attr">writable</span>: <span class="hljs-literal">true</span>,<br>    <br>      <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>)&#123;<br>          <span class="hljs-keyword">return</span> number <span class="hljs-comment">//为了使得age值一样，于是直接返回number</span><br>      &#125;,<br>      <span class="hljs-title function_">set</span>(<span class="hljs-params">value</span>)&#123;<br>          <span class="hljs-variable language_">this</span>.<span class="hljs-property">number</span> = value <span class="hljs-comment">//为了使得同时修改number，直接将值赋值给number</span><br>      &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p><strong>Vue3</strong></p><p>通过reactive它内部的proxy和Reflect（都是window内置对象-ES6新增）来实现（针对引用类型）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title function_">proxy</span>(person,&#123;<br>      <span class="hljs-title function_">get</span>(<span class="hljs-params">target,propName</span>)&#123;<br>          <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(target,propName) <br>      &#125;,<br>      <span class="hljs-comment">// 修改和添加时都会调用，类似 Vue.set或vm.$set()</span><br>      <span class="hljs-title function_">set</span>(<span class="hljs-params">target,propName,value</span>)&#123;<br>          <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">set</span>(target,propName,value) <br>      &#125;,<br>      <span class="hljs-title function_">deleteProperty</span>(<span class="hljs-params">target,propName</span>)&#123;<br>          <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">deleteProperty</span>(target,propName)<span class="hljs-comment">// true/false</span><br>      &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p><strong>Vue3相对于Vue2的实现优点</strong></p><p>Vue2缺点： </p><p>1.无法直接对对象进行添加和删除响应式操作（对象.新属性=值、delete 对象.属性名），只能使用Vue.set()或vm.$set()、Vue.delete()或vm.$delete   —– <strong>对象</strong></p><p>2.无法直接通过索引修改数组自动更新（只能用vm.$set或splice等方法）—– <strong>数组</strong></p><blockquote><p>注意：Vue2中，如果 通过索引修改数组的同时又修改了基本数据类型，那么此时数组仍然可以自动更新到页面 ，因为基本数据类型触发了响应式更新，看到数组有变化了顺带也更新了</p></blockquote><p>3.每次只能某个属性进行相应式修改，如果属性很多，代码会冗余</p><p>4.对同一个属性重复设置会报错，只能在外面手写try—catch，否则运行失败</p><p>Vue3优点：</p><p>弥补了Vue2实现的所有缺点</p><blockquote><p>注意：可以直接修改对象属性，但不能对对象重新赋值，比如：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> job = <span class="hljs-title function_">reactive</span>(&#123;<span class="hljs-attr">type</span>:<span class="hljs-string">&#x27;前端&#x27;</span>,<span class="hljs-attr">salary</span>:<span class="hljs-string">&#x27;10k&#x27;</span>&#125;)<br><br><span class="hljs-comment">// 点击修改job</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">change</span>(<span class="hljs-params"></span>)&#123;<br>    job = &#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;周杰&#x27;</span>,<span class="hljs-attr">age</span>:<span class="hljs-number">18</span>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>因为重新赋值意味着新的引用，而reactive只是对{type:’前端’,salary:’10k’}这个对象赋予响应式更新的能力，并非{name:’周杰’,age:18}</p></blockquote><p><strong>总结：Vue3的proxy用法更方便，使用风格更贴近于原生</strong></p>]]></content>
    
    
    <categories>
      
      <category>前端框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>横向比较</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kafka和Nifi的使用</title>
    <link href="/2023/08/31/kafka%E5%92%8Cnifi%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2023/08/31/kafka%E5%92%8Cnifi%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="Nifi"><a href="#Nifi" class="headerlink" title="Nifi"></a>Nifi</h3><p><strong>1.nifi是什么？</strong></p><p>为了解决不同系统之间数据自动流通的问题的工具</p><p><strong>2.使用场景？</strong></p><p>高效且可被追踪的 将数据 从A搬到B，B搬到C，C搬到A等等</p><p>01视频是为了测试消息消费者是否能转发给下一个消息发布者，当我手动在 消息消费者 那儿发布一则消息，那么 消息消费者 自动转发给了 下一个消息发布这那儿，那我在消息发布者那儿订阅消息，如果能获取到，那就说明 进行了转发操作</p><p>那为什么 地点在同一个位置也可以收到呢？</p><p>因为 同一个地点发布同一个地点订阅当然能收到，在此之前没有 经过转发操作</p><p><strong>3</strong>.<strong>Nifi的一些常见术语</strong></p><p>Flow File：系统中移动的每个对象，包含 属性和内容 两个变量</p><p>Prosess File：对Flow File中的数据进行处理</p><h3 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h3><p>它被设计用于高吞吐量、低延迟和可持久性的数据流处理。Kafka主要用于解决应用程序之间的异步通信、数据传输和事件流处理等后端场景。</p><p>将Kafka作为后端技术的例子包括：</p><ol><li>数据流处理：Kafka常用于在大规模数据流中传递、存储和处理数据，例如实时日志采集、事件处理、数据管道等。</li><li>消息队列：Kafka作为一种高性能的消息队列，可以作为后端的消息中间件，用于解耦和缓冲生产者和消费者之间的通信，支持发布-订阅模式。</li></ol><h3 id="MQTT"><a href="#MQTT" class="headerlink" title="MQTT"></a>MQTT</h3><p>和kafka类似的消息传递系统。</p><h4 id="下面是一个消息的传递实例：MQTT-gt-nifi-gt-kafka-gt-nifi-gt-MQTT"><a href="#下面是一个消息的传递实例：MQTT-gt-nifi-gt-kafka-gt-nifi-gt-MQTT" class="headerlink" title="下面是一个消息的传递实例：MQTT-&gt;nifi-&gt;kafka-&gt;nifi-&gt;MQTT"></a>下面是一个消息的传递实例：MQTT-&gt;nifi-&gt;kafka-&gt;nifi-&gt;MQTT</h4><h6 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h6><p>1）创建按一个consumer并配置（和练习的一样）</p><p>2）创建一个Extract Text（拖下来后在里面搜），用于对资料的截取，并配置如下</p><p><img src="/2023/08/31/kafka%E5%92%8Cnifi%E7%9A%84%E4%BD%BF%E7%94%A8/%E9%85%8D%E7%BD%AE1.png" alt="配置"></p><p>3）将前两个processor连接起来，1）-&gt; 2），这样在consumer那儿 pub资料后，资料会流到2）来进行截取资料</p><p>4）新建一个 ReplaceText（在里面搜），并进行如下配置，目的是 在传递给kafka之前要有一个数据的标准形式，这里的Replace可以看成是 格式的 replace</p><p><img src="/2023/08/31/kafka%E5%92%8Cnifi%E7%9A%84%E4%BD%BF%E7%94%A8/%E9%85%8D%E7%BD%AE2.png" alt="配置2"></p><p>5）新建一个kafka的processor（.10.1版本），先配置，因为是最后一个processor，因此后面相关的都terminal </p><p><img src="/2023/08/31/kafka%E5%92%8Cnifi%E7%9A%84%E4%BD%BF%E7%94%A8/%E9%85%8D%E7%BD%AE3.png" alt="配置3"></p><p><img src="/2023/08/31/kafka%E5%92%8Cnifi%E7%9A%84%E4%BD%BF%E7%94%A8/%E9%85%8D%E7%BD%AE4.png" alt="配置4"></p><p>再将箭头 从replace拉到 kafka处，配置connection的relationship为success，表示 只有成功匹配并处理才会抛给kafka</p><p>再配置replace</p><p>然后可以测试了，测试内容在01视频最后</p><p><img src="/2023/08/31/kafka%E5%92%8Cnifi%E7%9A%84%E4%BD%BF%E7%94%A8/%E9%85%8D%E7%BD%AE5.png" alt="配置5"></p><p>6）新建一个工作区<img src="/2023/08/31/kafka%E5%92%8Cnifi%E7%9A%84%E4%BD%BF%E7%94%A8/%E9%85%8D%E7%BD%AE6.png" alt="配置6"></p><p>7）新建一个consumerkafka，配置如下：</p><p><img src="/2023/08/31/kafka%E5%92%8Cnifi%E7%9A%84%E4%BD%BF%E7%94%A8/%E9%85%8D%E7%BD%AE7.png" alt="配置7"></p><p>8）添加一个MQTTPublish，将连接 从Kkafka连向这个，然后connect配置还是success。它的配置如下：</p><p><img src="/2023/08/31/kafka%E5%92%8Cnifi%E7%9A%84%E4%BD%BF%E7%94%A8/%E9%85%8D%E7%BD%AE8.png" alt="配置8"></p><p><img src="/2023/08/31/kafka%E5%92%8Cnifi%E7%9A%84%E4%BD%BF%E7%94%A8/%E9%85%8D%E7%BD%AE9.png" alt="配置9"></p><p>然后在最后这订阅进行测试</p>]]></content>
    
    
    <categories>
      
      <category>后端技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>kafka、nifi</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>k8s、harbor、docker、rancher的关系？</title>
    <link href="/2023/08/31/k8s%E3%80%81docker%E3%80%81rancher%E7%9A%84%E5%85%B3%E7%B3%BB/"/>
    <url>/2023/08/31/k8s%E3%80%81docker%E3%80%81rancher%E7%9A%84%E5%85%B3%E7%B3%BB/</url>
    
    <content type="html"><![CDATA[<p>docker从harbor那去取镜像来运行，而运行项目需要 K8S 来统一编排docker容器，而rancher是提供了良好的管理工具和界面更方便地使用k8s集群。下面是关系图：</p><p><img src="/2023/08/31/k8s%E3%80%81docker%E3%80%81rancher%E7%9A%84%E5%85%B3%E7%B3%BB/k8s%E3%80%81docker%E3%80%81rancher%E7%9A%84%E5%85%B3%E7%B3%BB.png" alt="k8s、docker、rancher的关系"></p>]]></content>
    
    
    <categories>
      
      <category>构建与部署</category>
      
    </categories>
    
    
    <tags>
      
      <tag>部署工具与平台</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>利用CICD从gitlab到部署的流程</title>
    <link href="/2023/08/31/%E5%88%A9%E7%94%A8CICD%E4%BB%8Egitlab%E5%88%B0%E9%83%A8%E7%BD%B2%E7%9A%84%E6%B5%81%E7%A8%8B/"/>
    <url>/2023/08/31/%E5%88%A9%E7%94%A8CICD%E4%BB%8Egitlab%E5%88%B0%E9%83%A8%E7%BD%B2%E7%9A%84%E6%B5%81%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>1.在 gitlab 上下载cicd文件以及 加载模板，更新runner</p><p>​                        配置cicd的variables，更新harbor名、gitlab-key、gitab-url</p><p>​                                                                      harbor-user、 harbor-password，等待执行cicd的pipelines</p><p>2.在harbor上查看刚刚推上来的项目，点进去，复制 pull 命令</p><p>3.在rancher上在workloads上点击deploy，输入地址，把pull给去掉，保留后面的</p><p>​                         在service discovery，添加record，设置项目端口</p><p>​                         在load balancing上，添加ingress，用于将前两个连接起来，并生成一个域名   </p>]]></content>
    
    
    <categories>
      
      <category>构建与部署</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CICD</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CICD</title>
    <link href="/2023/08/31/CICD/"/>
    <url>/2023/08/31/CICD/</url>
    
    <content type="html"><![CDATA[<h3 id="什么是CICD？"><a href="#什么是CICD？" class="headerlink" title="什么是CICD？"></a>什么是CICD？</h3><p>指持续集成和持续部署的软件开发实践方法，可以提前在yaml档进行配置，之后可以自动化执行这个脚本，其中包括对代码的 构建、代码检查、release、dockerize等</p><h3 id="怎么使用GitLab-CI？"><a href="#怎么使用GitLab-CI？" class="headerlink" title="怎么使用GitLab CI？"></a>怎么使用GitLab CI？</h3><p> 在项目下面创建一个.gitlab-ci.yml文件，里面包含了  集成、测试 的一些配置，到时候一旦 本地仓库push到gitlab上面之后，会通过 GitLab-Runner 自动执行配置好的一些行为</p><h3 id="什么是GitLab-Running"><a href="#什么是GitLab-Running" class="headerlink" title="什么是GitLab-Running?"></a>什么是GitLab-Running?</h3><p>GitLab-Running可能不止一个，因此GitLab CI需要找到提前注册好的GitLab-Running来帮他执行脚本</p><p>每种GitLab-Running能做的行为都不同</p><ul><li><h4 id="怎么注册并安装、启动一个GitLab-Running？"><a href="#怎么注册并安装、启动一个GitLab-Running？" class="headerlink" title="怎么注册并安装、启动一个GitLab-Running？"></a>怎么注册并安装、启动一个GitLab-Running？</h4><p>1）<a href="http://10.37.37.139/packages/">Index of /packages/</a> ——– 下载 gitlab-runner程序，用来当作命令行命令使用</p><p>2）下载 wistron-root.crt ——– 证书，用于给gitlab注册runner使用</p><p><img src="/2023/08/31/CICD/%E4%B8%8B%E8%BD%BD%E8%AF%81%E4%B9%A6%E9%A1%B5.png" alt="下载证书页"></p><p>2）进入刚刚下载的git-runner程序的文件夹，将此程序 命名为gitlab-runner.exe，因为命令的名字就是 gitlab-runner，打开cmd，输入指令注册runner：</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs delphi">gitlab-runner <span class="hljs-keyword">register</span> --tls-ca-<span class="hljs-keyword">file</span> wistron-root.crt的路径<br></code></pre></td></tr></table></figure></li></ul><p>​        3）打开gitlab进入自己的主页，新建一个项目，进入如图页面</p><p><img src="/2023/08/31/CICD/gitlab%E8%AE%BE%E7%BD%AE.png" alt="gitlab设置"></p><p>​          4）根据提示输入url和token</p><p><img src="/2023/08/31/CICD/%E6%A0%B9%E6%8D%AE%E6%8F%90%E7%A4%BA%E8%BE%93%E5%85%A5url%E5%92%8Ctoken.png" alt="根据提示输入url和token"></p><p>​          5）输入runner的描述和tags</p><p>​          6）选择docker为执行者，再输入如下作为docker image（镜像）：</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">alpine:</span>latest<br></code></pre></td></tr></table></figure><p><img src="/2023/08/31/CICD/%E9%80%89%E6%8B%A9docker.png" alt="选择docker"></p><p>​          7）安装到自己的项目下（刚刚只完成了注册操作，注册就相当于下载，还需要安装才能使用），执行：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">gitlab-runner <span class="hljs-keyword">install</span> --working-<span class="hljs-keyword">file</span>=gitlab-runner<br></code></pre></td></tr></table></figure><p><strong>如果出现</strong>： </p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">FATAL：Failed to <span class="hljs-keyword">install</span> gitlab-runner：service gitlab-runner already <span class="hljs-keyword">exists</span><br></code></pre></td></tr></table></figure><p>则先卸载再安装和启动，这时不需要指定指定的–working-file</p><p><img src="/2023/08/31/CICD/%E5%8D%B8%E8%BD%BD.png" alt="卸载"></p><p><strong>——这是在之前的cicd的runner页面就可以看到自己刚刚创建的running已经启动了（绿色）</strong></p><hr><p>以上可以不用看，直接 选用公司的runner就行，其中tags为：</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs subunit"><span class="hljs-keyword">tags:</span><br>   - k8s-runners<br></code></pre></td></tr></table></figure><h3 id="什么是Git-Running-excutor？"><a href="#什么是Git-Running-excutor？" class="headerlink" title="什么是Git-Running excutor？"></a>什么是Git-Running excutor？</h3><p>它是帮助GitLab-Running执行的，也就是GitLab-Running的工具</p><h3 id="GitLab-CI语法"><a href="#GitLab-CI语法" class="headerlink" title="GitLab-CI语法"></a>GitLab-CI语法</h3><p><strong>格式：</strong>yml</p><p><strong>例子：</strong>job就相当于一个个 脚本，stages包含各阶段的名称，一个job执行一个stage，script为job的脚本名称</p><p><img src="/2023/08/31/CICD/script1.png" alt="script1"></p><p><strong>注意：保留字不能作为job name，相当于编程中的保留字不能做变量名</strong></p><p><strong>基础指令：</strong></p><p> 1）image &amp; services ——– 指定镜像以及附加服务</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">image:</span><br><span class="hljs-symbol">  docker:</span>stable<br><span class="hljs-symbol"></span><br><span class="hljs-symbol">services:</span><br>  - name:docker:dind<br>    entrypointL[]<br><span class="hljs-symbol">    command:</span>[<span class="hljs-string">&quot;--security-register=harbor-k8s.wistron.com&quot;</span>]<br></code></pre></td></tr></table></figure><p>2）stages &amp; job</p><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">stages</span><span class="hljs-punctuation">:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">build</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">test</span><br><span class="hljs-attribute">job</span><span class="hljs-punctuation">:</span><br>  stage:build<br></code></pre></td></tr></table></figure><p>3）before_script &amp; after_script：用来定义 job 开始前 和 开始后 的脚本，既可以放在job之前，也可以放在job内部<img src="/2023/08/31/CICD/script2.png" alt="script2"></p><p>4）only &amp; except：限制执行的branch，不会执行develop这个分支</p><p>​      tags：设定执行的runner</p><p><img src="/2023/08/31/CICD/script3.png" alt="script3"></p><p>5）artifacts：添加特定档案或者目录在job上</p><p>​      artfacts:paths：将指定路径的档案或目录放到job</p><p>​      artfacts:when：什么时候存放，on_success、on_failure、always</p><p>​      artfacts:expire_in：档案或目录存放的时间，通常不要设置太大，否则存放的文档太多</p><p><img src="/2023/08/31/CICD/script4.png" alt="script4"></p><p><strong>需要注意格式问题：关键字冒号后面的内容一定要加空格</strong></p><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">image</span><span class="hljs-punctuation">:</span> <span class="hljs-string">docker:stable            -------image冒号后面要加空格，docker不是关键字，只是和stable一起                                        成为image的内容</span><br><span class="hljs-attribute">stages</span><span class="hljs-punctuation">:</span><br> <span class="hljs-bullet">-</span> <span class="hljs-string">Build image</span><br><span class="hljs-attribute">build</span><span class="hljs-punctuation">:</span><br> <span class="hljs-attribute">stage</span><span class="hljs-punctuation">:</span> <span class="hljs-string">Build image             -------stage冒号后面要加空格</span><br> <span class="hljs-attribute">tags</span><span class="hljs-punctuation">:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">runner01</span><br> <span class="hljs-attribute">script</span><span class="hljs-punctuation">:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">docker info</span><br></code></pre></td></tr></table></figure><hr><h3 id="docker和harbor的区别？"><a href="#docker和harbor的区别？" class="headerlink" title="docker和harbor的区别？"></a>docker和harbor的区别？</h3><p>harbor是存放镜像源的，而docker是运行镜像源的</p><hr><h3 id="如何使用gitlab-tool下载cicd的一些必须文件并使用？"><a href="#如何使用gitlab-tool下载cicd的一些必须文件并使用？" class="headerlink" title="如何使用gitlab tool下载cicd的一些必须文件并使用？"></a>如何使用gitlab tool下载cicd的一些必须文件并使用？</h3><p>1.网址：<a href="http://gittemplate-ui-dev.k8s-dev.k8s.wistron.com/ciscript">UI (wistron.com)</a></p><p>​           把angular的所有文件都下下来，除了old版本的文件</p><p>2.只要改一个文件.gitlab-ci.yml，而且改的内容也不多，只要改革 runner的tags</p><p>用公司的k8s-runners就行</p><p>3.打开 <a href="http://gittemplate-ui-dev.k8s-dev.k8s.wistron.com/pjtmp">UI (wistron.com)</a> ——– 输入项目相关信息，生成cicd的一些参数模板</p><p>4.在setting中的cicd的配置中的variable参数中，找到GITLAB-KEY，输入 setting 中的access tokens</p><p>​                                                                                           HARBOR-USER、HARBOR-PASSWORD，分别输入</p><p>k8si40和W#g5xT#y2d</p><p>​                                                                                           VERSION-FILE，在本地项目加一个文件version.txt</p>]]></content>
    
    
    <categories>
      
      <category>构建与部署</category>
      
    </categories>
    
    
    <tags>
      
      <tag>自动化流程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>gitlab的sshkey过期问题</title>
    <link href="/2023/08/31/gitlab%E7%9A%84sshkey%E8%BF%87%E6%9C%9F%E9%97%AE%E9%A2%98/"/>
    <url>/2023/08/31/gitlab%E7%9A%84sshkey%E8%BF%87%E6%9C%9F%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>1.输入ssh-keygen -t rsa -C<br>your email 替换成申请好的邮箱即可<br>ssh-keygen -t rsa -C “your email”<br>2.接着如下提示说让输入生成id_rsa文件的路径<br>复制你自己那括号里的路径就行<br>Enter file in which to save the key (~/.ssh/id_rsa):<br>3.接着提示设置密码，然后等待生成<br>Enter passphrase (empty for no passphrase):<br>Enter same passphrase again:<br>4.输入如下命令打开生成好的id_rsa.pub文件，复制里面的公钥用<br>cat ~/.ssh/id_rsa.pub<br>pbcopy &lt; ~/.ssh/id_rsa.pub<br>3.登录对应工作环境gitlab<br>打开gitlab网站，登录后，找到setting栏，再找到SSH key栏，选择ADD SSH KEY，把上面复制的公钥粘贴进去，OK</p>]]></content>
    
    
    <categories>
      
      <category>Gitlab</category>
      
    </categories>
    
    
    <tags>
      
      <tag>sshkey过期</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git常用命令</title>
    <link href="/2023/08/31/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <url>/2023/08/31/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<p>git clone @———–</p><p>git init 新建一个空的仓库<br>git status 查看状态<br>git add . 添加文件<br>git commit -m ‘注释’ 提交添加的文件并备注说明<br>git remote add origin <a href="mailto:&#x67;&#105;&#116;&#64;&#x67;&#105;&#116;&#x68;&#117;&#98;&#46;&#x63;&#x6f;&#109;">&#x67;&#105;&#116;&#64;&#x67;&#105;&#116;&#x68;&#117;&#98;&#46;&#x63;&#x6f;&#109;</a>:jinzhaogit/git.git 连接远程仓库<br>git push -u origin master 将本地仓库文件推送到远程仓库<br>git log 查看变更日志<br>git reset –hard 版本号前六位 回归到指定版本<br>git branch 查看分支<br>git branch newname 创建一个叫newname的分支<br>git checkout newname 切换到叫newname的分支上<br>git merge newname 把newname分支合并到当前分支上<br>git pull origin master 将master分支上的内容拉到本地上</p>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>常用命令</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ts语法</title>
    <link href="/2023/08/30/Typescript%E8%AF%AD%E6%B3%95/"/>
    <url>/2023/08/30/Typescript%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h3 id="什么是TypeScript？"><a href="#什么是TypeScript？" class="headerlink" title="什么是TypeScript？"></a>什么是TypeScript？</h3><p>1.是js的超集（js有的ts也有，而且ts还有js没有的东西）</p><p>2.没有的部分主要添加了类型检查，所以说名字有Type</p><h3 id="TypeScript为什么要添加类型支持？"><a href="#TypeScript为什么要添加类型支持？" class="headerlink" title="TypeScript为什么要添加类型支持？"></a>TypeScript为什么要添加类型支持？</h3><p>因为js经常会出现类型错误，ts就是来弥补这一缺陷的</p><ul><li><p><strong>为什么js经常会出现类型错误，ts又是如何解决的呢？</strong></p><p>编译语言分为静态语言（ts）和动态语言（js），静态语言是在编译时进行类型检查的，而动态语言是在运行时检查类型的，由于js每次在运行时才检查类型发现错误时就已经晚了，所以会经常出现类型错误，而ts在编译时配合VSCode编译器可以在编写代码时就及时提示错误的类型并加以改正，因此运行后bug就减少了许多。</p></li></ul><h3 id="TypeScript相比JavaScript的优势？"><a href="#TypeScript相比JavaScript的优势？" class="headerlink" title="TypeScript相比JavaScript的优势？"></a>TypeScript相比JavaScript的优势？</h3><p>1.任何地方都有代码提示，随时随地的安全感，提升代码体验</p><p>2.类似地，错误也会更早地发现，减少维护成本</p><p>3.支持js的最新语法，让你走在技术的最前端</p><p>4.支持类型推断：并不用任何地方都要写类型，即享受着ts的优势，又能减少开发成本</p><h3 id="为什么要安装TypeScript工具包？"><a href="#为什么要安装TypeScript工具包？" class="headerlink" title="为什么要安装TypeScript工具包？"></a>为什么要安装TypeScript工具包？</h3><p>因为node.js/浏览器只认识js，不认识ts，需要TypeScript工具包将ts转化为js</p><p><strong>简化编译运行的包的下载：npm i -g ts-node</strong></p><ul><li>直接ts-node 文件名，不用先tsc 在node </li><li>在使用之前需要先 node -init</li><li>它是在内部转化为js然后运行js文件的，因此不会显式地生成一个js文件</li></ul><h3 id="TypeScript中的类型"><a href="#TypeScript中的类型" class="headerlink" title="TypeScript中的类型"></a>TypeScript中的类型</h3><p><strong>分为js中已有的类型和ts新增的类型</strong></p><ul><li>js中已有的类型<ul><li>基础类型：number、string、boolean、undefined、null、symbol（es6新增）</li><li>引用类型：数组、函数、对象等</li></ul></li><li>ts新增的类型<ul><li>联合类型、自定义类型（类型别名）、接口、元组、字面量类型、枚举、void、any等</li></ul></li></ul><h3 id="基础类型"><a href="#基础类型" class="headerlink" title="基础类型"></a>基础类型</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs typescript">  <span class="hljs-comment">//练习void声明，声明在ts中叫做类型注解</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">unusable1</span>:<span class="hljs-built_in">void</span>=<span class="hljs-literal">undefined</span>;<br>   <span class="hljs-keyword">let</span> <span class="hljs-attr">unusable2</span>:<span class="hljs-built_in">void</span>=<span class="hljs-literal">null</span>;<br>   <span class="hljs-keyword">function</span> <span class="hljs-title function_">warnUser</span>(<span class="hljs-params"></span>):<span class="hljs-built_in">void</span>&#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;This is a warning message!&quot;</span>)<br>   &#125;<br><span class="hljs-comment">//undefined、null</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">u</span>:<span class="hljs-literal">undefined</span>=<span class="hljs-literal">undefined</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">n</span>:<span class="hljs-literal">null</span>=<span class="hljs-literal">null</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">num</span>:<span class="hljs-built_in">number</span>=<span class="hljs-literal">null</span>;<span class="hljs-comment">//null和undfined是所有类型的子类，可看作初始化吧</span><br><br><span class="hljs-comment">//never表示不存在的值的类型，比如函数中死循环或者抛出异常的返回值类型</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">infiniteLoop</span>(<span class="hljs-params"></span>)&#123;<br> <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br> <br> &#125;<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">error</span>(<span class="hljs-params">message:<span class="hljs-built_in">String</span></span>)&#123;<br> <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(message);<br>&#125;<br><br><span class="hljs-comment">//object类型是除了number、string、boolean、undefined或null之外的类型</span><br><br><span class="hljs-comment">//类型断言：在编译时告诉编译器&quot;我来手动指定类型，并且请你放心&quot;</span><br><span class="hljs-comment">//方式一</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">someValue</span>:<span class="hljs-built_in">any</span>=<span class="hljs-string">&quot;a value&quot;</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">strLength</span>:<span class="hljs-built_in">number</span>=(&lt;<span class="hljs-built_in">string</span>&gt;someValue).<span class="hljs-property">length</span>;<br><span class="hljs-comment">//方式二</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">strLength</span>:<span class="hljs-built_in">number</span>=(someValue <span class="hljs-keyword">as</span> <span class="hljs-built_in">string</span>).<span class="hljs-property">length</span>;<br></code></pre></td></tr></table></figure><h3 id="变量的声明"><a href="#变量的声明" class="headerlink" title="变量的声明"></a>变量的声明</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">//var</span><br><span class="hljs-comment">/*作用域</span><br><span class="hljs-comment">1.在函数内任何地方声明作用域都为整个函数内</span><br><span class="hljs-comment">2.在函数内直接声明，不加var则表示全局变量，否则是局部变量</span><br><span class="hljs-comment">3.在函数外不管加不加var则都是全局变量</span><br><span class="hljs-comment">*/</span><br>   <span class="hljs-comment">/*setTimeout异步处理机制：</span><br><span class="hljs-comment">  主线程里面的执行栈存放同步任务，还有个任务队列，只要有异步任务就会增加一个事件存放在任务队列</span><br><span class="hljs-comment">  系统先按顺序执行完所有执行栈中的同步任务，然后就会读取任务队列执行其中的事件解除对应异步任务的等待状态并将异步任务放到执行栈中执行</span><br><span class="hljs-comment">  直到任务队列中所有任务被执行完</span><br><span class="hljs-comment">*/</span><br>   <span class="hljs-comment">//let</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">作用域：局部作用域</span><br><span class="hljs-comment">其中捕获的异常也是局部的，例如这里的e在括号外是无法取到的</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">try</span>&#123;<br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Oh No!&quot;</span>)<br>&#125;<span class="hljs-keyword">catch</span>(e)&#123;<br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Oh Well!&quot;</span>)<br>&#125;<br>   <span class="hljs-comment">/*</span><br><span class="hljs-comment">正常来说 块级作用域变量在声明之前是无法使用的，但有个特例：函数的声明，但是调用却不行</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>     <span class="hljs-comment">//okay to capture &#x27;a&#x27;</span><br>     <span class="hljs-keyword">return</span> a;<br>   &#125;<br><span class="hljs-title function_">foo</span>();<span class="hljs-comment">//报错</span><br>   <span class="hljs-keyword">let</span> a=<span class="hljs-number">1</span>;<br>   <span class="hljs-comment">/*能用const就用const，是为了安全*/</span><br>   <span class="hljs-comment">//解构：解析一个数据的结构，是通过给这个数据每个值(不一定每一个，一一对应就行)定义一个变量来实现的，由于这个数据的结构由自定义的变量组成，因为它的结构整体上来看更清晰，更方便使用</span><br>   <span class="hljs-comment">//解构其实就是c++中的别名，既能访问，又能修改值（两边都变）</span><br>  <span class="hljs-comment">//1.解构数组</span><br>  <span class="hljs-keyword">let</span> input=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>];<br>  <span class="hljs-keyword">let</span> [first,second]=input;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(first)<span class="hljs-comment">//1</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(second)<span class="hljs-comment">//2</span><br>  <span class="hljs-comment">//交换变量很方便</span><br>  [first,second]=[second,first]<br>  <span class="hljs-comment">//作为函数参数</span><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">[first,second]:[<span class="hljs-built_in">number</span>,<span class="hljs-built_in">number</span>]</span>)&#123;<br>       <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(first)<br>       <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(second)<br>  &#125;<br>  <span class="hljs-title function_">f</span>(input);<br>  <span class="hljs-comment">//可使…创建剩余变量</span><br>  <span class="hljs-keyword">let</span> [first,…rest]=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(first)<span class="hljs-comment">//1</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(rest)<span class="hljs-comment">//2,3,4</span><br>  <span class="hljs-comment">//只定义一个变量时默认是第一个，没有定义全时，一一对应即可</span><br>  <span class="hljs-keyword">let</span> [first]=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(first)<span class="hljs-comment">//1</span><br>  <span class="hljs-keyword">let</span> [first,,third]=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(third)<span class="hljs-comment">//3</span><br>  <span class="hljs-comment">//2.解构对象</span><br>  <span class="hljs-keyword">let</span> o=&#123;<br>      <span class="hljs-attr">a</span>:<span class="hljs-string">&quot;a&quot;</span>,<br>      <span class="hljs-attr">b</span>:<span class="hljs-number">123</span>,<br>      <span class="hljs-attr">c</span>:<span class="hljs-string">&quot;cc&quot;</span><br>  &#125;<br>  <span class="hljs-keyword">let</span> &#123;a,b&#125;=o;<span class="hljs-comment">//一一对应</span><br>  <span class="hljs-comment">//用…声明剩余变量</span><br>  <span class="hljs-keyword">let</span> &#123;a,…passthrough&#125;=o;<br>  <span class="hljs-keyword">let</span> total=passthrough.<span class="hljs-property">b</span>+passthrough.<span class="hljs-property">c</span>.<span class="hljs-property">length</span><br>  <span class="hljs-comment">//属性重命名：在解构时可以对自定义的变量重新命名</span><br>  <span class="hljs-keyword">let</span> &#123;<span class="hljs-attr">a</span>:newName1,<span class="hljs-attr">b</span>:newName2&#125;=o;<span class="hljs-comment">//这里的冒号并不是指声明数据类型</span><br>  <span class="hljs-comment">//给解构变量声明数据类型:需要在整体后面加冒号，并且重新用括号一一制定</span><br>  <span class="hljs-keyword">let</span> &#123;a,b&#125;:&#123;<span class="hljs-attr">a</span>:<span class="hljs-built_in">string</span>,<span class="hljs-attr">b</span>:<span class="hljs-built_in">number</span>&#125;=o;<br>  <span class="hljs-comment">//4.默认值，目的是针对undfined的值有个缺省值</span><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">fun</span>(<span class="hljs-params"><span class="hljs-built_in">object</span>:&#123;a:<span class="hljs-built_in">string</span>,b?:<span class="hljs-built_in">number</span>&#125;</span>)&#123;<br>      <span class="hljs-keyword">let</span> &#123;a,b=<span class="hljs-number">100</span>&#125;=<span class="hljs-built_in">object</span>;<br>  &#125;<span class="hljs-comment">//b原来有个?表示undfined，现在object的b就有默认值不再是undfined了</span><br>  <span class="hljs-comment">//函数声明</span><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">&#123;a,b=<span class="hljs-number">0</span>&#125;=&#123;a=<span class="hljs-string">&quot;&quot;</span>&#125;</span>):<span class="hljs-built_in">void</span>&#123;<br>      ...<br>  &#125;<br>  <span class="hljs-comment">//从这里可以看出解构不仅仅是“别名”，若原来没有的还可以添加上去，比如这里的b而且还有缺省值</span><br>  <span class="hljs-title function_">f</span>(&#123;<span class="hljs-attr">a</span>:<span class="hljs-string">&quot;123&quot;</span>&#125;)--a=<span class="hljs-string">&quot;123&quot;</span>,b=<span class="hljs-number">0</span><br>  <span class="hljs-title function_">f</span>()----a=<span class="hljs-string">&quot;&quot;</span>,b=<span class="hljs-number">0</span><br>  <span class="hljs-title function_">f</span>(&#123;&#125;)----error, <span class="hljs-string">&#x27;a&#x27;</span> is required <span class="hljs-keyword">if</span> you supply an argument<br>  <span class="hljs-comment">//以上例子意思就是说不提供参数可以，因为都有缺省值可是已经确定提供参数了，那就说明不要缺省值，而你有没有替代缺省值的值，那肯定报错啊</span><br>  <span class="hljs-comment">//3.展开表达式：和解构相反，解构是将数据拆开来使用，而展开是将各个合并起来使用，展开指的是合并后的状态</span><br>  <span class="hljs-comment">//3.1 数组展开</span><br>  <span class="hljs-keyword">let</span> first = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>];<br>  <span class="hljs-keyword">let</span> second = [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br>  <span class="hljs-keyword">let</span> bothPlus = [<span class="hljs-number">0</span>,first,second,<span class="hljs-number">5</span>];<span class="hljs-comment">//0,1,2,3,4,5,浅拷贝，原来first second不会改变</span><br>  <span class="hljs-comment">//3.2 对象展开</span><br>  <span class="hljs-keyword">let</span> defaults = &#123; <span class="hljs-attr">food</span>: <span class="hljs-string">&quot;spicy&quot;</span>, <span class="hljs-attr">price</span>: <span class="hljs-string">&quot;$$&quot;</span>, <span class="hljs-attr">ambiance</span>: <span class="hljs-string">&quot;noisy&quot;</span> &#125;;<br>  <span class="hljs-keyword">let</span> search = &#123; ...defaults, <span class="hljs-attr">food</span>: <span class="hljs-string">&quot;rich&quot;</span> &#125;;<br>  <span class="hljs-comment">/*结果为food: &quot;spicy&quot;, price: &quot;$$&quot;, ambiance: &quot;noisy&quot;，food: &quot;rich&quot;</span><br><span class="hljs-comment">    但是 如果声明为 let search = &#123; food: &quot;rich&quot;, ...defaults &#125;;</span><br><span class="hljs-comment">    添加进来的若有重名的会替换，即只有一个后面的food</span><br><span class="hljs-comment">  */</span><br>  <span class="hljs-comment">//对象展开还有个限制：展开对象实例时只能访问属性无法访问方法</span><br>  <span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> &#123;<br>    p = <span class="hljs-number">12</span>;<br>    <span class="hljs-title function_">m</span>(<span class="hljs-params"></span>) &#123;<br>   &#125;<br>  &#125;<br> <span class="hljs-keyword">let</span> c = <span class="hljs-keyword">new</span> <span class="hljs-title function_">C</span>();<br> <span class="hljs-keyword">let</span> clone = &#123; ...c &#125;;<br> clone.<span class="hljs-property">p</span>; <span class="hljs-comment">// ok</span><br> clone.<span class="hljs-title function_">m</span>(); <span class="hljs-comment">// error!</span><br></code></pre></td></tr></table></figure><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">//1.接口初探：接口只是代表着一种对象的规范</span><br><span class="hljs-comment">//一般用于类型检查，即传过来的对象是是否符合规范，检查规则是是否包含接口中的属性，顺序可以不一样</span><br><span class="hljs-keyword">interface</span> labeledValue&#123;<br>    <span class="hljs-attr">label</span>:<span class="hljs-built_in">string</span>;<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">printLabel</span>(<span class="hljs-params">labeledObj:labeledValue</span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(labeledObj.<span class="hljs-property">label</span>)<br>&#125;<br><span class="hljs-keyword">let</span> myObj=&#123;<span class="hljs-attr">size</span>:<span class="hljs-number">10</span>,<span class="hljs-attr">label</span>:<span class="hljs-string">&quot;Size 10 Object&quot;</span>&#125;<br><span class="hljs-title function_">printLabel</span>(myObj)<br>------------------------------------------------------------------------------------<br><span class="hljs-comment">//2.可选属性：接口中属性的?表示可选，和没有可选属性的接口的区别是：有可选属性的接口的属性个数通常大于等于传入对象属性的个数，而没有可选属性的接口的属性个数通常小于等于传入对象属性的个数</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">SquareConfig</span> &#123;<br>  color?: <span class="hljs-built_in">string</span>;<br>  width?: <span class="hljs-built_in">number</span>;<br>&#125;<br><span class="hljs-comment">//注意：对象在声明时属性之间是分号，实例化之后是逗号</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">createSquare</span>(<span class="hljs-params">config: SquareConfig</span>): &#123;<span class="hljs-attr">color</span>: <span class="hljs-built_in">string</span>; <span class="hljs-attr">area</span>:<span class="hljs-built_in">number</span>&#125; &#123;<br>  <span class="hljs-keyword">let</span> newSquare = &#123;<span class="hljs-attr">color</span>: <span class="hljs-string">&quot;white&quot;</span>, <span class="hljs-attr">area</span>: <span class="hljs-number">100</span>&#125;;<br>  <span class="hljs-keyword">if</span> (config.<span class="hljs-property">color</span>) &#123;<br>    newSquare.<span class="hljs-property">color</span> = config.<span class="hljs-property">color</span>;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (config.<span class="hljs-property">width</span>) &#123;<br>    newSquare.<span class="hljs-property">area</span> = config.<span class="hljs-property">width</span> * config.<span class="hljs-property">width</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> newSquare;<br>&#125;<br><span class="hljs-keyword">let</span> mySquare = <span class="hljs-title function_">createSquare</span>(&#123;<span class="hljs-attr">color</span>: <span class="hljs-string">&quot;black&quot;</span>&#125;);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(mySquare)<br>------------------------------------------------------------------------------------<br><span class="hljs-comment">//3.只读属性：</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Point</span> &#123;<br>    <span class="hljs-keyword">readonly</span> <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>;<br>    <span class="hljs-keyword">readonly</span> <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span>;<br>&#125;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">p1</span>: <span class="hljs-title class_">Point</span> = &#123; <span class="hljs-attr">x</span>: <span class="hljs-number">10</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">20</span> &#125;;<br>p1.<span class="hljs-property">x</span> = <span class="hljs-number">5</span>; <span class="hljs-comment">// error!</span><br><span class="hljs-comment">//readOnly是针对属性的，而const是针对变量的</span><br><span class="hljs-comment">//4.额外的属性检查</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">SquareConfig</span> &#123;<br>    color?: <span class="hljs-built_in">string</span>;<br>    width?: <span class="hljs-built_in">number</span>;<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">createSquare</span>(<span class="hljs-params">config: SquareConfig</span>): &#123; <span class="hljs-attr">color</span>: <span class="hljs-built_in">string</span>; <span class="hljs-attr">area</span>: <span class="hljs-built_in">number</span> &#125; &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><span class="hljs-keyword">let</span> mySquare = <span class="hljs-title function_">createSquare</span>(&#123; <span class="hljs-attr">colour</span>: <span class="hljs-string">&quot;red&quot;</span>, <span class="hljs-attr">width</span>: <span class="hljs-number">100</span> &#125;);<span class="hljs-comment">//故意把color拼错</span><br><span class="hljs-comment">//此时ts会进行额外的属性检查：既然传入了一个两个属性的对象，那么ts就会注意检查是否和定义的两个属性的数据类型一样，如果只有width属性是可以的，因为color是可选的。简而言之，就是可选属性是指少一些属性可以，但是如果不少那么类型必须一样否则报错</span><br><span class="hljs-comment">//4.1 也可以绕开属性检查，方法一-----类型断言（强制类型转换）</span><br><span class="hljs-keyword">let</span> mySquare = <span class="hljs-title function_">createSquare</span>(&#123; <span class="hljs-attr">opacity</span>: <span class="hljs-number">0.5</span>, <span class="hljs-attr">width</span>: <span class="hljs-number">100</span> &#125; <span class="hljs-keyword">as</span> <span class="hljs-title class_">SquareConfig</span>);<br><span class="hljs-comment">//转换了之后参数就变为只有width的SquareConfig，可选属性就用上了</span><br><span class="hljs-comment">//4.3 方法二-----加一个索引签名：就是就是键值对（对象的属性本来就是键值对的形式定义的）</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">SquareConfig</span>&#123;<br>    color?: <span class="hljs-built_in">string</span>;<br>    width?: <span class="hljs-built_in">number</span>;<br>    [<span class="hljs-attr">propName</span>:<span class="hljs-built_in">string</span>]:<span class="hljs-built_in">any</span>;<span class="hljs-comment">//键为字符串，值为任意类型</span><br>&#125;<br><span class="hljs-comment">//4.4 方法三----对象赋值给另外一个变量（就好比原来是匿名对象后来有名字了）</span><br><span class="hljs-keyword">let</span> squareOptions=&#123; <span class="hljs-attr">colour</span>: <span class="hljs-string">&quot;red&quot;</span>, <span class="hljs-attr">width</span>: <span class="hljs-number">100</span> &#125;;<br><span class="hljs-keyword">let</span> mySquare = <span class="hljs-title function_">createSquare</span>(squareOptions);<br>------------------------------------------------------------------------------------<br><span class="hljs-comment">//5.使用接口也可以定义函数</span><br><span class="hljs-keyword">interface</span> searchFunc&#123;<br>    (<span class="hljs-attr">source</span>:<span class="hljs-built_in">string</span>,<span class="hljs-attr">subString</span>:<span class="hljs-built_in">string</span>):<span class="hljs-built_in">boolean</span>;<br>&#125; <br><span class="hljs-keyword">let</span> <span class="hljs-attr">mySearch</span>:searchFunc;<br>mySearch=<span class="hljs-keyword">function</span>(<span class="hljs-params">src:<span class="hljs-built_in">string</span>,sub:<span class="hljs-built_in">string</span></span>):<span class="hljs-built_in">boolean</span>&#123;<span class="hljs-comment">//名字可以不一样，重要的是检查类型</span><br>    <span class="hljs-keyword">let</span> result=src.<span class="hljs-title function_">search</span>(subString);<br>    retrurn result&gt;-<span class="hljs-number">1</span>;<br>&#125;<span class="hljs-comment">//mySearch(参数一，参数二)调用</span><br><span class="hljs-comment">//5.1 如果如果参数类型或返回值类型没写，ts还可以推断，在调用时根据传入的参数来判断然后再检查</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">mySearch</span>: <span class="hljs-title class_">SearchFunc</span>;<br>mySearch = <span class="hljs-keyword">function</span>(<span class="hljs-params">src, sub</span>) &#123;<br>    <span class="hljs-keyword">let</span> result = src.<span class="hljs-title function_">search</span>(sub);<br>    <span class="hljs-keyword">return</span> result &gt; -<span class="hljs-number">1</span>;<br>&#125;<br>------------------------------------------------------------------------------------<br><span class="hljs-comment">//6. 接口还可以定义可索引的类型（索引签名）</span><br><span class="hljs-keyword">interface</span> stringArray&#123;<br>    [<span class="hljs-attr">index</span>:<span class="hljs-built_in">number</span>]:<span class="hljs-built_in">string</span>;<br>&#125;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">myArray</span>:stringArray;<br>myArray=[<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>];<br><span class="hljs-keyword">let</span> myStr=myArray[<span class="hljs-number">0</span>];<br><span class="hljs-comment">//6.1 索引签名分为数值型和字符串型，接口可以同时定义这两个，（好像）但是名字要一样，于是最后只会用一个</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span>&#123;<br>    <span class="hljs-attr">name</span>:<span class="hljs-built_in">string</span>;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Animal</span>&#123;<br>    <span class="hljs-attr">breed</span>:<span class="hljs-built_in">string</span>;<br>&#125;<br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">NotOk</span>&#123;<br>    <span class="hljs-comment">//错误，数值型索引签名的返回值必须为字符串型索引签名的返回值的子类型，因为使用number来索引时，js会默认将数值型转换为字符串型然后再去索引对象，也就是说1最后会被当做&quot;1&quot;</span><br>    [<span class="hljs-attr">x</span>:<span class="hljs-built_in">number</span>]:<span class="hljs-title class_">Animal</span>;        [<span class="hljs-attr">x</span>:<span class="hljs-built_in">number</span>]:<span class="hljs-title class_">Dog</span>;---ok<br>    [<span class="hljs-attr">x</span>:<span class="hljs-built_in">string</span>]:<span class="hljs-title class_">Dog</span>;           [<span class="hljs-attr">x</span>:<span class="hljs-built_in">string</span>]:<span class="hljs-title class_">Animal</span>;----ok<br>    <span class="hljs-comment">//其实就是如下所示：上面的number变为string以后，如果传入的是100，那么就会变成&quot;100&quot;，第一个满足，则使用第一个类型，如果本来传入的就是&quot;100&quot;,那么就用第二个（此时第一个还是number，只有传入是数字型第一个才为字符型），后面的子类是为了 当都是string型时优先用子类的（多态）</span><br>    [<span class="hljs-attr">x</span>:<span class="hljs-built_in">string</span>]:<span class="hljs-title class_">Dog</span>; <br>    [<span class="hljs-attr">x</span>:<span class="hljs-built_in">string</span>]:<span class="hljs-title class_">Animal</span>;   <br>&#125;<br><span class="hljs-comment">//6.2 其中字符串索引声明还指明了接口属性的返回值，如果有属性返回值与字符串索引返回值不一致则会报错，可以把接口中的字符串索引当作是其他属性的规范,因为属性名默认都是string类型的</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">NumberDictionary</span>&#123;<br>    <span class="hljs-keyword">readonly</span> [<span class="hljs-attr">index</span>:<span class="hljs-built_in">string</span>]:<span class="hljs-built_in">number</span>;<span class="hljs-comment">//readonly加上可以不能被修改</span><br>    <span class="hljs-attr">length</span>:<span class="hljs-built_in">number</span>;<br>    <span class="hljs-attr">name</span>:<span class="hljs-built_in">string</span>;<span class="hljs-comment">//错误，应该为number</span><br>&#125;<br>------------------------------------------------------------------------------------<br><span class="hljs-comment">//7.和java一样可以用类实现接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">ClockInterface</span> &#123;<br>    <span class="hljs-attr">currentTime</span>: <span class="hljs-title class_">Date</span>;<br>    <span class="hljs-title function_">setTime</span>(<span class="hljs-attr">d</span>: <span class="hljs-title class_">Date</span>);<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Clock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ClockInterface</span> &#123;<br>    <span class="hljs-attr">currentTime</span>: <span class="hljs-title class_">Date</span>;<br>    <span class="hljs-title function_">setTime</span>(<span class="hljs-params">d: <span class="hljs-built_in">Date</span></span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">currentTime</span> = d;<br>    &#125;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">h: <span class="hljs-built_in">number</span>, m: <span class="hljs-built_in">number</span></span>) &#123; &#125;<br>&#125;<br>------------------------------------------------------------------------------------<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Ts</category>
      
    </categories>
    
    
    <tags>
      
      <tag>语法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Angular更新版本的注意点</title>
    <link href="/2023/08/30/Angular%E6%9B%B4%E6%96%B0%E7%89%88%E6%9C%AC%E7%9A%84%E6%B3%A8%E6%84%8F%E7%82%B9/"/>
    <url>/2023/08/30/Angular%E6%9B%B4%E6%96%B0%E7%89%88%E6%9C%AC%E7%9A%84%E6%B3%A8%E6%84%8F%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<p>1.自Angular V5起，不赞成使用@angular/http中的HttpModule和Http，而应改用@angular/common/http中的HttpClientModule和HttpClient</p><p>2.”@angular/platform-browser”: “^14.1.0”,</p><p>  “@angular/platform-browser-dynamic”: “^14.1.0”,</p><p>​    这两个都是和在浏览器上启动相关</p><p>3.file-saver是用于文件导出的，任何到处都要用到</p><p>4.angularjs的i18n是国际化，可以将英文翻译成中文</p><p>5.keycloak-js可以使得采用授权码方式登录账号</p><p>6.matomo-js用于统计网络数据</p><p>7.想安装开发依赖，要用–save-dev（就一个杠），想安装运行必须要的，则–save</p><p>8.最大的收获：修改bug要一个一个来，这样也容易寻找错误原因，切勿急躁</p><p>9.函数内var定义的变量是没有局部变量之说，在函数内都是可用的</p><p>10.<code>Observable.if</code>和 <code>Observable.throw</code> 这些方法已由 static 代替 <code>iif()</code>和 <code>throwError()</code>function</p><p>11.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-title class_">Observable</span>.<span class="hljs-keyword">throw</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>());<br><span class="hljs-comment">// becomes</span><br><span class="hljs-title function_">throwError</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>());<br></code></pre></td></tr></table></figure><p>12.namespace区域内的 声明 是为了 想要使用同名但不同功能的 属性或函数</p><p>13.在追踪bug时，一定要去找源头，比如数据没显示很可能是 本来就没有，而不是一直看显示方式问题</p>]]></content>
    
    
    <categories>
      
      <category>前端框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Angular</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Angular知识点</title>
    <link href="/2023/08/30/Angular/"/>
    <url>/2023/08/30/Angular/</url>
    
    <content type="html"><![CDATA[<p><strong>以下是我学习Angular的记录，虽然有些杂，但是是针对的遗漏的知识点进行的查漏补缺</strong></p><p>1.管道对于一些数据的格式化显示很方便<br>2.类或接口可以直接写在ts中，用export导出即可<br>3.在声明属性时，如果不初始化，可以在变量名后面加一个可选符号?，这样便可以去除异常了<br>4.如果数据的显示刚开始为空，后面不为空，则可以使用*ngIf来控制显示<br>5.要是动态属性都是加[]，[class.selected]=”hero === selectedHero”这指的是类选择器里面的.selected样式类<br>6.关于服务<br>  1）让服务去请求数据，这样的话所有组件都可以从服务中获取请求的数据<br>  2）通过依赖注入的方式，而不是new的方式，声明更方便，耦合度更低</p><p>7.关于Rxjs</p><p>  1）of(data)可以将data转换成Obserable对象</p><ol start="2"><li> 在订阅时subscribe里面的回调函数连函数的()都可以不用写</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">this</span>.<span class="hljs-property">heroService</span>.<span class="hljs-title function_">getHeroes</span>().<span class="hljs-title function_">subscribe</span>(<br>        <span class="hljs-function"><span class="hljs-params">heroes</span> =&gt;</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">heroes</span> = heroes<br>     )<br></code></pre></td></tr></table></figure><p>8.原来可以服务中再注入其他服务</p><p>9.依赖注入时 前面写private和pubic的区别：</p><p>   private只能在当前类中使用，而public在类外也可以使用，比如组建的HTML文件中</p><p>10.在字符串中传递参数时，有两个注意点:</p><p>​    1.需要用反单引号，这样才能识别参数</p><p>​    2.用${}来传递，和mybatis类似，只不过用$，可能是为了区分</p><p>11.关于app-routing.module.ts中的RouterModule.forRoot(routes)</p><p>forRoot 这么命名是因为我实在顶层(根部)配置路由的，这个方法可以提供给路由服务提供着和指令</p><ol start="12"><li><p>slice 原来还可以对数组操作，左闭右开，(1,5)表示第1-4个元素(英雄)</p></li><li><p>pathMatch:’full’指的是必须与路径完全匹配才会跳转</p><p>  另一个参数’prefix’是指路由中有path就可以</p><p>  举个例子： { path:’a’,redirectTo:’/dialog’,pathMatch:’prefix’},</p><p>  1.<a href="http://localhost:9800/a">http://localhost:9800/a</a></p><p>  2.<a href="http://localhost:9800/a/sadf/adfs/">http://localhost:9800/a/sadf/adfs/</a></p><p>  都会被重定向，但是</p><p>  <a href="http://localhost:9800/asdfsdf">http://localhost:9800/asdfsdf</a> —不可以，必须得是/a/</p><ol><li>full和prefix的区别：前者通常要整个路径匹配，而prefix既然是前缀，因此这个地址很可能在中间</li></ol></li><li><p>英雄案例使用动态路由的原因</p><p>点击需要跳转英雄详情页面，因此需要路由，又因为诶个英雄都有id，因此是动态路由</p></li><li><p>ngFor循环中的id原来在它本层也可以直接用(相当于是前c++中for循环的i++)，之前还以为只能在内层中使用</p></li><li><p>HEROES.find(h =&gt; h.id === id)关于函数表达式的解释</p><p>js中数组的find方法的第一个参数就是一个函数，这个函数需要有判断的性质来告诉find方法怎么查找</p></li><li><p>关于ts</p><p>在一个变量后面加上!表示当前变量排除null或undefined的取值</p></li><li><p>当代码中有一个错误怎么也找不到原因，那就很可能不是逻辑错误，这时候就不要把重心放在一些关键代码上而是一些 无关紧要细节，比如导包导错或未导包，如下就是未导location的包，导致路由跳转异常，连默认路由都跳转不过去</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//这个Location是angular中的依赖，有一个同名的接口，直接写不导入包的话那么用的就是那个接口！！！</span><br>private <span class="hljs-attr">location</span>: <span class="hljs-title class_">Location</span><br></code></pre></td></tr></table></figure></li><li><p>Number(this.route.snapshot.paramMap.get(‘id’))的代码解释：</p><p>1.snapshot指快照，对路由路径的保存</p><p>2.保存好了之后，paramMap用来获取路径中的参数，可以看出是个哈希结构因此用get按照键来取</p><p>3.路径中取到的默认是字符串，要用Number转化成数字类型</p></li><li><p>… 可以将数组的[]去掉，变成一个个零散的元素 value1,value2,value3，因为max只支持这样的参数</p><p>… 还可以用在 对象中，将…obj放入新的对象中，那么可以将多个属性组合成一个新的对象，这对于利用现有的对象组成新对象很方便</p></li><li><p>函数表达式如果箭头后面仅仅只有一个值，那么这个就是要返回的值</p></li><li><p>数组有一个map方法，可以在不修改原数组的情况下返回一个新数组，规则来自第一个参数（回调函数）</p></li><li><p>angular中get请求数据：this.http.get&lt;Hero[]&gt;(this.heroesUrl)   </p><p>​                                          private heroesUrl = ‘api/heroes’;  // URL to web api</p><p>1.由于get返回的也是一个obserable对象，但是不够明确（默认是一个无类型的Json数据），加个&lt;Hero[]&gt;，表示返回的是 obserable&lt;Hero[]&gt;对象</p><p>2.那么后面那个括号就是请求的地址</p><p>3.heroesUrl的前面api是模拟服务器默认地址，后面的heroes是里面数据库返回的数据名</p></li><li><p>关于模拟服务器数据（在内存中划分一块区域来存储）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//内存网络API模块，用来模拟服务请求与响应，包含内存数据服务，后面那个是数据封装，暂时不要</span><br><span class="hljs-title class_">HttpClientInMemoryWebApiModule</span>.<span class="hljs-title function_">forRoot</span>(<br>   <span class="hljs-title class_">InMemoryDataService</span>, &#123; <span class="hljs-attr">dataEncapsulation</span>: <span class="hljs-literal">false</span> &#125;<br>  )<br></code></pre></td></tr></table></figure></li><li><p>HttpClient的方法只返回单个值</p></li></ol><p>​      通常Observable在可以在一段时间内返回多个值，但是HttpClient比如http.get()就只能返回一个值，因此服务器那边要下次把要相应的数据准备好</p><p> 27.函数箭头表达式：本质上是用lambda表达式来表示一个匿名函数</p><p>​     () =&gt; {}、x =&gt; {} （只有一个参数可以去掉括号）、(x,y) =&gt; {}</p><p>​     当函数体中只有一条语句，则可以省略不写；只有一个参数但是要写类型的话必须加()</p><ol start="28"><li><p>tap(_ =&gt; this.log(‘fetched heroes’))—tap(窥视)能窥探Obervable数据流，并用log打印</p></li><li><p>由于大多Web API都支持 :BaseUrl/:id 的形式根据id获取对象，其实是因为我的英雄对象中包含id这个属性，因此我可以通过get请求来直接获取特定的英雄：</p><p>  const url =  <code>$&#123;this.heroesUrl&#125;/$&#123;id&#125;</code></p><p>  return this.http.get<Hero>(url)</p></li><li><p>在更新服务器数据时，需要一个请求头，不让浏览器认为是爬虫，可以认为是一个反爬虫机制</p><p>return this.http.put(this.heroesUrl, hero, this.httpOptions)</p></li><li><p>```js<br>httpOptions = {<br>  headers: new HttpHeaders({ ‘Content-Type’: ‘application/json’ })<br>};</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br>    千万要注意这个请求头new的是HttpHeaders而不是Headers，不报错很容出错<br><br>32. ```js<br>       &lt;input <span class="hljs-built_in">id</span>=<span class="hljs-string">&quot;new-hero&quot;</span> <span class="hljs-comment">#heroName&gt;</span><br>       &lt;button <span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;button&quot;</span> class=<span class="hljs-string">&quot;add-button&quot;</span> (click)=<span class="hljs-string">&quot;add(heroName.value);heroName.value = &#x27;&#x27;&quot;</span>&gt;&lt;/button&gt;<br></code></pre></td></tr></table></figure><p>1.原来HTML中的元素可以在当前页面通过#相互引用</p><p>2.原来(click)点击事件里面不止可以写函数，也可以直接写执行的操作，还可以用分号隔开放一起写</p></li><li><p>在添加 用户输入的数据时，要先trim()一下看是否为空，若为空则本来就没有输入，这样就可以直接结束函数了</p></li><li><p>想要将基础类型转化为对象类型，必须先得在这个基础类型外面加一个{}先把格式统一然后转化就很方便</p></li><li><p>正常进行post请求之后是会返回来提交的对象给回调函数的，方便再使用</p></li><li><p>http的put、delete、post都需要请求头，因为需要修改值，但是get不需要</p></li><li><p>http的这些请求有没有返回值就看有没有指出泛型类型，比如put就没有，而get&lt;Hero[]&gt;、post<Hero>、delete<Hero>都有</p></li><li><p>直接通过get的?name=xxx便可查询所有name为xxx的英雄</p><p>return this.http.get&lt;Hero[]&gt;(<code>$&#123;this.heroesUrl&#125;/?name = $&#123;term&#125;</code>)</p></li><li><p>由于ngFor里面不支持obserable对象，而这里想直接显示从服务器返回的结果，因此需要管道|转换为async，它会自动订阅，不用再组件中subscribe了 </p><li *ngFor="let hero of heroes$ | async"></li><li><p>Subject本身是Obsevrable对象，但是用法和promise类似（用next发出消息）</p></li><li><p>一般要把项目传输给别人时，node_modules文件夹是不传的，因为这个包大而，而且子文件分得太细了，系统要根据路径去找还得花时间，因此传输效率低</p></li><li><p>关于搜索请求，return this.http.get&lt;Hero[]&gt;(<code>$&#123;this.heroesUrl&#125;/?name=$&#123;term&#125;</code>)</p></li></ol><p>​       这里name=${term}多一个空格都不行，就像是sql语句一样，而且这个竟然是模糊查询</p><p> 43.为了避免请求次数过多，而作的请求限制</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// searchTerms 发送请求，再通过pipe处理一下数据，真正通过switchMap请求</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">heroes$</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">searchTerms</span>.<span class="hljs-title function_">pipe</span>(<br><br>    <span class="hljs-comment">// 每次请求要间隔300ms</span><br>    <span class="hljs-title function_">debounceTime</span>(<span class="hljs-number">300</span>),<br><br>    <span class="hljs-comment">// 只有在值变化才会请求</span><br>    <span class="hljs-title function_">distinctUntilChanged</span>(),<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 每一次请求都会换(switch)一个新的Observable对象请求</span><br><span class="hljs-comment">     * 虽然每隔至少300ms再请求，但是仍有一些请求没有得到相应(服务器忙不过来了)，此时就取最近的一次返回结果</span><br><span class="hljs-comment">     *  */</span><br>    <span class="hljs-title function_">switchMap</span>( <span class="hljs-function">(<span class="hljs-params">term:string</span>) =&gt;</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">heroService</span>.<span class="hljs-title function_">searchHeroes</span>(term))<br></code></pre></td></tr></table></figure><p>  44.引入样式时，最上面的会覆盖下面引入的样式表</p><p>  45.每引入一个组件样式，都需要在app.module.ts中引入</p><p>  46.什么是git？git bash？git shell？</p><p>​       git：分布式的版本控制工具</p><p>​       shell：linux、unix系统的外壳，用于执行一些命令</p><p>​       bash：最常见的shell</p><p>​       git bash：方便在windows环境下运行get命令</p><p>  47.切换路由时不变的部分放在父组件中即可，比如nav元素包含的部分</p><p>  48.设置路由时，path:’’和path:’**’的区别：</p><p>​       前者是默认路由，即localhost:4200，后者是前面都没有匹配才跳转的路由，通常放最后</p><p>  49.一个组件只能引入到一个Module中，若引入多个模块会报错</p><p>  50.可以专门为某一块部分专门设置 它的 路由和module，这样各个组成部分更独立</p><ol start="51"><li><p>imports: [RouterModule.forChild(routes)]</p><p>在特定路由中，这些路由就不是给根组件用的，而是某个孩子组件，因此是forChild</p></li><li><p>在获取动态路由中的id时，有两种方法：</p><p>使用ParamMap，可以复用子组件的实例（HeroDetailComponent）</p><p>使用snapshop，每次都是新的实例（每次复制一份）</p></li><li><p>当碰到 非常奇怪的bug（按正常逻辑无法排除出来）时，很有可能是模块引入的错误！</p></li><li><p>引入模块有两个原则：</p><p>1）一定是大的包含小的（比如 跟模块引入特殊模块）</p><p>2）要清楚是哪个模块需要哪个模块</p></li><li><p>想要 通过路由跳转到另一个页面（也可携带参数）用的是 Router服务，而想获取被选中数据的某些信息用的是ActivatedRouter服务</p></li><li><p>如何给路由添加动画？</p><p>1）在app.module.ts中添加BrowserAnimationsModule</p><p>2）在路由设置中每个路由后面加个data对象，利用里面的animiation名字来确定转场的对象</p><p>3）新建一个animinations.ts文件确定 动画触发器等具体动画内容</p><p>4）在需要转场的html中用一个div将routerOutlet包起来，加上@routeAnimation属性，用一个函数赋值来寻找转场对象值进行转场</p></li><li><p>设置子路由的目的就是 想要让子组件进行路由切换，而父路由保持不变</p></li><li><p>在路由设置中父子路由，那么父路由的path就是整个路由的前缀</p><p>比如：</p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;crisis-center&#x27;</span>,<br><span class="hljs-attr">component</span>: <span class="hljs-title class_">CrisisCenterComponent</span>,<br><span class="hljs-attr">children</span>: [<br>      &#123;<br>        <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br>            ……<br></code></pre></td></tr></table></figure><p>子路由为’ ‘，则整个路由地址就为 crisis-center/，也就是说子路由不用写斜杠，即子路由是在父路由路径的基础上做出的扩展</p><p>  60.当项目模块很多设置路由时，可以在顶层路由只设置 默认路由和通配符路由，其他模块的放在各模块的路由配置文件中，最后再将各个模块包含起来即可</p><p>  61.如果路径中 特定父路由突然发生了变化，那么就要在路由设置中进行修改，于是就有了 相对路由的写法，在跳转路由时不用写绝对路径</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">this</span>.<span class="hljs-property">router</span>.<span class="hljs-title function_">navigate</span>([<span class="hljs-string">&#x27;../&#x27;</span>,&#123;<span class="hljs-attr">id</span>: crisisId, <span class="hljs-attr">foo</span>: <span class="hljs-string">&#x27;foo&#x27;</span>&#125;], &#123;<span class="hljs-attr">relativeTo</span>:<span class="hljs-variable language_">this</span>.<span class="hljs-property">activedRoute</span>&#125;)<br></code></pre></td></tr></table></figure><p>  这里需要提供activedRoute来告诉编译器当前在什么位置，然后通过../再往上一层，最后再加上id</p><p>  62.在同一页面 只可以出现一个无名路由（没有name属性的值），但是可以有多个有名路由（这样就可以区分了）</p><p>  63.原来看两个组件是否是父子组件关系，直接看文件夹的包含关系</p><p>  64.怎么知道 哪个路由设置中的路由会在哪个outlet中进行切换？</p><p>  在父组件对应的路由配置中 设置子组件的路由，然后在父组件的html中加上outlet，表示这些都是子组件的路由出口</p><ol start="65"><li> 主路由(出口)：一个HTML中从上往下第一个outlet出口</li></ol><p>​        第二路由(出口）：一个HTML中从上往下第二个outlet出口</p><p>​        修改主路由并不会改变第二路由，因为那仅仅是切换了主路由而已</p><p> 66.this.route.navigate([{ outlets: { popup: null}}])</p><p>​      这里是通过将该路由的出口设置成null来阻断跳转，即不显示该路由跳转的页面</p><p> 67.路由守卫：在路由跳转之前处理一些数据或认证，或者决定是否跳转</p><p> 68.如果本身文件夹不是包含关系，是平级的，router-oulet在任意一个子组件也想要设置一个父子路由关系，那么这时就需要在父组件的（配置总是在父组件中）路由配置文件中用children手动设置关系</p><p> 69.devDependence和dependence的区别：</p><p>​       前者是开发时的用到的依赖，而后者是项目运行时用到的依赖，比如脚手架它就是只在开发时采用的到，所以只存在于devDependence中</p><p>70.目录结构不用 和 嵌套路由的结构保持一致</p><p>71.特征路由是和特征模块放一块的，里面指明了这个模块所有组件的路由</p><p>72.嵌套路由 和 和router-outlet的位置有关：</p><p>​     每个父路由组件的HTML中都要提供一个router-outlet来给它的子路由进行切换</p><p>73.创建特定模块顺便创建对应的路由：ng g module xxx –routing</p><p>74.才理解 路由配置中path:’ ‘ 为什么一定要加match:’full’ 了</p><p>​     full的意思是一直匹配到最后，与之对立的prefix则只要这个path在整个路径中存在就行了</p><p>​     因为如果不加full，则‘ ’可以作为中间路径（由于是空的等于没加，直接可跳转任何地址），然后后面可以加任何地址，因此空地址通常都要加full</p><p>75.[routerLinkActiveOptions]=”{exact: true}”就等于上面说的pathMatch:’full’通常是对空地址的限制</p><p>76.无组件路由：用于分组，层次更清晰，还可保护子路由（为什么暂时不清楚）</p><p>77.要记住加了[]的都是动态属性，是需要在ts中自己自定义变量的</p><p>78.pipe里面的tap函数不只是用来打印数据，也可以用来处理其他的逻辑（处理变量值）</p><p>79.RouterStateSnapshot指的是路由在某个点的瞬时路由状态信息，包含url和toString</p><p>​      而ActivatedRouteSnapshot，也包含当前的路由地址，但还包括组件的其他服务更多一些</p><p>80.字符串连接如果要和三元字符一起使用的话，后面的括号 要全包起来，因为是整体最终的结果才构成一个字符串，然后再拼接</p><p>81.总结一下 如何使用 canActivated 对登录 进行身份验证（守卫）：</p><p>​    1.添加守卫的module和routing——守卫也是个模块，也就有路由（用来设置重定向的路由地址）</p><p>​    2.添加 一个 canActivatied 的 guard</p><p>​    3.在路由配置中把想要进行守卫的路由后面加一个canActivatied :[添加的守卫名称]</p><p>​     4.在 guard文件里面加入 具体验证的逻辑（另在函数中写的），它只提供当前URL等信息，其中也是要调用 守卫的服务的（另外创建，包含登陆变量、打印、登入登出函数），若未登录则重定向到登陆页面</p><p>​    5.添加登陆页面以及组件（登陆成功则跳转首页）</p><p>82.守护一个路由但是它的子路由却保护不到，如何更方便地保护子路由？</p><p>1）在要保护的子路由的父路由添canActivatedChild:[添加的守卫名称]</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs typescript">&#123;<br>      <span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;admin&#x27;</span>,<br>      <span class="hljs-attr">component</span>:<span class="hljs-title class_">AdminComponent</span>,<br>      <span class="hljs-comment">// 在跳转之前加个身份验证</span><br>      <span class="hljs-attr">canActivate</span>:[<span class="hljs-title class_">AuthGuard</span>],<br>      <span class="hljs-attr">children</span>:[<br>         &#123;<br>          <span class="hljs-comment">// 无组件路由，用于分组，层次更清晰，也可保护子路由</span><br>            <span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;&#x27;</span>,<br>            <span class="hljs-comment">// 表示对下面所有的孩子进行守卫</span><br>            <span class="hljs-attr">canActivateChild</span>:[<span class="hljs-title class_">AuthGuard</span>],<br>            <span class="hljs-attr">children</span>:[<br>               &#123; <span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-attr">component</span>:<span class="hljs-title class_">AdminDashboardComponent</span> &#125;,<br><br>               &#123; <span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;crises&#x27;</span>, <span class="hljs-attr">component</span>:<span class="hljs-title class_">ManageCrisesComponent</span> &#125;,<br><br>               &#123; <span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;heroes&#x27;</span>, <span class="hljs-attr">component</span>:<span class="hljs-title class_">ManageHeroesComponent</span> &#125;,<br>            ]<br>         &#125;<br>      ]<br>    &#125;<br></code></pre></td></tr></table></figure><p>2）在guard文件中，添加实现canActivatedChild（这样就可以用一个guard来实现多个守卫了），添加守护子路由接口canActivatedChild，因为此时 子路由有子路由的 函数参数，因此直接调用前面守护路由的 函数就行了</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AuthGuard</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">CanActivate</span>,<span class="hljs-title class_">CanActivateChild</span> &#123;<br>...<br><span class="hljs-title function_">canActivateChild</span>(<br>    <span class="hljs-attr">route</span>: <span class="hljs-title class_">ActivatedRouteSnapshot</span>,<br>    <span class="hljs-attr">state</span>: <span class="hljs-title class_">RouterStateSnapshot</span>): <span class="hljs-title class_">Observable</span>&lt;<span class="hljs-built_in">boolean</span> | <span class="hljs-title class_">UrlTree</span>&gt; | <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">boolean</span> | <span class="hljs-title class_">UrlTree</span>&gt; | <span class="hljs-built_in">boolean</span> | <span class="hljs-title class_">UrlTree</span> &#123;<br>    <span class="hljs-comment">// console.log(&#x27;AuthGuard canActivated called&#x27;)</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">canActivate</span>(route,state);<br>  &#125;<br><br></code></pre></td></tr></table></figure><p>83.任何的具体的逻辑实现都是写在服务中的</p><p>84.canDeactivate是用来 是否允许离开的，通常是需要加个确认框的判断，如果符合条件就可以离开当前路由，否则还是停留在当前路由</p><h4 id="Angular官网英雄之旅练习案例：https-gitee-com-zhoujielovesinging-angulars-heroic-journey"><a href="#Angular官网英雄之旅练习案例：https-gitee-com-zhoujielovesinging-angulars-heroic-journey" class="headerlink" title="Angular官网英雄之旅练习案例：https://gitee.com/zhoujielovesinging/angulars-heroic-journey"></a>Angular官网英雄之旅练习案例：<a href="https://gitee.com/zhoujielovesinging/angulars-heroic-journey">https://gitee.com/zhoujielovesinging/angulars-heroic-journey</a></h4>]]></content>
    
    
    <categories>
      
      <category>前端框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Angular</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端面试题(持续更新)</title>
    <link href="/2023/08/30/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/"/>
    <url>/2023/08/30/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="1px物理像素的实现"><a href="#1px物理像素的实现" class="headerlink" title="1px物理像素的实现"></a>1px物理像素的实现</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;title&gt;1px物理像素的实现&lt;/title&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="language-css"><span class="language-xml">      *&#123;Lcrouny Si/WKS/Wistron</span></span><br><span class="language-css"><span class="language-xml">        <span class="hljs-attribute">margin</span>:<span class="hljs-number">0</span>;</span></span><br><span class="language-css"><span class="language-xml">        <span class="hljs-attribute">padding</span>:<span class="hljs-number">0</span>;</span></span><br><span class="language-css"><span class="language-xml">      &#125;</span></span><br><span class="language-css"><span class="language-xml">      <span class="hljs-selector-id">#box</span>&#123;</span></span><br><span class="language-css"><span class="language-xml">        <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;</span></span><br><span class="language-css"><span class="language-xml">        <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;</span></span><br><span class="language-css"><span class="language-xml">        <span class="hljs-attribute">position</span>: relative;</span></span><br><span class="language-css"><span class="language-xml">        <span class="hljs-comment">/* 方案一 ：用border厚度1px来区分1px物理像素 */</span></span></span><br><span class="language-css"><span class="language-xml">        <span class="hljs-comment">/* border-bottom: 1px solid #000; */</span></span></span><br><span class="language-css"><span class="language-xml">      &#125;</span></span><br><span class="language-css"><span class="language-xml">      <span class="hljs-comment">/* 方案二： @media screen 只针对#box:before进行反向变回来*/</span></span></span><br><span class="language-css"><span class="language-xml">      <span class="hljs-selector-id">#box</span><span class="hljs-selector-pseudo">:before</span>&#123;</span></span><br><span class="language-css"><span class="language-xml">        <span class="hljs-attribute">content</span>: <span class="hljs-string">&#x27;&#x27;</span>;</span></span><br><span class="language-css"><span class="language-xml">        <span class="hljs-attribute">position</span>: absolute;</span></span><br><span class="language-css"><span class="language-xml">        <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;</span></span><br><span class="language-css"><span class="language-xml">        <span class="hljs-attribute">bottom</span>: <span class="hljs-number">0</span>;</span></span><br><span class="language-css"><span class="language-xml">        <span class="hljs-comment">/* 用box前面放一个高为1的元素来验证 */</span></span></span><br><span class="language-css"><span class="language-xml">        <span class="hljs-attribute">height</span>: <span class="hljs-number">1px</span>;</span></span><br><span class="language-css"><span class="language-xml">        <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;</span></span><br><span class="language-css"><span class="language-xml">        <span class="hljs-attribute">background-color</span>: black;</span></span><br><span class="language-css"><span class="language-xml">      &#125;</span></span><br><span class="language-css"><span class="language-xml">      <span class="hljs-keyword">@media</span> screen <span class="hljs-keyword">and</span> (<span class="hljs-attribute">-webkit-min-device-pixel-ratio</span>:<span class="hljs-number">1.5</span>)&#123;</span></span><br><span class="language-css"><span class="language-xml">        <span class="hljs-selector-id">#box</span><span class="hljs-selector-pseudo">:before</span>&#123;</span></span><br><span class="language-css"><span class="language-xml">          <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">scaleY</span>(<span class="hljs-number">0.67</span>);</span></span><br><span class="language-css"><span class="language-xml">        &#125;</span></span><br><span class="language-css"><span class="language-xml">      &#125;</span></span><br><span class="language-css"><span class="language-xml">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></span><br>&lt;/head&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;</span></span><br><span class="language-xml">        312</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&#x27;text/javascript&#x27;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">   <span class="hljs-variable language_">window</span>.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">params</span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">       </span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-comment">// 以下是方案一</span></span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-comment">// 1. 物理像素/CSS像素 = 像素比 </span></span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-keyword">var</span> dpr = <span class="hljs-variable language_">window</span>.<span class="hljs-property">devicePixelRatio</span>;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(dpr);<span class="hljs-comment">//1.5</span></span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-comment">// 2.initial-scale在meta标签中指的是CSS像素的缩放比</span></span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-keyword">var</span> scale = <span class="hljs-number">1</span>/dpr;</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-comment">// 屏幕区的宽</span></span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-keyword">var</span> width = <span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>.<span class="hljs-property">width</span></span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-comment">// 3.由物理像素1px反推initial-scale的缩放比并重新设置</span></span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-keyword">var</span> metaNode = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;meta[name=&quot;viewport&quot;]&#x27;</span>)</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(metaNode);</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">      metaNode.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">&#x27;content&#x27;</span>,<span class="hljs-string">&quot;width=device-width, initial-scale=&quot;</span>+scale)</span></span><br><span class="language-javascript"><span class="language-xml">       </span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-keyword">var</span> htmlNode = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;html&#x27;</span>)</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-comment">// 4.但是整体initial-scale变了，盒子长宽也变了需要再反向乘回来</span></span></span><br><span class="language-javascript"><span class="language-xml">      htmlNode.<span class="hljs-property">style</span>.<span class="hljs-property">fontSize</span> = width * scale + <span class="hljs-string">&#x27;px&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">   &#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="纯CSS创建一个三角形"><a href="#纯CSS创建一个三角形" class="headerlink" title="纯CSS创建一个三角形"></a>纯CSS创建一个三角形</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;style&gt;<br>     #box&#123;<br>       <span class="hljs-attr">width</span>: 0px;<br>       <span class="hljs-attr">height</span>: 0px;<br>      <span class="hljs-comment">/* 原理：四个角border足够大，互不相让，就形成了三角形</span><br><span class="hljs-comment">               但是似乎border无法做到足够大，那么就把盒子宽高设置为0(相当于宽高是种达到三角形的束缚)</span><br><span class="hljs-comment">               其他不要的三角形就设置透明色</span><br><span class="hljs-comment">      */</span><br>       <span class="hljs-attr">border</span>: 100px solid;<br><br>       border-top-<span class="hljs-attr">color</span>: blue;<br>       border-bottom-<span class="hljs-attr">color</span>: transparent;<br>       border-left-<span class="hljs-attr">color</span>: transparent;<br>       border-right-<span class="hljs-attr">color</span>: transparent;<br>     &#125;<br>  &lt;/style&gt;<br>&lt;/head&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="求背景图片左边到-box盒子左边框外侧的距离"><a href="#求背景图片左边到-box盒子左边框外侧的距离" class="headerlink" title="求背景图片左边到#box盒子左边框外侧的距离"></a>求背景图片左边到#box盒子左边框外侧的距离</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;style&gt;<br>     *&#123;<br>        <span class="hljs-attr">margin</span>:<span class="hljs-number">0</span>;<br>        <span class="hljs-attr">padding</span>:<span class="hljs-number">0</span>;<br>     &#125;<br>     <span class="hljs-comment">/* 题目的意思就是按照给出的box位置，计算一下 背景图片左边到box左边框的距离</span><br><span class="hljs-comment">        其实就是考的 border-box、padding-box、content-box的关系</span><br><span class="hljs-comment">     */</span><br>     #box&#123;<br>        <span class="hljs-attr">width</span>: 100px;<br>        <span class="hljs-attr">height</span>: 200px;<br>        background-<span class="hljs-attr">color</span>: pink;<br>        <span class="hljs-attr">padding</span>: 100px;<br>        <span class="hljs-attr">border</span>: 80px solid blue;<br>        background-<span class="hljs-attr">image</span>: <span class="hljs-title function_">url</span>(<span class="hljs-string">&quot;./images/作用域和引用类型的传递.png&quot;</span>); <br>        background-<span class="hljs-attr">size</span>: contain;<br>        <span class="hljs-comment">/* 背景图片起始源的位置 */</span><br>        background-<span class="hljs-attr">origin</span>: content-box;<br>        background-<span class="hljs-attr">repeat</span>: no-repeat;<br>        <span class="hljs-comment">/* 在content-box的-50px ,于是答案为 (100+80)-50=130px*/</span><br>        background-<span class="hljs-attr">position</span>: -50px <span class="hljs-number">0</span>;<br>     &#125;<br>  &lt;/style&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><br><span class="language-xml">   <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;</span></span><br><span class="language-xml">   <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="如何实现移动端rem适配"><a href="#如何实现移动端rem适配" class="headerlink" title="如何实现移动端rem适配"></a>如何实现移动端rem适配</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;!-- em是针对父元素的适配单位，而rem是只针对<span class="hljs-title function_">html</span>(root即根部)的适配单位<br>       比如html的fontSize为50px，然后body的字体设置为<span class="hljs-number">50</span>%，那么这个1em/1rem就为25px<br>  --&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="language-css"><span class="language-xml">     <span class="hljs-selector-id">#box</span>&#123;</span></span><br><span class="language-css"><span class="language-xml">        <span class="hljs-attribute">width</span>: <span class="hljs-number">0.5rem</span>;</span></span><br><span class="language-css"><span class="language-xml">        <span class="hljs-attribute">height</span>: <span class="hljs-number">0.5rem</span>;</span></span><br><span class="language-css"><span class="language-xml">        <span class="hljs-attribute">background-color</span>: red;</span></span><br><span class="language-css"><span class="language-xml">     &#125;</span></span><br><span class="language-css"><span class="language-xml">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></span><br>&lt;/head&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-comment">&lt;!-- 方法就是 html根元素的字体大小 = 屏幕区的宽</span></span><br><span class="hljs-comment"><span class="language-xml">       目的是想把 1rem设置成整个屏幕的宽，那下次某个盒子想要设置成占整个屏幕多大比例，那直接 1rem/x</span></span><br><span class="hljs-comment"><span class="language-xml">       比如 某个盒子想要占屏幕的一半，那设置完之后就可以设置宽高为0.5rem-&gt;特指整个屏幕的一半，这样不管是什么分辨率都可以设置 </span></span><br><span class="hljs-comment"><span class="language-xml">       Ps：这里的字体大小默认是 指的是rem或em的单位</span></span><br><span class="hljs-comment"><span class="language-xml">      --&gt;</span></span><br><span class="language-xml">   <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;</span></span><br><span class="language-xml">       </span><br><span class="language-xml">   <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&#x27;text/javascript&#x27;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-variable language_">window</span>.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-comment">// 整个屏幕的宽</span></span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-keyword">var</span> width = <span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>.<span class="hljs-property">clientWidth</span></span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-keyword">var</span> htmlNode = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;html&#x27;</span>)</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">        htmlNode.<span class="hljs-property">style</span>.<span class="hljs-property">fontSize</span> = width + <span class="hljs-string">&#x27;px&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-comment">// 以上三个步骤是为了当前屏幕单位 都为1rem</span></span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="使用flex实现水平居中"><a href="#使用flex实现水平居中" class="headerlink" title="使用flex实现水平居中"></a>使用flex实现水平居中</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;!-- 顺便先复习下之前的两种水平居中方式：绝对定位 --&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="language-css"><span class="language-xml">     <span class="hljs-selector-id">#wrap</span>&#123;</span></span><br><span class="language-css"><span class="language-xml">       <span class="hljs-attribute">width</span>: <span class="hljs-number">500px</span>;</span></span><br><span class="language-css"><span class="language-xml">       <span class="hljs-attribute">height</span>: <span class="hljs-number">500px</span>;</span></span><br><span class="language-css"><span class="language-xml">       <span class="hljs-comment">/* position: relative; */</span></span></span><br><span class="language-css"><span class="language-xml">       <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid black;</span></span><br><span class="language-css"><span class="language-xml">       <span class="hljs-comment">/* 方案三: 靠flex,直接在父元素对子元素自动调整----------应该是最方便的了★ */</span></span></span><br><span class="language-css"><span class="language-xml">       <span class="hljs-attribute">display</span>: flex;</span></span><br><span class="language-css"><span class="language-xml">       <span class="hljs-comment">/* 主轴(水平)设置在居中位置 */</span></span></span><br><span class="language-css"><span class="language-xml">       <span class="hljs-attribute">justify-content</span>: center;</span></span><br><span class="language-css"><span class="language-xml">       <span class="hljs-comment">/* 侧轴(垂直)设置在居中位置 */</span></span></span><br><span class="language-css"><span class="language-xml">       <span class="hljs-attribute">align-items</span>: center;</span></span><br><span class="language-css"><span class="language-xml"></span></span><br><span class="language-css"><span class="language-xml">       <span class="hljs-comment">/* flex对应的老版本 */</span></span></span><br><span class="language-css"><span class="language-xml">       <span class="hljs-comment">/* display: -webkit-box;</span></span></span><br><span class="hljs-comment"><span class="language-css"><span class="language-xml">       -webkit-box-pack: center;</span></span></span><br><span class="hljs-comment"><span class="language-css"><span class="language-xml">       -webkit-box-align: center; */</span></span></span><br><span class="language-css"><span class="language-xml">      &#125;</span></span><br><span class="language-css"><span class="language-xml">     <span class="hljs-selector-id">#wrap</span> <span class="hljs-selector-class">.box</span>&#123;</span></span><br><span class="language-css"><span class="language-xml">       <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;</span></span><br><span class="language-css"><span class="language-xml">       <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;</span></span><br><span class="language-css"><span class="language-xml">       <span class="hljs-attribute">position</span>: absolute;</span></span><br><span class="language-css"><span class="language-xml">       <span class="hljs-comment">/* 方案一：靠margin  都为0目的是去除对margin控制盒子的影响 */</span></span></span><br><span class="language-css"><span class="language-xml">       <span class="hljs-comment">/* top: 0;</span></span></span><br><span class="hljs-comment"><span class="language-css"><span class="language-xml">       bottom: 0;</span></span></span><br><span class="hljs-comment"><span class="language-css"><span class="language-xml">       left: 0;</span></span></span><br><span class="hljs-comment"><span class="language-css"><span class="language-xml">       right: 0;</span></span></span><br><span class="hljs-comment"><span class="language-css"><span class="language-xml">       margin: auto; */</span></span></span><br><span class="language-css"><span class="language-xml">       <span class="hljs-comment">/* 方案二: 只靠定位 */</span></span></span><br><span class="language-css"><span class="language-xml">       <span class="hljs-comment">/* left: 50%;</span></span></span><br><span class="hljs-comment"><span class="language-css"><span class="language-xml">       top: 50%;</span></span></span><br><span class="hljs-comment"><span class="language-css"><span class="language-xml">       transform: translate(-50%,-50%); */</span></span></span><br><span class="language-css"><span class="language-xml"></span></span><br><span class="language-css"><span class="language-xml">       <span class="hljs-attribute">background-color</span>: pink;</span></span><br><span class="language-css"><span class="language-xml">     &#125;</span></span><br><span class="language-css"><span class="language-xml">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></span><br>&lt;/head&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><br><span class="language-xml">   <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;wrap&quot;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">   <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="字符串驼峰的转换"><a href="#字符串驼峰的转换" class="headerlink" title="字符串驼峰的转换"></a>字符串驼峰的转换</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">toString</span>(<span class="hljs-params">foo</span>) &#123;<br>  <span class="hljs-keyword">var</span> arr = foo.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;-&quot;</span>);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> index = <span class="hljs-number">1</span>; index &lt; arr.<span class="hljs-property">length</span>; index++) &#123;<br>    arr[index] =<br>      arr[index].<span class="hljs-title function_">charAt</span>(<span class="hljs-number">0</span>).<span class="hljs-title function_">toUpperCase</span>() +<br>      arr[index].<span class="hljs-title function_">substring</span>(<span class="hljs-number">1</span>, arr[index].<span class="hljs-property">length</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> arr.<span class="hljs-title function_">join</span>(<span class="hljs-string">&quot;&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="作用域和值类型和引用类型的传递"><a href="#作用域和值类型和引用类型的传递" class="headerlink" title="作用域和值类型和引用类型的传递"></a><strong>作用域和值类型和引用类型的传递</strong></h3><blockquote><p>1.作用域在JS高级里面叫 “执行上下文”，”上下文”很容易理解，对应”域”，那”执行”就对应”作用”了</p><p>2.分为全局执行上下文和函数执行上下文，这两个上下文都会提前将变量以及函数放入上下文</p><p>3.注意下 xxx is not defined、undefined、null的区别</p><p>xxx is not defined：没有定义</p><p>undefined：定义了为赋值</p><p>null：定义了，值为null</p><p>层层递进，情况越来越好</p></blockquote><hr><p><img src="/2023/08/30/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%BC%A0%E9%80%92.png" alt="作用域和引用类型的传递"></p><blockquote><p>这题我错在哪里？</p><p>错在了 我忘了函数 参数的传递是一个赋值过程，我忽略了这个过程，看来在 引用类型这种特殊的类型尤其要注意细节赋值</p><p>重新解题：第一个空忽略，第二个空：在栈处重新加一个变量person并赋值p的地址，一开始指向p的地址，后来指向new的地址，但是它问的是传进去p的name</p></blockquote><p><strong>错误总结：</strong>看到引用类型传值，就考的是引用类型地址指向的问题，这种就需要注意它输出的是 哪个引用类型变量的属性</p><h3 id="封装函数进行字符串驼峰命名转换（主要复习string的方法）"><a href="#封装函数进行字符串驼峰命名转换（主要复习string的方法）" class="headerlink" title="封装函数进行字符串驼峰命名转换（主要复习string的方法）"></a><strong>封装函数进行字符串驼峰命名转换（主要复习string的方法）</strong></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">toString</span>(<span class="hljs-params">foo</span>) &#123;<br>  <span class="hljs-comment">// 根据符号-分开并组成数组</span><br>  <span class="hljs-keyword">var</span> arr = foo.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;-&#x27;</span>)<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> index = <span class="hljs-number">1</span>; index &lt; arr.<span class="hljs-property">length</span>; index++) &#123;<br>      <span class="hljs-comment">//注意substring是左闭右开</span><br>      arr[index] = arr[index].<span class="hljs-title function_">charAt</span>(<span class="hljs-number">0</span>).<span class="hljs-title function_">toUpperCase</span>()+arr[index].<span class="hljs-title function_">substring</span>(<span class="hljs-number">1</span>,arr[index].<span class="hljs-property">length</span>)<br>  &#125;<br>  <span class="hljs-comment">// 根据符号再将数组个元素连成字符串</span><br>  <span class="hljs-keyword">return</span> arr.<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;&#x27;</span>)<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">toString</span>(<span class="hljs-string">&#x27;get-element-by-id&#x27;</span>));<br></code></pre></td></tr></table></figure><p>Ps：split这个方法就是专门针对某个字符进行分割，以后看到字符串里多次出现某个字符，就很可能要用这个</p><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a><strong>冒泡排序</strong></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> array = [<span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">8</span>];<br><span class="hljs-comment">// 轮数</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; array.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>; i++) &#123;<br>  <span class="hljs-comment">// 交换次数，插入排序才是j=i，轮数越往后交换次数越少因此肯定和i有关</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; array.<span class="hljs-property">length</span> - i - <span class="hljs-number">1</span>; j++) &#123;<br>    <span class="hljs-keyword">if</span> (array[j] &gt; array[j + <span class="hljs-number">1</span>]) &#123;<br>      <span class="hljs-keyword">let</span> temp = array[j];<br>      array[j] = array[j + <span class="hljs-number">1</span>];<br>      array[j + <span class="hljs-number">1</span>] = temp;<br>    &#125;<br>  &#125;<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(array);<br></code></pre></td></tr></table></figure><h3 id="Js综合"><a href="#Js综合" class="headerlink" title="Js综合"></a><strong>Js综合</strong></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Foo</span>(<span class="hljs-params"></span>) &#123;<br>    getName = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-title function_">alert</span>(<span class="hljs-number">1</span>)<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span><br><br><span class="hljs-title class_">Foo</span>.<span class="hljs-property">getName</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">alert</span>(<span class="hljs-number">2</span>)<br>&#125;<br><br><span class="hljs-title class_">Foo</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getName</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">alert</span>(<span class="hljs-number">3</span>)<br>&#125;<br><br><span class="hljs-keyword">var</span> getName = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">alert</span>(<span class="hljs-number">4</span>)<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getName</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">alert</span>(<span class="hljs-number">5</span>)<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * (1)注意 function Foo 内的getName不是这个函数的，因为没有用var定义，因此会默认往全局作用于去找-------变量的寻找，靠作用域</span><br><span class="hljs-comment"> * */</span> <br><span class="hljs-title class_">Foo</span>.<span class="hljs-title function_">getName</span>()<span class="hljs-comment">//2</span><br><br><span class="hljs-comment">/*------------------------变量和函数提升之后---------------*/</span><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">Foo</span>(<span class="hljs-params"></span>) &#123;<br>        getName = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>            <span class="hljs-title function_">alert</span>(<span class="hljs-number">1</span>)<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span><br>    &#125;<br>    <span class="hljs-comment">// var getName;</span><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">getName</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-title function_">alert</span>(<span class="hljs-number">5</span>) &#125;;<br>    <br>    <span class="hljs-title class_">Foo</span>.<span class="hljs-property">getName</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-title function_">alert</span>(<span class="hljs-number">2</span>)<br>    &#125;<br>    <span class="hljs-title class_">Foo</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getName</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-title function_">alert</span>(<span class="hljs-number">3</span>)<br>    &#125;<br>    getName = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-title function_">alert</span>(<span class="hljs-number">4</span>)<br>    &#125;<br><br><span class="hljs-comment">/*-------------------------------------------------------*/</span><br><br><span class="hljs-title function_">getName</span>()<span class="hljs-comment">//4      变量提升，详细见下一题</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 先把 Foo() 化简了，算出来再去调用</span><br><span class="hljs-comment"> * (2)Foo返回的是this，但是这个this指的是window，因为看的是调用者，(window).Foo()-------this的指向</span><br><span class="hljs-comment"> * 全局作用域上有两个一个是var getName一个是函数，在加载数据时，会变量和函数提升：见上面</span><br><span class="hljs-comment"> * 又因为变量和函数同名时会忽略变量，优先看函数的(Jsz中函数相当于类很重要)，alert此时为5 -------变量和函数提升</span><br><span class="hljs-comment"> * 到最后时getName被赋值为alert(4)</span><br><span class="hljs-comment"> * 但是在Foo调用之后getName又被重新赋值为alert(1)，因此过程为5-&gt;4-&gt;1</span><br><span class="hljs-comment"> * */</span> <br><span class="hljs-title class_">Foo</span>().<span class="hljs-title function_">getName</span>()<span class="hljs-comment">//1</span><br><br><span class="hljs-title function_">getName</span>() <span class="hljs-comment">//1  具体见上一题：最后被赋值为alert(1)</span><br><br><span class="hljs-comment">/*下面两题用到了优先级的大小，具体如下图</span><br><span class="hljs-comment">  new 不带参和new ( fun())带参</span><br><span class="hljs-comment">  可以这么理解：前者后面没有参数也就是把后面当作一个整体，算好了再new</span><br><span class="hljs-comment">               后者直接算算不出来，需要先配合new一起算，然后再.调用</span><br><span class="hljs-comment">  这就是对于new来说，new带参比new不带参优先级高的原因</span><br><span class="hljs-comment">*/</span> <br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * .的优先级比new高，因此先看Foo.getName，又刚好可以替换成 function () &#123;alert(2)&#125;</span><br><span class="hljs-comment"> * 因此直接变成 new (function () &#123;alert(2)&#125;)()-&gt;当前函数的实例()--&gt;2</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Foo</span>.<span class="hljs-title function_">getName</span>()<span class="hljs-comment">//2</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * (new Foo()).getName()-&gt;(new this).getName()-&gt;foo.getName()从原型链上找-&gt;alert(3)----原型链</span><br><span class="hljs-comment"> * */</span> <br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Foo</span>().<span class="hljs-title function_">getName</span>()<span class="hljs-comment">//3</span><br><br><span class="hljs-comment">// 根据上面两题分析：new (new Foo()).getName()-&gt;new foo.getName()-&gt;alert(3)再实例（实例不对结果有影响）</span><br><span class="hljs-keyword">new</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Foo</span>().<span class="hljs-title function_">getName</span>()<span class="hljs-comment">//3</span><br></code></pre></td></tr></table></figure><p><img src="/2023/08/30/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/new%E5%92%8C.%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7.png" alt="new和.运算符的优先级"></p><blockquote><p>这个题很牛：考到了知识点有 找变量按照作用域链、变量和函数声明的提升、运算符优先级、原型链</p></blockquote><h3 id="防抖与节流"><a href="#防抖与节流" class="headerlink" title="防抖与节流"></a><strong>防抖与节流</strong></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// -------------------------------防抖与节流-------------------------------------------</span><br><span class="hljs-comment">//  节流：为了节省资源，减少事件触发的频率</span><br><span class="hljs-comment">//  就可以通过 一个周期减少函数执行的次数来实现，即设置多长时间执行一次（也可以用定时器），提高了性能</span><br><span class="hljs-comment">//  (第一次生效，后面不生效)</span><br><span class="hljs-comment">//  参数：delay时间执行一次fn</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">throttle</span>(<span class="hljs-params">fn, delay</span>) &#123;<br>    <span class="hljs-comment">// 利用闭包，每次的lastTime不会变，相当于小的全局变量</span><br>    <span class="hljs-keyword">var</span> lastTime = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">var</span> nowTime = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>()<br>        <br>        <span class="hljs-comment">// 到达一定时间再执行</span><br>        <span class="hljs-keyword">if</span> (nowTime - lastTime &gt; delay) &#123;<br>            <span class="hljs-comment">// 使用call是为了让this指向和里层function一致(因为闭包使用的是外部函数的变量和参数因此this也是外部函数的this)</span><br>            <span class="hljs-title function_">fn</span>()<br><br>            <span class="hljs-comment">// 更新时间</span><br>            lastTime = nowTime<br>        &#125;<br>    &#125;<br>&#125;<br><br>documnt.<span class="hljs-property">onscroll</span> = <span class="hljs-title function_">throttle</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;onscroll事件被触发了&#x27;</span>)&#125;,<span class="hljs-number">1000</span>)<br><br><span class="hljs-comment">// 防抖：防止比必要的操作(抖动)来节省资源，在真正需要的时机(最后一次操作延迟一段时间)再触发</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">debounce</span>(<span class="hljs-params">fn,delay</span>)&#123;<br>    <span class="hljs-keyword">var</span> time = <span class="hljs-literal">null</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">funtion</span>(<span class="hljs-params"></span>)&#123;<br>       <span class="hljs-comment">// 只要在时间之内就给你结束掉(如果到达了时间并且成功执行完毕后也会自行关闭)</span><br>       <span class="hljs-built_in">clearTimeout</span>(time)<br>        time = <span class="hljs-title function_">setTimeOut</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>        <span class="hljs-title function_">fn</span>()<br>        &#125;,delay)<br>    &#125;<br>    <br>&#125;<br><br><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;#btn&#x27;</span>).<span class="hljs-property">onclick</span> = <span class="hljs-title function_">debounce</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;btn事件被触发了&#x27;</span>)&#125;,<span class="hljs-number">1000</span>)<br><br><span class="hljs-comment">// 化繁为简：最大的区别，防抖是要等待操作停止下来达到delay时间后再执行，而节流是不管你什么操作，只按照我的时间周期来执行</span><br></code></pre></td></tr></table></figure><h3 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h3><p><strong>面试题：什么是跨域？跨域的解决办法是什么？</strong></p><p>浏览器安全的一种策略（类似权限的设置），需要保证 协议、域名、端口号一致</p><p>解决办法：</p><p>jsonp（需前后端都配置）、cors（只需后端配置）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// jsonp：利用script标签的不受跨域限制的特点，将需要执行的回调函数作为参数传递过去，那么请求结束回调函数自动会执行</span><br><br><span class="hljs-keyword">var</span> script = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;script&#x27;</span>)<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getData</span>(<span class="hljs-params">data</span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data)<br>&#125;<br><br>script.<span class="hljs-property">src</span> = <span class="hljs-string">&#x27;http://localhost:3000?callback=&#x27;</span>+getData<br><br><span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(script)<br></code></pre></td></tr></table></figure><h3 id="nodejs事件轮询机制"><a href="#nodejs事件轮询机制" class="headerlink" title="nodejs事件轮询机制"></a>nodejs事件轮询机制</h3><p><strong>面试题：下面三个函数执行顺序是什么？</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;setTimeout&#x27;</span>)<br>&#125;)<br><br><span class="hljs-title function_">setImmediately</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;setImmediately&#x27;</span>)<br>&#125;)<br><br>process.<span class="hljs-title function_">nextTick</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;process.nextTick&#x27;</span>)<br>&#125;)<br><br><span class="hljs-comment">// 不论执行的顺序先后如何，最后的打印结果都会如下：</span><br><span class="hljs-comment">// process.nextTick(在任何阶段都可以优先执行)</span><br><span class="hljs-comment">// setTimeout</span><br><span class="hljs-comment">// setImmediately</span><br></code></pre></td></tr></table></figure><p><img src="/2023/08/30/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/nodejs%E8%BD%AE%E8%AF%A2%E6%9C%BA%E5%88%B6(1).png" alt="事件循环机制的六个阶段(1)"></p><p><img src="/2023/08/30/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/nodejs%E8%BD%AE%E8%AF%A2%E6%9C%BA%E5%88%B6(2).png" alt="事件循环机制的六个阶段(2)"></p><p>**化繁为简一句话总结：优先级为 process.nextTick &gt;  定时器 &gt; poll阶段的回调函数 &gt; setImmediately **</p><h3 id="从URL输入网址"><a href="#从URL输入网址" class="headerlink" title="从URL输入网址"></a>从URL输入网址</h3><p><strong>面试题：从url输入网址到最终页面渲染完成，发生了什么？</strong></p><blockquote><p>补充：<a href="http://www.baidu.com/">www.baidu.com</a></p><p>www：万维网</p><p>URL：统一资源定位符</p><p>一共会有6个步骤，如下：</p><ol><li><p>DNS解析：将域名解析成ip地址，会按照以下顺序寻找映射表</p><ul><li>从浏览器缓存</li><li>从当前系统</li><li>从路由表</li><li>从网络运营商</li><li>递归搜索，从顶级域名服务器往下寻找，例如要找的是<a href="http://www.example.com这个地址/">www.example.com这个地址</a><ul><li>从.com域名寻找</li><li>从.example域名寻找</li><li>从www域名寻找</li></ul></li></ul></li><li><p>TCP连接：三次握手</p><ol><li><p>第一次握手，由浏览器发起，通知服务器准备发送数据了</p></li><li><p>第二次握手，由服务器发起，告诉浏览器确认收到通知了</p></li><li><p>第三次握手，由浏览器发起，告诉服务器收到确认消息了，我要开始发了，你准备好了</p><p><strong>面试题：为什么第三次还要再握手一次？</strong></p><p>因为前两次握手只能让客户端知道服务器能正常收到自己发送的数据，但是服务器不能保证客户端能正常收到自己发送的数据（可能半路数据丢失了，于是服务器自己就会超时重传），三次握手就是保证双方发送和接受都是正常的</p></li></ol></li><li><p>发送报文</p></li><li><p>响应报文</p></li><li><p>渲染页面：</p><ul><li>遇见HTML标签，浏览器用HTML解析器生成Token标记并构建成DOM树</li><li>遇见Style/Link标签，浏览器用CSS解析器构建CSSOM树</li><li>遇见script标签，浏览器用javascript解析器处理javascript代码（绑定事件，修改DOM树、CSSDOM树）</li><li>将DOM树、CSSOM树合并成渲染树</li><li>根据渲染树来计算布局，包括元素几何信息、大小等（布局）——— 回流（重排）</li><li>给元素绘制颜色（颜色） ————重绘</li></ul><p>由于各个内容可能经常变动，这些步骤会经常执行，并且顺序不固定</p></li><li><p>关闭TCP连接，四次挥手</p><ol><li>第一次挥手，浏览器告知服务器，即将关闭传输数据的通道，你准备准备</li><li>第二次挥手，服务器确认收到浏览器的关闭通知，表示还需要把剩余的数据传完再说</li><li>第三次挥手，服务器告知浏览器，我数据传递完毕了，我要关闭了</li><li>第四次挥手，浏览器确认服务器的关闭通知，你关闭吧，我过一段时间也关闭</li></ol><p><strong>面试题：为什么第四次挥手要等一段时间才关闭？</strong></p><p>确保服务器能收到自己的确认消息，让服务器放心【在发送路途中考虑到特殊情况（延迟、重传、乱序等问题），确保服务器其能收到自己发的消息】—和第三次握手目的是一样的</p></li></ol></blockquote><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p><strong>什么是闭包？</strong></p><p>它是一个对象（Closure），数据结构为key-value形式</p><p><strong>闭包形成的条件？</strong></p><ol><li>嵌套函数</li><li>内层函数对外层函数变的引用</li><li>**<u>外部函数调用时</u>**（重要），此时产生Closure对象</li></ol><p><strong>闭包优缺点以及注意点？</strong></p><p>优点：延长外层函数变量的生命周期</p><p>缺点：使用不当容易造成内存泄露</p><p>注意点：要及时销毁</p><p><strong>如何销毁？</strong></p><p>没有被使用 或者 被使用了之后成为了垃圾对象（没有指向新的对象或设置为null）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn1</span>(<span class="hljs-params"></span>)&#123;<br>    -------------------------------------此时就已经产生了闭包(变量提升)<br>    <span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">fn2</span>(<span class="hljs-params"></span>)&#123;<br>        a++  <span class="hljs-comment">//引用函数外部变量，产生闭包</span><br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a)<br>    &#125;------------------------------------这里整个fn2就会被释放，因为没有被使用(<span class="hljs-number">1</span>)<br>     <span class="hljs-keyword">function</span> <span class="hljs-title function_">fn3</span>(<span class="hljs-params"></span>)&#123;<br>        a++  <span class="hljs-comment">//引用函数外部变量，产生闭包</span><br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a)<br>    &#125;<br>    <span class="hljs-keyword">return</span> fn3<br>&#125;<br><span class="hljs-comment">//fn1()----------------------------------这里fn1调用结束后，如果没有变量指向fn3(返回值)，那fn3就会成为垃圾对象，准备被销毁，那闭包中的变量也没了(2)</span><br><span class="hljs-keyword">var</span> f = <span class="hljs-title function_">fn1</span>()<br><span class="hljs-title function_">f</span>()<br>f = <span class="hljs-literal">null</span> <span class="hljs-comment">// (2)设置为null也成为了垃圾对象</span><br></code></pre></td></tr></table></figure><p><strong>闭包的使用场景？</strong></p><p>函数的防抖与节流、第三方库的封装（数据私有化）</p><blockquote><p>下面举个第三方库的封装的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> counter = (<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 私有变量</span><br>  <span class="hljs-keyword">var</span> count = <span class="hljs-number">0</span>;<br>  <br>  <span class="hljs-comment">// 私有函数</span><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">increment</span>(<span class="hljs-params"></span>) &#123;<br>    count++;<br>  &#125;<br>  <br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">decrement</span>(<span class="hljs-params"></span>) &#123;<br>    count--;<br>  &#125;<br>  <br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">getCount</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> count;<br>  &#125;<br>  <br>  <span class="hljs-comment">// 返回接口</span><br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">increment</span>: increment,<br>    <span class="hljs-attr">decrement</span>: decrement,<br>    <span class="hljs-attr">getCount</span>: getCount<br>  &#125;;<br>&#125;)();<br><br>可以通过<span class="hljs-string">`counter.increment()`</span>和<span class="hljs-string">`counter.getCount()`</span>等接口来操作和获取计数器的状态，而无需关心内部的实现细节。<br></code></pre></td></tr></table></figure></blockquote><p><strong>闭包面试题</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fun</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a)<br>    &#125;<br>&#125;<br><span class="hljs-keyword">let</span> fun2 = <span class="hljs-title function_">fun</span>()<br><span class="hljs-title function_">fun2</span>()<span class="hljs-comment">//1</span><br><span class="hljs-title function_">fun2</span>()<span class="hljs-comment">//1 ---------- 这两次一直在使用闭包中的变量</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fun</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        a++<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a)<br>    &#125;<br>&#125;<br><span class="hljs-keyword">let</span> fun2 = <span class="hljs-title function_">fun</span>() <br><span class="hljs-title function_">fun2</span>()<span class="hljs-comment">//2</span><br><span class="hljs-title function_">fun2</span>()<span class="hljs-comment">//3 ---------- 同上</span><br><br><span class="hljs-comment">// 下面是闭包终极面试题 ----- 懂了就没啥问题了</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fun</span>(<span class="hljs-params">n,o</span>)&#123;<br>    <span class="hljs-comment">// var n,o</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(o)<br>    <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-attr">fun</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">m</span>)&#123;<br>            <span class="hljs-comment">// var m</span><br>            <span class="hljs-title function_">fun</span>(m,n)<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">var</span> a = <span class="hljs-title function_">fun</span>(<span class="hljs-number">0</span>)<br>a.<span class="hljs-title function_">fun</span>(<span class="hljs-number">1</span>)<br>a.<span class="hljs-title function_">fun</span>(<span class="hljs-number">2</span>)<br>a.<span class="hljs-title function_">fun</span>(<span class="hljs-number">3</span>) <span class="hljs-comment">// undefined,0,0,0</span><br><br><span class="hljs-keyword">var</span> b = <span class="hljs-title function_">fun</span>(<span class="hljs-number">0</span>).<span class="hljs-title function_">fun</span>(<span class="hljs-number">1</span>).<span class="hljs-title function_">fun</span>(<span class="hljs-number">2</span>).<span class="hljs-title function_">fun</span>(<span class="hljs-number">3</span>) <span class="hljs-comment">// undefined,0,1,2</span><br><br><span class="hljs-keyword">var</span> c = <span class="hljs-title function_">fun</span>(<span class="hljs-number">0</span>).<span class="hljs-title function_">fun</span>(<span class="hljs-number">1</span>)<br>c.<span class="hljs-title function_">fun</span>(<span class="hljs-number">2</span>)<br>c.<span class="hljs-title function_">fun</span>(<span class="hljs-number">3</span>) <span class="hljs-comment">// undefined,1,1,1</span><br></code></pre></td></tr></table></figure><p><strong>总结技巧：</strong></p><ul><li>对于链式 ———– 返回上一个对象里面闭包的值</li><li>对于非链式———要清除该对象内闭包值是多少，只要不是新的对象，闭包值不变</li></ul><h3 id="变量提升-amp-执行上下文-amp-作用域链"><a href="#变量提升-amp-执行上下文-amp-作用域链" class="headerlink" title="变量提升&amp;执行上下文&amp;作用域链"></a>变量提升&amp;执行上下文&amp;作用域链</h3><blockquote><ol><li><p>变量提升（预处理）   ————— 提前保存</p><p>1）收集 变量</p><p>2）收集 函数的声明以及函数的参数</p><p>3）将 收集的 东西 放入 <strong>变量对象</strong> 中</p><p>其中，变量对象 分为 全局和局部</p><p>全局 -&gt; window</p><p>局部 -&gt; 抽象的</p></li><li><p>确认this的指向 ——————–方便给程序员统一用this访问数据</p><p>1）全局：this-&gt;window   ———（有上面可知，全局变量对象也-&gt;window，即this = 变量对象 = winodw）</p><p>2）局部：this-&gt;调用它的对象 </p></li><li><p>创建作用域链 —————— 如果找不到数据-&gt;找上找</p><p>它的值 = 父级作用域链 + 当前变量对象</p></li></ol><p><strong>总结：以上所有数据保存在执行上下文对象（execute obj）中</strong></p><p>ECObj = {</p><p>​      变量对象：{变量，函数的声明，函数的参数}，</p><p>​      this：{window || 调用它的对象 }，</p><p>​      作用域链（scopeChain）：父级作用域链 + 当前变量对象</p><p>}</p><p>流程：按照作用域链，先从当前执行上下文的变量对象去找，找不到再往外</p><p>this就是指当前执行上下文，只不过默认就是直接跳过变量对象去访问变量</p></blockquote><h3 id="宏任务与微任务"><a href="#宏任务与微任务" class="headerlink" title="宏任务与微任务"></a>宏任务与微任务</h3><p><strong>宏任务、微任务和nodejs事件循环机制的关系</strong></p><blockquote><p>宏任务、微任务都是nodejs事件循环机制处理的对象</p></blockquote><p><strong>宏任务</strong></p><blockquote><p>分类：定时器（<u>setTimeout、setInterval</u>）、requestAnimationFrame（请求动画的回调）</p><p>特点：耗时</p></blockquote><p><strong>宏任务队列</strong></p><blockquote><p>可以用来存放宏任务的，可以有多个，但是第一个是给 主线程 用的，后面的存放宏任务</p></blockquote><p><strong>微任务</strong></p><blockquote><p>分类：new promise(回调).then()、process.nextTick()</p><p>特点：紧急性高</p></blockquote><p><strong>微任务对队列</strong></p><blockquote><p>用来存放微任务，有且只有一个</p></blockquote><p><strong>宏任务和微任务执行顺序？</strong></p><blockquote><p>-&gt;执行第一个宏任务队列（主线程）</p><p>-&gt; 如果存在微任务队列</p><p>​     -&gt; 执行微任务队列</p><p>​    否则</p><p>​    -&gt;执行宏任务队列</p></blockquote><p><strong>宏任务、微任务以及nodejs事件循环检查阶段的执行顺序？</strong></p><blockquote><p>nodejs事件循环检查阶段———————–见上面：事件循环机制的六个阶段</p><p>nodejs事件循环检查阶段主要是针对宏任务的，只是在每个检查阶段结束后都会检查微队列中是否有微队列要执行，有的话先执行微队列，说明了微任务的紧急性。</p></blockquote><p><strong>面试题</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;---------------------start-------------------------&#x27;</span>)<br><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;setTimeout&#x27;</span>)<br>&#125;, <span class="hljs-number">0</span>)<br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i)<br>  &#125;<br>  <span class="hljs-title function_">resolve</span>()<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Promise实例成功执行&#x27;</span>)<br>&#125;)<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;---------------------end-------------------------&#x27;</span>)<br><br><span class="hljs-comment">//以下是执行结果</span><br>---------------------start-------------------------<br><span class="hljs-number">0</span><br><span class="hljs-number">1</span><br><span class="hljs-number">2</span><br><span class="hljs-number">3</span><br><span class="hljs-number">4</span><br>---------------------end-------------------------<br><span class="hljs-title class_">Promise</span>实例成功执行<br><span class="hljs-built_in">setTimeout</span><br></code></pre></td></tr></table></figure><h3 id="比较React和Vue"><a href="#比较React和Vue" class="headerlink" title="比较React和Vue"></a>比较React和Vue</h3><p><strong>相同点</strong></p><ol><li>都支持props进行父子组件间通信</li><li>都支持数据驱动视图，即 数据改变自动更新视图，不需手动更新</li><li>都支持服务端渲染</li><li>都支持虚拟DOM（React偏向于全部重新渲染）</li><li>都支持组件化开发</li></ol><p><strong>不同点</strong></p><ol><li>Vue是双向数据流，而React是单向的</li><li>Vue在修改仓库的数据可以直接this.xxx修改，而React必须调用封装的setState函数</li><li>Vue使用的是webback+vue-loader将js、html、css打包成的组件文件，而React使用的是JSX文件，将html、css全放入js中</li></ol><blockquote><p>如何记忆？js-&gt;模板视图渲染-&gt;组件</p><p>​                   js-&gt;仓库数据-&gt;组件</p><p>分类-&gt;时间顺序-&gt;规模由小到大</p></blockquote><h3 id="Vuex状态管理的机制"><a href="#Vuex状态管理的机制" class="headerlink" title="Vuex状态管理的机制"></a>Vuex状态管理的机制</h3><p><strong>是什么</strong></p><p>是一个专门用于Vue状态管理的插件</p><p><strong>作用</strong></p><p>可集中式处理多个组件的状态和处理后台数据</p><p><strong>原理</strong></p><p>state用来存储状态，getters是对于state计算后的结果，这两者都可以通过$store.state/getters或mapState、mapGetters给组件使用；actions里面的函数可以通过$store.dispatch或mapActions触发，触发后本质上是通过commit调用mutations里面的函数，mutions会直接修改state的值，当然，刚刚这个是actions获取数据，还可以actions里面也可以去修改后台数据。</p><blockquote><p>不难，但是要能说出来</p><p>思路：管理状态和处理后台数据</p><p>管理状态：state-&gt;actions-&gt;mutations-&gt;state-&gt;actions</p><p>处理后台数据：actions</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>面试题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端综合</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Node.js知识点</title>
    <link href="/2023/08/30/node-js/"/>
    <url>/2023/08/30/node-js/</url>
    
    <content type="html"><![CDATA[<h3 id="1-为什么javascript代码可以在浏览器中被执行？"><a href="#1-为什么javascript代码可以在浏览器中被执行？" class="headerlink" title="1.为什么javascript代码可以在浏览器中被执行？"></a>1.为什么javascript代码可以在浏览器中被执行？</h3><p>因为浏览器有js解析引擎，可以对js代码进行解析。这个js解析引擎每个浏览器都不同，只要知道其中谷歌浏览器的V8引擎是性能最好的，这也是前端程序员喜欢用谷歌浏览器的原因。</p><p><img src="/2023/08/30/node-js/js%E8%A7%A3%E6%9E%90%E5%BC%95%E6%93%8E.png" alt="js解析引擎"></p><h3 id="2-为什么javascript可以操作DOM、BOM"><a href="#2-为什么javascript可以操作DOM、BOM" class="headerlink" title="2.为什么javascript可以操作DOM、BOM"></a>2.为什么javascript可以操作DOM、BOM</h3><p>因为每个浏览器都内置了DOM、BOM这样的内置对象，这样js就可以在浏览器里操作它们。</p><ul><li><p>什么是DOM、BOM</p><p>DOM文本对象模型，包含处理页面的许多API</p><p>BOM浏览器对象模型，包含了与浏览器交互的API</p></li></ul><h3 id="3-javascript的运行环境包括什么？"><a href="#3-javascript的运行环境包括什么？" class="headerlink" title="3.javascript的运行环境包括什么？"></a>3.javascript的运行环境包括什么？</h3><p>即代码所需要的运行环境，包括 js解析引擎 和 内置API，其实就是上面两点所说的</p><p><u>关系：</u>应该是先经过解析引擎解析然后调用内置API就可以操作 BOM、DOM了</p><p><img src="/2023/08/30/node-js/js%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83.png" alt="js运行环境"></p><h3 id="4-javascript是如何做后端开发的？"><a href="#4-javascript是如何做后端开发的？" class="headerlink" title="4.javascript是如何做后端开发的？"></a>4.javascript是如何做后端开发的？</h3><p>javascript放在浏览器的环境里就是做前端的，放在node.js环境里就是做后端的。</p><ul><li>注意：在node.js环境中不能调用DOM、BOM、ajax对象，因为它里面只提供后端的API，这些浏览器的内置API它无关。</li></ul><h4 id="5-什么是node-js？"><a href="#5-什么是node-js？" class="headerlink" title="5.什么是node.js？"></a>5.什么是node.js？</h4><p>node.js是基于V8引擎的javascript运行环境。注意是这里也是V8引擎，是因为谷歌V8引擎性能好。</p><h3 id="6-node-js可以干什么以及学习路径？"><a href="#6-node-js可以干什么以及学习路径？" class="headerlink" title="6.node.js可以干什么以及学习路径？"></a>6.node.js可以干什么以及学习路径？</h3><p>可以做所有后端可以做的事情</p><p>学习路径：js基础语法-&gt;内置API（fs、path、http）-&gt;第三方API模块（express、mysql）</p><h3 id="7-powershell是什么？如何打开？"><a href="#7-powershell是什么？如何打开？" class="headerlink" title="7.powershell是什么？如何打开？"></a>7.powershell是什么？如何打开？</h3><p>它是cmd的升级版，以后尽量使用powershell，在当前文件夹按住shift右键便可打开</p><h3 id="8-终端中的快捷键"><a href="#8-终端中的快捷键" class="headerlink" title="8.终端中的快捷键"></a>8.终端中的快捷键</h3><p>方向↑键：获取上一条命令</p><p>esc：清空当前命令</p><p>tab：在当前文件夹中，输入某个文件的前几个字符，按tab可以直接补全，这个一般用于 文件名太长的场景下。</p><p>cls：清空所有命令</p><h2 id="fs文件系统模块"><a href="#fs文件系统模块" class="headerlink" title="fs文件系统模块"></a>fs文件系统模块</h2><h3 id="1-How-to-import"><a href="#1-How-to-import" class="headerlink" title="1.How to import?"></a>1.How to import?</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="2-什么是utf-8？"><a href="#2-什么是utf-8？" class="headerlink" title="2.什么是utf-8？"></a>2.什么是utf-8？</h3><p>它是一种基于unicode的一种编码方式，可以表示unicode的任意一种字符</p><h2 id="path模块"><a href="#path模块" class="headerlink" title="path模块"></a>path模块</h2><h3 id="1-什么是path模块？"><a href="#1-什么是path模块？" class="headerlink" title="1.什么是path模块？"></a>1.什么是path模块？</h3><p>可以对路径进行各种处理，包括join()可将多个路径片段拼接成一个字符串、basename()获取路径中的文件名</p><h2 id="HTTP模块"><a href="#HTTP模块" class="headerlink" title="HTTP模块"></a>HTTP模块</h2><h3 id="1-127-0-0-1就是localhost"><a href="#1-127-0-0-1就是localhost" class="headerlink" title="1.127.0.0.1就是localhost"></a>1.127.0.0.1就是localhost</h3><h3 id="2-80端口的服务80端口是可以省略的"><a href="#2-80端口的服务80端口是可以省略的" class="headerlink" title="2.80端口的服务80端口是可以省略的"></a>2.80端口的服务80端口是可以省略的</h3><p>npm与包</p><h3 id="1-安装package-json的命令：npm-init-y"><a href="#1-安装package-json的命令：npm-init-y" class="headerlink" title="1.安装package.json的命令：npm init -y"></a>1.安装package.json的命令：npm init -y</h3><p>这里的-y是指当选择确认或者取消的时候自动选择y(yes)，好像可以不写-y</p><p>注意：</p><ul><li>使用这个命令的时候，路径不能为中文且名字不能有空格</li><li>一定要初始化之后，安装第三方包才会生效，才会安装到此项目中，否则都不知道安装到哪去了</li></ul><h3 id="2-dependences"><a href="#2-dependences" class="headerlink" title="2.dependences"></a>2.dependences</h3><p>在package.json里面，专门记录安装了哪些包，因此有时候也说依赖包，在依赖下的包</p><p>在安装多个包的时候，可以用空格来分隔 npm i jquery art-template</p><h3 id="3-devDependence"><a href="#3-devDependence" class="headerlink" title="3.devDependence"></a>3.devDependence</h3><p>只在开发阶段使用的包放在这里，怎么看是否要安装到dev环境？</p><p>到官网npmjs.com去查找使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">npm i 包名 -D<br></code></pre></td></tr></table></figure><p>这里的-D就是–save -dev的简写，不写-D默认安装在dependences里面</p><h3 id="4-包下载慢的问题"><a href="#4-包下载慢的问题" class="headerlink" title="4.包下载慢的问题"></a>4.包下载慢的问题</h3><p><strong>原因：</strong></p><p>使用npm通常是直接从国外服务器下载过来的，其中需要经过海底光缆，需要一定时间</p><p>而 国内淘宝镜像服务器 它可以每隔一段时间把国外服务器上的数据同步过来，然后提供给国内用户下载，这样国内用户就可以在镜像上下载，而且还很快</p><p><strong>称为镜像的原因：</strong></p><p>就像镜子中的人像一样，就相当于你的副本</p><p><strong>如何切换为国内淘宝镜像源：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-number">1</span>、先查看当前镜像源地址<br>npm config get registry<br><span class="hljs-number">2</span>、配置<br>npm config set registry=<span class="hljs-attr">https</span>:<span class="hljs-comment">//registry.npm.taobao.org/</span><br></code></pre></td></tr></table></figure><p><strong>如何更方便的切换：使用nrm（node registry management）</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-number">1</span>、安装<br>npm i nrm -g<br><span class="hljs-number">2</span>、查看所有镜像源地址<br>nrm ls<br><span class="hljs-number">3</span>、使用淘宝镜像<br>nrm use taobao <br></code></pre></td></tr></table></figure><h3 id="4-包的分类"><a href="#4-包的分类" class="headerlink" title="4.包的分类"></a>4.包的分类</h3><ul><li><p>项目包（从项目开发的角度）</p><p>又开发依赖包（devDependence）和核心包（dependence）</p></li><li><p>全局包</p><p>默认安装位置：C:\Users\K22070055\AppData\Roaming\npm\node_modules</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">npm i 包名 -g<br>npm uninstall 包名 -g<br></code></pre></td></tr></table></figure><p>什么时候需要加-g？</p><p>1.加-g的最好是工具包，就是可以提供一些命令使用的，这样就可以任意地方使用</p><p>2.是在不清楚可以去npmjs.com官网查看是否需要加，人家都有写在上面</p><p><u>PS：好用的全局包</u>：</p><p>npm i -g i5ting_toc ————– 可以将md文件转换为html文件</p><p>使用方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">i5ting_toc -f md文件地址 -o<br></code></pre></td></tr></table></figure><p>表示把文件（file）地址为…的文件从md转换为html并打开（open）</p><p>注意文件地址，如果是相对路径一定要和当前目录拼接对应上</p></li></ul><h3 id="5-规范的包结构"><a href="#5-规范的包结构" class="headerlink" title="5.规范的包结构"></a>5.规范的包结构</h3><ul><li>包必须以单独的目录存在（node_modules）</li><li>每个包的顶级目录（当前包刚点进去）必有一个package.json文件</li><li>每个package.json文件必须包含name（包名）、version（版本号）、main（包的入口），这个入口就是提供被别人使用require来引入的</li></ul><h3 id="6-开发属于自己的包"><a href="#6-开发属于自己的包" class="headerlink" title="6.开发属于自己的包"></a>6.开发属于自己的包</h3><p>1.新建一个文件夹itheima-tools，作为包的根目录</p><p>2.在itheima-tools文件夹中新建如下三个文件：</p><ul><li>package.json（包管理配置文件）</li><li>index.js（包的入口文件）</li><li>README.md（包的说明文档）</li><li>在当前包根目录下 npm publish即可发布，名字不能是大写而且改完后还要改package.json文件里的name</li></ul><p>注意：尽量不要在npm上面发布无意义的包，此时就需要删除自己发布的包，用命令 npm unpublish 包名 –force</p><h3 id="7-模块的加载机制"><a href="#7-模块的加载机制" class="headerlink" title="7.模块的加载机制"></a>7.模块的加载机制</h3><p><u>优先从缓存中加载</u>，即如果一个包已经加载过一次，那么就会在本地缓存一份，那么下次再加载就会优先从缓存中加载，不会再从头到尾重新执行一遍代码，提高了加载效率</p><ul><li><p>内置模块的加载机制，如果出现同名模块，则优先加载内置模块的那个</p></li><li><p>自定义模块的加载机制，在加载时一定要以./、../开头，因为不加这些node会默认把它当作是内置模块或者是第三方模块，加了就是为了告诉node我写的模块在哪</p><p>同时，如果自定义模块在加载时 拓展名 忘记写了，则Node会默认按照一下顺序进行不全，补全.js进行加载-&gt;补全.json进行加载-&gt;补全.node进行加载-&gt;加载失败，终端报错</p></li><li><p>将某目录作为模块，则会 </p><p>找当前目录的package.json文件，然后找到main属性所指向的地址-&gt;如果没有package.json文件或者main不存在或者地址无法解析，则会加载当前目录的index.js-&gt;如果前两部都失败了，则会报错：Error:Can’t find the module xxx</p></li></ul><h2 id="Express"><a href="#Express" class="headerlink" title="Express"></a>Express</h2><h3 id="1-简单介绍"><a href="#1-简单介绍" class="headerlink" title="1.简单介绍"></a>1.简单介绍</h3><ul><li><p>它是基于node.js的极简的web框架的第三方模块</p></li><li><p>没有express可以创建web服务器吗？</p><p>可以，使用Http模块就可以</p></li><li><p>既然有了Http模块，为什么还要express？</p><p>因为Http模块太过繁琐，开发效率低，而express是从Http模块进一步封装来的，开发效率高</p></li></ul><h3 id="2-Express能做什么？"><a href="#2-Express能做什么？" class="headerlink" title="2.Express能做什么？"></a>2.Express能做什么？</h3><p>对于前端程序员有两种服务器：</p><ul><li><p>网站服务器</p><p>专门对外提供网站资源的服务器</p></li><li><p>API接口服务器</p><p>专门对外提供API接口的服务器</p></li></ul><p>Express能够很方便的<u>创建网站服务器</u>或<u>API接口服务器</u></p><h3 id="3-Express中间件"><a href="#3-Express中间件" class="headerlink" title="3.Express中间件"></a>3.Express中间件</h3><p><strong>1.概念</strong></p><p>类似于处理污水的中间处理环节</p><p><strong>2.中间件的处理流程</strong></p><p>当一个请求到达express服务器的时候，会连续调用多个中间件，进而对请求进行预处理，也就是说中间件的作用就是对请求进行预处理</p><p><img src="/2023/08/30/node-js/%E4%B8%AD%E9%97%B4%E4%BB%B6%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B.png" alt="中间件调用流程"></p><p><strong>3.中间件的格式</strong></p><p>中间件本质上是个处理函数，在参数上比路由多一个next参数，且这个next参数是个函数</p><p><img src="/2023/08/30/node-js/%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%A0%BC%E5%BC%8F.png" alt="中间件格式"></p><p><strong>4.next函数的作用</strong></p><p>它是中间件连续调用的关键，调用了next函数后就可以转接给下一个中间件或路由</p><p><strong>5.中间件的作用</strong></p><p>由于中间件之间可以共享req res，因此上层中间件可以定义一些自定义属性和方法给下层使用</p><p><strong>6.中间件的分类</strong></p><ul><li><p>应用级别</p><p>像app.get、app.post这种挂载在app上的中间件</p></li><li><p>路由级别</p><p>像router.get、router.post这种由express.Router()挂载的中间件</p></li><li><p>错误级别</p><p>函数参数前面还需要err的中间件</p></li><li><p>内置</p><p>express.static、express.json（负责解析json格式数据）、express.urlencoded（负责解析URL-encoded格式数据），后两个必须要在4.16.0以后才能使用</p></li><li><p>第三方</p></li></ul><h2 id="跨域问题"><a href="#跨域问题" class="headerlink" title="跨域问题"></a><strong>跨域问题</strong></h2><p><strong>1.前言</strong></p><p>在不同域数据时请求时，由于浏览器的同源策略，会阻止服务器返回来的资源进入浏览器</p><p><strong>2.用cors解决跨域</strong></p><p>它会有一些响应头相当于vip让浏览器可以允许通过 </p><p><strong>3.cors的三个请求头</strong></p><p>Access-Control-Allow-Origin：可具体设置允许哪个 url，或者*所有url 通过</p><p>Access-Control-Allow-Header：内置一些允许的头部，如果请求的头部不在里面，则需另外加</p><p>Access-Control-Allow-Methods：针对一些方法来设置是否允许请求，比如DELETE、PUT</p><p><strong>4.cors请求的分类</strong></p><ul><li><p>简单请求</p><p>①请求方式：GET、POST、HEAD三者之一</p><p>②头部信息不超过内置的所有种类</p></li><li><p>预检请求</p><p>在浏览器与服务器正式通信之前，浏览器会先发送OPTION请求进行<u>预检</u>，来确认服务器是否允许这次请求</p><p>①请求方式为除了GET、POST、HEAD之外的Method类型</p><p>②请求头中包含自定义字段</p><p>③向服务器发送了application/json格式的数据</p></li></ul><p><strong>5.jsonp来解决跨域</strong></p><p><u>概念</u>：浏览器通过<script>标签的src属性向服务器请求数据，服务器返回一个函数的调用，这种方式就叫做JSONP</p><p><u>特点</u>：</p><p>①JSONP不属于Ajax请求，因为它没有使用XMLHttpRequest这个对象</p><p>②JSONP仅支持GET请求，不支持PUT、DELETE、POST等请求</p><h3 id="JWT（Json-Web-Token）身份认证"><a href="#JWT（Json-Web-Token）身份认证" class="headerlink" title="JWT（Json Web Token）身份认证"></a>JWT（Json Web Token）身份认证</h3><p><strong>1.组成部分</strong></p><p>Payload：这才是真正的用户信息，它是由用户信息经过加密后字符串</p><p>Header、Signature：只是为了保证Token的安全 </p>]]></content>
    
    
    <categories>
      
      <category>Node.js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>知识点</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue3相对于Vue2的不同用法</title>
    <link href="/2023/08/30/Vue3%E7%9B%B8%E5%AF%B9%E4%BA%8EVue2%E7%9A%84%E4%B8%8D%E5%90%8C%E7%94%A8%E6%B3%95/"/>
    <url>/2023/08/30/Vue3%E7%9B%B8%E5%AF%B9%E4%BA%8EVue2%E7%9A%84%E4%B8%8D%E5%90%8C%E7%94%A8%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h3 id="1-项目结构"><a href="#1-项目结构" class="headerlink" title="1.项目结构"></a>1.项目结构</h3><p><strong>main.js文件</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; createApp &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./App.vue&#x27;</span><br><br><span class="hljs-comment">//Vue3写法 </span><br><span class="hljs-title function_">createApp</span>(<span class="hljs-title class_">App</span>).<span class="hljs-title function_">mount</span>(<span class="hljs-string">&#x27;#app&#x27;</span>)<br><br><span class="hljs-comment">// Vue2写法</span><br><span class="hljs-comment">// new Vue(&#123;</span><br><span class="hljs-comment">//     render: h =&gt; h(App)</span><br><span class="hljs-comment">// &#125;)</span><br><br><span class="hljs-comment">// ========&gt; (1)新建实例并渲染App 直接简化为 创建App,简化后更加利于理解</span><br></code></pre></td></tr></table></figure><h3 id="2-setup"><a href="#2-setup" class="headerlink" title="2.setup"></a>2.setup</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;template&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;&#123; a &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;sayHello&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>&lt;/template&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> &#123;h&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-attr">name</span>: <span class="hljs-string">&quot;HelloWorld&quot;</span>,</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-comment">//    vue2的写法是可以兼容的  data...</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-comment">//    访问顺序，vue2的配置(data、computed、watch...)=&gt;vue3的stepup，但vue3的stepup无法访问vue2的配置</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-comment">// (3)目的是：Vue3统一访问数据规范，不乱套(如果有重名优先setup)</span></span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-comment">// (1)数据、方法全放在sepup里，用于替代created、beforecreated，</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-comment">//    是组合式API，也Vue3的原生写法，代码更清晰</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-comment">// (4)不可在setup前加async，因为它默认只有返回对象或渲染函数才能被模板使用，而不是包裹着promise的对象（后期也可以返回promise对象，只是需要suspense和异步引入组件）</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml"> <span class="hljs-keyword">let</span> a = <span class="hljs-number">1</span>;</span></span><br><span class="language-javascript"><span class="language-xml"> <span class="hljs-keyword">function</span> <span class="hljs-title function_">sayHello</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">   <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;hello&quot;</span>);</span></span><br><span class="language-javascript"><span class="language-xml"> &#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"> <span class="hljs-comment">// 返回对象 ----- 组合式API体现出来了</span></span></span><br><span class="language-javascript"><span class="language-xml"> <span class="hljs-keyword">return</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">   a,</span></span><br><span class="language-javascript"><span class="language-xml">   sayHello</span></span><br><span class="language-javascript"><span class="language-xml"> &#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"> <span class="hljs-comment">// (2)返回渲染函数----针对具体某个标签单独渲染</span></span></span><br><span class="language-javascript"><span class="language-xml"> <span class="hljs-comment">// return ()=&gt;h(&#x27;h1&#x27;,a)</span></span></span><br><span class="language-javascript"><span class="language-xml">&#125;,</span></span><br><span class="language-javascript"><span class="language-xml">&#125;;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="3-ref"><a href="#3-ref" class="headerlink" title="3.ref"></a>3.ref</h3><p><strong>基本类型</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;template&gt;<br>&lt;!-- (<span class="hljs-number">4</span>)在模板中不需要 .<span class="hljs-property">value</span>，因为<span class="hljs-title class_">Vue3</span>默认给你添上了 --&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;&#123; name &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;&#123; age &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;changeInfo&quot;</span>&gt;</span>更改信息<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>&lt;/template&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> &#123;ref&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-attr">name</span>: <span class="hljs-string">&quot;HelloWorld&quot;</span>,</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-attr">props</span>: &#123;</span></span><br><span class="language-javascript"><span class="language-xml"> <span class="hljs-attr">msg</span>: <span class="hljs-title class_">String</span>,</span></span><br><span class="language-javascript"><span class="language-xml">&#125;,</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml"> <span class="hljs-keyword">let</span> name = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&#x27;张三&#x27;</span>); <span class="hljs-comment">// (2)&#x27;张三&#x27;变成了引用对象RefImpl:&#123;...,value,...&#125;</span></span></span><br><span class="language-javascript"><span class="language-xml"> <span class="hljs-keyword">let</span> age = <span class="hljs-title function_">ref</span>(<span class="hljs-number">18</span>);</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"> <span class="hljs-comment">// (1)不用ref并对value修改的话，数据不是响应式的：数据修改了但是没有渲染到模板上(因为是原生写法)</span></span></span><br><span class="language-javascript"><span class="language-xml"> <span class="hljs-comment">// (5)而ref是响应式的，看名字也可理解：引用实现，相当于C++的引用，模板拿的是地址，而这里是地址对应的值</span></span></span><br><span class="language-javascript"><span class="language-xml"> <span class="hljs-keyword">function</span> <span class="hljs-title function_">changeInfo</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">   name.<span class="hljs-property">value</span> = <span class="hljs-string">&#x27;李四&#x27;</span>; <span class="hljs-comment">// (3)在原型对象上有getter和setter可对value进行读写</span></span></span><br><span class="language-javascript"><span class="language-xml">   age.<span class="hljs-property">value</span> = <span class="hljs-number">48</span>;</span></span><br><span class="language-javascript"><span class="language-xml">   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name,age);</span></span><br><span class="language-javascript"><span class="language-xml"> &#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"> <span class="hljs-keyword">return</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">   name,</span></span><br><span class="language-javascript"><span class="language-xml">   age,</span></span><br><span class="language-javascript"><span class="language-xml">   changeInfo</span></span><br><span class="language-javascript"><span class="language-xml"> &#125;</span></span><br><span class="language-javascript"><span class="language-xml">&#125;,</span></span><br><span class="language-javascript"><span class="language-xml">&#125;;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p><strong>引用类型</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;template&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;&#123; job.type &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;&#123; job.salary &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;changeInfo&quot;</span>&gt;</span>更改信息<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>&lt;/template&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> &#123;ref&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-attr">name</span>: <span class="hljs-string">&quot;HelloWorld&quot;</span>,</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml"> <span class="hljs-keyword">let</span> job = <span class="hljs-title function_">ref</span>(&#123;</span></span><br><span class="language-javascript"><span class="language-xml">   <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;前端&#x27;</span>,</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-attr">salary</span>:<span class="hljs-string">&#x27;10K&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml"> &#125;)</span></span><br><span class="language-javascript"><span class="language-xml"> <span class="hljs-keyword">function</span> <span class="hljs-title function_">changeInfo</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">   <span class="hljs-comment">// (1) ref对于对象类型来说，直接转换为proxy对象:proxy&#123;type: &#x27;前端&#x27;,salary:&#x27;10K&#x27;&#125;，因此不需要type再.value了</span></span></span><br><span class="language-javascript"><span class="language-xml">   <span class="hljs-comment">//     而proxy的实现其实reactive来封装的，因此可以说ref对于对象类型其实求助于了reactive     即 value:proxy&#123;&#125; </span></span></span><br><span class="language-javascript"><span class="language-xml">   job.<span class="hljs-property">value</span>.<span class="hljs-property">type</span> = <span class="hljs-string">&#x27;UI设计师&#x27;</span>;</span></span><br><span class="language-javascript"><span class="language-xml">   job.<span class="hljs-property">value</span>.<span class="hljs-property">salary</span> = <span class="hljs-string">&#x27;20K&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml"> &#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"> <span class="hljs-keyword">return</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">   changeInfo,</span></span><br><span class="language-javascript"><span class="language-xml">   job</span></span><br><span class="language-javascript"><span class="language-xml"> &#125;</span></span><br><span class="language-javascript"><span class="language-xml">&#125;,</span></span><br><span class="language-javascript"><span class="language-xml">&#125;;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="4-reactive"><a href="#4-reactive" class="headerlink" title="4.reactive"></a>4.reactive</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js">...<br><span class="hljs-keyword">let</span> job = <span class="hljs-title function_">reactive</span>(&#123;<br>   <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;前端&#x27;</span>,<br>    <span class="hljs-attr">salary</span>:<span class="hljs-string">&#x27;10K&#x27;</span><br> &#125;)<br> <br> <span class="hljs-keyword">function</span> <span class="hljs-title function_">changeInfo</span>(<span class="hljs-params"></span>) &#123;<br>   name.<span class="hljs-property">value</span> = <span class="hljs-string">&#x27;李四&#x27;</span>; <br>   age.<span class="hljs-property">value</span> = <span class="hljs-number">48</span>;<br><br>   <span class="hljs-comment">// (1)reactive直接转化成 proxy&#123;type: &#x27;前端&#x27;,salary:&#x27;10K&#x27;&#125;,这样就可以像正常访问数据并修改后直接相应到模板上</span><br>   job.<span class="hljs-property">type</span> = <span class="hljs-string">&#x27;UI设计师&#x27;</span>;<br>   job.<span class="hljs-property">salary</span> = <span class="hljs-string">&#x27;20K&#x27;</span><br> &#125;<br>...<br></code></pre></td></tr></table></figure><blockquote><p>建议：基本类型使用ref，引用类型用reactive（不用写value）</p></blockquote><h3 id="5-reflect"><a href="#5-reflect" class="headerlink" title="5.reflect"></a>5.reflect</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> person = &#123;<br>    <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;周杰&#x27;</span><br>&#125;<br><span class="hljs-comment">// (1)Reflect也自带defineproperty，但是它可以自动捕获异常(比如对同一属性重复设置值)，而原来的Object.defineproperty需要手写try-catch</span><br><span class="hljs-comment">// (2)通常配合proxy实现数据响应，使Vue3中数据相应使用更方便</span><br><span class="hljs-keyword">let</span> r = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">defineproperty</span>(person,<span class="hljs-string">&#x27;age&#x27;</span>,&#123;<br>      <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>)&#123;<br>          <span class="hljs-keyword">return</span> number <br>      &#125;,<br>      <span class="hljs-title function_">set</span>(<span class="hljs-params">value</span>)&#123;<br>          <span class="hljs-variable language_">this</span>.<span class="hljs-property">number</span> = value <br>      &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="6-setup补充"><a href="#6-setup补充" class="headerlink" title="6.setup补充"></a>6.setup补充</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 父组件</span><br>&lt;template&gt;<br>  &lt;!-- 绑定一个自定义事件hello给子组件，表示需要子组件传值 --&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Demo</span> <span class="hljs-attr">msg</span>=<span class="hljs-string">&quot;你好啊&quot;</span> <span class="hljs-attr">school</span>=<span class="hljs-string">&quot;尚硅谷&quot;</span> @<span class="hljs-attr">hello</span>=<span class="hljs-string">&quot;hello&quot;</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-comment">&lt;!-- 插槽内容得写在子组件内部，这样就表示子组件是需要使用的 --&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:asd</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>插槽内容<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">Demo</span>&gt;</span></span><br>&lt;/template&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Demo</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./components/Demo.vue&quot;</span>;</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;App&quot;</span>,</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">components</span>: &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-title class_">Demo</span>,</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">function</span> <span class="hljs-title function_">hello</span>(<span class="hljs-params">value</span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;-----接收到了子组件的值：&quot;</span>, value);</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">return</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      hello,</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;;</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">&#125;;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><br><span class="hljs-comment">//子组件</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;&#123; person.name &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;&#123; person.age &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;test&quot;</span>&gt;</span>测试一下触发自定义事件<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> &#123; reactive &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;myDemo&quot;</span>,</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">props</span>: [<span class="hljs-string">&quot;msg&quot;</span>, <span class="hljs-string">&quot;school&quot;</span>],</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-comment">// Vue3中不写会有警告</span></span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">emits</span>: [<span class="hljs-string">&quot;hello&quot;</span>],</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-comment">// slots:[&#x27;asd&#x27;],</span></span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-title function_">beforeCreate</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;---beforeCreate---&quot;</span>);</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-comment">// (1) setup执行的比beforeCreate还早(提前准备好响应式数据)</span></span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-comment">//   且setup的this为undefined(因为setup规范好了不使用this，避免像Vue2中this的指向问题)</span></span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-title function_">setup</span>(<span class="hljs-params">props, context</span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// (2) props参数指 父组件传递过来数据并且子组件中用props:[]接受好了，那么此时使用setup内的props就不会有警告(得准备好了)</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">//     为什么需要setup里面的props?因为它已经把props[]接收到的数据转化成立proxy对象，使用可立即响应</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// (3) context上下文相当于以前的vm，可以获取以前vm很多内置属性attr、emit(没有$)</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">//     在vue3有专门的emits属性，和props一样，这样写非常清晰，表示接受了什么自定义事件</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;---setup---&quot;</span>, props, context);</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;---setup---&quot;</span>, props, context.<span class="hljs-property">attrs</span>);</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;---setup---&quot;</span>, props, context.<span class="hljs-property">emit</span>);</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;---setup---&quot;</span>, props, context.<span class="hljs-property">slots</span>);</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">let</span> person = <span class="hljs-title function_">reactive</span>(&#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;张三&quot;</span>,</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;);</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      context.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;我是传递的值&quot;</span>);</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">return</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      person,</span></span><br><span class="language-javascript"><span class="language-xml">      test</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;;</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">&#125;;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p><strong>化繁为简：</strong>主要讲了setup函数的执行时间以及setup两个参数props和context（数据都是从父组件传过来的）</p><h3 id="7-computed"><a href="#7-computed" class="headerlink" title="7.computed"></a>7.computed</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;template&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>一个人的信息<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br>  姓：&lt;input type=<span class="hljs-string">&quot;text&quot;</span> v-model=<span class="hljs-string">&quot;person.firstName&quot;</span> /&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span></span><br>  名：&lt;input type=<span class="hljs-string">&quot;text&quot;</span> v-model=<span class="hljs-string">&quot;person.lastName&quot;</span> /&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span></span><br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>全名：&#123;&#123; person.fullName &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span></span><br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;person.fullName&quot;</span> /&gt;</span></span><br>&lt;/template&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-comment">// 体现出了组合式API的使用</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> &#123; reactive, computed &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;myDemo&quot;</span>,</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">let</span> person = <span class="hljs-title function_">reactive</span>(&#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">firstName</span>: <span class="hljs-string">&quot;张&quot;</span>,</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">lastName</span>: <span class="hljs-string">&quot;三&quot;</span>,</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;);</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// 简写形式，默认调用get-----只读</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// person.fullName = computed(() =&gt; &#123;</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">//   return person.firstName+&#x27;-&#x27;+person.lastName</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// &#125;)</span></span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// 完整形式，可读可写</span></span></span><br><span class="language-javascript"><span class="language-xml">    person.<span class="hljs-property">fullName</span> = <span class="hljs-title function_">computed</span>(&#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-keyword">return</span> person.<span class="hljs-property">firstName</span> + <span class="hljs-string">&quot;-&quot;</span> + person.<span class="hljs-property">lastName</span>;</span></span><br><span class="language-javascript"><span class="language-xml">      &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-title function_">set</span>(<span class="hljs-params">value</span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-keyword">let</span> arr = value.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;-&quot;</span>);</span></span><br><span class="language-javascript"><span class="language-xml">        person.<span class="hljs-property">firstName</span> = arr[<span class="hljs-number">0</span>];</span></span><br><span class="language-javascript"><span class="language-xml">        person.<span class="hljs-property">lastName</span> = arr[<span class="hljs-number">1</span>];</span></span><br><span class="language-javascript"><span class="language-xml">      &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;);</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">return</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      person,</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;;</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">&#125;;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="8-watch"><a href="#8-watch" class="headerlink" title="8.watch"></a>8.watch</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;template&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>当前求和：&#123;&#123; sum &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;add&quot;</span>&gt;</span>点击+1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>当前信息：&#123;&#123; msg &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;msg += &#x27;!&#x27;&quot;</span>&gt;</span>点击增加感叹号<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span></span><br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>姓名：&#123;&#123; person.name &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>年龄：&#123;&#123; person.age &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;person.name += &#x27;~&#x27;&quot;</span>&gt;</span>修改姓名<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span></span><br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;person.age++&quot;</span>&gt;</span>增长年龄<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span></span><br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>薪资：&#123;&#123; person.job.j1.salary &#125;&#125;K<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span></span><br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;person.job.j1.salary++&quot;</span>&gt;</span>涨薪<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>&lt;/template&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-comment">// 体现出了组合式API的使用</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> &#123; ref, watch, reactive &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;myDemo&quot;</span>,</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">let</span> sum = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>);</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">let</span> msg = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&quot;你好啊&quot;</span>);</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">let</span> person = <span class="hljs-title function_">reactive</span>(&#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;张三&quot;</span>,</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">job</span>: &#123;</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-attr">j1</span>: &#123;</span></span><br><span class="language-javascript"><span class="language-xml">          <span class="hljs-attr">salary</span>: <span class="hljs-number">10</span>,</span></span><br><span class="language-javascript"><span class="language-xml">        &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">      &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;);</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      sum.<span class="hljs-property">value</span>++;</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// 情况一：监视ref定义的一个响应式数据</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// watch(sum, (newValue, oldValue) =&gt; &#123;</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">//   console.log(&quot;sum数据变化了：&quot;, newValue, oldValue);</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// &#125;);</span></span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// 情况二：监视ref多个属性，参数位置：监视对象,数据回调函数,配置项</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// watch(</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">//   [sum, msg],</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">//   (newValue, oldValue) =&gt; &#123;</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">//     console.log(&quot;sum数据变化了：&quot;, newValue[0], oldValue[0]);</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">//     console.log(&quot;msg数据变化了：&quot;, newValue[1], oldValue[1]);</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// );</span></span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">/**</span></span></span><br><span class="hljs-comment"><span class="language-javascript"><span class="language-xml">     * 情况三：监视reactive定义的对象全部属性(两个bug)</span></span></span><br><span class="hljs-comment"><span class="language-javascript"><span class="language-xml">     * 1.注意：变化后新旧值一样，只能把所有属性分别用ref定义来解决</span></span></span><br><span class="hljs-comment"><span class="language-javascript"><span class="language-xml">     * 2.注意：强制开启了深度监听(deep:false无效)</span></span></span><br><span class="hljs-comment"><span class="language-javascript"><span class="language-xml">     * */</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// watch(person, (newValue, oldValue) =&gt; &#123;</span></span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">//   console.log(&quot;person数据变化了：&quot;, newValue, oldValue);</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// &#125;, &#123; deep: false &#125;);</span></span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// 情况四：监视reactive定义的一个响应式数据的某个属性</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">//        属性必须得写成箭头函数，否则无法监视到</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// watch(</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">//   ()=&gt;person.age,</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">//   (newValue, oldValue) =&gt; &#123;</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">//     console.log(&quot;person数据变化了：&quot;, newValue, oldValue);</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">//   &#125;,</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// );</span></span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// 情况五：监视reactive定义的一个响应式数据的某些属性</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">//   watch(</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">//   [()=&gt;person.name, ()=&gt;person.age],</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">//   (newValue, oldValue) =&gt; &#123;</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">//     console.log(&quot;sum数据变化了：&quot;, newValue[0], oldValue[0]);</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">//     console.log(&quot;msg数据变化了：&quot;, newValue[1], oldValue[1]);</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">//   &#125;,</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// );</span></span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// 特殊情况</span></span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-title function_">watch</span>(</span></span><br><span class="language-javascript"><span class="language-xml">       <span class="hljs-function">()=&gt;</span>person.<span class="hljs-property">job</span>,</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-function">(<span class="hljs-params">newValue, oldValue</span>) =&gt;</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;person数据变化了：&quot;</span>, newValue, oldValue);</span></span><br><span class="language-javascript"><span class="language-xml">          &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">      &#123;<span class="hljs-attr">deep</span>:<span class="hljs-literal">true</span>&#125;<span class="hljs-comment">//此处由于监视的是reactive中的某个对象属性(因为这时已经是至少2层了)，deep配置有效-------和情况三区分开来</span></span></span><br><span class="language-javascript"><span class="language-xml">    );</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">return</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      sum,</span></span><br><span class="language-javascript"><span class="language-xml">      add,</span></span><br><span class="language-javascript"><span class="language-xml">      msg,</span></span><br><span class="language-javascript"><span class="language-xml">      person,</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;;</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">&#125;;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p><strong>化繁为简：</strong>重点关注对reactive监听 的坑（情况三、四、五、特殊），正常开发其实一般只关注newValue，实在需要使用可以单独用ref拎出去</p><h3 id="9-watch补充"><a href="#9-watch补充" class="headerlink" title="9.watch补充"></a>9.watch补充</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script&gt;<br><span class="hljs-comment">// 体现出了组合式API的使用</span><br><span class="hljs-keyword">import</span> &#123; ref, watch &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;myDemo&quot;</span>,<br>  <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">let</span> sum = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">let</span> msg = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&quot;你好啊&quot;</span>);<br>    <span class="hljs-keyword">let</span> person = <span class="hljs-title function_">ref</span>(&#123;<br>      <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;张三&quot;</span>,<br>      <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,<br>      <span class="hljs-attr">job</span>: &#123;<br>        <span class="hljs-attr">j1</span>: &#123;<br>          <span class="hljs-attr">salary</span>: <span class="hljs-number">10</span>,<br>        &#125;,<br>      &#125;,<br>    &#125;);<br><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params"></span>) &#123;<br>      sum.<span class="hljs-property">value</span>++;<br>    &#125;<br><br>    <span class="hljs-comment">// (1)由于ref的.value值是定的，没有必要监视，因此会出现警报无法监视</span><br>    <span class="hljs-comment">//    而直接监视ref对象(其value可能会变)便可以监视了（有点类似字面量和变量的区别）</span><br>    <span class="hljs-comment">// watch(sum.value, (newValue, oldValue) =&gt; &#123;</span><br>    <span class="hljs-comment">//    console.log(&#x27;sum被监视了：&#x27;,newValue,oldValue);</span><br>    <span class="hljs-comment">// &#125;)</span><br><br>    <span class="hljs-comment">// (2)无法监视到，ref的person是个proxy对象，而只要对象地址不变，就认为没有变化</span><br>    <span class="hljs-comment">// 解决方法：1.加deep:true(不仅监视对象地址，还监视里面的属性)</span><br>    <span class="hljs-comment">//          2.加.value，这时监视的是reactive的proxy对象，强制deep:true</span><br>    <span class="hljs-title function_">watch</span>(person.<span class="hljs-property">value</span>,<span class="hljs-function">(<span class="hljs-params">newValue, oldValue</span>) =&gt;</span> &#123;<br>       <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;person被监视了：&#x27;</span>,newValue,oldValue);<br>    &#125;)<br><br>    <span class="hljs-keyword">return</span> &#123;<br>      sum,<br>      add,<br>      msg,<br>      person,<br>    &#125;;<br>  &#125;,<br>&#125;;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p><strong>化繁为简</strong>：主要针对ref的基本数据类型和对象类型的.value的情况进行了补充</p><h3 id="10-watchEffect"><a href="#10-watchEffect" class="headerlink" title="10.watchEffect"></a>10.watchEffect</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs js">    <span class="hljs-comment">// 不指明监视对象，在回调里用到什么数据就监视什么数据</span><br>    <span class="hljs-comment">// ==&gt;(1)好处是：不用针对不同的监视对象专门写个watch了</span><br>    <span class="hljs-comment">//       坏处是：如果监视的对象和处理的逻辑没有任何关系，则不会触发监听</span><br>    <span class="hljs-comment">// ==&gt;(2)为什么叫Effect?可能就是指 在回调里面哪个受影响了(使用到了)就监视</span><br>    <span class="hljs-comment">// (3)横向对比：有点类似computed，都会以来某些数据来做出相应的反应</span><br>    <span class="hljs-comment">//          只是computed重视的是结果，watchEffect重视过程 </span><br><span class="hljs-keyword">import</span> &#123; reactive, watchEffect &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">setup</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> state = <span class="hljs-title function_">reactive</span>(&#123;<br>    <span class="hljs-attr">count</span>: <span class="hljs-number">0</span>,<br>  &#125;);<br><br>  <span class="hljs-comment">// 在 watchEffect 中依赖到了 state.count</span><br>  <span class="hljs-title function_">watchEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;count 发生变化：&#x27;</span>, state.<span class="hljs-property">count</span>);<br>  &#125;);<br><br>  <span class="hljs-comment">// 在 setup 函数内部修改 state.count 的值</span><br>  state.<span class="hljs-property">count</span> = <span class="hljs-number">1</span>; <span class="hljs-comment">// 触发 watchEffect 回调函数</span><br><br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">increment</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    state.<span class="hljs-property">count</span>++; <span class="hljs-comment">// 不会触发 watchEffect 回调函数</span><br>  &#125;;<br><br>  <span class="hljs-keyword">return</span> &#123;<br>    state,<br>    increment,<br>  &#125;;<br>&#125;;<br></code></pre></td></tr></table></figure><p>在上面的例子中，我们在 <code>watchEffect</code> 的回调函数中依赖了 <code>state.count</code>，因此当 <code>state.count</code> 发生变化时，会触发 <code>watchEffect</code> 的回调函数。</p><p>然而，在 <code>increment</code> 函数中虽然修改了 <code>state.count</code> 的值，但由于 <code>watchEffect</code> 并没有依赖到 <code>increment</code> 函数，所以不会触发 <code>watchEffect</code> 的回调函数。</p><p>因此，只有在 <code>watchEffect</code> 函数内部依赖的响应式数据发生变化时，才会触发 <code>watchEffect</code> 的回调函数。其他的响应式数据变化不会对 <code>watchEffect</code> 产生影响。</p><h3 id="11-生命周期函数"><a href="#11-生命周期函数" class="headerlink" title="11.生命周期函数"></a>11.生命周期函数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// (1)setup相当于beforeCreated、created</span><br><span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">let</span> sum = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>);<br><br>  <span class="hljs-comment">// (2)在组合式API中得生命周期函数都加了 On</span><br>  <span class="hljs-title function_">onBeforeMount</span>(<span class="hljs-function">() =&gt;</span> &#123; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;---onBeforeMount---&#x27;</span>);&#125;);<br><br>  <span class="hljs-title function_">onMounted</span>(<span class="hljs-function">() =&gt;</span> &#123; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;---onMounted---&#x27;</span>);&#125;);<br><br>  <span class="hljs-title function_">onBeforeUpdate</span>(<span class="hljs-function">() =&gt;</span> &#123; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;---onBeforeUpdate---&#x27;</span>);&#125;);<br><br>  <span class="hljs-title function_">onUpdated</span>(<span class="hljs-function">() =&gt;</span> &#123; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;---onUpdated---&#x27;</span>);&#125;);<br>  <br>  <span class="hljs-comment">// (3)destoryed改为了 unmount，有种对应的感觉</span><br>  <span class="hljs-title function_">onBeforeUnmount</span>(<span class="hljs-function">() =&gt;</span> &#123; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;---onBeforeUnmount---&#x27;</span>);&#125;);<br><br>  <span class="hljs-title function_">onUnmounted</span>(<span class="hljs-function">() =&gt;</span> &#123; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;---onUnmounted---&#x27;</span>);&#125;);<br><br>  <span class="hljs-keyword">return</span> &#123;<br>    sum,<br>  &#125;;<br></code></pre></td></tr></table></figure><h3 id="12-自定义hooks"><a href="#12-自定义hooks" class="headerlink" title="12.自定义hooks"></a>12.自定义hooks</h3><ul><li>定义：是对组合式API的封装，写在setup中代码更加清晰</li><li>类比：相当于Vue2中的mixin</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// hooks/usePoint.js</span><br><span class="hljs-keyword">import</span> &#123; onBeforeUnmount, onMounted,reactive &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">let</span> point = <span class="hljs-title function_">reactive</span>(&#123;<br>    <span class="hljs-attr">x</span>: <span class="hljs-number">0</span>,<br>    <span class="hljs-attr">y</span>:<span class="hljs-number">0</span><br>  &#125;)<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">savePoint</span>(<span class="hljs-params">event</span>) &#123;<br>    point.<span class="hljs-property">x</span> = event.<span class="hljs-property">pageX</span>;<br>    point.<span class="hljs-property">y</span> = event.<span class="hljs-property">pageY</span>;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(point.<span class="hljs-property">x</span>,point.<span class="hljs-property">x</span>);<br>  &#125;<br>  <span class="hljs-title function_">onMounted</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, savePoint)<br>  &#125;);<br>  <span class="hljs-title function_">onBeforeUnmount</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-comment">// 一个点击事件可能有多个回调，因此要指明移除哪个回调</span><br>    <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, savePoint)<br>  &#125;);<br>  <span class="hljs-keyword">return</span> point;<br>&#125;<br><br><span class="hljs-comment">// 使用该逻辑的组件</span><br>&lt;template&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>鼠标坐标X:&#123;&#123; point.x &#125;&#125;,&#123;&#123; point.y &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br>&lt;/template&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> usePoint <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../hooks/usePoint&quot;</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;myDemo&quot;</span>,</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">let</span> point = <span class="hljs-title function_">usePoint</span>()</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">return</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      point</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;;</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">&#125;;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="13-toRef-toRefs"><a href="#13-toRef-toRefs" class="headerlink" title="13.toRef/toRefs"></a>13.toRef/toRefs</h3><ul><li>使用场景：想单独对某个对象的某些属性进行响应式更新，但是不想写多个对象.属性</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;template&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;&#123; person &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>姓名：&#123;&#123; name &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>年龄：&#123;&#123; age &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>薪资：&#123;&#123; salary &#125;&#125;K<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;name += &#x27;~&#x27;&quot;</span>&gt;</span>修改姓名<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span></span><br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;age++&quot;</span>&gt;</span>增长年龄<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span></span><br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;salary++&quot;</span>&gt;</span>涨薪<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>&lt;/template&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-comment">// 体现出了组合式API的使用</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> &#123; reactive, toRef,toRefs &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;myDemo&quot;</span>,</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">let</span> person = <span class="hljs-title function_">reactive</span>(&#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;张三&quot;</span>,</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">job</span>: &#123;</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-attr">j1</span>: &#123;</span></span><br><span class="language-javascript"><span class="language-xml">          <span class="hljs-attr">salary</span>: <span class="hljs-number">10</span>,</span></span><br><span class="language-javascript"><span class="language-xml">        &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">      &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;);</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// (3)toRef可以拿到某个对象的引用来响应式更新对应属性</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">return</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      person,</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-comment">// 错误使用(1)这种方式修改了，不会响应式更新，因为拿到的只是个 数值</span></span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-comment">// name: person.name,</span></span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-comment">// 错误使用(2)这种方式，仅仅是将person.name初始值复制了一份并进行响应式更新，源person内的name没有改变</span></span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-comment">// name: ref(person.name),</span></span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-comment">// name: toRef(person, &quot;name&quot;),</span></span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-comment">// age: toRef(person, &quot;age&quot;),</span></span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-comment">// salary: toRef(person.job.j1, &quot;salary&quot;),</span></span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-comment">// (4) 可以让某对象所有属性都拿到引用来响应式更新对应属性，通常和...一起使用(只能展开一层)----------要用的属性多且只有一层建议使用toRefs，否则toRef</span></span></span><br><span class="language-javascript"><span class="language-xml">      ...<span class="hljs-title function_">toRefs</span>(person)</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;;</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">&#125;;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="14-shallowReactive和shallowRef"><a href="#14-shallowReactive和shallowRef" class="headerlink" title="14.shallowReactive和shallowRef"></a>14.shallowReactive和shallowRef</h3><p>shallowReactive：只针对对象数据第一层进行响应式</p><p>shallowRef：可以对基本数据类型进行相应，但是对于对象数据不响应（没有求助reactive用proxy实现）</p><p>使用场景：<strong>针对对象数据类型，可以提高性能</strong></p><ul><li>如果某个对象层次很深，但是明确知道只有第一层会用到响应式——–shallowReactive</li><li>如果某个对象只可能在将来被整体替换，并且它里面的属性不会被修改——–shallowRef</li></ul><p>​     （shallowReactive只是只针对第一层，而shallowRef都没有进到对象里面，只考虑重新赋值后的属性初始值）</p><h3 id="15-readOnly和shallowReadonly"><a href="#15-readOnly和shallowReadonly" class="headerlink" title="15.readOnly和shallowReadonly"></a>15.readOnly和shallowReadonly</h3><p>把数据变成只读的（ref、reactive），shallowReadonly可以针对对象类型只在第一层限制只读</p><p>（readOnly对于普通对象还可以转化为proxy对象，谁叫这是vue3的api）</p><p>使用场景：某数据在组件A，传递给组件B时，要求组件B只能使用不能修改</p><h3 id="16-toRaw和markRaw"><a href="#16-toRaw和markRaw" class="headerlink" title="16.toRaw和markRaw"></a>16.toRaw和markRaw</h3><p>toRaw：可以将reactive对象———&gt;原对象</p><p>场景：临时不需要响应式——— 用的非常少</p><p>markRaw：永久标记成非响应式的</p><p>场景：第三方库不需要响应式 或者 某个某个对象层数太多，非响应式可以提高性能</p><h3 id="17-customRef"><a href="#17-customRef" class="headerlink" title="17.customRef"></a>17.customRef</h3><ul><li>作用：自定义逻辑的ref</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 通过自定义ref实现 在input框输入值，通过指定delay时间之后再显示到h1</span><br>&lt;template&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;keyword&quot;</span> /&gt;</span></span><br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;&#123; keyword &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br>&lt;/template&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> &#123; customRef &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;App&quot;</span>,</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">function</span> <span class="hljs-title function_">myRef</span>(<span class="hljs-params">value, delay</span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-keyword">return</span> <span class="hljs-title function_">customRef</span>(<span class="hljs-function">(<span class="hljs-params">track, trigger</span>) =&gt;</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-keyword">let</span> timer;</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-keyword">return</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">          <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-title function_">track</span>();</span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-keyword">return</span> value;</span></span><br><span class="language-javascript"><span class="language-xml">          &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">          <span class="hljs-title function_">set</span>(<span class="hljs-params">newValue</span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-comment">// 防止设置太多定时器，因此要每次清理定时器，然后只取最后一次以防抖</span></span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-built_in">clearTimeout</span>(timer);</span></span><br><span class="language-javascript"><span class="language-xml">            timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">              value = newValue;</span></span><br><span class="language-javascript"><span class="language-xml">              <span class="hljs-title function_">trigger</span>();</span></span><br><span class="language-javascript"><span class="language-xml">            &#125;, delay);</span></span><br><span class="language-javascript"><span class="language-xml">          &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">        &#125;;</span></span><br><span class="language-javascript"><span class="language-xml">      &#125;);</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">let</span> keyword = <span class="hljs-title function_">myRef</span>(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-number">500</span>);</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">return</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      keyword,</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;;</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">&#125;;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="18-provide和inject"><a href="#18-provide和inject" class="headerlink" title="18.provide和inject"></a>18.provide和inject</h3><ul><li>作用：用于祖孙之间通信（Vue3废除了全局事件总线）</li></ul><p>​                  (父子组件也能通信，但是父子组件最好还是props)</p><ul><li> 用法：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 爷组件</span><br><span class="hljs-title function_">provide</span>(<span class="hljs-string">&#x27;名字&#x27;</span>，要传递的数据)<br><br><span class="hljs-comment">// 孙组件</span><br><span class="hljs-keyword">let</span> name =  <span class="hljs-title function_">inject</span>(<span class="hljs-string">&#x27;名字&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="19-响应式数据的判断"><a href="#19-响应式数据的判断" class="headerlink" title="19.响应式数据的判断"></a>19.响应式数据的判断</h3><p>isRef、isReactive、isReadOnly、isProxy</p><p>注意：isProxy是判断是否由reactive或者readOnly创建的代理</p><h3 id="20-compositionApi的优势"><a href="#20-compositionApi的优势" class="headerlink" title="20.compositionApi的优势"></a>20.compositionApi的优势</h3><p>![vue2](C:/Users/K22070055/Desktop/新建文件夹 (3)/blog/source/_posts/vue2.gif)</p><p>![vue3](C:/Users/K22070055/Desktop/新建文件夹 (3)/blog/source/_posts/vue3.gif)</p><p>总结：vue2中一个功能被分散在各个配置项中，功能一多就不易维护，但是vue3一个功能可集中写在一起的</p><h3 id="21-fragmant组件"><a href="#21-fragmant组件" class="headerlink" title="21.fragmant组件"></a>21.fragmant组件</h3><p>由原来Vue2中必须得在template里面写一个跟标签，到Vue3中不用写根标签，但是默认被包在了一个Fragment元素中，<strong>即用内置的Fragment替换手写根标签</strong></p><h3 id="22-teleport组件"><a href="#22-teleport组件" class="headerlink" title="22.teleport组件"></a>22.teleport组件</h3><ul><li>作用：可将html标签移动到指定位置</li><li>案例：在多层嵌套标签内部点击出现基于全屏居中的弹框</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 祖组件</span><br>&lt;template&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;App&quot;</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>我是祖组件<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">Child</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Child</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&lt;/template&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Child</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./components/Child&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;App&#x27;</span>,</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">components</span>:&#123;</span></span><br><span class="language-javascript"><span class="language-xml">     <span class="hljs-title class_">Child</span></span></span><br><span class="language-javascript"><span class="language-xml">  &#125;</span></span><br><span class="language-javascript"><span class="language-xml">&#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;css&quot;</span> <span class="hljs-attr">scoped</span>&gt;</span><span class="language-css"></span></span><br><span class="language-css"><span class="language-xml">  <span class="hljs-selector-class">.App</span>&#123;</span></span><br><span class="language-css"><span class="language-xml">    <span class="hljs-attribute">background-color</span>: gray;</span></span><br><span class="language-css"><span class="language-xml">    <span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span>;</span></span><br><span class="language-css"><span class="language-xml">  &#125;</span></span><br><span class="language-css"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></span><br><br><span class="hljs-comment">// 父组件</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;Child&quot;</span>&gt;</span></span><br><span class="language-xml">       <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>我是父组件<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>    </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Son</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Son</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br>  <br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-keyword">import</span> <span class="hljs-title class_">Son</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./Son&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;myChild&#x27;</span>,</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-attr">components</span>:&#123;</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-title class_">Son</span></span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;</span></span><br><span class="language-javascript"><span class="language-xml">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br>  <br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;css&quot;</span> <span class="hljs-attr">scoped</span>&gt;</span><span class="language-css"></span></span><br><span class="language-css"><span class="language-xml">    <span class="hljs-selector-class">.Child</span>&#123;</span></span><br><span class="language-css"><span class="language-xml">      <span class="hljs-attribute">background-color</span>: skyblue;</span></span><br><span class="language-css"><span class="language-xml">      <span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span>;</span></span><br><span class="language-css"><span class="language-xml">    &#125;</span></span><br><span class="language-css"><span class="language-xml">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></span><br><br><span class="hljs-comment">// 孙组件</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;Son&quot;</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>我是孙组件<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span> </span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;isShow = true&quot;</span>&gt;</span>点我打开<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">teleport</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&#x27;body&#x27;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;mask&quot;</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;isShow&quot;</span>&gt;</span></span><br><span class="language-xml">         <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;dialog&quot;</span>&gt;</span></span><br><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>我是内容<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>我是内容<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>我是内容<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;isShow = false&quot;</span>&gt;</span>点我关闭<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">         <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">teleport</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br>  <br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> &#123;ref&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;mySon&quot;</span>,</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">let</span> isShow = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">false</span>);</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">return</span>&#123;</span></span><br><span class="language-javascript"><span class="language-xml">        isShow</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;</span></span><br><span class="language-javascript"><span class="language-xml">&#125;;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br>  <br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;css&quot;</span> <span class="hljs-attr">scoped</span>&gt;</span><span class="language-css"></span></span><br><span class="language-css"><span class="language-xml"><span class="hljs-selector-class">.dialog</span>&#123;</span></span><br><span class="language-css"><span class="language-xml">   <span class="hljs-attribute">height</span>: <span class="hljs-number">300px</span>;</span></span><br><span class="language-css"><span class="language-xml">   <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;</span></span><br><span class="language-css"><span class="language-xml">   <span class="hljs-attribute">background-color</span>: green;</span></span><br><span class="language-css"><span class="language-xml">   <span class="hljs-attribute">text-align</span>: center;</span></span><br><span class="language-css"><span class="language-xml">   <span class="hljs-attribute">position</span>: absolute;</span></span><br><span class="language-css"><span class="language-xml">   <span class="hljs-attribute">top</span>: <span class="hljs-number">50%</span>;</span></span><br><span class="language-css"><span class="language-xml">   <span class="hljs-attribute">left</span>: <span class="hljs-number">50%</span>;</span></span><br><span class="language-css"><span class="language-xml">   <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate</span>(-<span class="hljs-number">50%</span>,-<span class="hljs-number">50%</span>);</span></span><br><span class="language-css"><span class="language-xml">&#125;</span></span><br><span class="language-css"><span class="language-xml"><span class="hljs-selector-class">.mask</span>&#123;</span></span><br><span class="language-css"><span class="language-xml">  <span class="hljs-attribute">position</span>: absolute;</span></span><br><span class="language-css"><span class="language-xml">  <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;</span></span><br><span class="language-css"><span class="language-xml">  <span class="hljs-attribute">bottom</span>: <span class="hljs-number">0</span>;</span></span><br><span class="language-css"><span class="language-xml">  <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;</span></span><br><span class="language-css"><span class="language-xml">  <span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;</span></span><br><span class="language-css"><span class="language-xml">  <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0.5</span>);</span></span><br><span class="language-css"><span class="language-xml">&#125;</span></span><br><span class="language-css"><span class="language-xml"><span class="hljs-selector-class">.Son</span> &#123;</span></span><br><span class="language-css"><span class="language-xml">  <span class="hljs-attribute">background-color</span>: orange;</span></span><br><span class="language-css"><span class="language-xml">  <span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span>;</span></span><br><span class="language-css"><span class="language-xml">&#125;</span></span><br><span class="language-css"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>![效果](C:/Users/K22070055/Desktop/新建文件夹 (3)/blog/source/_posts/弹框.png)</p><h3 id="23-Suspense组件"><a href="#23-Suspense组件" class="headerlink" title="23.Suspense组件"></a>23.Suspense组件</h3><ul><li>作用：让异步组件渲染一些额外内容，用户体验会更好。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 父组件</span><br>&lt;template&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;App&quot;</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>我是父组件<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">Suspense</span>&gt;</span></span><br><span class="language-xml">       <span class="hljs-comment">&lt;!-- 正常显示 --&gt;</span></span><br><span class="language-xml">       <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:default</span>&gt;</span></span><br><span class="language-xml">         <span class="hljs-tag">&lt;<span class="hljs-name">Child</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Child</span>&gt;</span></span><br><span class="language-xml">       <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">       <span class="hljs-comment">&lt;!-- 网速慢或者加个定时器了就显示加载中 --&gt;</span></span><br><span class="language-xml">       <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:fallback</span>&gt;</span></span><br><span class="language-xml">         <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>加载中...<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="language-xml">       <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">Suspense</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&lt;/template&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> &#123; defineAsyncComponent &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-comment">// import Child from &#x27;./components/Child&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">const</span> <span class="hljs-title class_">Child</span> = <span class="hljs-title function_">defineAsyncComponent</span>(<span class="hljs-function">()=&gt;</span><span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./components/Child.vue&#x27;</span>))</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;App&#x27;</span>,</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">components</span>:&#123;</span></span><br><span class="language-javascript"><span class="language-xml">     <span class="hljs-title class_">Child</span></span></span><br><span class="language-javascript"><span class="language-xml">  &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">&#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;css&quot;</span> <span class="hljs-attr">scoped</span>&gt;</span><span class="language-css"></span></span><br><span class="language-css"><span class="language-xml">  <span class="hljs-selector-class">.App</span>&#123;</span></span><br><span class="language-css"><span class="language-xml">    <span class="hljs-attribute">background-color</span>: gray;</span></span><br><span class="language-css"><span class="language-xml">    <span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span>;</span></span><br><span class="language-css"><span class="language-xml">  &#125;</span></span><br><span class="language-css"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></span><br><br><span class="hljs-comment">// 子组件</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;Child&quot;</span>&gt;</span></span><br><span class="language-xml">       <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>我是子组件<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>  </span><br><span class="language-xml">       &#123;&#123; sum &#125;&#125;  </span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br>  <br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-keyword">import</span> &#123;ref&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;myChild&#x27;</span>,</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">async</span> <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">     <span class="hljs-keyword">let</span> sum = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>);</span></span><br><span class="language-javascript"><span class="language-xml">     <span class="hljs-keyword">let</span> p =  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>)=&gt;</span>&#123;</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;</span></span><br><span class="language-javascript"><span class="language-xml">          <span class="hljs-title function_">resolve</span>(&#123;sum&#125;)</span></span><br><span class="language-javascript"><span class="language-xml">        &#125;,<span class="hljs-number">3000</span>);<span class="hljs-comment">// 这样 加载中... 就等了3s才出现</span></span></span><br><span class="language-javascript"><span class="language-xml">     &#125;)</span></span><br><span class="language-javascript"><span class="language-xml">     <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> p;</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;</span></span><br><span class="language-javascript"><span class="language-xml">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br>  <br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;css&quot;</span> <span class="hljs-attr">scoped</span>&gt;</span><span class="language-css"></span></span><br><span class="language-css"><span class="language-xml">    <span class="hljs-selector-class">.Child</span>&#123;</span></span><br><span class="language-css"><span class="language-xml">      <span class="hljs-attribute">background-color</span>: skyblue;</span></span><br><span class="language-css"><span class="language-xml">      <span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span>;</span></span><br><span class="language-css"><span class="language-xml">    &#125;</span></span><br><span class="language-css"><span class="language-xml">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="24-其他"><a href="#24-其他" class="headerlink" title="24.其他"></a>24.其他</h3><h4 id="1-全局API的转移"><a href="#1-全局API的转移" class="headerlink" title="1.全局API的转移"></a>1.全局API的转移</h4><ul><li>Vue 2.x 有许多全局 API 和配置。<ul><li>例如：注册全局组件、注册全局指令等。</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript">javascript复制代码<span class="hljs-comment">//注册全局组件</span><br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">component</span>(<span class="hljs-string">&#x27;MyButton&#x27;</span>, &#123;<br>  <span class="hljs-attr">data</span>: <span class="hljs-function">() =&gt;</span> (&#123;<br>    <span class="hljs-attr">count</span>: <span class="hljs-number">0</span><br>  &#125;),<br>  <span class="hljs-attr">template</span>: <span class="hljs-string">&#x27;&lt;button @click=&quot;count++&quot;&gt;Clicked &#123;&#123; count &#125;&#125; times.&lt;/button&gt;&#x27;</span><br>&#125;)<br><br><span class="hljs-comment">//注册全局指令</span><br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">directive</span>(<span class="hljs-string">&#x27;focus&#x27;</span>, &#123;<br>  <span class="hljs-attr">inserted</span>: <span class="hljs-function"><span class="hljs-params">el</span> =&gt;</span> el.<span class="hljs-title function_">focus</span>()<br>&#125;<br></code></pre></td></tr></table></figure><p>Vue3.0中对这些API做出了调整：</p><ul><li><p>将全局的API，即：<code>Vue.xxx</code>调整到应用实例（<code>app</code>）上</p><table><thead><tr><th>2.x 全局 API（<code>Vue</code>）</th><th>3.x 实例 API (<code>app</code>)</th></tr></thead><tbody><tr><td>Vue.config.xxxx</td><td>app.config.xxxx</td></tr><tr><td>Vue.config.productionTip</td><td><strong>移除</strong></td></tr><tr><td>Vue.component</td><td>app.component</td></tr><tr><td>Vue.directive</td><td>app.directive</td></tr><tr><td>Vue.mixin</td><td>app.mixin</td></tr><tr><td>Vue.use</td><td>app.use</td></tr><tr><td>Vue.prototype</td><td>app.config.globalProperties</td></tr></tbody></table></li></ul><h4 id="2-其他改变"><a href="#2-其他改变" class="headerlink" title="2.其他改变"></a>2.其他改变</h4><h5 id="①-data选项应始终被声明为一个函数（避免对象形式的引用关系互相影响）"><a href="#①-data选项应始终被声明为一个函数（避免对象形式的引用关系互相影响）" class="headerlink" title="① data选项应始终被声明为一个函数（避免对象形式的引用关系互相影响）"></a>① <code>data</code>选项应始终被声明为一个函数（避免对象形式的引用关系互相影响）</h5><h5 id="②-过渡类名的更改"><a href="#②-过渡类名的更改" class="headerlink" title="② 过渡类名的更改"></a>② 过渡类名的更改</h5><p>Vue2.x写法</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css">css复制代码<span class="hljs-selector-class">.v-enter</span>,<br><span class="hljs-selector-class">.v-leave-to</span> &#123;<br>  <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-selector-class">.v-leave</span>,<br><span class="hljs-selector-class">.v-enter-to</span> &#123;<br>  <span class="hljs-attribute">opacity</span>: <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>Vue3.x写法</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs css">css复制代码<span class="hljs-selector-class">.v-enter-from</span>,--------------更易理解<br><span class="hljs-selector-class">.v-leave-to</span> &#123;<br>  <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-selector-class">.v-leave-from</span>,<br><span class="hljs-selector-class">.v-enter-to</span> &#123;<br>  <span class="hljs-attribute">opacity</span>: <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="③-移除keyCode作为-v-on-的修饰符，同时也不再支持config-keyCodes（因为兼容性差）"><a href="#③-移除keyCode作为-v-on-的修饰符，同时也不再支持config-keyCodes（因为兼容性差）" class="headerlink" title="③ 移除keyCode作为 v-on 的修饰符，同时也不再支持config.keyCodes（因为兼容性差）"></a>③ 移除<code>keyCode</code>作为 <code>v-on</code> 的修饰符，同时也不再支持<code>config.keyCodes</code>（因为兼容性差）</h5><h5 id="④-移除v-on-native修饰符"><a href="#④-移除v-on-native修饰符" class="headerlink" title="④ 移除v-on.native修饰符"></a>④ 移除<code>v-on.native</code>修饰符</h5><ul><li>父组件中绑定事件</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">javascript复制代码&lt;my-component<br>  v-<span class="hljs-attr">on</span>:close=<span class="hljs-string">&quot;handleComponentEvent&quot;</span><br>  v-<span class="hljs-attr">on</span>:click=<span class="hljs-string">&quot;handleNativeClickEvent&quot;</span><br>/&gt;<br></code></pre></td></tr></table></figure><p>子组件中声明自定义事件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">javascript复制代码&lt;script&gt;<br>  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>    <span class="hljs-attr">emits</span>: [<span class="hljs-string">&#x27;close&#x27;</span>]-------------通过emit来显式声明哪个是自定义事件，如果不写原生有的话就认为是原生的(比如click)<br>  &#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h5 id="⑤-移除过滤器（filter）"><a href="#⑤-移除过滤器（filter）" class="headerlink" title="⑤ 移除过滤器（filter）"></a>⑤ 移除过滤器（filter）</h5><blockquote><p>过滤器虽然这看起来很方便，但它需要一个自定义语法，打破大括号内表达式是 “只是 JavaScript” 的假设，这不仅有学习成本，而且有实现成本！建议用方法调用或计算属性去替换过滤器。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>前端框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>flex布局影响滚动条的显示</title>
    <link href="/2023/08/29/flex%E5%B8%83%E5%B1%80%E5%BD%B1%E5%93%8D%E6%BB%9A%E5%8A%A8%E6%9D%A1%E7%9A%84%E6%98%BE%E7%A4%BA/"/>
    <url>/2023/08/29/flex%E5%B8%83%E5%B1%80%E5%BD%B1%E5%93%8D%E6%BB%9A%E5%8A%A8%E6%9D%A1%E7%9A%84%E6%98%BE%E7%A4%BA/</url>
    
    <content type="html"><![CDATA[<p><strong>前言</strong></p><p>在设置子标签的滚动条时，发现父元素设置了固定高度、overflow:auto了，并且子标签高度已经大于这个高度，但是滚动条就是不显示。</p><p><strong>发现问题</strong></p><p>在调试时发现把flex布局去掉后，滚动条显示了</p><p><strong>原因</strong></p><p>flex布局下的子元素自带弹性伸缩属性，即 即使父元素设置了固定高度，但是子标签始终会按照flex对应的排列方式排列，即使元素非常多，也会缩小自己以排列在父元素内部。这样就不会有溢出的空间并触发滚动条了，比如：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs CSS">just-<span class="hljs-attribute">content</span>:space-between<br></code></pre></td></tr></table></figure><p>这个属性，最两端的元素肯定是贴在父元素边上的，绝不会溢出来一说，中间的元素就全缩在一起。</p><p><img src="/2023/08/29/flex%E5%B8%83%E5%B1%80%E5%BD%B1%E5%93%8D%E6%BB%9A%E5%8A%A8%E6%9D%A1%E7%9A%84%E6%98%BE%E7%A4%BA/%E5%AD%90%E5%85%83%E7%B4%A0%E4%BC%B8%E7%BC%A9.png" alt="子元素缩小"></p><p><strong>解决方法</strong></p><p>在flex布局标签外部套一个div，重新设置 固定高度和overflow:auto，摆脱flex布局即可。</p>]]></content>
    
    
    <categories>
      
      <category>CSS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>滚动条显示问题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>变量样式var()的使用</title>
    <link href="/2023/08/29/%E5%8F%98%E9%87%8F%E6%A0%B7%E5%BC%8Fvar-%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2023/08/29/%E5%8F%98%E9%87%8F%E6%A0%B7%E5%BC%8Fvar-%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p><strong>前言</strong></p><p>在调整UI组件的内置样式时，发现组件内置的样式通常值都不是具体值，而是一个类似 </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">属性名:<span class="hljs-built_in">var</span>(--属性名)<br></code></pre></td></tr></table></figure><p>这样的格式，于是我去查询了用法。</p><p><strong>发现新大陆</strong></p><p><u>定义</u></p><p>原来这是一种变量样式的写法，也就是说 样式值是一个变量，它被定义在引入的样式文件根部中，如下：</p><p><img src="/2023/08/29/%E5%8F%98%E9%87%8F%E6%A0%B7%E5%BC%8Fvar-%E7%9A%84%E4%BD%BF%E7%94%A8/%E6%A0%B7%E5%BC%8F%E6%96%87%E4%BB%B6%E7%9A%84%E6%A0%B9%E9%83%A8.png" alt="引入的样式文件根部"></p><p><u>使用</u></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attr">--background</span>: <span class="hljs-built_in">var</span>(--ion-color-buttonRed);<br></code></pre></td></tr></table></figure><p><u>好处</u></p><p>如果变更需求，只要在样式文件根部修改即可。 </p>]]></content>
    
    
    <categories>
      
      <category>CSS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>变量样式var()</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>像素对齐问题</title>
    <link href="/2023/08/28/%E5%83%8F%E7%B4%A0%E5%AF%B9%E9%BD%90%E9%97%AE%E9%A2%98/"/>
    <url>/2023/08/28/%E5%83%8F%E7%B4%A0%E5%AF%B9%E9%BD%90%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p><strong>前言</strong></p><p>在调整item和label标签距离时，随着距离越来越近，发现下面label的文字竟然模糊了。效果如下：</p><p><img src="/2023/08/28/%E5%83%8F%E7%B4%A0%E5%AF%B9%E9%BD%90%E9%97%AE%E9%A2%98/before.png" alt="before"></p><p><img src="/2023/08/28/%E5%83%8F%E7%B4%A0%E5%AF%B9%E9%BD%90%E9%97%AE%E9%A2%98/after.png" alt="after"></p><p><strong>原因</strong></p><p>当两个标签的位置非常接近时，可能会出现像素对齐问题，导致字体模糊。这是因为浏览器在渲染字体时，会将字体的位置对齐到像素网格上，如果两个标签的位置不是像素网格的整数倍，就会出现模糊。</p><p><strong>解决方法</strong></p><p>调整标签的位置，使其与像素网格对齐，通常距离要调大一点。</p>]]></content>
    
    
    <categories>
      
      <category>CSS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字体显示不正常</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS样式调整经验(持续更新)</title>
    <link href="/2023/08/25/CSS%E6%A0%B7%E5%BC%8F%E8%B0%83%E6%95%B4%E7%BB%8F%E9%AA%8C-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/"/>
    <url>/2023/08/25/CSS%E6%A0%B7%E5%BC%8F%E8%B0%83%E6%95%B4%E7%BB%8F%E9%AA%8C-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/</url>
    
    <content type="html"><![CDATA[<ul><li>父元素高度跟着子元素高度走 原因 是父元素没有设置固定高度导致子元素没有活动空间</li><li>尽量使用flex布局，其中just-content指的是flex-direction的排列方式，而align-items指的是just-content另外一个方向的排列方式，比如flex-direction:row;just-content:center是水平居中，那么align-items:center就是垂直居中，总之：just-content:center、align-items:center都加上就是水平+垂直居中</li><li>若UI组件中同一行的两个元素默认宽度平分，这时可以添加</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">flex-grow</span><br></code></pre></td></tr></table></figure><p>属性来给每个标签设置权重，以达到需求的比例显示效果</p><ul><li>嵌套样式中，相同标签内部样式会覆盖外部样式，比如：</li></ul><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">500px</span>;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#f5f5f5</span>;<br>  <br>  <span class="hljs-selector-tag">p</span> &#123;<br>    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">14px</span>;<br>    <span class="hljs-attribute">color</span>: <span class="hljs-number">#333</span>;<br>  &#125;<br>  <br>  <span class="hljs-selector-class">.content</span> &#123;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">400px</span>;<br>    <span class="hljs-attribute">padding</span>: <span class="hljs-number">20px</span>;<br>    <br>    <span class="hljs-selector-tag">p</span> &#123;<br>      <span class="hljs-attribute">font-size</span>: <span class="hljs-number">16px</span>;<br>      <span class="hljs-attribute">color</span>: <span class="hljs-number">#007bff</span>;<br>    &#125;<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>在上面的例子中，<code>.container</code>元素中的<code>p</code>标签样式设置了字体大小为14px，颜色为#333。但是在<code>.content</code>元素中，又重新设置了<code>p</code>标签的字体大小为16px，颜色为#007bff。这样一来，<code>.content</code>元素中的<code>p</code>标签样式会覆盖<code>.container</code>元素中的<code>p</code>标签样式。</p>]]></content>
    
    
    <categories>
      
      <category>CSS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>经验</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端开发经验(持续更新)</title>
    <link href="/2023/08/25/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E7%BB%8F%E9%AA%8C-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/"/>
    <url>/2023/08/25/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E7%BB%8F%E9%AA%8C-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/</url>
    
    <content type="html"><![CDATA[<p>我发现前端开发主要工作就这么几个步骤：</p><ol><li>尽量使用UI组件使用UI组件，因为这些组件不仅统一了样式还统一了布局</li><li>我需要做的就是调整部分内置样式（一方面可查看UI组件官网、另一方面可debug查看内置样式）来达到实际需要的样子</li></ol><p>​       需要调成什么样？直接复制UI画图部门提供的CSS样式</p><p>   3.Call Api并利用前端框架的知识将数据展示到合适的位置</p>]]></content>
    
    
    <categories>
      
      <category>经验</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cordova_not_available</title>
    <link href="/2023/08/14/ionic%EF%BC%9Acordova-not-available/"/>
    <url>/2023/08/14/ionic%EF%BC%9Acordova-not-available/</url>
    
    <content type="html"><![CDATA[<p><strong>问题</strong></p><p><img src="/2023/08/14/ionic%EF%BC%9Acordova-not-available/cordova_not_available.png" alt="cordova_not_available"></p><p><strong>原因</strong></p><p>调用android原生api只能在真机或模拟器上，浏览器不支持，因此也就没有值</p><p><strong>解决办法：</strong></p><p>要么build后安装apk到手机上debug，要么连接模拟器（似乎很麻烦）</p><p>Ps：由于只是个warning，如果能确保调用的api方法没错的情况下，不影响其他部分的开发</p>]]></content>
    
    
    <categories>
      
      <category>Ionic</category>
      
    </categories>
    
    
    <tags>
      
      <tag>issues</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ts中的??与||的区别</title>
    <link href="/2023/08/10/Ts%E4%B8%AD%E7%9A%84-%E4%B8%8E%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2023/08/10/Ts%E4%B8%AD%E7%9A%84-%E4%B8%8E%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<p><strong>前言</strong></p><p>在开发时发现Ts中的??与js中的||似乎有类似的作用，但是又不知道其中的区别    </p><p><strong>异同点</strong></p><p>同：都用于判断前者的值来确定是否赋值于后者</p><p>异：||会当前者值为 null、undefined、’’、0时才会赋值为后者</p><p>​        ?? 仅当前者值为 null、undefined 才会赋值为后者</p><p><strong>总结：</strong></p><p>可以看出??是||的部分情况，这两个情况是专门用于判断 <u>引用类型</u> <u>是否定义</u>或<u>是否有值</u>（用的最多），而||可用于 引用类型、字符串、数值 类型的判断</p>]]></content>
    
    
    <categories>
      
      <category>Ts</category>
      
    </categories>
    
    
    <tags>
      
      <tag>用法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>npm无法下载问题</title>
    <link href="/2023/08/07/npm%E6%97%A0%E6%B3%95%E4%B8%8B%E8%BD%BD%E9%97%AE%E9%A2%98/"/>
    <url>/2023/08/07/npm%E6%97%A0%E6%B3%95%E4%B8%8B%E8%BD%BD%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p><strong>前言</strong></p><p>经常会出现npm下载包无法下载的问题，问题如下：</p><p><img src="/2023/08/07/npm%E6%97%A0%E6%B3%95%E4%B8%8B%E8%BD%BD%E9%97%AE%E9%A2%98/npm%E6%97%A0%E6%B3%95%E4%B8%8B%E8%BD%BD.png" alt="npm无法下载"></p><p><strong>设置代理试过：无效</strong></p><p><strong>可进行以下操作</strong></p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-number">1</span>、查看代理设置执行，不为<span class="hljs-literal">null</span>时设置为空：<br>npm config <span class="hljs-built_in">get</span> proxy<br>npm config <span class="hljs-built_in">get</span> <span class="hljs-keyword">https</span>-proxy<br>如果返回值不为<span class="hljs-literal">null</span>，继续执行：<br>（这一步很重要，一定要保证两个命令的返回值都为<span class="hljs-literal">null</span>）<br>npm config <span class="hljs-built_in">set</span> proxy <span class="hljs-literal">null</span><br>npm config <span class="hljs-built_in">set</span> <span class="hljs-keyword">https</span>-proxy <span class="hljs-literal">null</span><br><span class="hljs-number">2</span>、执行：<br>npm config <span class="hljs-built_in">set</span> registry <span class="hljs-keyword">http</span>://registry.cnpmjs.org/<br><span class="hljs-number">3</span>、执行npm i 成功<br></code></pre></td></tr></table></figure><p><strong>总结</strong>：似乎设置代理和设置镜像源不能同时设置，因此要设置为null</p>]]></content>
    
    
    <categories>
      
      <category>Npm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>npm操作问题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git操作:一些关于回退的操作</title>
    <link href="/2023/06/06/git%E6%93%8D%E4%BD%9C-%E4%B8%80%E4%BA%9B%E5%85%B3%E4%BA%8E%E5%9B%9E%E9%80%80%E7%9A%84%E6%93%8D%E4%BD%9C/"/>
    <url>/2023/06/06/git%E6%93%8D%E4%BD%9C-%E4%B8%80%E4%BA%9B%E5%85%B3%E4%BA%8E%E5%9B%9E%E9%80%80%E7%9A%84%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<p><strong>前言</strong></p><p>我们在git协同操作的时候有时候难免会 合并、提交出错，这时候就需要回退操作，使之回到操作之前的状态</p><p><strong>退回到暂存区之前（git add之前）</strong></p><p>有以下几种方式：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">git <span class="hljs-keyword">reset</span>/git <span class="hljs-keyword">reset</span> HEAD/git <span class="hljs-keyword">reset</span> <span class="hljs-comment">--mixed </span><br></code></pre></td></tr></table></figure><p><strong>退回到暂存区commit之前（git commit之前）</strong></p><blockquote><p>1）退回上一次commit</p></blockquote><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">git <span class="hljs-keyword">reset</span> <span class="hljs-comment">--soft HEAD^</span><br></code></pre></td></tr></table></figure><p>Ps：要在vscode里面写，命令行里要写两个^^，因为它默认^是换行</p><p>或</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">git <span class="hljs-keyword">reset</span> <span class="hljs-comment">--soft HEAD~1</span><br></code></pre></td></tr></table></figure><p>Ps：这种方式适合你知道你要退回到前几次commit，1表示退回到上一次，2就是上两次的状态</p><blockquote><p>2）退回到具体的某提提交（可能某次提交太久远了，记不住次数）</p></blockquote><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">git <span class="hljs-keyword">reset</span> <span class="hljs-comment">--soft commitId</span><br></code></pre></td></tr></table></figure><p><u>如何查看某次commit的ID？</u></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">git <span class="hljs-built_in">log</span><br></code></pre></td></tr></table></figure><p><strong>退回commit时，重新修改注释</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">git <span class="hljs-keyword">commit</span> <span class="hljs-comment">--amend</span><br></code></pre></td></tr></table></figure><p>自动会跳出编辑器，重新更新就行</p><p><strong>退回到上一个版本（不会保留新版本修改的代码，慎重）</strong></p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">git reset <span class="hljs-params">--hard</span> Head^<span class="hljs-string">/commitId</span><br></code></pre></td></tr></table></figure><p>Ps：这种一般是用作退回版本的，也可以用于退回合并之前</p><p><strong>总结：</strong></p><p><img src="/2023/06/06/git%E6%93%8D%E4%BD%9C-%E4%B8%80%E4%BA%9B%E5%85%B3%E4%BA%8E%E5%9B%9E%E9%80%80%E7%9A%84%E6%93%8D%E4%BD%9C/git%E5%9B%9E%E9%80%80.png"></p>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git操作</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git操作:如何删除本地和远程分支</title>
    <link href="/2023/05/25/git%E6%93%8D%E4%BD%9C-%E5%A6%82%E4%BD%95%E5%88%A0%E9%99%A4%E6%9C%AC%E5%9C%B0%E5%92%8C%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF/"/>
    <url>/2023/05/25/git%E6%93%8D%E4%BD%9C-%E5%A6%82%E4%BD%95%E5%88%A0%E9%99%A4%E6%9C%AC%E5%9C%B0%E5%92%8C%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF/</url>
    
    <content type="html"><![CDATA[<p><strong>删除本地分支</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">git branch -d <span class="hljs-tag">&lt;<span class="hljs-name">本地分支名</span>&gt;</span><br></code></pre></td></tr></table></figure><p>此删除会检查是否存在没有分支没有合并的内容，会进行提示</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">git branch -D <span class="hljs-tag">&lt;<span class="hljs-name">本地分支名</span>&gt;</span><br></code></pre></td></tr></table></figure><p>此删除是强行删除</p><p><strong>删除远程分支</strong></p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">git <span class="hljs-built_in">push</span> <span class="hljs-built_in">origin</span> -d &lt;远程分支名&gt;<br></code></pre></td></tr></table></figure><p>注意这里的origin指的是远程分支为 origin/&lt;远程分支名&gt; 的分支，如果不清楚远程分支全称，可以通过以下命令查看</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">git branch -r</span><br></code></pre></td></tr></table></figure><p>为什么会有push，我的理解是将删除远程分支的指令告诉远程代码，而 push 就相当于 通往远程代码的 通道。</p>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git操作</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git之问题-没有当前分支的跟踪信息</title>
    <link href="/2023/04/02/git%E4%B9%8B%E9%97%AE%E9%A2%98-%E6%B2%A1%E6%9C%89%E5%BD%93%E5%89%8D%E5%88%86%E6%94%AF%E7%9A%84%E8%B7%9F%E8%B8%AA%E4%BF%A1%E6%81%AF/"/>
    <url>/2023/04/02/git%E4%B9%8B%E9%97%AE%E9%A2%98-%E6%B2%A1%E6%9C%89%E5%BD%93%E5%89%8D%E5%88%86%E6%94%AF%E7%9A%84%E8%B7%9F%E8%B8%AA%E4%BF%A1%E6%81%AF/</url>
    
    <content type="html"><![CDATA[<p><strong>前言</strong></p><p>在git pull 的时候出现 There is no tracking information for the current branch.</p><p><strong>直接原因</strong></p><p>原因是 本地分支没有与远程分支 关联</p><p><strong>发生场景</strong></p><p>通常新建一个本地分支之后，git不清楚这个新分支要准备推送到哪个分支</p><p><strong>解决方法</strong></p><p>输入以下命令可实现关联：</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs delphi">git branch --<span class="hljs-keyword">set</span>-upstream-<span class="hljs-keyword">to</span>=origin/远程分支的名字  本地分支的名字<br></code></pre></td></tr></table></figure><p>否则只能指定远程分支名字（较麻烦）</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">git pull <span class="hljs-built_in">origin</span> 远程分支<br></code></pre></td></tr></table></figure><p><strong>总结：</strong></p><p>下次记得不能随便删除本地仓库.git文件，克隆下来后别动，方便后续开发</p>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git操作</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>slice函数&amp;splice函数&amp;split函数的区别</title>
    <link href="/2023/04/02/slice%E5%87%BD%E6%95%B0&amp;splice%E5%87%BD%E6%95%B0&amp;split%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2023/04/02/slice%E5%87%BD%E6%95%B0&amp;splice%E5%87%BD%E6%95%B0&amp;split%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<p>这三个函数长得非常相似，将它们区分开来很有必要。</p><h3 id="slice（切割）"><a href="#slice（切割）" class="headerlink" title="slice（切割）"></a><strong>slice（切割）</strong></h3><p><strong>作用</strong>：可将 <u>字符串或数组</u> 切割成 其部分的 新的 <u>字符串或数组</u> （不改变原字符串、数组）</p><p><strong>方法：</strong></p><ul><li>str.slice(start,end) ———— 区间 左闭右开—–切割[start,end)区间的 字符串或数组</li></ul><blockquote><p>说到获取部分字符串，便可想到 substr方法和substring方法（也是不改变原字符串、数组）</p><ul><li>str.substr(start,num) ——————从start开始截取num个字符</li><li>str.substring(start,end) ————— 用法和 slice 一样</li></ul></blockquote><h3 id="splice（拼接）"><a href="#splice（拼接）" class="headerlink" title="splice（拼接）"></a>splice（拼接）</h3><p><strong>作用：</strong>可对数组元素进行插入、删除、替换，号称“最强数据操作的方法”，但是会直接修改原数组的，简单粗暴。</p><p><strong>方法：</strong></p><ul><li>str.splice(位置，删除的个数，插入的新的元素1，插入的新的元素1…)</li></ul><blockquote><p>使用：</p><p>删除：str.splice(2,2)——删除位置为2后的2个元素</p><p>替换：str.splice(2,2,2,2)—–删除位置为2后的2个元素并替换成2、2</p><p>插入：str.splice(2,0,2,2)——删除位置为2后的0个元素，并插入2、2–插入2、2</p></blockquote><h3 id="split（分离）"><a href="#split（分离）" class="headerlink" title="split（分离）"></a>split（分离）</h3><p><strong>作用：</strong>对字符串以分隔符进行分离，被拆分的各个部分组成变成各个数组</p><p><strong>使用：</strong>“1：2：3”.split(“:”) —————–[‘1’]、[‘2’]、[‘3’]</p><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p><strong>操作对象的不同：</strong>splice只可操作数组，split只可操作字符串，而slice两者都可</p>]]></content>
    
    
    <categories>
      
      <category>Js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>函数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git之问题:push之后某文件夹出现@+一串数字</title>
    <link href="/2023/03/12/git%E4%B9%8B%E9%97%AE%E9%A2%98-push%E4%B9%8B%E5%90%8E%E6%9F%90%E6%96%87%E4%BB%B6%E5%A4%B9%E5%87%BA%E7%8E%B0-%E4%B8%80%E4%B8%B2%E6%95%B0%E5%AD%97/"/>
    <url>/2023/03/12/git%E4%B9%8B%E9%97%AE%E9%A2%98-push%E4%B9%8B%E5%90%8E%E6%9F%90%E6%96%87%E4%BB%B6%E5%A4%B9%E5%87%BA%E7%8E%B0-%E4%B8%80%E4%B8%B2%E6%95%B0%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<p><strong>问题：</strong></p><p>今天在拉取之前代码时，发现项目突然运行不起来了，找了半天发现缺少文件，再在gitee代码中发现有个子文件夹前面有个@，后面还有一串数字，点进去一看，该文件夹是空的！</p><p><strong>原因：</strong></p><p>在网上找了answer，说是该文件夹的子文件夹中还有.git文件，似乎git只能按照一个git仓库上传，内部文件夹的git仓库默认不上传（又来一个git仓库不知道怎么处理直接不处理）</p><p><strong>解决方法：</strong></p><p>删除内部文件夹的.git文件，重新commit并push，这样才能全部push上去，那么拉去的代码也就不缺少东西啦</p>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git操作</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>吸引力法则和自我催眠法则的关系</title>
    <link href="/2023/03/11/%E5%90%B8%E5%BC%95%E5%8A%9B%E6%B3%95%E5%88%99%E5%92%8C%E8%87%AA%E6%88%91%E5%82%AC%E7%9C%A0%E6%B3%95%E5%88%99%E7%9A%84%E5%85%B3%E7%B3%BB/"/>
    <url>/2023/03/11/%E5%90%B8%E5%BC%95%E5%8A%9B%E6%B3%95%E5%88%99%E5%92%8C%E8%87%AA%E6%88%91%E5%82%AC%E7%9C%A0%E6%B3%95%E5%88%99%E7%9A%84%E5%85%B3%E7%B3%BB/</url>
    
    <content type="html"><![CDATA[<p>分享两个有关心理学（原本是物理学，后来引申到心理学）的知识，吸引力法则与自我催眠法则的关系（信不信看个人）。</p><p><img src="/2023/03/11/%E5%90%B8%E5%BC%95%E5%8A%9B%E6%B3%95%E5%88%99%E5%92%8C%E8%87%AA%E6%88%91%E5%82%AC%E7%9C%A0%E6%B3%95%E5%88%99%E7%9A%84%E5%85%B3%E7%B3%BB/%E5%90%B8%E5%BC%95%E5%8A%9B%E6%B3%95%E5%88%99.jpg" alt="吸引力法则"></p><p><img src="/2023/03/11/%E5%90%B8%E5%BC%95%E5%8A%9B%E6%B3%95%E5%88%99%E5%92%8C%E8%87%AA%E6%88%91%E5%82%AC%E7%9C%A0%E6%B3%95%E5%88%99%E7%9A%84%E5%85%B3%E7%B3%BB/%E5%82%AC%E7%9C%A0%E8%8A%82%E5%A5%8F%E6%B3%95%E5%88%99.jpg" alt="催眠节奏法则"></p>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>心理学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue项目该有的意识（更新中）</title>
    <link href="/2023/03/11/vue%E9%A1%B9%E7%9B%AE%E8%AF%A5%E6%9C%89%E7%9A%84%E6%84%8F%E8%AF%86%EF%BC%88%E7%BB%8F%E9%AA%8C%EF%BC%89/"/>
    <url>/2023/03/11/vue%E9%A1%B9%E7%9B%AE%E8%AF%A5%E6%9C%89%E7%9A%84%E6%84%8F%E8%AF%86%EF%BC%88%E7%BB%8F%E9%AA%8C%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p><strong>用父组件发请求子组件接数据以减少多次请求api</strong></p><blockquote><p>1）组件如果需要重复多次，那么不建议在组件内部发送api请求，因为那样就请求了多次，性能不高，直接在父组件请求好，这样只用请求一次，这是一方面；然后把数据传给子组件，那么子组件就只要对这一份数据进行动态展示就行，这样相当于增加了内聚性，减少了耦合性</p></blockquote><p><strong>标签决定页面格式</strong></p><blockquote><p>2）循环的格式不对，看看v-for写的标签位置是不是不对，因为标签决定了页面格式（标签上有样式）</p></blockquote><p><strong>已经有vue框架了，不需要用原生DOM</strong></p><blockquote><p>3）尽量不要用原生DOM操作，一方面是vue框架就是为了不是用原生框架而设计的，另一方面使用原生DOM代码会出现错误，比如ducoment.querySelector在循环的时候似乎只会生效一次，要使用ref</p></blockquote><p><strong>复用的重要性</strong></p><blockquote><p>4）在页面中有相同或相似的部分要拆分成一个公共组件</p></blockquote><p><strong>展示的数据需要考虑为空时的情况 ——— 请求api是异步的</strong></p><blockquote><p>5）仓库store中state存储的数据的初始值要考虑全面，比如没有请求成功时应该返回给前端什么数据（因为请求api是异步的，很可能返回来数据时页面已经加载完成这时就取不到数据），这时state中的某个list就改写成  list||[] （如果需要数组来展示）</p><p>注意：有时这种需要考虑的是多层的</p><p>比如一开始报 list[0]取不到数据，已经用   list||[]  解决掉了，但是后面子组件还要取 list[0].imageUrl，这时还要在 子组件computed数据的时候 需要 list[0].imageUrl ||{}，因为只有对象才能y用.来取数据</p></blockquote><p><strong>看到页面结构就要想到数据结构</strong></p><blockquote><p>这是一个成熟前端该有的能力：看到页面结构心理就已经有了大致结构</p></blockquote><p><strong>Vuex的Getters的善用</strong></p><blockquote><p>当api请求回来的数据是多层嵌套，需要利用vuex的getters先计算好了再返回，这样前端直接拿来用就行</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>前端框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue2:$nextClick和watch的妙用</title>
    <link href="/2023/03/09/$nextClick%E4%B8%8Ewatch%E7%9A%84%E5%A6%99%E7%94%A8/"/>
    <url>/2023/03/09/$nextClick%E4%B8%8Ewatch%E7%9A%84%E5%A6%99%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p><strong>场景：</strong></p><p>在组件里经常需要在mounted时需要$store.dispatch-&gt;store中的action向服务器发送请求，然后保存在state中，最后组件通过mapState获取数据并展示，也就是所谓的仓库store的三连环（仓库向api请求数据-&gt;将返回的数据保存在仓库中-&gt;组件从仓库中捞数据并展示）。这时，在展示的时候需要配合某个插件使用，这个插件需要在页面完全渲染完成后加上它的js代码才能完成它的动态效果。</p><p><strong>具体：</strong></p><p>我这里需要用到swiper轮播图这个插件，官网的使用代码是这样的：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;swiper&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;swiper-wrapper&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;swiper-slide&quot;</span>&gt;</span>Slide 1<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;swiper-slide&quot;</span>&gt;</span>Slide 2<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;swiper-slide&quot;</span>&gt;</span>Slide 3<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 如果需要分页器 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;swiper-pagination&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <br>    <span class="hljs-comment">&lt;!-- 如果需要导航按钮 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;swiper-button-prev&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;swiper-button-next&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript">        </span><br><span class="language-javascript">  <span class="hljs-keyword">var</span> mySwiper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Swiper</span> (<span class="hljs-string">&#x27;.swiper&#x27;</span>, &#123;</span><br><span class="language-javascript">    <span class="hljs-attr">loop</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 循环模式选项</span></span><br><span class="language-javascript">    </span><br><span class="language-javascript">    <span class="hljs-comment">// 如果需要分页器</span></span><br><span class="language-javascript">    <span class="hljs-attr">pagination</span>: &#123;</span><br><span class="language-javascript">      <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;.swiper-pagination&#x27;</span>,</span><br><span class="language-javascript">    &#125;,</span><br><span class="language-javascript">    </span><br><span class="language-javascript">    <span class="hljs-comment">// 如果需要前进后退按钮</span></span><br><span class="language-javascript">    <span class="hljs-attr">navigation</span>: &#123;</span><br><span class="language-javascript">      <span class="hljs-attr">nextEl</span>: <span class="hljs-string">&#x27;.swiper-button-next&#x27;</span>,</span><br><span class="language-javascript">      <span class="hljs-attr">prevEl</span>: <span class="hljs-string">&#x27;.swiper-button-prev&#x27;</span>,</span><br><span class="language-javascript">    &#125;,</span><br><span class="language-javascript">  &#125;)        </span><br><span class="language-javascript">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>很明显这个js代码需要页面渲染完成才能通过选择器获取到<u>‘swiper’</u>，换到vue组件中使用时，通常我想组件挂载结束获取到数据并展示，同时还想运用这个插件，可是通常通过this.$store.dispatch请求api获得数据是**<u>异步</u>**的操作，这样一来就会先执行插件的js代码（先执行主程序的同步任务，再把异步任务拿到主程序中执行），然后数据才能获取到并存储到store中，此时页面还没有渲染完成，最终结果就是js代码执行2无效，因为无法获取页面的.swiper。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div class=&quot;list-container&quot;&gt;<br>    &lt;div class=&quot;sortList clearfix&quot;&gt;<br>      &lt;div class=&quot;center&quot;&gt;<br>        &lt;!--banner轮播--&gt;<br>        &lt;div class=&quot;swiper-container&quot; id=&quot;mySwiper&quot;&gt;<br>          &lt;div class=&quot;swiper-wrapper&quot;&gt;<br>            &lt;div<br>              class=&quot;swiper-slide&quot;<br>              v-for=&quot;banner in bannerList&quot;<br>              :key=&quot;banner.id&quot;<br>            &gt;<br>              &lt;img :src=&quot;banner.imgUrl&quot; /&gt;<br>            &lt;/div&gt;<br>          &lt;/div&gt;<br>          &lt;!-- 如果需要分页器 --&gt;<br>          &lt;div class=&quot;swiper-pagination&quot;&gt;&lt;/div&gt;<br><br>          &lt;!-- 如果需要导航按钮 --&gt;<br>          &lt;div class=&quot;swiper-button-prev&quot;&gt;&lt;/div&gt;<br>          &lt;div class=&quot;swiper-button-next&quot;&gt;&lt;/div&gt;<br>        &lt;/div&gt;<br>      &lt;/div&gt;<br>    &lt;/div&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>import &#123; mapState &#125; from &quot;vuex&quot;;<br>import Swiper from &quot;swiper&quot;;<br>export default &#123;<br>  name: &quot;ListContainer&quot;,<br>  mounted() &#123;<br>    this.$store.dispatch(&quot;bannerList&quot;);<br>    /**<br>     * 由于this.$store.dispatch(&quot;bannerList&quot;)请求服务器数据包含异步操作，因此<br>     * (3) 复习：虽然代码写在前面，但是异步任务是在主程序同步任务执行完才会放入同步任务来执行<br>     * 那么没有bannerList数据那么页面结构就没有完成，轮播图的js代码就获取不到结构<br>     * 得想办法把轮播图js代码在this.$store.dispatch(&quot;bannerList&quot;)后面执行<br>     * */<br>    // 方法一：可以用setTimeOut但是必须要等一段时间才执行，不是最完美的方案<br>    // setTimeout(() =&gt; &#123;<br><br>    //   &#125;);<br>    // &#125;, 2000);<br>  &#125;,<br>  computed: &#123;<br>    // 为什么要...展开？复习一下，这里的展开值得是将获得的bannerList展开成computed的函数形式<br>    ...mapState(&#123;<br>      bannerList: (state) =&gt; state.home.bannerList,<br>    &#125;),<br>  &#125;,<br>&#125;;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p><strong>解决方法：watch+$nextClick</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs vue">// 方法二：<br>watch: &#123;<br>  bannerList: &#123;<br>    handler(newVal, oldVal) &#123;<br>      /**<br>       * (1)虽然数据变化了，已经有了，但是页面并没有渲染完成，那就获取不到<br>       *    nextTick可以在页面渲染完成后再执行<br>       * <br>       * 最后一个问题：为什么要放到watch里面？<br>       * 我试了一下，直接放到mounted也行，我觉得放这是因为提高性能<br>       * 类似于懒加载，减少new Swiper的次数<br>       * <br>       * (2) 以后知道了一些插件经常要使用nextClick，因为都要在DOM渲染完成之后才能执行某些代码<br>       * */ <br>      this.$nextTick(() =&gt; &#123;<br>        var mySwiper = new Swiper(&quot;#mySwiper&quot;, &#123;<br>          loop: true, // 循环模式选项<br><br>          // 如果需要分页器<br>          pagination: &#123;<br>            el: &quot;.swiper-pagination&quot;,<br>            clickable: true,<br>          &#125;,<br><br>          // 如果需要前进后退按钮<br>          navigation: &#123;<br>            nextEl: &quot;.swiper-button-next&quot;,<br>            prevEl: &quot;.swiper-button-prev&quot;,<br>          &#125;,<br>        &#125;);<br>      &#125;);<br>    &#125;,<br>  &#125;,<br>&#125;,<br></code></pre></td></tr></table></figure><p><u>$nextClick</u>：都知道可以页面渲染完再执行，已经可以解决问题了，可是把代码放在哪？</p><p><strong>为什么要放在数据的监听watch里面？</strong></p><p><del>因为可以提高性能，我试了一下把$nextClick放到mounted中也可以有同样的效果，但是如果发给到mouned里面那么就会每使用一次这个组件，都会new一次Swiper实例，而放到watch里面，有点类似懒加载的感觉，数据真正返回了（第一道关卡，因为可能请求不成功没有数据返回，没有数据直接不执行）我再用$nextClick执行相关插件（第二道关卡，等页面完全渲染完再执行）</del></p><p>先问第一个问题：异步操作和页面渲染完成哪个在后面？</p><p>这个不确定啊，有可能页面渲染完成之后请求数据的异步操作都没完成，好，那我就等你数据来了（异步操作已经执行并返回了数据）我再在nextClick里面执行DOM操作的代码，这样就一来，页面结构才叫完全ok，我安心地操作DOM。</p><p><strong>总结：</strong></p><p>1）异步操作什么时候结束不太确定，因此需要找一个临界点，比如用watch</p><p>2）$nextClick经常和一些插件一起使用</p>]]></content>
    
    
    <categories>
      
      <category>前端框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ES新特性</title>
    <link href="/2023/03/04/ES%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <url>/2023/03/04/ES%E6%96%B0%E7%89%B9%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h3 id="ES6新特性"><a href="#ES6新特性" class="headerlink" title="ES6新特性"></a>ES6新特性</h3><h4 id="1-ECMA（European-Computer-Manufacture-Assocition）"><a href="#1-ECMA（European-Computer-Manufacture-Assocition）" class="headerlink" title="1.ECMA（European Computer Manufacture Assocition）"></a>1.ECMA（European Computer Manufacture Assocition）</h4><blockquote><p>1）欧洲计算机制造商协会</p><p>2）ECMAScript 是脚本程序设计语言,js便是ECMA的一种实现，ES6即ECMA Script 6</p></blockquote><h4 id="2-let"><a href="#2-let" class="headerlink" title="2.let"></a>2.let</h4><blockquote><p> 1）不能重复声明，防止变量被污染，这样每个变量的用途都是唯一的</p><p> ​       不像以前var可以重复声明（后面的会把前面的覆盖掉），很乱</p><p> 2）拥有块级作用域</p><p> 3）不存在变量提升</p><p> 4）不影响作用域链</p><p> 综上：let完全和c++、java中正常声明变量一模一样了</p></blockquote><h4 id="3-const"><a href="#3-const" class="headerlink" title="3.const"></a>3.const</h4><blockquote><p>1）和c++中一样，表示常量、块级作用域、不能被修改、且一般用大写字母命名</p><p>2）一定要赋初始值（如果没有初始值又不能被修改，那这个变量不就没用了）</p><p>3）对const声明的数组是可以修改里面的元素的，因为数组的地址没有改变。— 只要const声明的 变量值 不变就行</p><p>4）以后声明数组和对象都要用const，比较稳妥（地址不变，指向的数组/对象就不变）</p></blockquote><h4 id="4-变量的解构赋值（结构拆解为各个变量并赋值，可选择其中几个）"><a href="#4-变量的解构赋值（结构拆解为各个变量并赋值，可选择其中几个）" class="headerlink" title="4.变量的解构赋值（结构拆解为各个变量并赋值，可选择其中几个）"></a>4.变量的解构赋值（结构拆解为各个变量并赋值，可选择其中几个）</h4><blockquote><p>1）数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">F4</span> = [<span class="hljs-string">&#x27;小沈阳&#x27;</span>，<span class="hljs-string">&#x27;刘能&#x27;</span>，<span class="hljs-string">&#x27;赵四&#x27;</span>，<span class="hljs-string">&#x27;宋小宝&#x27;</span>]<br><span class="hljs-keyword">let</span> [xiao,liu,zhao,song] = <span class="hljs-variable constant_">F4</span><span class="hljs-comment">//左边按照数组的结构给各个元素声明变量就叫解构，然后右边赋值指明解的是哪个数组，并把元素一一对应赋值</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(xiao)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(liu)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(zhao)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(song)<br></code></pre></td></tr></table></figure><p>2）对象（结构的变量必须和原来对象属性值一致，否则单独取一个不知道取哪个）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> zhao = &#123;<br> <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;赵本山&#x27;</span>，<br> <span class="hljs-attr">age</span>:<span class="hljs-string">&#x27;不详&#x27;</span>，<br> <span class="hljs-attr">talent</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>     <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;演小品&#x27;</span>)<br> &#125;<br>&#125;<br><span class="hljs-keyword">let</span> &#123;name,age,talent&#125; = zhao<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(age)<br><span class="hljs-title function_">talent</span>()       --------------这么写是为了想把属性/方法脱离对象的关系<br></code></pre></td></tr></table></figure></blockquote><h4 id="5-模板字符串"><a href="#5-模板字符串" class="headerlink" title="5.模板字符串"></a>5.模板字符串</h4><blockquote><p>1）将字符串 ’ ‘和” “ 统一为 反引号``</p><p>2）可以直接出现换行符，不需要像以前一样需要用 + 拼接（以前只能识别一行）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> str = <span class="hljs-string">`&lt;ul&gt;</span><br><span class="hljs-string">         &lt;li&gt;沈腾&lt;/li&gt;</span><br><span class="hljs-string">         &lt;li&gt;玛丽&lt;/li&gt;</span><br><span class="hljs-string">        &lt;/ul&gt;</span><br><span class="hljs-string">       `</span><br></code></pre></td></tr></table></figure><p>3）变量拼接，在``里才能使用${}</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> lovest = <span class="hljs-string">&#x27;魏翔&#x27;</span><br><span class="hljs-keyword">let</span> out = <span class="hljs-string">`<span class="hljs-subst">$&#123;lovest&#125;</span> 是我心目中最搞笑的演员！！！`</span><br></code></pre></td></tr></table></figure></blockquote><h4 id="6-对象的简化写法"><a href="#6-对象的简化写法" class="headerlink" title="6.对象的简化写法"></a>6.对象的简化写法</h4><blockquote><p>1）直接拿现有的 变量和函数 充当对象的属性和方法 —— 越来越懒了，而且还更霸道了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> name=<span class="hljs-string">&#x27;zhoujie&#x27;</span><br><span class="hljs-keyword">let</span> change = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;我会变得更强的！&#x27;</span>)<br>&#125;<br><span class="hljs-keyword">const</span> person = &#123;<br> name,<br> change<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person.<span class="hljs-property">name</span>,person.<span class="hljs-property">change</span>)<br></code></pre></td></tr></table></figure><p>2）对象中 方法的简写</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> person = &#123;<br> name,<br> change,<br> <span class="hljs-title function_">improve</span>(<span class="hljs-params"></span>)&#123;<br>     <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;提高技能&#x27;</span>)<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>综上：越来越像C++中类里面成员变量和函数的声明了（变量不赋值，函数可以直接声明）</p></blockquote><h4 id="7-箭头函数"><a href="#7-箭头函数" class="headerlink" title="7.箭头函数"></a>7.箭头函数</h4><blockquote><p>1）声明：直接将function变成后面的箭头</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> fn = <span class="hljs-keyword">function</span>(<span class="hljs-params">a,b</span>)&#123;<br>...<br>&#125;<br>==&gt;<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">fn</span> = (<span class="hljs-params">a,b</span>) =&gt; &#123;<br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>2）特性：</p><ul><li>箭头函数 声明的方法，它的this是静态的，始终指向 函数声明时 <strong>所在作用域</strong>下 this 的值，这时之前的 规则是不生效的</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getName1</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>)<br>&#125;<br><span class="hljs-keyword">let</span> <span class="hljs-title function_">getName2</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>)<br>&#125;<br><span class="hljs-variable language_">window</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;zhoujie&#x27;</span><br><span class="hljs-keyword">const</span> school = &#123;<br>    <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;周杰&#x27;</span><br>&#125;<br>getName1.<span class="hljs-title function_">call</span>(school)<span class="hljs-comment">//周杰</span><br>getName2.<span class="hljs-title function_">call</span>(school)<span class="hljs-comment">//zhoujie，不会因为在对象里this就指向当前对象</span><br><br></code></pre></td></tr></table></figure><ul><li>不能作为构造函数实例化对象，因为箭头函数没有constructor</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> <span class="hljs-title function_">Person</span> = (<span class="hljs-params">name,age</span>) =&gt; &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age<br>&#125;<br><span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;zhoujie&#x27;</span>,<span class="hljs-number">18</span>)<span class="hljs-comment">//Person is not a constructor</span><br></code></pre></td></tr></table></figure><ul><li>不能使用arguments变量</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> <span class="hljs-title function_">fn</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">arguments</span>)<br>&#125;<br><span class="hljs-title function_">fn</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)<span class="hljs-comment">//arguments is not defined</span><br></code></pre></td></tr></table></figure><ul><li><p>箭头函数的简写</p><p>1）当形参只有一个时，可以省略小括号</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> <span class="hljs-title function_">fn</span> = n =&gt; &#123;<br>    <span class="hljs-keyword">return</span> n*n<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">fn</span>(<span class="hljs-number">8</span>))<br></code></pre></td></tr></table></figure><p>2）当函数体只有一条语句的时候，可以省略花括号，return也要省掉</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> <span class="hljs-title function_">fn</span> = n =&gt; n*n<br></code></pre></td></tr></table></figure></li></ul><p><strong>3）实践与应用</strong></p><p>1）考点：箭头函数的this指向的是函数声明时 <strong>所在作用域</strong>下 this的值，这里箭头函数和定时器作为整体 放在外部function的作用域下，而这个作用域的this是属于ad的、</p><p>注意js中只有 全局作用域、函数作用域、块作用域，这里定时器第一个参数都不属于一个作用域</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;div id=<span class="hljs-string">&quot;ad&quot;</span>&gt;&lt;/div&gt;<br><span class="hljs-keyword">let</span> ad = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;ad&#x27;</span>)<br>ad.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;click&quot;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">style</span>.<span class="hljs-property">background</span> = <span class="hljs-string">&#x27;pink&#x27;</span><br>    &#125;,<span class="hljs-number">2000</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><p>2）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>]<br>不用箭头函数：<br><span class="hljs-keyword">const</span> result = arr.<span class="hljs-title function_">fliter</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">item</span>)&#123;<br>     <span class="hljs-keyword">if</span>(item % <span class="hljs-number">2</span> === <span class="hljs-number">0</span>)&#123;<br>         <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>     &#125;<span class="hljs-keyword">else</span>&#123;<br>         <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>     &#125;<br>&#125;)<br>使用箭头函数：<br>分析：省去大括号说明只有一条语句，这是个判断那说明是个<span class="hljs-keyword">if</span>语句判断，真则<span class="hljs-literal">true</span>否则<span class="hljs-literal">false</span><br><span class="hljs-keyword">const</span> result = arr.<span class="hljs-title function_">fliter</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item % <span class="hljs-number">2</span> === <span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p><strong>4）总结：</strong></p><p>使用场景：箭头函数适合与this无关的回调、定时器、数组的方法回调</p><p>​                   不适合与this有关的回调、事件回调、对象的方法</p><p>原因：不想与es5中原本this指向规则冲突，但不适合不代表不能用</p></blockquote><h4 id="8-知识点补充"><a href="#8-知识点补充" class="headerlink" title="8.知识点补充"></a>8.知识点补充</h4><p><strong>this指向的补充</strong></p><blockquote><p><strong>在不使用箭头函数</strong>和call、apply、bind的情况下，这些this的指向，当我们调用函数的时候是确定的。调用函数的不同决定了this指向的不同。</p><p><img src="/2023/03/04/ES%E6%96%B0%E7%89%B9%E6%80%A7/this%E7%9A%84%E6%8C%87%E5%90%91.png" alt="this的指向"><br>总结：也就是除了指明对象和事件的，其他都是window</p></blockquote><h4 id="9-函数参数的默认设置"><a href="#9-函数参数的默认设置" class="headerlink" title="9.函数参数的默认设置"></a>9.函数参数的默认设置</h4><blockquote><p>1）允许给函数参数赋缺省值，形参初始值一般放最后面，和c++一样</p><p>应用场景：和解构赋值结合在一起，目的是不现在函数内 多次写对象名</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">connect</span>(<span class="hljs-params">&#123;host=<span class="hljs-string">&#x27;127.0.0.1&#x27;</span>,username,password,port&#125;</span>)&#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(host)<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(username)<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(password)<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(port)<br>&#125;<br><span class="hljs-title function_">connect</span>(&#123;<br> <span class="hljs-attr">host</span>:<span class="hljs-string">&#x27;zhoujie.com&#x27;</span>,<br> <span class="hljs-attr">username</span>:<span class="hljs-string">&#x27;zhoujie&#x27;</span>,<br> <span class="hljs-attr">password</span>:<span class="hljs-string">&#x27;123&#x27;</span>,<br> <span class="hljs-attr">port</span>:<span class="hljs-string">&#x27;4200&#x27;</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>2）引入rest来获取函数实参，以代替arguments，表示剩余的实参，即三个点…</p><p>语法：必须放最后，且前面要有…，可以任意命名，一般取名为args</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params">a,b,...args</span>)&#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a)<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(b)<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(args)<br>&#125;<br><span class="hljs-title function_">fn</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>)<br></code></pre></td></tr></table></figure></blockquote><h4 id="10-扩展运算符的介绍"><a href="#10-扩展运算符的介绍" class="headerlink" title="10.扩展运算符的介绍"></a>10.扩展运算符的介绍</h4><blockquote><p>定义：[…]扩展运算符 可以将 [数组] 转换为逗号分隔的 [参数序列]</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> tfboys = [<span class="hljs-string">&#x27;易烊千玺&#x27;</span>，<span class="hljs-string">&#x27;王源&#x27;</span>，<span class="hljs-string">&#x27;王俊凯&#x27;</span>]<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">chunwan</span>(<span class="hljs-params"></span>)&#123;<br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">arguments</span>)<br>&#125;<br><span class="hljs-title function_">chunwan</span>(...tfboys)<span class="hljs-comment">//&#x27;易烊千玺&#x27;，&#x27;王源&#x27;，&#x27;王俊凯&#x27;</span><br></code></pre></td></tr></table></figure><p>与rest参数的区别：rest参数是放到形参上，而扩展运算符放在实参上</p><p>应用：</p><ul><li><p>数组的合并</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> kuaizi = [<span class="hljs-string">&#x27;王太利&#x27;</span>，<span class="hljs-string">&#x27;肖央&#x27;</span>]<br><span class="hljs-keyword">const</span> fenghuang = [<span class="hljs-string">&#x27;曾毅&#x27;</span>，<span class="hljs-string">&#x27;玲花&#x27;</span>]<br><span class="hljs-keyword">const</span> zuixuanxiaopingguo = [...kuaizi,...fenghuang]<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(zuixuanxiaopingguo)<span class="hljs-comment">//[&#x27;王太利&#x27;，&#x27;肖央&#x27;,&#x27;曾毅&#x27;，&#x27;玲花&#x27;]</span><br></code></pre></td></tr></table></figure></li><li><p>数组的克隆（浅拷贝）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> sanzhihua = [<span class="hljs-string">&#x27;E&#x27;</span>,<span class="hljs-string">&#x27;G&#x27;</span>,<span class="hljs-string">&#x27;M&#x27;</span>]<br><span class="hljs-keyword">const</span> sanyecao = [...sanzhihua]<br></code></pre></td></tr></table></figure></li><li><p>将伪数组转化为真数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;div&gt;&lt;/div&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="hljs-keyword">const</span> divs = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">&#x27;div&#x27;</span>)<br><span class="hljs-keyword">const</span> divArr = [...divs]<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(divArr)<span class="hljs-comment">//拥有数组的方法</span><br></code></pre></td></tr></table></figure><p><strong>什么是伪数组？</strong></p><p>没有继承Array.prototype，没有数组该有的方法，常见的比如 arguments,querySelectorAll获取的list</p></li></ul></blockquote><h4 id="11-Symbol的基本使用"><a href="#11-Symbol的基本使用" class="headerlink" title="11.Symbol的基本使用"></a>11.Symbol的基本使用</h4><blockquote><p>1）定义：ES6引入的新的基本数据类型，表示独一无二的值，类似于字符串</p><p>2）特点：</p><ul><li>Symbol的值是唯一的，用来解决命名冲突的问题（但是如果用Symbol.for创建对象，内容一样，则地址是一样的，为了节省空间）</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> s = <span class="hljs-title class_">Symbol</span>()<br><span class="hljs-keyword">let</span> s1 = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;zhoujie&#x27;</span>)<br><span class="hljs-keyword">let</span> s2 = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;zhoujie&#x27;</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(s1 === s2)<span class="hljs-comment">//false</span><br><span class="hljs-keyword">let</span> s3 = <span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">for</span>(<span class="hljs-string">&#x27;zhoujie&#x27;</span>)<br><span class="hljs-keyword">let</span> s4 = <span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">for</span>(<span class="hljs-string">&#x27;zhoujie&#x27;</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(s3 === s4)<span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure><ul><li>Symbol的值不能与其他数据类型进行运算</li><li>Symbol定义的对象属性不能使用for…in循环，但是可以使用Reflect.ownKeys来获取所有键名</li></ul><p>3）使用场景：向对象中添加方法（假设不确定被添加的对象中有没有此方法）,调用不是很方便，要通过键值对</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//第一种</span><br><span class="hljs-keyword">let</span> game = &#123;...&#125;<span class="hljs-comment">//假设不确定被添加的对象中有没有此方法</span><br><br><span class="hljs-comment">//声明一个对象</span><br><span class="hljs-keyword">let</span> methods = &#123;<br>     <span class="hljs-attr">up</span>:<span class="hljs-title class_">Symbol</span>(),<br>     <span class="hljs-attr">down</span>:<span class="hljs-title class_">Symbol</span>()<br>&#125;<br>game[method.<span class="hljs-property">up</span>] = <span class="hljs-keyword">function</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;上升&#x27;</span>)<br>&#125;<br>game[method.<span class="hljs-property">down</span>] = <span class="hljs-keyword">function</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;下降&#x27;</span>)<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(game)<span class="hljs-comment">//会在原有基础上添加两个名为Symbol()的函数，把Symbol()当作字符串即可，它会保证不一样，    这样不管原来有没有此方法都可以安全添加</span><br><br><span class="hljs-comment">//第二种</span><br><span class="hljs-keyword">let</span> youxi = &#123;<br>    <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;狼人杀&#x27;</span>，<br>    [<span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;say&#x27;</span>)]:<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<span class="hljs-comment">//Symbol()这是一个表达式，是动态的值不能作为名字，估计真正使用的时候才会定下来，因此外面需要加[]给它固定值</span><br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;我可以发言&#x27;</span>)<br>    &#125;<br>    [<span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;zibao&#x27;</span>)]:<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;我可以自爆&#x27;</span>)<br>    &#125;<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(youxi)<br></code></pre></td></tr></table></figure><p>4）Symbol的内置属性</p><ul><li><p>hasInstance，当别的对象用instanceof判断是否是当前对象（类）的实例时，就会自动调用当前对象 名为 [Symbol.hasInstance]的方法—-用执行当前类方法来表示当前类有实例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br>    <span class="hljs-keyword">static</span> [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">hasInstance</span>](param)&#123;<span class="hljs-comment">//还可以将obj对象传过来</span><br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(param)<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;我被用来检测类型了！&#x27;</span>)<br>    &#125;<br>&#125;<br><span class="hljs-keyword">let</span> obj = &#123;&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Person</span>)<br><span class="hljs-comment">// &#123;&#125;</span><br><span class="hljs-comment">// 我被用来检测类型了！</span><br></code></pre></td></tr></table></figure></li><li><p>isConcatSpreadable，布尔值，表示是否可以被展开，当使用数组的concat方法时才有效</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr1 = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br><span class="hljs-keyword">let</span> arr2 = [<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]<br>arr2[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">isConcatSpreadable</span>] = <span class="hljs-literal">false</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-property">concat</span>)<br></code></pre></td></tr></table></figure></li></ul></blockquote><h4 id="12-迭代器（iterator）"><a href="#12-迭代器（iterator）" class="headerlink" title="12.迭代器（iterator）"></a>12.迭代器（iterator）</h4><blockquote><p>1）for…of和for…in的区别：前者得到的是元素，后者得到的是下标</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js">     <span class="hljs-keyword">const</span> xiyou = [<span class="hljs-string">&#x27;孙悟空&#x27;</span>,<span class="hljs-string">&#x27;猪八戒&#x27;</span>,<span class="hljs-string">&#x27;唐僧&#x27;</span>,<span class="hljs-string">&#x27;沙僧&#x27;</span>]<br><br>     <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> item <span class="hljs-keyword">of</span> xiyou)&#123;<br>         <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(item)<br>     &#125;<br><br>     <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> item <span class="hljs-keyword">in</span> xiyou)&#123;<br>         <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(item)<br>     &#125;<br>结果：<br>孙悟空<br>猪八戒<br>唐僧<br>沙僧<br><span class="hljs-number">0</span><br><span class="hljs-number">1</span><br><span class="hljs-number">2</span><br><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>2）原理</p><p>在数组里有个 Symbol(Symbol.iterator):values() ，是个函数，它返回的对象（是个容器）有next()方法每调用一次都会通过指针往后指一个。next()对象是由两个属性组成的对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> xiyou = [<span class="hljs-string">&#x27;孙悟空&#x27;</span>,<span class="hljs-string">&#x27;猪八戒&#x27;</span>,<span class="hljs-string">&#x27;唐僧&#x27;</span>,<span class="hljs-string">&#x27;沙僧&#x27;</span>]<br><span class="hljs-keyword">let</span> iterator =  xiyou[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>]()<br><span class="hljs-variable language_">console</span>,<span class="hljs-title function_">log</span>(iterator.<span class="hljs-title function_">next</span>())<br><span class="hljs-variable language_">console</span>,<span class="hljs-title function_">log</span>(iterator.<span class="hljs-title function_">next</span>())<br><span class="hljs-variable language_">console</span>,<span class="hljs-title function_">log</span>(iterator.<span class="hljs-title function_">next</span>())<br><span class="hljs-variable language_">console</span>,<span class="hljs-title function_">log</span>(iterator.<span class="hljs-title function_">next</span>())<br><span class="hljs-variable language_">console</span>,<span class="hljs-title function_">log</span>(iterator.<span class="hljs-title function_">next</span>())<br><span class="hljs-comment">//结果：done指的是是否已迭代完成</span><br>&#123;<span class="hljs-attr">value</span>: <span class="hljs-string">&#x27;孙悟空&#x27;</span>, <span class="hljs-attr">done</span>: <span class="hljs-literal">false</span>&#125;<br>&#123;<span class="hljs-attr">value</span>: <span class="hljs-string">&#x27;猪八戒&#x27;</span>, <span class="hljs-attr">done</span>: <span class="hljs-literal">false</span>&#125;<br>&#123;<span class="hljs-attr">value</span>: <span class="hljs-string">&#x27;唐僧&#x27;</span>, <span class="hljs-attr">done</span>: <span class="hljs-literal">false</span>&#125;<br>&#123;<span class="hljs-attr">value</span>: <span class="hljs-string">&#x27;沙僧&#x27;</span>, <span class="hljs-attr">done</span>: <span class="hljs-literal">false</span>&#125;<br>&#123;<span class="hljs-attr">value</span>: <span class="hljs-literal">undefined</span>, <span class="hljs-attr">done</span>: <span class="hljs-literal">true</span>&#125;<br></code></pre></td></tr></table></figure><p>3）自定义遍历数据（相当于重写，将length和value换掉即可）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> num = &#123;<br> <span class="hljs-attr">name</span>:<span class="hljs-string">&quot;数字&quot;</span>,<br> <span class="hljs-attr">stus</span>:[<br>     <span class="hljs-string">&#x27;1&#x27;</span>,<br>     <span class="hljs-string">&#x27;2&#x27;</span>,<br>     <span class="hljs-string">&#x27;3&#x27;</span>,<br>     <span class="hljs-string">&#x27;4&#x27;</span><br> ],<br> <span class="hljs-comment">//下面是手动添加的  </span><br> [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>]()&#123;<br>     <span class="hljs-comment">//索引变量</span><br>     <span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span><br>     <br>     <span class="hljs-keyword">let</span> _this = <span class="hljs-variable language_">this</span><br>     <span class="hljs-keyword">return</span>&#123;<br>         <span class="hljs-attr">next</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>             <span class="hljs-keyword">if</span>(index &lt; _this.<span class="hljs-property">stus</span>.<span class="hljs-property">length</span>)&#123;<br>                  <span class="hljs-keyword">let</span> result = &#123; <span class="hljs-attr">value</span>:_this.<span class="hljs-property">stus</span>[index] , <span class="hljs-attr">done</span>:<span class="hljs-literal">false</span>&#125;<br><br>                  index++<br>                  <span class="hljs-keyword">return</span> result<br>             &#125;<span class="hljs-keyword">else</span>&#123;<br>                 <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">value</span>:<span class="hljs-literal">undefined</span>, <span class="hljs-attr">done</span>:<span class="hljs-literal">true</span>&#125;<br>             &#125;<br>         &#125;<br>     &#125;<br> &#125;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> item <span class="hljs-keyword">of</span> num)&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(item)<br>&#125;<br><span class="hljs-comment">//结果：</span><br><span class="hljs-number">1</span><br><span class="hljs-number">2</span><br><span class="hljs-number">3</span><br><span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p><strong>迭代器和foe循环的关系：</strong>for…of可以直接返回迭代器中value的值，也就是说迭代器是for循环的内部实现</p></blockquote><h4 id="13-生成器"><a href="#13-生成器" class="headerlink" title="13.生成器"></a>13.生成器</h4><blockquote><p>1）定义：一种特殊的函数，用于创建自定义迭代器对象</p><p>2）语法：在function和函数名之间加一个 *  </p><p>3）yield关键字：会将生成器函数代码进行分割，每次使用next执行的时候碰到一个yield都会暂停（yield后者一条语句也会执行）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> * <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;111&#x27;</span>);<br>   <span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;一直没有耳朵&#x27;</span>;<br>   <span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;一只没有眼睛&#x27;</span>;<br>   <span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;真奇怪&#x27;</span>;<br>&#125;<br><span class="hljs-keyword">let</span> tiger = <span class="hljs-title function_">fn</span>()<br><span class="hljs-comment">// tiger.next()</span><br><span class="hljs-comment">// tiger.next()</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> item <span class="hljs-keyword">of</span> tiger)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(item);<br>&#125;<br></code></pre></td></tr></table></figure><p>4）参数传递：next里也可以传递参数，它将作为前一个yield（相对于当前next迭代停止的yield）的返回值（而不是yield后面的值）</p><p>​      为什么是前一个？因为 next每次碰到yield都会停止，这时不好执行，必须到下一个yield才可把给上一个yield赋返回值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> * <span class="hljs-title function_">gen</span>(<span class="hljs-params">arg</span>)&#123;<br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arg);<br> <span class="hljs-keyword">let</span> one = <span class="hljs-keyword">yield</span> <span class="hljs-number">111</span>;<br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(one);<br> <span class="hljs-keyword">let</span> two = <span class="hljs-keyword">yield</span> <span class="hljs-number">222</span>;<br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(two);<br> <span class="hljs-keyword">let</span> three = <span class="hljs-keyword">yield</span> <span class="hljs-number">333</span>;<br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(three);<br> <span class="hljs-keyword">let</span> four = <span class="hljs-keyword">yield</span> <span class="hljs-number">444</span>;<br>&#125;<br><span class="hljs-keyword">let</span> iterator = <span class="hljs-title function_">gen</span>(<span class="hljs-string">&#x27;AAA&#x27;</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iterator.<span class="hljs-title function_">next</span>());<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iterator.<span class="hljs-title function_">next</span>(<span class="hljs-string">&#x27;BBB&#x27;</span>));<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iterator.<span class="hljs-title function_">next</span>(<span class="hljs-string">&#x27;CCC&#x27;</span>));<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iterator.<span class="hljs-title function_">next</span>(<span class="hljs-string">&#x27;DDD&#x27;</span>));<br><span class="hljs-comment">//结果：</span><br><span class="hljs-variable constant_">AAA</span><br><span class="hljs-attr">value</span>: <span class="hljs-number">111</span>, <span class="hljs-attr">done</span>: <span class="hljs-literal">false</span>&#125;<br><span class="hljs-variable constant_">BBB</span><br>&#123;<span class="hljs-attr">value</span>: <span class="hljs-number">222</span>, <span class="hljs-attr">done</span>: <span class="hljs-literal">false</span>&#125;<br><span class="hljs-variable constant_">CCC</span><br>&#123;<span class="hljs-attr">value</span>: <span class="hljs-number">333</span>, <span class="hljs-attr">done</span>: <span class="hljs-literal">false</span>&#125;<br><span class="hljs-variable constant_">DDD</span><br>&#123;<span class="hljs-attr">value</span>: <span class="hljs-number">444</span>, <span class="hljs-attr">done</span>: <span class="hljs-literal">false</span>&#125;<br></code></pre></td></tr></table></figure><p>5）对异步编程的影响</p><p>异步任务：文件操作、网络操作(ajax、request)、数据库操作</p><p>回调地狱：回调函数层层嵌套调用，代码复杂</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js">需求：1s 输出 <span class="hljs-number">111</span>，再过2s输出 <span class="hljs-number">222</span>，再过3s输出<span class="hljs-number">333</span><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">111</span>)<br> <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">222</span>)<br>      <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">333</span>)<br>      &#125;,<span class="hljs-number">3000</span>)<br> &#125;,<span class="hljs-number">2000</span>)<br>&#125;,<span class="hljs-number">1000</span>)<br>为什么要嵌套？<br>因为要再过几秒，因此是在上面的基础上<br></code></pre></td></tr></table></figure><p>6）示例</p><ul><li>使用生成器函数解决回调地狱：生成器函数与其他函数来回调用，这时next就相当于指挥部，来指出下个调用哪个。</li></ul><p>​       实质：简单来说，就是通过生成器函数将多个定时器分开调用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">one</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">111</span>)<br>        iterator.<span class="hljs-title function_">next</span>()<br>    &#125;,<span class="hljs-number">1000</span>)<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">two</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">222</span>)<br>        iterator.<span class="hljs-title function_">next</span>()<br>    &#125;,<span class="hljs-number">2000</span>)<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">three</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">333</span>)<br>        iterator.<span class="hljs-title function_">next</span>()<br>    &#125;,<span class="hljs-number">3000</span>)<br>&#125;<br><span class="hljs-keyword">function</span> * <span class="hljs-title function_">gen</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">yield</span> <span class="hljs-title function_">one</span>();<br>    <span class="hljs-keyword">yield</span> <span class="hljs-title function_">two</span>();<br>    <span class="hljs-keyword">yield</span> <span class="hljs-title function_">three</span>();<br>&#125;<br><span class="hljs-keyword">let</span> iterator = <span class="hljs-title function_">gen</span>()<br>iterator.<span class="hljs-title function_">next</span>()<br></code></pre></td></tr></table></figure><ul><li><p>三个任务：获取用户数据、获取订单、获取商品，这三个任务都是1s执行，因此有异步问题，我要确保这三个任务是按顺序来执行的，这三个任务执行后还可以把数据返回，可以使用生成器来解决</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getUsers</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>        <span class="hljs-keyword">let</span> data = <span class="hljs-string">&#x27;用户数据&#x27;</span><br>        iterator.<span class="hljs-title function_">next</span>(data)<br>    &#125;,<span class="hljs-number">1000</span>)<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getOrders</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>        <span class="hljs-keyword">let</span> data = <span class="hljs-string">&#x27;订单数据&#x27;</span><br>        iterator.<span class="hljs-title function_">next</span>(data)<br>    &#125;,<span class="hljs-number">1000</span>)<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getGoods</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>        <span class="hljs-keyword">let</span> data = <span class="hljs-string">&#x27;商品数据&#x27;</span><br>        iterator.<span class="hljs-title function_">next</span>(data)<br>    &#125;,<span class="hljs-number">1000</span>)<br>&#125;<br><span class="hljs-keyword">function</span> * <span class="hljs-title function_">gen</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">let</span> users = <span class="hljs-keyword">yield</span> <span class="hljs-title function_">getUsers</span>();<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(users)<br>    <span class="hljs-keyword">let</span> orders = <span class="hljs-keyword">yield</span> <span class="hljs-title function_">getOrders</span>();<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(orders)<br>    <span class="hljs-keyword">let</span> goods = <span class="hljs-keyword">yield</span> <span class="hljs-title function_">getGoods</span>();<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(goods)<br>&#125;<br><span class="hljs-keyword">let</span> iterator = <span class="hljs-title function_">gen</span>()<br>iterator.<span class="hljs-title function_">next</span>()<br></code></pre></td></tr></table></figure></li></ul></blockquote><h4 id="14-Promise"><a href="#14-Promise" class="headerlink" title="14.Promise"></a>14.Promise</h4><blockquote><p>1）基本介绍与使用</p><ul><li><p>介绍</p><p>解决异步编程的方案，他是一个构造函数，它封装了 异步操作并可以获取其成功或失败的结果</p></li><li><p>基本使用</p><p>过程：由Promise参数函数的两个参数（只能调用一个）来决定p的状态（初始化、失败、成功），然后p通过then进行回调，第一个函数是成功时执行并返回数据，第二个函数失败时调用的函数并返回数据</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve,reject</span>)&#123;<br>            <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>                <span class="hljs-comment">// let data = &#x27;数据库中的数据&#x27;</span><br>                <span class="hljs-comment">// resolve(data)</span><br>                <span class="hljs-keyword">let</span> error = <span class="hljs-string">&#x27;数据读取失败&#x27;</span><br>                <span class="hljs-title function_">reject</span>(error)<br>            &#125;,<span class="hljs-number">1000</span>)<br>       &#125;)<br><br>p.<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">value</span>)=&gt;</span>&#123;<br>     <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value)<br>&#125;,<span class="hljs-function">(<span class="hljs-params">reason</span>)=&gt;</span>&#123;<br>     <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reason)<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>2）封装读取操作</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 1.导入模块</span><br><span class="hljs-keyword">let</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;fs&quot;</span>)<br><br><span class="hljs-comment">// 2.调用方法读取文件</span><br><span class="hljs-comment">// fs.readFile(&#x27;C://Users//K22070055//Desktop//部署流程//项目从git上到部署完成的流程.txt&#x27;,(error,data)=&gt;&#123;</span><br>     <br><span class="hljs-comment">//    if(error) throw error</span><br><br><span class="hljs-comment">//    console.log(data.toString());</span><br><span class="hljs-comment">// &#125;)</span><br><br><span class="hljs-comment">// 3.使用promise封装</span><br><span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br><br>     fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;C:1//Users//K22070055//Desktop//部署流程//项目从git上到部署完成的流程.txt&#x27;</span>,<span class="hljs-function">(<span class="hljs-params">error,data</span>)=&gt;</span>&#123;<br>     <br>     <span class="hljs-keyword">if</span>(error) <span class="hljs-title function_">reject</span>(error)<br><br>     <span class="hljs-title function_">resolve</span>(data)<br><br>    &#125;)<br><br>&#125;)<br><br>p.<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">value</span>)=&gt;</span>&#123;<br>   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value.<span class="hljs-title function_">toString</span>())<br>&#125;,<span class="hljs-function">(<span class="hljs-params">reason</span>)=&gt;</span>&#123;<br>   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;读取失败&#x27;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><p>3）封装ajax请求（代码更清晰）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> p =<span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(resolve,reject) =&gt; &#123;<br>  <span class="hljs-comment">//1.创建对象</span><br>  <span class="hljs-keyword">const</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>()<br>  <br>  <span class="hljs-comment">//2.初始化</span><br>  xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;GET&#x27;</span>,<span class="hljs-string">&#x27;api&#x27;</span>)<br>    <br>  <span class="hljs-comment">//3.发送</span><br>  xhr.<span class="hljs-title function_">send</span>()<br>    <br>  <span class="hljs-comment">//4.绑定事件，处理响应结果</span><br>  xhr.<span class="hljs-property">onreadystatechange</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>      <span class="hljs-comment">//判断</span><br>      <span class="hljs-keyword">if</span>(xhr.<span class="hljs-property">readyState</span> === <span class="hljs-number">4</span>)&#123;<br>          <span class="hljs-comment">//判断响应状态码 200-299</span><br>          <span class="hljs-keyword">if</span>(xhr.<span class="hljs-property">status</span> &gt;= <span class="hljs-number">200</span> &amp;&amp; xhr.<span class="hljs-property">status</span> &lt; <span class="hljs-number">300</span>)&#123;<br>              <span class="hljs-title function_">resolve</span>(xhr.<span class="hljs-property">response</span>)<br>          &#125;<span class="hljs-keyword">else</span>&#123;<br>              <span class="hljs-title function_">reject</span>(xhr.<span class="hljs-property">status</span>)<br>          &#125;<br>      &#125;<br>  &#125;<br>&#125;<br><br>p.<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">value</span>)=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value)<br>&#125;,<span class="hljs-function">(<span class="hljs-params">reason</span>)=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(reason)<br>&#125;)<br></code></pre></td></tr></table></figure><p>4）Promise的then方法：返回值仍然是个Promise对象，其状态是由回调函数执行结果决定</p><p>​      规则：1.若回调函数返回值是个 非Promise对象，则 状态为成功，返回值为对象的成功值</p><p>​                  2.若回调函数返回值是个Promise对象，则 内部promise返回的状态 等于 外部then返回对象的状态</p><p>​                  3.用throw抛出错误，则then状态也为失败</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> resulr = p.<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">value</span>)=&gt;</span>&#123;<br>    <span class="hljs-comment">//1.非promise类型，则返回promise的状态为成功，因为有具体的值</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;i love you&#x27;</span><br>    <span class="hljs-comment">//2.promise类型</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>        <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;ok&#x27;</span>)<br>       <span class="hljs-comment">// reject(&#x27;fail&#x27;)</span><br>    &#125;)<br>    <span class="hljs-comment">//3.抛出错误</span><br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;出错啦！&#x27;</span>)<br>&#125;,<span class="hljs-function">(<span class="hljs-params">reason</span>)=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(reason)<br>&#125;)<br><br><span class="hljs-comment">//既然then返回的还是promise对象，则可以使用链式调用，逐步解决一个个异步任务</span><br><br>p.<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">value</span>)=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value)<br>&#125;,<span class="hljs-function">(<span class="hljs-params">reason</span>)=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(reason)<br>&#125;).<span class="hljs-property">p</span>.<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">value</span>)=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value)<br>&#125;,<span class="hljs-function">(<span class="hljs-params">reason</span>)=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(reason)<br>&#125;)<br></code></pre></td></tr></table></figure><p>本质：返回非promise对象就直接出结果了，否则继续使用链式调用</p><p>5）实践：多个文件内容读取</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>)<br><br><span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>     <br>     fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;C://Users//K22070055//Desktop//部署流程//K8S &amp; docker &amp;  rancher.txt&#x27;</span>,<span class="hljs-function">(<span class="hljs-params">err,data</span>)=&gt;</span>&#123;<br>          <br>          <span class="hljs-keyword">if</span>(err) <span class="hljs-title function_">reject</span>(err)<br><br>          <span class="hljs-title function_">resolve</span>(data)<br>     &#125;)<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">value</span>)=&gt;</span>&#123;<br>   <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br><br>          fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;C://Users//K22070055//Desktop//部署流程//项目从git上到部署完成的流程.txt&#x27;</span>,<span class="hljs-function">(<span class="hljs-params">err,data</span>)=&gt;</span>&#123;<br>              <br>          <span class="hljs-keyword">if</span>(err) <span class="hljs-title function_">reject</span>(err)<br>      <br>          <span class="hljs-title function_">resolve</span>([value,data])<br>       &#125;)<br>   &#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">value</span>)=&gt;</span>&#123;<br>       <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value.<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;\r\n&#x27;</span>))<br>   &#125;,<span class="hljs-function">(<span class="hljs-params">reason</span>)=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(reason)<br> &#125;)<br>&#125;,<span class="hljs-function">(<span class="hljs-params">reason</span>)=&gt;</span>&#123;<br>   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(reason)<br>&#125;)<br></code></pre></td></tr></table></figure></blockquote><h4 id="15-Set（自动去重）、Map"><a href="#15-Set（自动去重）、Map" class="headerlink" title="15.Set（自动去重）、Map"></a>15.Set（自动去重）、Map</h4><blockquote><p>Set方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">size</span>()<br><span class="hljs-title function_">add</span>()<br><span class="hljs-title function_">delete</span>()<br><span class="hljs-title function_">has</span>()<br><span class="hljs-title function_">clear</span>()<br></code></pre></td></tr></table></figure><p>Map方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">size</span>()<br><span class="hljs-title function_">set</span>(键,值)<br><span class="hljs-title function_">get</span>()<br><span class="hljs-title function_">has</span>()<br><span class="hljs-title function_">clear</span>()<br></code></pre></td></tr></table></figure></blockquote><h4 id="16-Class"><a href="#16-Class" class="headerlink" title="16.Class"></a>16.Class</h4><blockquote><p>1）使用和java中一摸一样，只有构造函数名字是需要一定是constructor</p><p>2）提一下 static 在原本ES5中的实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Phone</span>(<span class="hljs-params"></span>)&#123;<br> <br>&#125;<br><span class="hljs-title class_">Phone</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;手机&#x27;</span><br><span class="hljs-title class_">Phone</span>.<span class="hljs-property">change</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;我可以改变世界&quot;</span>)<br>&#125;<br>这里添加的name、change都是构造函数<span class="hljs-title class_">Phone</span>的静态成员，把<span class="hljs-title class_">ES5</span>中的函数名看成类型就行<br>注意：<span class="hljs-title class_">ES5</span>中静态方法实例是访问不到的，因为这是放在构造函数里面的，不走原型链<br></code></pre></td></tr></table></figure><p>3）继承与java对比的小区别：</p><ul><li><p>ES6用super代替ES5的call帮助子类初始化</p></li><li><p>属性放在实例里，方法还自动是放 它隐式原型指向的对象上，而父方法放在则放在 再上一层隐式原型指向的对象上——即方法的保存还是遵循ES5，只是用法变了</p></li></ul><p>4）重写与java对比的小区别</p><ul><li>子类可以直接写再写一遍父类的方法，然后对内容进行重写，不需要override标识符</li></ul><p>5）get和set与java对比的小区别</p><ul><li>get/set 关键字后面 是 属性/方法 名字，而java中 get/set和名字写在一起，比如setName</li></ul></blockquote><h4 id="17-数值扩展"><a href="#17-数值扩展" class="headerlink" title="17.数值扩展"></a>17.数值扩展</h4><blockquote><ul><li><p>Number.EPSILON 是 js 的最小精度</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">equal</span>(<span class="hljs-params">a,b</span>)&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">abs</span>(a-b) &lt; <span class="hljs-title class_">Number</span>.<span class="hljs-property">EPSILON</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>进制表示（0b—二进制，0o—八进制，0x—十六进制），直接写在数的前面，表示是对应进制的数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-number">0b1010</span><br><span class="hljs-number">0o777</span><br><span class="hljs-number">0xfff</span><br></code></pre></td></tr></table></figure></li><li><p>Number.finite()，检测是否是有限的数</p></li><li><p>Number.isNaN()</p></li><li><p>Number.parseInt()</p></li><li><p>Number.isInteger()</p></li><li><p>Math.trunc()，可以将数值小数部分去掉</p></li><li><p>Math.sign()，判断是否是正数</p></li></ul></blockquote><h4 id="18-对象扩展"><a href="#18-对象扩展" class="headerlink" title="18.对象扩展"></a>18.对象扩展</h4><blockquote><ul><li><p>Object.is(obj1,obj2) ——- 判断两个对象是否完全相等（任意对象），更加简单、准确，比如两个NaN直接用===就不相等，而Object.is却相等</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">is</span>(<span class="hljs-number">120</span>,<span class="hljs-number">121</span>))<span class="hljs-comment">//false</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">is</span>(<span class="hljs-title class_">NaN</span>,<span class="hljs-title class_">NaN</span>))<span class="hljs-comment">//true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">is</span>(<span class="hljs-title class_">NaN</span> === <span class="hljs-title class_">NaN</span>))<span class="hljs-comment">//false</span><br></code></pre></td></tr></table></figure></li><li><p>Object.assign(obj1,obj2) ——- 一样的属性，会用后面的更新，不一样的则保存</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> config1 = &#123;<br>    <span class="hljs-attr">host</span>:<span class="hljs-string">&#x27;127.0.0.1&#x27;</span>,<br>    <span class="hljs-attr">port</span>:<span class="hljs-number">3306</span>,<br>    <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;root&#x27;</span>,<br>    <span class="hljs-attr">pass</span>:<span class="hljs-string">&#x27;root&#x27;</span>,<br>    <span class="hljs-attr">test</span>:<span class="hljs-string">&#x27;test&#x27;</span><br>&#125;<br><span class="hljs-keyword">const</span> config2 = &#123;<br>    <span class="hljs-attr">host</span>:<span class="hljs-string">&#x27;128.0.0.1&#x27;</span>,<br>    <span class="hljs-attr">port</span>:<span class="hljs-number">3307</span>,<br>    <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;root1&#x27;</span>,<br>    <span class="hljs-attr">pass</span>:<span class="hljs-string">&#x27;root1&#x27;</span>,<br>    <span class="hljs-attr">test1</span>:<span class="hljs-string">&#x27;test1&#x27;</span><br>&#125;<br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(config1,config2)<br></code></pre></td></tr></table></figure></li><li><p>Object.setPrototype、Object.getPrototype 设置/获取原型对象，一般不这么设置，效率低下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> school = &#123;<br>     <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;just&#x27;</span><br>&#125;<br><span class="hljs-keyword">const</span> s = &#123;<br>     <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;s&#x27;</span><br>&#125;<br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">setPrototypeOf</span>(school,s)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(school));<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(school);<br></code></pre></td></tr></table></figure></li></ul></blockquote><h4 id="19-模块化"><a href="#19-模块化" class="headerlink" title="19.模块化"></a>19.模块化</h4><blockquote><p>1）ES6之前的规范</p><ul><li>CommonJS  =&gt; NodeJS、Browserfy</li><li>AMD             =&gt; requireJS</li><li>CMD             =&gt; seaJS</li></ul><p>2）ES6模块化语法一</p><p>​        <strong>暴露方式</strong></p><p>​        <u>分别暴露：只单独暴露某个数据</u></p><ul><li><p>export 规定模块的对外接口—–放在js文件中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">let</span> sss = &#123;<br>    <span class="hljs-attr">school</span>:<span class="hljs-string">&#x27;just&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>import 导入其他模块的功能，语法格式如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script type=<span class="hljs-string">&#x27;module&#x27;</span>&gt;<span class="hljs-comment">//表示会引入模块</span><br>    <span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> m1 <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;路径&quot;</span><br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p><u>统一暴露</u></p><p>暴露接口时用{}放入所有数据</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> data1 = <span class="hljs-number">8</span><br><br><span class="hljs-keyword">let</span> <span class="hljs-title function_">data2</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;data2&#x27;</span>)<br>&#125;<br><br><span class="hljs-keyword">export</span>&#123;data1,data2&#125;<br></code></pre></td></tr></table></figure><p><u>默认暴露</u></p><p>导入时需要多写个default，表示这个通过默认暴露的数据，就相当于类名</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span>&#123;<br>    <span class="hljs-attr">school</span>:<span class="hljs-string">&#x27;just&#x27;</span>,<br>    <span class="hljs-attr">change</span>:<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;change~&#x27;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> m3 <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;...&#x27;</span><br>m3.<span class="hljs-property">default</span>.<span class="hljs-title function_">change</span>()<br></code></pre></td></tr></table></figure><p><strong>导入方式</strong></p><p><u>前面都是通用的导入方式</u></p><p><u>解构赋值方式</u></p><p>选择模块中其中几个（对象属性名要一致，要不然不知道选哪个）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; school, teach&#125; <span class="hljs-keyword">from</span> &#123;...&#125;<br><span class="hljs-keyword">import</span> &#123; school <span class="hljs-keyword">as</span> just, findJob&#125; <span class="hljs-keyword">from</span> &#123;...&#125;<span class="hljs-comment">//不能重名，可以用as起别名</span><br></code></pre></td></tr></table></figure><p>默认导入一定要起别名，因为引入的来自多个文件的数据，可能都是default数据，因此要区分</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123;<span class="hljs-keyword">default</span> <span class="hljs-keyword">as</span> m3&#125;<br></code></pre></td></tr></table></figure><p><u>简便形式</u></p><p>只针对默认暴露，为什么叫默认暴露，因为简便的默认引入就是针对他的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> school <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;...&#x27;</span><br></code></pre></td></tr></table></figure></li></ul><p>3）ES6模块化语法二</p><p>将 导入的语句 全部放在一个入口文件 .js 中，然后HTML文件中 再通过script引入，解偶了</p><p>4）模块化引入npm包</p><p>先用npm下载包，然后在js引入</p><p>5）babel对模块化的代码替换</p><p>由于并不是所有浏览器都像谷歌浏览器兼容性好，因此有时需要babel可将代码转换为ES5的代码。了解即可，后面webpack会做这些工作</p></blockquote><h3 id="ES7新特性"><a href="#ES7新特性" class="headerlink" title="ES7新特性"></a>ES7新特性</h3><h4 id="1-Arrary-prototype-include"><a href="#1-Arrary-prototype-include" class="headerlink" title="1.Arrary.prototype.include"></a>1.Arrary.prototype.include</h4><blockquote><p>1）前言：之前都是使用includeOf进行判断的某元素是否存在于数组之中，使用起来总有些不方便，返回值是一个数字，-1表示不存在</p><p>2）用法如下，返回值为布尔值，用于判断很方便</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> mingzhu = [<span class="hljs-string">&#x27;三国演义&#x27;</span>，<span class="hljs-string">&#x27;水浒传&#x27;</span>，<span class="hljs-string">&#x27;西游记&#x27;</span>,<span class="hljs-string">&#x27;红楼梦&#x27;</span>]<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(mingzhu.<span class="hljs-title function_">includes</span>(<span class="hljs-string">&#x27;三国演义&#x27;</span>))<span class="hljs-comment">//true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(mingzhu.<span class="hljs-title function_">includes</span>(<span class="hljs-string">&#x27;金瓶梅&#x27;</span>))<span class="hljs-comment">//false</span><br></code></pre></td></tr></table></figure></blockquote><h4 id="2-幂运算"><a href="#2-幂运算" class="headerlink" title="2.幂运算 **"></a>2.幂运算 **</h4><blockquote><p>1）用法如下，效果等同于Math.pow(2,10)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span> ** <span class="hljs-number">10</span>)<span class="hljs-comment">//1024</span><br></code></pre></td></tr></table></figure></blockquote><h3 id="ES8新特性"><a href="#ES8新特性" class="headerlink" title="ES8新特性"></a>ES8新特性</h3><h4 id="1-async和await"><a href="#1-async和await" class="headerlink" title="1.async和await"></a>1.async和await</h4><blockquote><p>1）介绍：async和await的结合使用可以让异步代码同步执行</p><p>2）async函数：用async修饰的函数</p><ul><li><p>返回值特性</p><p><u>如果返回值不是个promise对象，那么返回值就是一个（执行）成功的Promise</u></p><p><u>用throw抛出错误，则返回的是失败的Promise</u></p><p><u>如果返回值是个promise对象，那么返回值根据情况而定的Promise</u></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-comment">// return &#x27;尚硅谷&#x27;</span><br>  <span class="hljs-comment">//  throw new Error(&#x27;出错啦&#x27;)</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>      <span class="hljs-comment">// resolve(&#x27;Success&#x27;)</span><br>      <span class="hljs-title function_">reject</span>(<span class="hljs-string">&#x27;Failed&#x27;</span>)<br>  &#125;)<br>&#125;<br><br><span class="hljs-keyword">const</span> result = <span class="hljs-title function_">fn</span>()<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result)<br><br>result.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span>=&gt;</span>&#123;<br>   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);<br>&#125;,<span class="hljs-function"><span class="hljs-params">reason</span>=&gt;</span>&#123;<br>   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">warn</span>(reason);<br>&#125;)<br></code></pre></td></tr></table></figure><p>3）await表达式：后面接一个Promise对象，表达式整体返回值是成功的Promise结果值，如果这个Promise对象返回的是失败的值，则会报错，需要trycatch</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>  <span class="hljs-comment">//  resolve(&#x27;用户数据&#x27;)</span><br>  <span class="hljs-title function_">reject</span>(<span class="hljs-string">&#x27;失败啦&#x27;</span>)<br>&#125;)<br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">try</span>&#123;<br>    <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> p;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result);<br>  &#125;<span class="hljs-keyword">catch</span>(e)&#123;<br>    &#125;<br>&#125;<br><span class="hljs-title function_">main</span>()<br></code></pre></td></tr></table></figure><p>4）练习async和await读取文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>)<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">readHarvest</span>(<span class="hljs-params">params</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>    fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&quot;./my harvest.txt&quot;</span>,<span class="hljs-string">&#x27;utf8&#x27;</span>,<span class="hljs-function">(<span class="hljs-params">err,data</span>)=&gt;</span>&#123;<br>      <span class="hljs-comment">// 将err传给用reject，让这个异步任务在后面某个时候获取 </span><br>      <span class="hljs-keyword">if</span>(err) <span class="hljs-title function_">reject</span>(err) <br>      <span class="hljs-title function_">resolve</span>(data)<br>    &#125;)<br>  &#125;)<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">readREADME</span>(<span class="hljs-params">params</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>    fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&quot;./README.md&quot;</span>,<span class="hljs-string">&#x27;utf8&#x27;</span>,<span class="hljs-function">(<span class="hljs-params">err,data</span>)=&gt;</span>&#123;<br>      <span class="hljs-comment">// 将err传给用reject，让这个异步任务在后面某个时候获取 </span><br>      <span class="hljs-keyword">if</span>(err) <span class="hljs-title function_">reject</span>(err) <br>      <span class="hljs-title function_">resolve</span>(data)<br>    &#125;)<br>  &#125;)<br>&#125;<br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"></span>)&#123;<br>  <br>  <span class="hljs-comment">// 使用async + await可以使得原本是异步的代码想同步代码一样清晰</span><br><br>  <span class="hljs-keyword">const</span> harvest = <span class="hljs-keyword">await</span> <span class="hljs-title function_">readHarvest</span>()<br><br>  <span class="hljs-keyword">const</span> readME = <span class="hljs-keyword">await</span> <span class="hljs-title function_">readREADME</span>()<br><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(harvest);<br><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(readME);<br><br>&#125;<br><br><span class="hljs-title function_">main</span>()<br></code></pre></td></tr></table></figure></li></ul></blockquote><h4 id="2-对象方法扩展"><a href="#2-对象方法扩展" class="headerlink" title="2.对象方法扩展"></a>2.对象方法扩展</h4><blockquote><p><strong>Object.keys、Object.entries、Object.values</strong></p><p>1）介绍：entries，入口，作为Map函数的入口，可传入Map构造函数里初始化Map</p><p>2）格式：数组，里面每个元素还是数组，其中第一个元素是属性，第二个元素是值（可能也是个数组，因为值可以是多个）</p><p>3）用法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> school = &#123;<br><span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;尚硅谷&#x27;</span>,<br><span class="hljs-attr">cities</span>:[<span class="hljs-string">&#x27;背景&#x27;</span>,<span class="hljs-string">&#x27;上海&#x27;</span>,<span class="hljs-string">&#x27;深圳&#x27;</span>],<br><span class="hljs-attr">subject</span>:[<span class="hljs-string">&#x27;前端&#x27;</span>,<span class="hljs-string">&#x27;Java&#x27;</span>,<span class="hljs-string">&#x27;大数据&#x27;</span>,<span class="hljs-string">&#x27;运维&#x27;</span>]<br>&#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(school));<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">values</span>(school));<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">entries</span>(school));<br><span class="hljs-comment">// 可以这么理解：entries，入口，作为Map函数的入口</span><br><span class="hljs-keyword">const</span> m = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">entries</span>(school))<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(m.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;name&#x27;</span>));<br></code></pre></td></tr></table></figure><p><strong>Object.getOwnPropertyDescriptors</strong></p><p>1）介绍：对象属性的描述对象，即属性配置了一些特性，可能用于克隆这样特性的属性</p><p>2）用法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertyDescriptors</span>(school));<br><span class="hljs-comment">// 以上输出的结果就是如下的name格式</span><br><span class="hljs-keyword">const</span> obj = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-literal">null</span>,&#123;<br><span class="hljs-attr">name</span>:&#123;<br>   <span class="hljs-attr">value</span>:<span class="hljs-string">&#x27;尚硅谷&#x27;</span>,<br>   <span class="hljs-attr">writable</span>:<span class="hljs-literal">true</span>,<br>   <span class="hljs-attr">enumerable</span>:<span class="hljs-literal">true</span>,<br>   <span class="hljs-attr">configurable</span>:<span class="hljs-literal">true</span><br>&#125;<br>&#125;)<br></code></pre></td></tr></table></figure></blockquote><h3 id="ES9新特性"><a href="#ES9新特性" class="headerlink" title="ES9新特性"></a>ES9新特性</h3><h4 id="1-Rest参数（…）引入了在对象中的使用，之前是只能在数组中使用"><a href="#1-Rest参数（…）引入了在对象中的使用，之前是只能在数组中使用" class="headerlink" title="1.Rest参数（…）引入了在对象中的使用，之前是只能在数组中使用"></a>1.Rest参数（…）引入了在对象中的使用，之前是只能在数组中使用</h4><h4 id="2-正则扩展"><a href="#2-正则扩展" class="headerlink" title="2.正则扩展"></a>2.正则扩展</h4><blockquote><p><strong>命名捕获分组</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 定义一个字符串</span><br><span class="hljs-keyword">const</span> str = <span class="hljs-string">&#x27;&lt;a href=&quot;http://www.atguigu.com&quot;&gt;尚硅谷&lt;/a&gt;&#x27;</span><br><br><span class="hljs-comment">// const regx = /&lt;a href=&quot;(.*)&quot;&gt;(.*)&lt;\/a&gt;/</span><br><br><span class="hljs-comment">// const result = regx.exec(str)</span><br><br><span class="hljs-comment">// console.log(result);</span><br><br><span class="hljs-comment">// 通过语法?&lt;定义一个名字&gt;语法，就可以从 正则结果中的 group中去单独拿出来 匹配的部分内容</span><br><span class="hljs-keyword">const</span> regx = <span class="hljs-regexp">/&lt;a href=&quot;(?&lt;url&gt;.*)&quot;&gt;(?&lt;text&gt;.*)&lt;\/a&gt;/</span><br><br><span class="hljs-keyword">const</span> result = regx.<span class="hljs-title function_">exec</span>(str)<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result);<br></code></pre></td></tr></table></figure><p><strong>正向断言</strong></p><p>解释：断言指的是判断；正向指根据后面的内容断言（从左往后看是正向）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> str = <span class="hljs-string">&#x27;JS5211314你知道么555啦啦啦&#x27;</span><br><span class="hljs-comment">// \d:先判断数字，+:重复不止一次，():类似于if判断的括号，?=:是否等于,即匹配后面为啦的数字</span><br><span class="hljs-keyword">const</span> regx = <span class="hljs-regexp">/\d+(?=啦)/</span><br><span class="hljs-keyword">const</span> result = regx.<span class="hljs-title function_">exec</span>(str)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result);<br></code></pre></td></tr></table></figure><p><strong>反向断言</strong></p><p>解释：根据前面的条件来判断并匹配</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> str = <span class="hljs-string">&#x27;JS5211314你知道么555啦啦啦&#x27;</span><br><span class="hljs-comment">// &lt;表示反向，即前面为么的数字</span><br><span class="hljs-keyword">const</span> regx = <span class="hljs-regexp">/(?&lt;=么)\d+/</span><br><span class="hljs-keyword">const</span> result = regx.<span class="hljs-title function_">exec</span>(str)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result);<br></code></pre></td></tr></table></figure><p><strong>dotAll模式</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> str = <span class="hljs-string">`</span><br><span class="hljs-string">&lt;ul&gt;</span><br><span class="hljs-string"> &lt;li&gt;</span><br><span class="hljs-string">   &lt;a&gt;肖生克的救赎&lt;/a&gt;</span><br><span class="hljs-string">   &lt;p&gt;上映时间:&lt;/p&gt;</span><br><span class="hljs-string"> &lt;/li&gt;</span><br><span class="hljs-string"> &lt;li&gt;</span><br><span class="hljs-string">   &lt;a&gt;阿甘正传&lt;/a&gt;</span><br><span class="hljs-string">   &lt;p&gt;上映时间:&lt;/p&gt;</span><br><span class="hljs-string"> &lt;/li&gt;</span><br><span class="hljs-string">&lt;/ul&gt;</span><br><span class="hljs-string">`</span><br><span class="hljs-comment">// 没有dotAll的情况下，想要匹配肖生克的救赎、上映时间:得加很多\s</span><br><span class="hljs-keyword">const</span> regx = <span class="hljs-regexp">/&lt;li&gt;\s+&lt;a&gt;(.*?)&lt;\/a&gt;\s+&lt;p&gt;(.*?)&lt;\/p&gt;\s+&lt;\/li&gt;/</span><br><span class="hljs-keyword">const</span> result = regx.<span class="hljs-title function_">exec</span>(str)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result);<br><br><span class="hljs-comment">// .是指可以匹配所有字符，以下是有dotAll的情况,表示在最后加s，那么.可以匹配任意字符</span><br><span class="hljs-keyword">const</span> regx = <span class="hljs-regexp">/&lt;li&gt;.*?&lt;a&gt;(.*?)&lt;\/a&gt;.*?&lt;p&gt;(.*?)&lt;\/p&gt;/g</span>s<br><span class="hljs-keyword">let</span> result;<br><span class="hljs-keyword">const</span> data = []<br><span class="hljs-keyword">while</span> (result=regx.<span class="hljs-title function_">exec</span>(str)) &#123;<br>data.<span class="hljs-title function_">push</span>(&#123;<span class="hljs-attr">title</span>:result[<span class="hljs-number">1</span>],<span class="hljs-attr">time</span>:result[<span class="hljs-number">2</span>]&#125;)<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);<br></code></pre></td></tr></table></figure></blockquote><h3 id="ES10新特性"><a href="#ES10新特性" class="headerlink" title="ES10新特性"></a>ES10新特性</h3><blockquote><p><strong>Object.fromEntries</strong></p><p>解释：（数组）类型的键值对，转化为对象，因为对象形式用的更多</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 可以这么理解：Entries默认指的是(有键值对形式的)数组，那么Object.fromEntries就是从数组转化为Object</span><br><span class="hljs-keyword">const</span> result = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">fromEntries</span>([<br>[<span class="hljs-string">&#x27;name&#x27;</span>,<span class="hljs-string">&#x27;尚硅谷&#x27;</span>],<br>[<span class="hljs-string">&#x27;address&#x27;</span>,<span class="hljs-string">&#x27;上海&#x27;</span>]<br>])<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;传入二维数组时：&#x27;</span>+result);<br><br><span class="hljs-comment">// Map和Entries是有关系的，内容都是键值对，只是前者只是键值对，后者还可以是数组形式的，Entries形式更多因此也可以传入Map</span><br><span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>()<br>map.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;name&#x27;</span>,<span class="hljs-string">&#x27;周杰&#x27;</span>)<br><span class="hljs-keyword">const</span> result1 = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">fromEntries</span>(map)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;传入Map对象时：&#x27;</span>+result1);<br><br><span class="hljs-comment">// 这是Object.fromEntries的逆运算，从对象再转化为数组，是ES8的方法</span><br><span class="hljs-keyword">const</span> result2 = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">entries</span>(&#123;<br><span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;尚硅谷&#x27;</span><br>&#125;)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Object.fromEntries的逆运算为：&#x27;</span>+result2);<br></code></pre></td></tr></table></figure><p>trimStart和trimEnd</p><p>解释：从字面意思来看就知道，一个是清除左边空白，一个是清除右边空白，算是对字符串的处理，对空白的清除更加有针对性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> str = <span class="hljs-string">&#x27;    i love you       &#x27;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">trimStart</span>());<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">trimEnd</span>());<br></code></pre></td></tr></table></figure><p>flat和flatMap</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// flat有平的意思,在这里是把高阶数组变平(降阶)</span><br><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,[<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>]]<br><span class="hljs-comment">// 将二维数组变成一维数组(把里面那层数组符号去掉)</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">flat</span>());<br><br><span class="hljs-comment">// 如果是想把三维数组降为一维的话,需要指定深度,默认是1(一维数组是0)</span><br><span class="hljs-keyword">const</span> arr2 = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,[<span class="hljs-number">6</span>,[<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>]]]<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr2.<span class="hljs-title function_">flat</span>(<span class="hljs-number">2</span>));<br><br><span class="hljs-comment">// 还有个flatMap方法,它能在使用Map(返回一个新的数组)的同时,对含有多维数组的结果进行降阶</span><br><span class="hljs-keyword">const</span> arr3 = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr3.<span class="hljs-title function_">flatMap</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> [item * <span class="hljs-number">10</span>]));<br></code></pre></td></tr></table></figure><p>Symbol.prototype.description</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> s = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;尚硅谷&#x27;</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(s.<span class="hljs-property">description</span>)<br></code></pre></td></tr></table></figure></blockquote><h3 id="ES11新特性"><a href="#ES11新特性" class="headerlink" title="ES11新特性"></a>ES11新特性</h3><blockquote><p>类中的私有属性，在变量前用#表示</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br>name;<br>#age;<br>#weight;<br><br><span class="hljs-title function_">constructor</span>(<span class="hljs-params">name,age,weight</span>)&#123;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name<br><span class="hljs-variable language_">this</span>.#age = age<br><span class="hljs-variable language_">this</span>.#weight = weight<br>&#125;<br>&#125; <br><br><span class="hljs-keyword">const</span> girl = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;周杰&#x27;</span>,<span class="hljs-number">23</span>,<span class="hljs-string">&#x27;56kg&#x27;</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(girl.#age); <span class="hljs-comment">//报错,私有属性不可访问</span><br></code></pre></td></tr></table></figure><p>Promise.allSettled()、Promise.all()</p><p>传入一个数组，存放Promise对象，调用后可返回各个Promise对象异步任务的返回结果</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br><span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;商品数据 - 1&#x27;</span>)<br>&#125;, <span class="hljs-number">1000</span>);<br>&#125;)<br><br><span class="hljs-keyword">const</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br><span class="hljs-comment">// resolve(&#x27;商品数据 - 1&#x27;)</span><br><span class="hljs-title function_">reject</span>(<span class="hljs-string">&#x27;出错啦!&#x27;</span>)<br>&#125;, <span class="hljs-number">1000</span>);<br>&#125;)<br><br><span class="hljs-comment">// allSettled指的是执行传进来的所有promise对象的异步任务,最外面的Promise是成功的,里面的就看定义是什么，这里的Settled指都展开来看，能看到每个对象执行结果</span><br><span class="hljs-keyword">const</span> result = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">allSettled</span>([p1,p2])<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result);<span class="hljs-comment">// 返回一个数组,值是每个promise对象的异步任务的结果</span><br><span class="hljs-comment">// 只有all但没有settled表示,只有所有promise对象成功才能成功,一旦有一个失败最后整体就是失败</span><br><span class="hljs-keyword">const</span> result2 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([p1,p2])<br></code></pre></td></tr></table></figure><p>str.allMatched()</p><p>可对正则结果批量提取</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> str = <span class="hljs-string">`</span><br><span class="hljs-string">&lt;ul&gt;</span><br><span class="hljs-string">&lt;li&gt;</span><br><span class="hljs-string">&lt;a&gt;肖生克的救赎&lt;/a&gt;</span><br><span class="hljs-string">&lt;p&gt;上映时间:&lt;/p&gt;</span><br><span class="hljs-string">&lt;/li&gt;</span><br><span class="hljs-string">&lt;li&gt;</span><br><span class="hljs-string">&lt;a&gt;阿甘正传&lt;/a&gt;</span><br><span class="hljs-string">&lt;p&gt;上映时间:&lt;/p&gt;</span><br><span class="hljs-string">&lt;/li&gt;</span><br><span class="hljs-string">&lt;/ul&gt;</span><br><span class="hljs-string">`</span><br><span class="hljs-keyword">const</span> regx = <span class="hljs-regexp">/&lt;li&gt;.*?&lt;a&gt;(.*?)&lt;\/a&gt;.*?&lt;p&gt;(.*?)&lt;\/p&gt;/</span>sg<br><br><span class="hljs-comment">// str.matchAll使用matchAll可以匹配所有结果,但返回值只是个可迭代的对象,还需要循环遍历或者展开才能拿到最里面的数据</span><br><span class="hljs-keyword">const</span> result = str.<span class="hljs-title function_">matchAll</span>(regx)<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result);<br><br><span class="hljs-comment">// for(let v of result)&#123;</span><br><span class="hljs-comment">//   console.log(v);</span><br><span class="hljs-comment">// &#125;</span><br><br><span class="hljs-keyword">const</span> arr = [...result]<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr);<br></code></pre></td></tr></table></figure><p>可选字符?</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">main</span>(<span class="hljs-params">config</span>) &#123;<br><span class="hljs-comment">//  const dbHost = config &amp;&amp; config.db &amp;&amp; config.db.host</span><br><span class="hljs-comment">// 可用?判断是否存在,如果不存在就会返回undefined,这样写更简单</span><br><span class="hljs-keyword">const</span> dbHost = config?.<span class="hljs-property">db</span>?.<span class="hljs-property">host</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(dbHost);<br>&#125;<br><br><span class="hljs-title function_">main</span>(&#123;<br><span class="hljs-attr">db</span>:&#123;<br><span class="hljs-attr">host</span>:<span class="hljs-string">&#x27;127.0.0.1&#x27;</span>,<br><span class="hljs-attr">username</span>:<span class="hljs-string">&#x27;root&#x27;</span><br>&#125;,<br><span class="hljs-attr">cache</span>:&#123;<br><span class="hljs-attr">host</span>:<span class="hljs-string">&#x27;127.0.0.2&#x27;</span>,<br><span class="hljs-attr">username</span>:<span class="hljs-string">&#x27;admin&#x27;</span><br>&#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>动态import</p><p>在用到的时候再加载</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> btn = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;btn&#x27;</span>)<br><br>btn.<span class="hljs-property">onclick</span> = <span class="hljs-function">()=&gt;</span>&#123;<br><span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./hello&#x27;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">module</span> =&gt;</span> &#123;<br><span class="hljs-variable language_">module</span>.<span class="hljs-title function_">hello</span>()<br>&#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>BigInt</p><p>转化为大整数，用于大数运算</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 后缀加上n表示大整数----和java有点类似</span><br><span class="hljs-keyword">let</span> n = <span class="hljs-number">121n</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">typeof</span>(n));<br><br><span class="hljs-comment">// 也可以用函数转化成大整数，加后缀要简单些</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">typeof</span>(<span class="hljs-title class_">BigInt</span>(<span class="hljs-number">123</span>)));<br><br><span class="hljs-keyword">const</span> number = <span class="hljs-title class_">Number</span>.<span class="hljs-property">MAX_SAFE_INTEGER</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(number+<span class="hljs-number">1</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(number+<span class="hljs-number">2</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">BigInt</span>(number)+<span class="hljs-number">2n</span>);<br></code></pre></td></tr></table></figure><p>globalThis</p><p>全局对象，某个对象想全局使用就赋值给它</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>ES</category>
      
    </categories>
    
    
    <tags>
      
      <tag>知识点</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS高级</title>
    <link href="/2023/03/04/JS%E9%AB%98%E7%BA%A7/"/>
    <url>/2023/03/04/JS%E9%AB%98%E7%BA%A7/</url>
    
    <content type="html"><![CDATA[<h2 id="基本数据类型以及使用"><a href="#基本数据类型以及使用" class="headerlink" title="基本数据类型以及使用"></a>基本数据类型以及使用</h2><h4 id="1-和-的区别："><a href="#1-和-的区别：" class="headerlink" title="1.===和==的区别："></a>1.===和==的区别：</h4><p>前者是完全相等，后者会做数据类型转换</p><h4 id="2-typeof返回的是数据类型的字符串表达"><a href="#2-typeof返回的是数据类型的字符串表达" class="headerlink" title="2.typeof返回的是数据类型的字符串表达"></a>2.typeof返回的是数据类型的字符串表达</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a)---------<span class="hljs-literal">undefined</span> 表示这是个未定义的值<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(type a)----------<span class="hljs-string">&#x27;undefined&#x27;</span> 表示这个变量的数据类型为未定义，数据类型用字符串表达<br></code></pre></td></tr></table></figure><h4 id="3-null数据类型是Object，而undefined就是’undefined’，因此这两个还是有区别的，并不是-类型都是它本身"><a href="#3-null数据类型是Object，而undefined就是’undefined’，因此这两个还是有区别的，并不是-类型都是它本身" class="headerlink" title="3.null数据类型是Object，而undefined就是’undefined’，因此这两个还是有区别的，并不是 类型都是它本身"></a>3.null数据类型是Object，而undefined就是’undefined’，因此这两个还是有区别的，并不是 类型都是它本身</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a,<span class="hljs-keyword">typeof</span> a,<span class="hljs-keyword">typeof</span> a === <span class="hljs-string">&#x27;undefined&#x27;</span>,a === <span class="hljs-literal">undefined</span>)<br><br>      a = <span class="hljs-literal">null</span><br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a, <span class="hljs-keyword">typeof</span> a,<span class="hljs-keyword">typeof</span> a === <span class="hljs-string">&#x27;null&#x27;</span>)<br></code></pre></td></tr></table></figure><h4 id="4-复杂对象中的函数调用，如何捋清楚—看每一次访问-调用-返回的是什么"><a href="#4-复杂对象中的函数调用，如何捋清楚—看每一次访问-调用-返回的是什么" class="headerlink" title="4.复杂对象中的函数调用，如何捋清楚—看每一次访问(调用)返回的是什么"></a>4.复杂对象中的函数调用，如何捋清楚—看每一次访问(调用)返回的是什么</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> b1 = &#123;<br>       <span class="hljs-attr">b2</span>: [<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;2&#x27;</span>,<span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span>],<br>       <span class="hljs-attr">b3</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>           <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;外函数&#x27;</span>)<br>           <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>               <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;zhoujie&#x27;</span><br>           &#125;<br>       &#125;<br>     &#125;<br><br>     <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(b1.<span class="hljs-title function_">b3</span>()())<br></code></pre></td></tr></table></figure><h4 id="5-typeof无法区分判断-Object与null、Object与Array，因为它们都是Object-引用-类型"><a href="#5-typeof无法区分判断-Object与null、Object与Array，因为它们都是Object-引用-类型" class="headerlink" title="5.typeof无法区分判断 Object与null、Object与Array，因为它们都是Object(引用)类型"></a>5.typeof无法区分判断 Object与null、Object与Array，因为它们都是Object(引用)类型</h4><h4 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a><strong>面试题</strong></h4><h4 id="6-undefined和null的区别？"><a href="#6-undefined和null的区别？" class="headerlink" title="6.undefined和null的区别？"></a>6.undefined和null的区别？</h4><p>undefined是定义未赋值，而null定义并赋值了，只是值为null</p><blockquote><p>补充：再加个xxx is not defined</p><p>xxx is not defined：没有定义</p></blockquote><h4 id="7-什么时候用null？"><a href="#7-什么时候用null？" class="headerlink" title="7.什么时候用null？"></a>7.什么时候用null？</h4><p>1.初始赋值，表明即将赋值为对象类型</p><p>2.结束前赋值，表明此对象为垃圾对象，即将被回收</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> b = <span class="hljs-literal">null</span><br><br>   b = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br><br>   b = <span class="hljs-literal">null</span><br></code></pre></td></tr></table></figure><h4 id="8-如何严格区分变量类型和数据类型？"><a href="#8-如何严格区分变量类型和数据类型？" class="headerlink" title="8.如何严格区分变量类型和数据类型？"></a>8.如何严格区分变量类型和数据类型？</h4><p>变量类型：包含 基本类型和引用类型（保存的是地址），</p><p>数据类型：包含 基本类型和对象类型</p><p>可以这么记：数据比较抽象，只看表面，而变量接受的是一个具体的值，因此是里面的地址</p><h4 id="9-在js中调用函数传递参数时，是值传递还是引用传递？"><a href="#9-在js中调用函数传递参数时，是值传递还是引用传递？" class="headerlink" title="9.在js中调用函数传递参数时，是值传递还是引用传递？"></a>9.在js中调用函数传递参数时，是值传递还是引用传递？</h4><p>值传递，只是传的这个值 可以是基本值也可以是地址</p><h4 id="10-JS引擎如何释放内存？"><a href="#10-JS引擎如何释放内存？" class="headerlink" title="10.JS引擎如何释放内存？"></a>10.JS引擎如何释放内存？</h4><p>1.局部变量：函数执行完自动释放</p><p>2.对象：成为垃圾对象==&gt;被垃圾回收器回收</p><hr><h4 id="11-函数内的所有局部变量在函数调用时产生，在调用结束时就被清理了"><a href="#11-函数内的所有局部变量在函数调用时产生，在调用结束时就被清理了" class="headerlink" title="11.函数内的所有局部变量在函数调用时产生，在调用结束时就被清理了"></a>11.函数内的所有局部变量在函数调用时产生，在调用结束时就被清理了</h4><h4 id="12-JS中直接用对象赋值的相当于-定义和实例化同步进行，好处是不用那么麻烦了，定义了后就直接用，需要注意的是-对象赋值时，属性后面是冒号（因为是键值对）"><a href="#12-JS中直接用对象赋值的相当于-定义和实例化同步进行，好处是不用那么麻烦了，定义了后就直接用，需要注意的是-对象赋值时，属性后面是冒号（因为是键值对）" class="headerlink" title="12.JS中直接用对象赋值的相当于 定义和实例化同步进行，好处是不用那么麻烦了，定义了后就直接用，需要注意的是 对象赋值时，属性后面是冒号（因为是键值对）"></a>12.JS中直接用对象赋值的相当于 定义和实例化同步进行，好处是不用那么麻烦了，定义了后就直接用，需要注意的是 对象赋值时，属性后面是冒号（因为是键值对）</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> b = &#123;<br>    <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;zhoujie&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="13-在访问对象属性时，除了可以直接-访问，也可以用-‘属性名’-访问，后面这种相当于-把属性和值看成键值对"><a href="#13-在访问对象属性时，除了可以直接-访问，也可以用-‘属性名’-访问，后面这种相当于-把属性和值看成键值对" class="headerlink" title="13.在访问对象属性时，除了可以直接.访问，也可以用[‘属性名’]访问，后面这种相当于 把属性和值看成键值对"></a>13.在访问对象属性时，除了可以直接.访问，也可以用[‘属性名’]访问，后面这种相当于 把属性和值看成键值对</h4><ul><li><p>什么时候使用[‘属性名’]？有什么好处?</p><p>好处：用.的方式有时会失效，而[‘属性名’]是通用的</p><p>When：</p><p>1）属性名包含特殊字符时，因为对象的属性的命名也遵循基本命名规则，可以这么理解：它新加了一个[]就是为了能够海纳百川 从而改进.的方式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = &#123;&#125;<br><span class="hljs-comment">// 添加一个属性content-type   </span><br><span class="hljs-comment">// a.content-type = &#x27;text/json&#x27;</span><br>  <br>a[<span class="hljs-string">&#x27;content-type&#x27;</span>] = <span class="hljs-string">&#x27;text/json&#x27;</span><br></code></pre></td></tr></table></figure><p>2）变量名不确定</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> proName = <span class="hljs-string">&#x27;myAge&#x27;</span><br><span class="hljs-keyword">var</span> value = <span class="hljs-number">18</span><br>a.<span class="hljs-property">proName</span> = value<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a)----&#123;content-<span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;text/json&#x27;</span>, <span class="hljs-attr">proName</span>: <span class="hljs-number">18</span>&#125;<br>  <br>a[proName] = value<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a)----&#123;content-<span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;text/json&#x27;</span>, <span class="hljs-attr">proName</span>: <span class="hljs-number">18</span>, <span class="hljs-attr">myAge</span>: <span class="hljs-number">18</span>&#125;<br></code></pre></td></tr></table></figure><p> 原因：[]多做了一步变量替换，它是先将proName替换为myAge，然后a再去添加myAge属性，而.的方式直接认为proName就是属性名</p><p> 注意点：[]放变量不要加引号，加了引号那就是proName字符常量了</p></li></ul><h4 id="14-原来new也可以调用函数？因为函数也是一个对象"><a href="#14-原来new也可以调用函数？因为函数也是一个对象" class="headerlink" title="14.原来new也可以调用函数？因为函数也是一个对象"></a>14.原来new也可以调用函数？因为函数也是一个对象</h4><h4 id="15-可以调用对象中不存在的方法"><a href="#15-可以调用对象中不存在的方法" class="headerlink" title="15.可以调用对象中不存在的方法"></a>15.可以调用对象中不存在的方法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">test.<span class="hljs-property">call</span>/<span class="hljs-title function_">apply</span>(obj)-------临时将test作为obj的函数来调用<br><span class="hljs-comment">//可以这么理解：call就相当于test作为求职者来寻找雇主boj</span><br><span class="hljs-comment">//            apply就相当于雇主obj叫求职者test来应聘</span><br></code></pre></td></tr></table></figure><h4 id="16-常见的回调函数"><a href="#16-常见的回调函数" class="headerlink" title="16.常见的回调函数"></a>16.常见的回调函数</h4><p>什么是回调函数？你定义的、你没有调用、但它最终却执行了（某个时刻自己执行）</p><p>1）dom事件回调函数</p><p>2）定时器回调函数</p><p>3）ajax请求回调函数</p><p>4）生命周期回调函数</p><h4 id="17-window-function"><a href="#17-window-function" class="headerlink" title="17.window.$ = function(){}"></a>17.window.$ = function(){}</h4><p>​       代表给window对象自定义一个函数，既然是widow对象，那么这个自定义函数就是在页面加载时就产生</p><h4 id="18-匿名对象中的函数：左边属性名，右边函数名"><a href="#18-匿名对象中的函数：左边属性名，右边函数名" class="headerlink" title="18.匿名对象中的函数：左边属性名，右边函数名"></a>18.匿名对象中的函数：左边属性名，右边函数名</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"> &#123;<br>   <span class="hljs-attr">test</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>       ...<br>   &#125;<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">如果test函数已知，则 直接test()整个放入，而前面的test相当于test()别名，调用别名test就等于test()</span><br><span class="hljs-comment">为什么一定左边是个名字，因为对象 中元素都是键值对 格式的，左边是名字，右边是具体值</span><br><span class="hljs-comment">*/</span><br> <span class="hljs-variable language_">window</span>.<span class="hljs-property">$</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>   <span class="hljs-attr">test</span>:test<br>&#125;<br>$.<span class="hljs-title function_">test</span>()<br></code></pre></td></tr></table></figure><h4 id="19-关于this"><a href="#19-关于this" class="headerlink" title="19.关于this"></a>19.关于this</h4><p>1.函数其实本质上都是通过某个对象调用的，如果没有直接指定就是window，也就是为什么location.href其实就是window.location.href，即location其实就是window的方法</p><p>   test()，那么这个函数打印出的this指的是window</p><p>2.有直接指定的 那this就是它的调用者</p><p>   p.test—-this为p</p><p>  var p1 = new test()—-this为新创建的对象p1</p><p>  p.call(obj)：obj—-p把掌控权交给了obj，因此是objs</p><h4 id="20-关于分号"><a href="#20-关于分号" class="headerlink" title="20.关于分号"></a>20.关于分号</h4><p>1）在 小括号 前面要加分号——因为会把前面的值 当成 函数名 来调用</p><p>2）在 中括号 前面加分号——-因为会把前面的值 当成数组名 来调用</p><p>解决方法：在这两者之前面 加分号 </p><h4 id="21-js中是没有类的，只有对象。似乎-函数在承担着一些-以前类的职责，比如-原型就是函数才有的，而原型就相当于封装好的类；比如new-function，太像了。而这里面的对象似乎经常作为-匿名对象出现，直接传入具体的值。"><a href="#21-js中是没有类的，只有对象。似乎-函数在承担着一些-以前类的职责，比如-原型就是函数才有的，而原型就相当于封装好的类；比如new-function，太像了。而这里面的对象似乎经常作为-匿名对象出现，直接传入具体的值。" class="headerlink" title="21.js中是没有类的，只有对象。似乎 函数在承担着一些 以前类的职责，比如 原型就是函数才有的，而原型就相当于封装好的类；比如new function，太像了。而这里面的对象似乎经常作为 匿名对象出现，直接传入具体的值。"></a>21.js中是没有类的，只有对象。似乎 函数在承担着一些 以前类的职责，比如 原型就是函数才有的，而原型就相当于封装好的类；比如new function，太像了。而这里面的对象似乎经常作为 匿名对象出现，直接传入具体的值。</h4><h2 id="函数高级"><a href="#函数高级" class="headerlink" title="函数高级"></a>函数高级</h2><h4 id="22-函数的prototype属性"><a href="#22-函数的prototype属性" class="headerlink" title="22.函数的prototype属性"></a>22.函数的prototype属性</h4><p>1）每个函数都会有一个prototype属性，它指向一个空对象</p><p>2）这个空对象有一个constructor属性，它指向函数本身（可以这么记：构造函数和类名（函数名）同名）</p><p>3）可以给原型对象添加属性（一般是方法），目的是 给接受这个 方法的实例对象拥有添加的属性（方法）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Date</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);<br><br>     <span class="hljs-keyword">function</span> <span class="hljs-title function_">Fun</span>(<span class="hljs-params"></span>)&#123;<br><br>     &#125;<br><br>     <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Fun</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Fun</span>);<br><br>     <span class="hljs-comment">// 手动给Fun函数的原型添加函数test</span><br>     <span class="hljs-title class_">Fun</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">test</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>)&#123;<br>          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;the added method&quot;</span>);<br>     &#125;<br>     <span class="hljs-comment">/**</span><br><span class="hljs-comment">      * 让实例对象使用，在访问、修改里面的方法时需要通过prototype，但是真正实例化使用的时候</span><br><span class="hljs-comment">      * 还是直接让函数自己去</span><br><span class="hljs-comment">      * */</span> <br>     <span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Fun</span>()<br>     p.<span class="hljs-title function_">test</span>()<br></code></pre></td></tr></table></figure><h4 id="23-显式原型和隐式原型"><a href="#23-显式原型和隐式原型" class="headerlink" title="23.显式原型和隐式原型"></a>23.显式原型和隐式原型</h4><p>1）每个函数都有个显式原型prototype，显式原型是函数创建时自动创建的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Fn</span>(<span class="hljs-params"></span>)&#123;<br>    ...<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Fn</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);<br></code></pre></td></tr></table></figure><p>2）每个实例都有隐式原型______proto_（因此只有对象才有），是Fn在实例化的时候，内部执行了 this.<strong><strong>proto</strong></strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> fn = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Fn</span>()<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(fn.<span class="hljs-property">__proto__</span>)<br></code></pre></td></tr></table></figure><p>3）<strong>每个实例的隐式原型的值 = 其构造函数的显式原型的值</strong>  （其实就是上面两点的值是相等的，说得这么绕是因为想 将两者联系起来，因为构造函数其实就是函数本身，变量代换了属于是）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Fn</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>===fn.<span class="hljs-property">__proto__</span>)<br></code></pre></td></tr></table></figure><h4 id="25-变量为声明打印的话是会报错：not-defined，这个和打印为-‘undefined’不一样，前者是未定义，后者是定义未赋值"><a href="#25-变量为声明打印的话是会报错：not-defined，这个和打印为-‘undefined’不一样，前者是未定义，后者是定义未赋值" class="headerlink" title="25.变量为声明打印的话是会报错：not defined，这个和打印为 ‘undefined’不一样，前者是未定义，后者是定义未赋值"></a>25.变量为声明打印的话是会报错：not defined，这个和打印为 ‘undefined’不一样，前者是未定义，后者是定义未赋值</h4><h4 id="26-var和function的变量提升（只是声明提前，如果有值还得在赋值的地方才有效）"><a href="#26-var和function的变量提升（只是声明提前，如果有值还得在赋值的地方才有效）" class="headerlink" title="26.var和function的变量提升（只是声明提前，如果有值还得在赋值的地方才有效）"></a>26.var和function的变量提升（只是声明提前，如果有值还得在赋值的地方才有效）</h4><p>1）变量声明的提升</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-number">10</span><br>------------相当于<br><span class="hljs-keyword">var</span> a<br>a = <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><p>2）声明式函数或函数表达式的提升，整体提升（变量和后面的赋值整体往上）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">a</span>(<span class="hljs-params"></span>)&#123;&#125;<br>------------相当于<br><span class="hljs-keyword">var</span> a<br>a = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;&#125;<br></code></pre></td></tr></table></figure><p>3）同名函数声明时，会把后面的替换前面的（默认后面的事最新的更改），而且在编译器中还不会报错，，难道是为了 保存记录，方便 出问题了 来追踪并查找bug吗？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">a</span>(<span class="hljs-params"></span>)&#123; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;123&#x27;</span>)&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">a</span>(<span class="hljs-params"></span>)&#123; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;456&#x27;</span>)&#125;<br>------------------------------相当于<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">a</span>(<span class="hljs-params"></span>)&#123; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;456&#x27;</span>)&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="面试题-1"><a href="#面试题-1" class="headerlink" title="面试题"></a>面试题</h4><p>4）函数变量的提升比var变量提升的优先级高，声明更靠前</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-number">10</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fun</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">var</span> b = <span class="hljs-number">11</span><br>&#125;<br>--------------相当于<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fun</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">var</span> b = <span class="hljs-number">11</span><br>&#125;<br><span class="hljs-keyword">var</span> a<br>a = <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><p>5）如果变量与函数<strong>同名</strong>了，<strong>此时函数声明与变量声明只声明一个</strong>，并且变量<strong>没有赋值</strong>，那么函数优先级更高，原理如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">a</span>(<span class="hljs-params"></span>)&#123;&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">a</span>())<br>--------------相当于<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">a</span>(<span class="hljs-params"></span>)&#123;&#125;-----变量不会声明<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">a</span>())<br></code></pre></td></tr></table></figure><p>6）如果变量与函数<strong>同名</strong>了，并且变量 <strong>赋值了</strong>，那么变量优先级更高（不管谁先声明，因为函数总是在变量前面的），原理如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-number">10</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">a</span>(<span class="hljs-params"></span>)&#123;&#125;<br>--------------相当于<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">a</span>(<span class="hljs-params"></span>)&#123;&#125;<br>a = <span class="hljs-number">10</span><br><span class="hljs-title function_">a</span>()<span class="hljs-comment">//报错，此时a是个变量</span><br></code></pre></td></tr></table></figure><hr><h4 id="27-原型链"><a href="#27-原型链" class="headerlink" title="27.原型链"></a>27.原型链</h4><p><img src="/2023/03/04/JS%E9%AB%98%E7%BA%A7/%E5%8E%9F%E5%9E%8B%E9%93%BE1.png" alt="原型链1"></p><p><strong>作用：查找对象的属性（方法）</strong></p><p><strong>容易混淆的点：这里面通过原型链往后找的只是本身的原型（类），即本身是原型的实例，这个和父类没有关系</strong></p><p><img src="/2023/03/04/JS%E9%AB%98%E7%BA%A7/%E5%8E%9F%E5%9E%8B%E9%93%BE2.png" alt="原型链2"></p><p><strong>这两张图的联系的重点：实例的隐式原型 = 其构造函数的显式原型 在两张图如何体现</strong></p><p>1）在第二张图如何体现？</p><p>比如 实例Foo的_proto__ = Function的prototype，因此它们都指向 Function的prototype，其中Foo的prototype并没有在第一张图体现出来，因为第一张图没有画以Foo为构造函数的原型，必须要有别的proto__指向它</p><p>2）第一张图图如何体现？</p><p>比如 实例fn的_proto__ = Fn实例对象的prototype（都是0x456）</p><p><strong>补充：</strong>完整的图</p><p><img src="/2023/03/04/JS%E9%AB%98%E7%BA%A7/%E5%8E%9F%E5%9E%8B%E9%93%BE.jpg" alt="原型链"></p><p>1）Object<strong>的原型对象</strong>是顶层，再往上找不到了，因此它的_proto是null，即Object.prototype.proto__ = null</p><p>2）Function.prototype 是Object 的实例（Object才是顶层）</p><p>3）所有函数都是Function的实例（从proto__可以看出来）</p><h4 id="28-原型链的属性问题"><a href="#28-原型链的属性问题" class="headerlink" title="28.原型链的属性问题"></a>28.原型链的属性问题</h4><p>1）实例查找属性也是先 本身-&gt;原型链</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Fn</span>(<span class="hljs-params"></span>)&#123;<br>    <br>&#125;<br><span class="hljs-title class_">Fn</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">aaa</span> = <span class="hljs-string">&#x27;xxx&#x27;</span><br><span class="hljs-keyword">var</span> fn = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Fn</span>()<br>cosole.<span class="hljs-title function_">log</span>(fn.<span class="hljs-property">aaa</span>)-------可以访问，但是不建议放在原型链中，见（<span class="hljs-number">3</span>）<br></code></pre></td></tr></table></figure><p>2）在修改值的时候，不会查找原型链，如果不存在，会在函数本身中创建（优先在函数本身中处理属性）</p><p>3）属性一般放在函数本身中，而方法一般放在原型链中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Fn</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-attr">aaa</span>:<span class="hljs-string">&#x27;111&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>对于（3）为什么要这么做？</p><p>可以这么理解：一个函数（类）的各个实例属性一般不同，但是方法（功能）大差不差，最多像java中重写</p><h4 id="29-使用原型的好处"><a href="#29-使用原型的好处" class="headerlink" title="29.使用原型的好处"></a>29.使用原型的好处</h4><p>所有实例共享属性和方法，不用再每个实例都添加一遍了</p><h4 id="30-怎么通过原型链看A是不是B的实例（instance-of的原理）？"><a href="#30-怎么通过原型链看A是不是B的实例（instance-of的原理）？" class="headerlink" title="30.怎么通过原型链看A是不是B的实例（instance of的原理）？"></a>30.怎么通过原型链看A是不是B的实例（instance of的原理）？</h4><p>A 通过自己的proto_链找，有B的原型就说明A是B的实例（多条路都可以）</p><hr><h4 id="面试题-2"><a href="#面试题-2" class="headerlink" title="面试题"></a>面试题</h4><p>（1）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">A</span>(<span class="hljs-params"></span>)&#123;<br>    <br>&#125;<br>A.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">n</span> = <span class="hljs-number">1</span><br><span class="hljs-keyword">var</span> b = <span class="hljs-keyword">new</span> <span class="hljs-title function_">A</span>()<br>A.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = &#123;<br>    n : <span class="hljs-number">2</span>,<br>    m : <span class="hljs-number">3</span><br>&#125;<br><span class="hljs-keyword">var</span> c = <span class="hljs-keyword">new</span> <span class="hljs-title function_">A</span>()<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(b.<span class="hljs-property">m</span>,b.<span class="hljs-property">n</span>,c.<span class="hljs-property">m</span>,c.<span class="hljs-property">n</span>)<span class="hljs-comment">// 1 undefined 2 3</span><br></code></pre></td></tr></table></figure><p><img src="/2023/03/04/JS%E9%AB%98%E7%BA%A7/%E9%9D%A2%E8%AF%95%E9%A2%9801.png" alt="面试题01"></p><p><strong>关键点：在堆里新建一个对象后，赋值给 A.prototype 后，直接更改了指向</strong></p><p> （2）完整的图记住就可以了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">F</span>(<span class="hljs-params"></span>)&#123;&#125;<br><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">a</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;a&#x27;</span>)<br>&#125;<br><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">b</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;b&#x27;</span>)<br>&#125;<br><span class="hljs-keyword">var</span> f = <span class="hljs-keyword">new</span> <span class="hljs-title function_">F</span>()<br>f.<span class="hljs-title function_">a</span>() ---- a<br>f.<span class="hljs-title function_">b</span>() ----报错 b不是函数<br>F.<span class="hljs-title function_">a</span>() ---- a<br>F.<span class="hljs-title function_">b</span>() ---- b<br></code></pre></td></tr></table></figure><hr><h4 id="31-执行上下文"><a href="#31-执行上下文" class="headerlink" title="31.执行上下文"></a>31.执行上下文</h4><p><strong>（1）全局执行上下文</strong></p><p>全局预处理会执行以下操作：</p><ul><li>将window作为全局执行上下文</li><li>将所有变量和函数的声明提前并放入全局执行上下文中</li><li>将this指向window</li></ul><p><strong>（2）函数执行上下文（虚拟的，存在于栈中）</strong></p><p>函数在调用时会执行以下操作：</p><ul><li>将形参作为函数执行上下文的属性</li><li>将arguments（形参列表）作为函数执行上下文的属性</li><li>将所有 局部声明的 变量和函数的声明 提前并放入函数执行上下文中</li></ul><p><strong>函数执行上下文 什么时候被创建 ？调用时才会被创建，但是创建后使用之前肯定已经准备好的</strong></p><h4 id="32-执行上下文栈"><a href="#32-执行上下文栈" class="headerlink" title="32.执行上下文栈"></a>32.执行上下文栈</h4><p><strong>（1）执行上下文的个数怎么看？</strong></p><p>n（函数调用的次数）+1，嵌套一次就会叠加一层</p><p><strong>（2）执行上下文栈的运行机制？</strong></p><p> 先放入 window全局执行上下文，然后放入一个个函数，函数在调用完后就会出战，最终留下window在栈里</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-number">10</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-title function_">foo</span>()<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;aaa&#x27;</span>)<br>&#125;<br><span class="hljs-title function_">bar</span>()<br><span class="hljs-title function_">push</span>(<span class="hljs-variable language_">window</span>)-&gt;<span class="hljs-title function_">push</span>(bar)-&gt;<span class="hljs-title function_">push</span>(foo)-&gt;<span class="hljs-title function_">pop</span>(foo)-&gt;<span class="hljs-title function_">pop</span>(bar) 最终留下<span class="hljs-variable language_">window</span><br></code></pre></td></tr></table></figure><hr><h4 id="面试题-3"><a href="#面试题-3" class="headerlink" title="面试题"></a>面试题</h4><p><strong>（1）在看递归的打印时，一定要注意临界时的输出情况，别漏了</strong></p><p><strong>（2）变量与函数同名问题</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> c = <span class="hljs-number">1</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">c</span>(<span class="hljs-params">c</span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(c)<br>&#125;<br><span class="hljs-title function_">c</span>(<span class="hljs-number">2</span>)<span class="hljs-comment">//c不是函数 ，考的还是变量与函数同名问题，下次要有意识地注意看名字</span><br></code></pre></td></tr></table></figure><p><strong>（3）if内部的定义的变量仍然是 全局的，只有函数内才是局部的，因此依然会变量提升</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">if</span>(!(b <span class="hljs-keyword">in</span> <span class="hljs-variable language_">window</span>))&#123;<br>    <span class="hljs-keyword">var</span> b = <span class="hljs-number">1</span><br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(b)<span class="hljs-comment">//undefined</span><br></code></pre></td></tr></table></figure><hr><h4 id="33-作用域-amp-作用域链与执行上下文"><a href="#33-作用域-amp-作用域链与执行上下文" class="headerlink" title="33.作用域&amp;作用域链与执行上下文"></a>33.作用域&amp;作用域链与执行上下文</h4><p><strong>作用域内寻找变量的过程：先从当前执行上下文找，没有然后再到外面的执行上下文，找不到就报错。到执行上下文上找是因为变量提升，那里有所有定义好的变量——-寻找的路径就是作用域链</strong></p><p><img src="/2023/03/04/JS%E9%AB%98%E7%BA%A7/%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE.png"></p><p><strong>区别1：先后顺序不同</strong></p><ul><li>全局执行上下文是在全局作用域确定之后，全局代码执行之前生成</li><li>函数执行上下文是在函数调用时，函数代码执行之前生成</li></ul><p><strong>区别2：变化发展的不同</strong></p><ul><li>作用域是静态的，只要代码一生成，就一直存在</li><li>执行上下文是动态的，全局执行上下文在预加载时生成，函数执行上下文在调用时，且在调用结束后被释放</li></ul><p><strong>联系：</strong></p><ul><li><p>执行上下文环境是属于作用域内的（如上图）</p><p><strong>原型链和作用域链总结：原型链是用来找方法的，作用域链是用来找变量的</strong></p><hr><h3 id="面试题-4"><a href="#面试题-4" class="headerlink" title="面试题"></a>面试题</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> x = <span class="hljs-number">10</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x)<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">show</span>(<span class="hljs-params">f</span>)&#123;<br>    <span class="hljs-keyword">var</span> x = <span class="hljs-number">20</span><br>    <span class="hljs-title function_">fn</span>()<br>&#125;<br><span class="hljs-title function_">show</span>(fn)<span class="hljs-comment">//10</span><br></code></pre></td></tr></table></figure><p><strong>（1）千万不能认为嵌套调用函数就是直接把函数代码拿过来，这在js行不通</strong></p><p><strong>（2）考的是 函数作用域在 代码生成后就定下来了 ，因此本体fn的作用域就是上面，找不到再网上找 那就是10</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//题目：</span><br><span class="hljs-keyword">var</span> x = <span class="hljs-number">10</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(fn)<br>&#125;<br><span class="hljs-title function_">fn</span>()<br>-------------------------<br><span class="hljs-comment">//结果：</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(fn)<br>&#125;<br>-------------------------<br><span class="hljs-comment">//题目：</span><br><span class="hljs-keyword">var</span> obj = &#123;<br>    <span class="hljs-attr">fn2</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(fn2)<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">fn2</span>)<br>    &#125;<br>&#125;<br>obj.<span class="hljs-title function_">fn2</span>()<br>-------------------------<br> <span class="hljs-comment">//结果：</span><br> fn2 is not defined <br> <span class="hljs-attr">fn2</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(fn2)<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">fn2</span>)<br>    &#125;<br></code></pre></td></tr></table></figure><p>  <strong>（1）打印 函数名 得到的是 整个函数（全貌），相当于这个名字代表的是函数的全貌</strong></p><p>  <strong>（2）会在哪找一定要确定这个东西属于哪个作用域（注意作用域只有全局和函数内），这里fn寻找过程：function内-&gt;全局作用域</strong></p><p>  **（3）想要找到对象内的属性（方法），注意善用this **</p></li></ul><hr><h4 id="34-闭包"><a href="#34-闭包" class="headerlink" title="34.闭包"></a>34.闭包</h4><p><strong>经典案例</strong></p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs xml">//实现点击提示是哪个按钮<br>   <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>点击<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>点击<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>点击<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">       <span class="hljs-comment">/**</span></span><br><span class="hljs-comment"><span class="language-javascript">        * 需求：点击按钮，提示这是第几个按钮</span></span><br><span class="hljs-comment"><span class="language-javascript">       */</span></span><br><span class="language-javascript">      <span class="hljs-keyword">var</span> buttons = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementsByTagName</span>(<span class="hljs-string">&#x27;button&#x27;</span>)</span><br><span class="language-javascript">      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>,length = buttons.<span class="hljs-property">length</span>; i &lt; length; i++)&#123;</span><br><span class="language-javascript">          <span class="hljs-keyword">var</span> btn = buttons[i]  <span class="hljs-comment">//必须要单独声明一个btn，因为要给每个btn添加点击事件</span></span><br><span class="language-javascript">          btn.<span class="hljs-property">index</span> = i</span><br><span class="language-javascript">          btn.<span class="hljs-property">onclick</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript">              <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;第&#x27;</span>+(<span class="hljs-variable language_">this</span>.<span class="hljs-property">index</span>+<span class="hljs-number">1</span>)+<span class="hljs-string">&#x27;个按钮&#x27;</span>);  <span class="hljs-comment">//this表示当前btn，否则报错</span></span><br><span class="language-javascript">          &#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript">      &#125;</span><br><span class="language-javascript">      <span class="hljs-comment">//第二种：用闭包(稍后再说)</span></span><br><span class="language-javascript">      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>,length = buttons.<span class="hljs-property">length</span>; i &lt; length; i++)&#123;</span><br><span class="language-javascript">        (<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript">              <span class="hljs-keyword">var</span> btn = buttons[i]  <span class="hljs-comment">//必须要单独声明一个btn，因为要给每个btn添加点击事件</span></span><br><span class="language-javascript">              <span class="hljs-comment">//btn.index = i</span></span><br><span class="language-javascript">               btn.<span class="hljs-property">onclick</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript">              <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;第&#x27;</span>+(<span class="hljs-variable language_">this</span>.<span class="hljs-property">index</span>+<span class="hljs-number">1</span>)+<span class="hljs-string">&#x27;个按钮&#x27;</span>);  <span class="hljs-comment">//this表示当前btn，否则报错</span></span><br><span class="language-javascript">          &#125;</span><br><span class="language-javascript">        &#125;)()</span><br><span class="language-javascript">      &#125;</span><br><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>   解答：调用length次，生成length个闭包，每个闭包单独保存i<br></code></pre></td></tr></table></figure><p><strong>产生：嵌套函数中内部函数访问外部函数的变量（属性），<u><em>并且外部函数调用时</em></u>，就产生了闭包</strong></p><p><strong>定义：内部函数对外部函数的应用</strong></p><p><strong>常见闭包：</strong></p><p>（1）将函数作为另一个函数的返回值，既然是返回值，就肯定会再次调用，由于闭包的特点：内部函数的变量会一直存在内存中，因此再次调用访问的还是第一次生成的变量</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn1</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">fn2</span>(<span class="hljs-params"></span>)&#123;<br>        a++  <span class="hljs-comment">//引用函数外部变量，产生闭包</span><br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a)<br>    &#125;<br>    <span class="hljs-keyword">return</span> fn2<br>&#125;<br><span class="hljs-keyword">var</span> f = <span class="hljs-title function_">fn1</span>()<br><span class="hljs-title function_">f</span>()<span class="hljs-comment">// 3 ---- 第一次调用fn2</span><br><span class="hljs-title function_">f</span>()<span class="hljs-comment">// 4 ---- 再次调用fn2，访问的是之前的a</span><br></code></pre></td></tr></table></figure><p>（2）函数作为另一个函数参数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params">msg,time</span>)&#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-title function_">alert</span>(msg) <span class="hljs-comment">//访问函数外部变量msg，产生闭包</span><br>    &#125;,time)<br>&#125;<br><span class="hljs-title function_">fn</span>(<span class="hljs-string">&#x27;zhoujie&#x27;</span>,<span class="hljs-number">2000</span>)<br></code></pre></td></tr></table></figure><p><strong>闭包作用：</strong></p><p>1）函数内部的变量可以继续保存在内存中，方便下次使用，延长了局部变量的生命周期。（既然你需要外部的变量，那就满足它无后顾之忧）</p><p>​    <strong>新的问题：那这个变量什么时候被释放？</strong></p><ul><li><p>对象成为垃圾对象（该对象没有引用指向它）</p></li><li><p>不使用的时候（既然没有使用需求，为什么还要开辟空间来准备呢）</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn1</span>(<span class="hljs-params"></span>)&#123;<br>    -------------------------------------此时就已经产生了闭包(变量提升)<br>    <span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">fn2</span>(<span class="hljs-params"></span>)&#123;<br>        a++  <span class="hljs-comment">//引用函数外部变量，产生闭包</span><br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a)<br>    &#125;------------------------------------这里整个fn2就会被释放，因为没有被使用<br>     <span class="hljs-keyword">function</span> <span class="hljs-title function_">fn3</span>(<span class="hljs-params"></span>)&#123;<br>        a++  <span class="hljs-comment">//引用函数外部变量，产生闭包</span><br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a)<br>    &#125;<br>    <span class="hljs-keyword">return</span> fn3<br>&#125;<br><span class="hljs-comment">//fn1()----------------------------------这里fn1调用结束后，如果没有变量指向fn3(返回值)，那fn3就会成为垃圾对象，准备被销毁，那闭包中的变量也没了</span><br><span class="hljs-keyword">var</span> f = <span class="hljs-title function_">fn1</span>()<br><span class="hljs-title function_">f</span>()<br></code></pre></td></tr></table></figure><p>​     <strong>这两点说的是一个意思，都是指成为垃圾对象</strong></p><p>2）让函数外部可以操作函数内部的数据（局部变量）（本来外部是不能访问局部变量的 ）</p><p><strong>闭包的生命周期</strong></p><p>产生：在嵌套内部函数执行完函数定义时（需要调用外部函数）就产生了，当然这个内部函数要引用外部变量</p><p>死亡：在嵌套内部函数成为垃圾对象时（和前面提出的问题是一样的）</p><p><strong>闭包的应用 —- 自定义JS模块</strong></p><p><strong>步骤：</strong></p><ul><li>第一种</li></ul><p>1）在js文件中定义函数myModule，注意返回值是一个返回多个属性（方法）的对象</p><p>2）在html文件中引用并 var module = myModule()，module.doSomething()</p><ul><li>第二种</li></ul><p>1）在js文件中定义为 IIFE 函数，这时返回值是：window.myModule01 = { }</p><p>2）在html文件中引用并 直接 myModule01.doSomething()</p><blockquote><p>其实是 一样的，相当于前者后函数执行（实例化）调用，后者是 先成为window的一部分并自动执行（实例化），那么引入就可以直接用了</p></blockquote><p><strong>闭包与其他语言中类的异曲同工之处：</strong></p><blockquote><p>这一切的一切都是因为 js中没有类只有对象！因此利用函数充当类，用函数局部变量外部不可见充当私有属性（对象的属性默认是公有的），用 闭包 充当 类中函数访问成员变量，用返回值为对象充当 类调用方法</p></blockquote><p><strong>闭包的缺点：</strong></p><blockquote><p>当你不需要再使用闭包内的数据时，如果没有及时释放，那那片内存就一直被占用着，造成内存泄露</p><p>解决办法：能不用就不用，就算用了要及时赋值给null</p></blockquote><p><strong>内存溢出与内存泄漏</strong></p><blockquote><p>内存溢出：当程序需要的内存超过剩余的内存时，就会抛出内存溢出的错误</p><p>内存泄露：占用的内存没有被释放，积累多了就会导致内存溢出，这个泄露指的是在总内存</p><p>常见的内存泄漏：</p><ul><li>意外的全局变量</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>)&#123;<br>    a = <span class="hljs-number">1</span> --------------------------------- 没有用<span class="hljs-keyword">var</span>定义的变量都是全局变量，函数调用结束后并不会销毁，这样定义越来越多，久而久之也会溢出的<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">fn2</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a)<br>    &#125;<br>    <span class="hljs-keyword">return</span> fn2<br>&#125;<br><span class="hljs-keyword">var</span> f = <span class="hljs-title function_">fn</span>()<br><span class="hljs-title function_">f</span>()<br></code></pre></td></tr></table></figure><ul><li>没有及时清理的定时器或回调函数</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> intervalId = <span class="hljs-built_in">setInterval</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(--------)<br>&#125;)<br><span class="hljs-built_in">clearInterval</span>() ---------------------------不清理的话，它会一直隔段时间就执行<br></code></pre></td></tr></table></figure><ul><li>闭包</li></ul></blockquote><hr><h4 id="面试题-5"><a href="#面试题-5" class="headerlink" title="面试题"></a>面试题</h4><blockquote><p>对象内的函数的this要注意区分：如果属性是一个函数此时调用的this就是obj的this(因为属性和对象挂钩)，如果直接return function(){}这时回往window找，因为这是个匿名函数和对象无关</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;the window&#x27;</span><br><span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;My Obj&#x27;</span><br>    <span class="hljs-attr">getNameFunc</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span><br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-title function_">alert</span>(obj.<span class="hljs-title function_">getNameFunc</span>()())-------the <span class="hljs-variable language_">window</span>，无闭包<br><br><span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;the window&#x27;</span><br><span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;My Obj&#x27;</span><br>    <span class="hljs-attr">getNameFunc</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">var</span> that = <span class="hljs-variable language_">this</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>            <span class="hljs-keyword">return</span> that.<span class="hljs-property">name</span><br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-title function_">alert</span>(obj.<span class="hljs-title function_">getNameFunc</span>()())-------<span class="hljs-title class_">My</span> <span class="hljs-title class_">Obj</span>，有闭包<br></code></pre></td></tr></table></figure><hr><h2 id="对象高级"><a href="#对象高级" class="headerlink" title="对象高级"></a>对象高级</h2><h4 id="35-对象创建模式"><a href="#35-对象创建模式" class="headerlink" title="35.对象创建模式"></a><strong>35.对象创建模式</strong></h4><blockquote><p>（1）Object构造函数法 —– 相当于动态创建</p><p>先new 一个对象，然后再手动添加属性和方法</p><p>场景：适用于刚开始不知道对象的属性，但是代码多</p><p>（2）对象字面量法 —– 相当于静态创建</p><p>全放在一个对象字面量中，字面量是指属性值已经定下来了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> obj = &#123;<br> <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;a&#x27;</span>,<br> <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,<br> <span class="hljs-attr">getName</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>     <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span><br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>场景：对象内的数据已经确定，适用于一个对象，多个对象可能会代码重复</p><p>（3）工厂模式 —– 相当于 对象字面量法的封装，弥补了缺点，在工厂里准备好，出来时动态变换</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createPerson</span>(<span class="hljs-params">name,age</span>)&#123;<br> <span class="hljs-keyword">var</span> obj = &#123;    <br>     <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;a&#x27;</span>,    <br>     <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,    <br>     <span class="hljs-attr">getName</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;       <br>      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>    <br>   &#125;<br> &#125;<br> <span class="hljs-keyword">return</span> obj<br>&#125;<br><span class="hljs-keyword">var</span> p1 = <span class="hljs-title function_">createPerson</span>(<span class="hljs-string">&#x27;Tom&#x27;</span>,<span class="hljs-number">12</span>)<br><span class="hljs-keyword">var</span> p2 = <span class="hljs-title function_">createPerson</span>(<span class="hljs-string">&#x27;Bob&#x27;</span>,  <span class="hljs-number">13</span>)<br></code></pre></td></tr></table></figure><p>场景：需要创建多个对象，但是没有一个具体的类型，在用到一个具体类型时又要重新写个工厂</p><p>（4）属性放在构造函数中，方法放在原型中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params">name,age</span>)&#123;<br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name<br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age<br>&#125;<br>fn.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">setName</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">name</span>)&#123;<br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name<br>&#125;<br><span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title function_">fn</span>(<span class="hljs-string">&#x27;Tom&#x27;</span>,<span class="hljs-number">18</span>)<br></code></pre></td></tr></table></figure><p>优点：既是动态，又是函数放在公共的位置（原型），省内存、高效</p></blockquote><h4 id="36-继承形式"><a href="#36-继承形式" class="headerlink" title="36.继承形式"></a>36.继承形式</h4><p><strong>原理：</strong></p><blockquote><p>属性是存在于实例中，方法是存在于prototype指向的Object实例，那我通过子类型的prototype改变地址，指向父类的实例，那么我子类不就既能访问父类实例中的属性，又能通过父类实例的proto_找到其存放的方法</p></blockquote><p><strong>（1）通过原型链继承</strong></p><p><strong>步骤：</strong></p><blockquote><p>将子类型的原型指向父类型的实例</p></blockquote><blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 父函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Super</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">supProp</span>= <span class="hljs-string">&#x27;SP&#x27;</span><br>&#125;<br><span class="hljs-comment">// 父函数添加方法</span><br><span class="hljs-title class_">Super</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">showSuperProp</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>   <span class="hljs-comment">//因为用的是this,因此是在Super里面找函数表达式的this访问都是从左边这个变量找</span><br>   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">supProp</span>)<br>&#125;<br><span class="hljs-comment">// 子函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Sub</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">subProp</span>= <span class="hljs-string">&#x27;SP&#x27;</span><br>&#125;<br><span class="hljs-comment">// 继承</span><br><span class="hljs-title class_">Sub</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Super</span>()<br><span class="hljs-comment">// 将子类型的constructor指向它自己原型的构造函数(此处是手动添加的)</span><br><span class="hljs-title class_">Sub</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> = <span class="hljs-title class_">Sub</span><br><span class="hljs-title class_">Sub</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">showSubProp</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>. subProp)<br>&#125;<br><span class="hljs-keyword">var</span> sub =<span class="hljs-keyword">new</span> <span class="hljs-title class_">Sub</span>()<br>sub.<span class="hljs-title function_">showSuperProp</span>()<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(sub);<br><br></code></pre></td></tr></table></figure></blockquote><p><img src="/2023/03/04/JS%E9%AB%98%E7%BA%A7/%E7%BB%A7%E6%89%BF.png" alt="继承"></p><p><strong>（2）借用构造函数继承</strong></p><blockquote><p>子类型借用 call 函数调用父函数的构造函数来帮助子构造函数来添加初始化属性。这是一种伪继承，因为仅仅是通过调用并复制父类型的属性来添加的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">father</span>(<span class="hljs-params">name,age</span>)&#123; <br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name  <br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">child</span>(<span class="hljs-params">name,age,price</span>)&#123; <br>  father.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>,name,age) <span class="hljs-comment">//相当于this.father(name,age)</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">price</span> = price<br>&#125;<br><span class="hljs-keyword">var</span> c = <span class="hljs-keyword">new</span> <span class="hljs-title function_">child</span>(<span class="hljs-string">&#x27;111&#x27;</span>,<span class="hljs-number">18</span>,<span class="hljs-number">19</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(c.<span class="hljs-property">name</span>);<br></code></pre></td></tr></table></figure></blockquote><p><strong>（3）组合继承</strong></p><blockquote><p>组合前面两种方法，这样就可以完全继承父类型的属性和方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 父函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Super</span>(<span class="hljs-params">name,age</span>)&#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age<br>&#125;<br><span class="hljs-comment">// 父函数添加方法</span><br><span class="hljs-title class_">Super</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">showSuperProp</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>   <span class="hljs-comment">//因为用的是this,因此是在Super里面找函数表达式的this访问都是从左边这个变量找</span><br>   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span>)<br>&#125;<br><span class="hljs-comment">// 子函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Sub</span>(<span class="hljs-params">name,age,price</span>)&#123;<br>   <span class="hljs-title class_">Super</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>,name,age)<br>   <span class="hljs-variable language_">this</span>.<span class="hljs-property">price</span> = price<br>&#125;<br><span class="hljs-comment">// 继承</span><br><span class="hljs-title class_">Sub</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Super</span>()<br><span class="hljs-comment">// 将子类型的constructor指向它自己原型的构造函数(此处是手动添加的)</span><br><span class="hljs-title class_">Sub</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> = <span class="hljs-title class_">Sub</span><br><span class="hljs-title class_">Sub</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">showSubProp</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>. subProp)<br>&#125;<br><span class="hljs-keyword">var</span> sub =<span class="hljs-keyword">new</span> <span class="hljs-title class_">Sub</span>(<span class="hljs-string">&#x27;zhoujie&#x27;</span>,<span class="hljs-number">18</span>,<span class="hljs-number">1808080</span>)<br>sub.<span class="hljs-title function_">showSuperProp</span>()<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(sub.<span class="hljs-property">name</span>);<br></code></pre></td></tr></table></figure></blockquote><p><strong>解答疑惑：为什么第一种方法也可以访问到父类型的属性，还需要第二种方法来添加属性呢？</strong></p><p>不规范。我们规定 属性要放在实例中，而方法放在原型链中。第一种方法通过实例找的其实是父类型的实例，而不是子类型的实例</p><h4 id="37-关于constructor"><a href="#37-关于constructor" class="headerlink" title="37.关于constructor"></a>37.关于constructor</h4><p><strong>位置：</strong> </p><blockquote><p>作为属性 存放在构造函数原型指向的实例对象 上，但它的值是 构造函数的地址（箭头又指回去了），箭头的起始端就是存放该属性的地方</p></blockquote><p><img src="/2023/03/04/JS%E9%AB%98%E7%BA%A7/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0.png" alt="构造函数"></p><p><strong>规则：</strong></p><blockquote><p>一定要指向该 protrotype的构造函数</p></blockquote><p><strong>使用场景：</strong></p><blockquote><p>在进行继承之后，子类型的constructor指向的为 父类的构造函数，因此要重新指定一下。</p></blockquote><blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Sub</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> = <span class="hljs-title class_">Sub</span><br></code></pre></td></tr></table></figure></blockquote><p><strong>思考：既然能手动添加constructor在Super实例里，说明访问constructor是只能通过函数对象（就像上面那样），否则就如果可以通过实例访问的话，Super实例访问的constructor就是Sub的了</strong> </p><h4 id="38-有关prototype-amp-prototype-amp-proto"><a href="#38-有关prototype-amp-prototype-amp-proto" class="headerlink" title="38.有关prototype&amp;[[prototype]]&amp;___proto"></a>38.有关prototype&amp;[[prototype]]&amp;___proto</h4><blockquote><p>（1）每个对象的都有___proto，在创建实例时生成</p><p>（2）每个函数都有prototype，在声明函数时生成</p><p>（3）[[prototype]]就是___proto，不同写法而已</p></blockquote><h4 id="39-有关函数的新理解"><a href="#39-有关函数的新理解" class="headerlink" title="39.有关函数的新理解"></a>39.有关函数的新理解</h4><blockquote><p>看成 类里面的构造函数就行了，函数名的值在js中本来就是构造函数的值</p></blockquote><hr><h4 id="面试题-6"><a href="#面试题-6" class="headerlink" title="面试题"></a>面试题</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fun</span>(<span class="hljs-params">n,o</span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(o)<br>    <span class="hljs-attr">fun</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params">m</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">fun</span>(m,n)<br>    &#125;<br>&#125;<br><span class="hljs-keyword">var</span> a = <span class="hljs-title function_">fun</span>(<span class="hljs-number">0</span>)<br>a.<span class="hljs-title function_">fun</span>(<span class="hljs-number">1</span>)<br>a.<span class="hljs-title function_">fun</span>(<span class="hljs-number">2</span>)<br>a.<span class="hljs-title function_">fun</span>(<span class="hljs-number">3</span>)<br><br><span class="hljs-keyword">var</span> b = <span class="hljs-title function_">fun</span>(<span class="hljs-number">0</span>).<span class="hljs-title function_">fun</span>(<span class="hljs-number">1</span>).<span class="hljs-title function_">fun</span>(<span class="hljs-number">3</span>)<br><br><span class="hljs-keyword">var</span> c = <span class="hljs-title function_">fun</span>(<span class="hljs-number">0</span>).<span class="hljs-title function_">fun</span>(<span class="hljs-number">1</span>)<br>c.<span class="hljs-title function_">fun</span>(<span class="hljs-number">2</span>)<br>c.<span class="hljs-title function_">fun</span>(<span class="hljs-number">3</span>)<br><br>结果：<br><span class="hljs-literal">undefined</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <br><span class="hljs-literal">undefined</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span><br><span class="hljs-literal">undefined</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>考点：</strong></p><blockquote><p>1）只有调用外部函数才会生成闭包</p><p>2）只要只有一个闭包，那么就不会再引用新的外部变量，直到产生新的闭包</p></blockquote><hr><h2 id="线程机制与事件"><a href="#线程机制与事件" class="headerlink" title="线程机制与事件"></a>线程机制与事件</h2><h4 id="40-进程与线程"><a href="#40-进程与线程" class="headerlink" title="40.进程与线程"></a>40.进程与线程</h4><blockquote><p>1）线程池：存放线程对象的容器，便于复用线程对象</p><p>2）程序是单线程还是多线程的是看一个进程中最多有几个线程</p><p>3）js是单线程的</p><p>4）浏览器是多线程的（一个进程处理多个请求）</p><p>5）浏览器是单进程还是多进程看浏览器（现在基本都是多进程，比如新IE、chrome）</p></blockquote><h4 id="42-浏览器内核"><a href="#42-浏览器内核" class="headerlink" title="42.浏览器内核"></a>42.浏览器内核</h4><blockquote><p>1）浏览器内核是浏览器运行最核心的程序</p><p>2）浏览器内核是由多个模块组成</p><ul><li> js引擎 —- 负责js程序的编译和运行</li><li> html,css文档解析模块：负责文本的解析</li><li> DOM/CSS模块：负责dom/css在内存中的相关处理 —— 将标签处理为对象</li><li> 布局和渲染模块：负责页面的布局和效果的绘制</li></ul><p>…… 以上为主线程，下面为分线程</p><ul><li>定时器模块：负责定时器的管理</li><li>时间相应模块：负责事件的管理</li><li>网络请求模块：负责ajax的请求</li></ul></blockquote><h4 id="43-js是单线程执行的"><a href="#43-js是单线程执行的" class="headerlink" title="43.js是单线程执行的"></a>43.js是单线程执行的</h4><blockquote><p>1）为什么js要用单线程模式？</p><p>因为多线程会带来同步问题</p></blockquote><h4 id="44-有关定时器"><a href="#44-有关定时器" class="headerlink" title="44.有关定时器"></a>44.有关定时器</h4><blockquote><p>1）定时器真的是定时执行的吗？</p><p>不是，会有一些延迟</p><p>2）定时器回调函数是在分线程执行的吗？</p><p>在主线程执行</p></blockquote><h4 id="45-事件循环模型"><a href="#45-事件循环模型" class="headerlink" title="45.事件循环模型"></a>45.事件循环模型</h4><p><img src="/2023/03/04/JS%E9%AB%98%E7%BA%A7/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%A8%A1%E5%9E%8B.png" alt="事件循环模型"></p><p><strong>过程：</strong></p><blockquote><p>先执行主线程（执行栈）中的同步代码（初始代码），每碰到一个异步任务 由分线程WebAPIs中的模块管理，放到回调队列（异步队列）中，等主线程执行完之后，就会从回调队列中一个一个取出来到主线程中执行再执行</p></blockquote><p><strong>分线程和回调队列执行顺序并不确定</strong></p><blockquote><p>比如 点击事件，等主线程中执行完，就会拿回调队列中的任务执行，可能执行了之后，我都还没点击，因此这时 分线程的点击事件在 回调队列中的任务后面执行</p></blockquote><h4 id="Web-Workers多线程"><a href="#Web-Workers多线程" class="headerlink" title="Web Workers多线程"></a>Web Workers多线程</h4><blockquote><p>1）定义：它是HTML5为js提供的多线程解决方案</p><p>2）用途：可将一些计算量大的代码交给web Worker作为分线程运行而不冻结用户界面</p><p>3）特点：分线程完全受主线程控制，且无法操控DOM（一旦主线程指定了worker文件，那么文件的this对象默认是worker，而不是window，也自然不好操控DOM）</p><p><img src="/2023/03/04/JS%E9%AB%98%E7%BA%A7/webWorker.png" alt="webWorker"></p><p>4）缺点：</p><ul><li>慢（需要来回发送接收消息）</li><li>不能操作DOM（本身局限）</li><li>并不是所有浏览器都支持</li><li>不能跨域</li><li>————————————–因此公司基本不用，但是要了解</li></ul></blockquote>]]></content>
    
    
    <categories>
      
      <category>Js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>知识点以及面试题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>我的第一篇博客</title>
    <link href="/2023/03/02/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
    <url>/2023/03/02/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<p>终于把Gitee Pages给弄好了，第一次认证的时候竟然说是人像模糊导致认证不通过？那还不是我的iphone13pro人像模式拍照，近处聚焦，远处虚化导致的（好吧，不装了，哈哈），下次知道了如果不想要背景虚化的话拍照要调成正常照片模式。</p><p>之前呢，喜欢每天在博客园上写一些生活上的感悟，由于内容比较私人吧，因此分在“日记”一栏中，也就是不发布出来的，只有自己能看到。但是慢慢地，我发现只有自己能看到的话，就缺少监督，写东西很容易偷懒，能省则省，比如因为某件事明白了某个道理，虽然说自己能看懂，但是缺少一个细致地复盘的过程，这样印象就不深，可能过几天，这个感悟又忘了，也就是输出太少了；另一方面呢，我之前每天记的一些东西，太零散了，不成体系，而且，这些感悟，它缺少一定时间的实践来验证，因此需要过一段时间来写出一篇高质量的文章，那这种公开的博客就很适合写进去。</p><p>今天还是主要说了下，弄博客的原因，由于时间比较仓促，就先写到这里，以后我会在这里写一些技术性的文章还有生活上的感悟。</p>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>生活感悟</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>开启博客的缘由</title>
    <link href="/2023/03/02/%E5%BC%80%E9%80%9A%E5%8D%9A%E5%AE%A2%E7%9A%84%E7%BC%98%E7%94%B1/"/>
    <url>/2023/03/02/%E5%BC%80%E9%80%9A%E5%8D%9A%E5%AE%A2%E7%9A%84%E7%BC%98%E7%94%B1/</url>
    
    <content type="html"><![CDATA[<p>之前在查询技术问题的时候，经常看到别人精心布置的博客，羡慕不已，也幻想过拥有一个属于自己的博客，之前总是觉得没时间搞，想着自己的想法写在一些平台上不是一样的嘛，其实现在看来只是”没有追求”罢了。</p><p>看着自己精美的博客，自己不仅心情变得更好了，而且相比一些平台也更乐于去维护，这是一方面；</p><p>另一方面，“轻易得到的都不会珍惜”，平台上的博客使用门槛低，而且有时候我写一些生活方面的东西，可能比较私人，就不发出来，不发出来就不认真写，久而久之容易养成不认真做事的习惯。</p>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>生活感悟</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
